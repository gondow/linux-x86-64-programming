<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x86-64機械語命令 - Linuxで学ぶx86-64アセンブリ言語</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="4-encoding.html"><strong aria-hidden="true">4.</strong> データ表現，2進数，2の補数</a></li><li class="chapter-item "><a href="5-arch.html"><strong aria-hidden="true">5.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど</a></li><li class="chapter-item expanded "><a href="6-inst.html" class="active"><strong aria-hidden="true">6.</strong> x86-64機械語命令</a></li><li class="chapter-item "><a href="7-asmdir.html"><strong aria-hidden="true">7.</strong> GNUアセンブラ命令</a></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ</a></li><li class="chapter-item "><a href="9-abi.html"><strong aria-hidden="true">9.</strong> ABI: アプリケーション・バイナリ・インタフェース</a></li><li class="chapter-item "><a href="10-gdb.html"><strong aria-hidden="true">10.</strong> デバッガgdbの使い方</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集</a></li><li class="chapter-item "><div><strong aria-hidden="true">13.</strong> AT&TスタイルとIntelスタイルの違い</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 6; }
</style>
<h1 id="x86-64機械語命令"><a class="header" href="#x86-64機械語命令">x86-64機械語命令</a></h1>
<h2 id="how-to-execute-x86-inst"><a class="header" href="#how-to-execute-x86-inst">x86-64機械語命令の実行方法</a></h2>
<h3 id="概要デバッガ上で実行します"><a class="header" href="#概要デバッガ上で実行します">概要：デバッガ上で実行します</a></h3>
<p>機械語命令を実行しても，単に<code>a.out</code>を実行するだけでは
意図通りに実行できたかの確認が難しいです．
(アセンブリコード内から<code>printf</code>を呼び出せばいいのですが，
そのコードもうざいので)．
そこで本書では<strong>デバッガを使って</strong>機械語命令の実行と確認を行います．</p>
<p>以下では例として<code>movq $999, %rax</code>という機械語命令を実行してみます．
(これらのファイルは<a href="https://github.com/gondow/linux-x86-64-programming/tree/main/src/asm">サンプルコード</a>から入手できます)．
<code>movq $999, %rax</code>は「定数<code>999</code>を<code>%rax</code>レジスタに格納する」という命令ですので，
実行後，<code>%rax</code>レジスタに<code>999</code>という値が入っていれば，
うまく実行できたことを確認できます．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p>実行確認のための<code>gdb</code>のコマンド列を書いたファイルも用意しています．</p>
<div id="asm/movq-4.txt">
<pre><code># asm/movq-4.txt
b 7
r
list 6,6
p $rax
echo # %raxの値が999なら成功\n
quit
</code></pre>
</div>
<h3 id="デバッガ上で実行gdbコマンドを手入力"><a class="header" href="#デバッガ上で実行gdbコマンドを手入力">デバッガ上で実行：<code>gdb</code>コマンドを手入力</a></h3>
<p><code>asm/movq-4.txt</code>中の<code>gdb</code>コマンドを
以下のように1行ずつ入力してみて下さい．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶
(gdb) b 7 ❷
Breakpoint 1 at 0x1130: file movq-4.s, line 6.
(gdb) r ❸
Breakpoint 1, main () at movq-4.s:6
6	    ret
(gdb) list 6,6 ❹
5	    movq $999, %rax
(gdb) p $rax ❺
$1 = 999
(gdb) quit
</code></pre>
<ul>
<li>❶ コンパイルした<code>a.out</code>を<code>gdb</code>上で実行</li>
<li>❷ ブレークポイントを7行目(<code>movq $999, %rax</code>の次の行)に設定 (<code>b</code>はbreakの略)</li>
<li>❸ 実行開始 (<code>r</code> は run の略)</li>
<li>❹ ソースコードの6行目だけを表示</li>
<li>❺ レジスタ<code>%rax</code>の値を(10進表記で)表示 (<code>p</code>はprintの略)</li>
<li><a href="#asm/movq-4.txt"><code>movq-4.txt</code></a>
の最後の行 <code>echo # %raxの値が999なら成功\n</code>は，
「どうなると正しく実行できたか」を確認するメッセージを出力するコマンドですので，
ここでは入力不要です．
❺の結果と一致したので「正しい実行」と確認できました．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力--xオプションを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力--xオプションを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>-x</code>オプションを使う)</a></h3>
<p><code>gdb</code>コマンドを手入力して，よく使う<code>gdb</code>コマンドを覚えることは良いことです．
とはいえ，手入力は面倒なので，自動入力も使いましょう．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶ -x movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	 ❷ movq $999, %rax
❸ $1 = 999 
❹ # %raxの値が999なら成功
(gdb) 

</code></pre>
<ul>
<li>❶ <code>-x movq-4.txt</code> というオプションをつけると，指定したファイル(ここでは<code>movq-4.txt</code>)の中に書かれている<code>gdb</code>コマンドを1行ずつ順番に実行してくれます</li>
<li><code>list 6,6</code>を実行した結果，❷6行目の<code>movq $999, %rax</code> が表示されています</li>
<li><code>p $rax</code>を実行した結果，<code>%rax</code>レジスタの値が❸999であると表示されています．
(<code>$1</code>は<code>gdb</code>が扱う変数です．ここでは無視して下さい)</li>
<li><code>echo # %raxの値が999なら成功\n</code> を<code>gdb</code>が実行した結果，
❹ <code># %raxの値が999なら成功</code>というメッセージが表示されています．
このメッセージと❸の実行結果を見比べれば「実行結果が正しい」ことを確認できます．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>source</code>コマンドを使う)</a></h3>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) ❶ source movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	    movq $999, %rax
$1 = 999
# %raxの値が999なら成功
</code></pre>
<p><code>gdb</code>は通常通りに実行開始して，
❶ <code>source</code>コマンドを使えば，<code>movq-4.txt</code>中の<code>gdb</code>コマンドを実行できます．
<code>-x</code>オプションと<code>source</code>コマンドは好きな方を使って下さい．</p>
<h2 id="アドレッシングモード-オペランドの表記方法"><a class="header" href="#アドレッシングモード-オペランドの表記方法">アドレッシングモード (オペランドの表記方法)</a></h2>
<h3 id="アドレッシングモードの概要"><a class="header" href="#アドレッシングモードの概要">アドレッシングモードの概要</a></h3>
<p>機械語命令は命令(<strong>オペコード</strong>(opcode))と
その引数の<strong>オペランド</strong>(operand)から構成されています．
例えば，<code>movq $999, %rax</code>という命令では，
<code>movq</code>がオペコードで，<code>$999</code>と<code>%rax</code>がオペランドです．</p>
<img src="figs/opcode-operand.svg" height="100px" id="fig:opcode-operand">
<p><strong>アドレッシングモード</strong>とはオペランドの書き方のことです．
(元々は「メモリのアドレスを指定する記法」という意味で「アドレッシングモード」という用語が使われています).
x86-64では大きく，以下の4種類の書き方ができます．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td></tr>
<tr><td><code>movq foo, %rax</code></td></tr>
<tr><td rowspan="3">
<p><a href="#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベル（その値はアドレス）であり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="addr-mode-imm"><a class="header" href="#addr-mode-imm">アドレッシングモード：即値（定数）</a></h3>
<h4 id="定数-999"><a class="header" href="#定数-999">定数 <code>$999</code></a></h4>
<p><strong>即値</strong>(immediate value，定数)には<code>$</code>をつけます．
例えば<code>$999</code>は定数<code>999</code>を意味します．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-4.s"><code>movq-4.s</code></a>の6行目の
<code>movq $999, %rax</code>は「定数<code>999</code>をレジスタ<code>%rax</code>に格納する」という意味です．
デバッガで動作を確認します
(デバッガの操作手順は<a href="./asm/movq-4.txt"><code>movq-4.txt</code></a>にもあります)．</p>
<pre><code>$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-4.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-4.s:6
6	    movq $999, %rax
(gdb) si
main () at movq-4.s:7
7	    ret
(gdb) p $rax
$1 = 999
</code></pre>
<p>確かに<code>%rax</code>レジスタ中に<code>999</code>が格納されていました．</p>
<p>なお，多くの場合，即値は32ビットまでで，オペランドのサイズが64ビットの場合，
32ビットの即値は，64ビットの演算前に
<strong>64ビットに<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">符号拡張</a></strong> されます
(<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a>だと
負の値が大きな正の値になって困るからです)．
64ビットに符号拡張される例は<a href="x86-list.html#imm-64bit-signed-extended">こちら</a>
を見て下さい．
例外は<code>movq</code>命令で，64ビットの即値を扱えます．
実行例は<a href="x86-list.html#mov-64bit-imm">こちら</a>を見て下さい．</p>
<h4 id="ラベル-main"><a class="header" href="#ラベル-main">ラベル <code>$main</code></a></h4>
<p>定数が書ける場所にはラベル(その値はアドレス)も書けます．
ラベルは関数名やグローバル変数の実体があるメモリの先頭番地を
示すために使われます(それ以外にはジャンプのジャンプ先としても使われます)．
ですので，<code>main</code>関数の先頭番地を示す<code>main</code>というラベルが
<code>main</code>関数をコンパイルしたアセンブリコード中に存在します．</p>
<pre><code class="language-x86asmatt"># asm/movq-6.s
    .text
    .globl main
    .type main, @function
main:
    movq $main, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-6.s">movq-6.s</a>の6行目の<code>movq $main, %rax</code>は
「ラベル<code>main</code>が表すアドレスを<code>%rax</code>レジスタに格納する」という意味です．
<code>gdb</code>で確かめます．</p>
<pre><code>$ gcc ❶ -no-pie -g movq-6.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at ❷ 0x40110a: file movq-6.s, line 7.
(gdb) r
Breakpoint 1, main () at movq-6.s:7
7   ❸  movq $main, %rax
(gdb) ❹ si
main () at movq-6.s:8
8	ret
(gdb) p/x $rax
$1 = ❺ 0x40110a 
</code></pre>
<ul>
<li>まず❶ <code>-no-pie</code>オプションをつけてコンパイルして下さい．
(<code>-static</code>オプションを使ってもうまくいくと思います)</li>
</ul>
<details>
<summary>
なぜ -no-pieオプション
</summary>
<p><code>-no-pie</code>オプションをつけないと以下のエラーが出てしまうからです．</p>
<pre><code>$ gcc -g movq-6.s
/usr/bin/ld: /tmp/ccqHsPbg.o: relocation R_X86_64_32S against symbol `main' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld: failed to set dynamic section sizes: bad value
collect2: error: ld returned 1 exit status
</code></pre>
<p><code>-no-pie</code>は「位置独立実行可能ファイル
(<a href="./3-binary.html#ASLR-PIE">PIE</a>，<a href="./3-binary.html#PIE">PIE</a>)を生成しない」
というオプションです．
最近のLinuxの<code>gcc</code>では，PIEがデフォルトで有効になっている事が多いです．
<a href="./3-binary.html#PIC">PIC</a>(位置独立コード)やPIEは「再配置(アドレス調整)無しに
どのメモリ番地に配置しても，そのまま実行可能」という機械語命令列です．
そのため，PIEやPICのメモリ参照では<strong>絶対アドレス</strong>(absolute address)が使えません．</p>
<p><code>-no-pie</code>オプションが無いと，
アセンブラは<code>movq $main, %rax</code>という命令中の<code>main</code>というラベルを
「絶対アドレスだ」と解釈してエラーにするようです．</p>
<details>
<summary>
絶対アドレス，相対アドレスとは
</summary>
<div id="絶対アドレス・相対アドレス">
<img src="figs/absolute-addr.svg" height="250px" id="fig:absolute-addr">
<p><strong>絶対アドレス</strong>とは「メモリの先頭0番地から何バイト目か」で示すアドレスです．
上図で青色のメモリ位置の絶対アドレスは<code>0x1000</code>番地となります．
一方，<strong>相対アドレス</strong>(relative address)は(0番地ではなく)別の何かを起点とした差分のアドレスです．
x86-64では<code>%rip</code>レジスタ(プログラムカウンタ)を起点とすることが多いです．
上図では青色のメモリ位置の相対アドレスは
<code>%rip</code>を起点とすると，<code>-0x500</code>番地となります(<code>0x1000 - 0x1500 = -0x500</code>)．</p>
<p>また，相対アドレスに起点のアドレスを足すと絶対アドレスになります
(<code>-0x500 + 0x1500 = 0x1000</code>)．</p>
</div>
</details>
<p>なぜ PICやPIEで絶対アドレスが使えないかと言うと，
機械語命令列を何番地に置くかで，絶対アドレスが変化してしまうからです．</p>
<details>
<summary>
もうちょっと具体的に
</summary>
<p>例えば，<code>movq $main, %rax</code>という命令は
<code>main</code>関数のアドレスを<code>%rax</code>レジスタに格納するわけですが，
このアドレスが絶対アドレスの場合，出力される機械語命令に
絶対アドレスが埋め込まれてしまいます．</p>
<pre><code>$ gcc -no-pie -g movq-6.s
$ objdump -d ./a.out
(一部略)
000000000040110a &lt;main&gt;:
  40110a:  48 c7 c0 ❷ 0a 11 40 00    mov ❶$0x40110a,%rax
  401111:  c3                        ret    
</code></pre>
<p>上の逆アセンブル結果を見ると，確かに<code>main</code>関数のアドレス❶ <code>0x40110a</code>が
機械語命令列に❷埋め込まれています．
(x86-64は<a href="./3-binary.html#LSB">リトルエンディアン</a>なので，バイトの並びが逆順に見えることに注意)．</p>
<p>相対アドレスだと大丈夫なことも見てみます．
<a href="./asm/leaq-1.s"><code>leaq-1.s</code></a>中の
<code>leaq main(%rip), %rax</code>は，
「<code>%rip</code>を起点とした<code>main</code>の相対アドレスと，
<code>%rip</code>の値との和を<code>%rax</code>レジスタに格納する」という命令です．
(<code>lea</code> は load effective address の略です．effective addressは日本語では<strong>実効アドレス</strong>です)．</p>
<pre><code class="language-x86asmatt"># asm/leaq-1.s
    .text
    .globl main
    .type main, @function
main:
    leaq main(%rip), %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g leaq-1.s
$ objdump -d ./a.out
(一部略)
0000000000001129 &lt;main&gt;:
 ❶ 1129:  48 8d 05 ❸ f9 ff ff ff    lea    ❷ -0x7(%rip),%rax  # 1129 &lt;main&gt;
 ❹ 1130:  c3                      ret    
</code></pre>
<p>上のように逆アセンブルすると以下が分かります．</p>
<ul>
<li><code>main</code>関数の(ファイル<code>a.out</code>中での)アドレスは❶ <code>0x1129</code>番地</li>
<li><code>leaq main(%rip), %rax</code>の <code>%rip</code>の値は❸ <code>0x1130</code>番地
(プログラムカウンタ <code>%rip</code>は「次に実行する機械語命令のアドレス」を保持しています)．</li>
<li>機械語命令に埋め込まれているアドレスは相対アドレスで，
❶ <code>0x1129</code> - ❸ <code>0x1130</code> = ❷ <code>-0x7</code> = ❸ <code>0xFFFFFFF9</code> です．</li>
</ul>
<p>❶ <code>0x1129</code> や ❹ <code>0x1130</code> のアドレスは，
<code>main</code>関数がどのアドレスに配置されるかで変化します．
しかし，この相対アドレス❷ <code>-0x7</code> は
<code>main</code>関数がどのアドレスに配置されても変化しないので，
この機械語命令はPICやPIEとして使えるわけです．</p>
<p>❷ <code>-0x7</code> が ❸ <code>0xFFFFFFF9</code> として埋め込まれているのは，
<a href="xxx">2の補数表現</a>だからですね</p>
<p>なお，相対アドレスが固定にならない場合(例えば，<code>printf</code>関数のアドレス)もあります．
その場合は<a href="./3-binary.html#GOT-PLT">GOTやPLT</a>を使います．
<code>printf</code>関数のアドレスを機械語命令列(<code>.text</code>セクション)に埋め込むのではなく，
別の書込み可能なセクション(例：<code>got</code>セクション)に格納し，
そのアドレスを使って<strong>間接コール</strong>(indirect call)するのです．</p>
</details>
</details>
<details>
<summary>
-staticオプションとは
</summary>
<p><code>-static</code>オプションは(動的リンクではなく)
<a href="./3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
せよという，<code>gcc</code>への指示になります．</p>
</details>
<ul>
<li>
<p><code>main</code>関数の先頭にブレークポイントを設定します．
<code>main</code>関数の先頭アドレスが❷ <code>0x40110a</code>と分かります．</p>
</li>
<li>
<p>❸ <code>movq $main, %rax</code>の実行直前で止まっているので，
❹ <code>si</code>で1命令実行を進めます．</p>
</li>
<li>
<p>❺ <code>%rax</code>レジスタ中に<code>main</code>関数のアドレス❷ <code>0x40110a</code>が入っていました．</p>
</li>
</ul>
<h3 id="addr-mode-reg"><a class="header" href="#addr-mode-reg">アドレッシングモード：レジスタ参照</a></h3>
<pre><code class="language-x86asmatt"># asm/movq-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    movq %rax, %rbx
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-1.s"><code>movq-1.s</code></a>中の<code>movq %rax, %rbx</code>は
「<code>%rax</code>レジスタ中の値を<code>%rbx</code>に格納する」という意味です．</p>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-1.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-1.s:6
6	    ❶ movq $999, %rax
(gdb) si
7	    ❷ movq %rax, %rbx
(gdb) si
main () at movq-1.s:8
8	    ret
(gdb) p $rax
$1 = ❸ 999
(gdb) p $rbx
$2 = ❹ 999
</code></pre>
<p><code>gdb</code>上での実行で，❶ 定数<code>999</code>が<code>%rax</code>に格納され，
❷ <code>%rax</code>中の<code>999</code>がさらに<code>%rbx</code>に格納されたことを
❸❹確認できました．</p>
<h3 id="addr-mode-direct"><a class="header" href="#addr-mode-direct">アドレッシングモード：直接メモリ参照</a></h3>
<p><strong>直接メモリ参照</strong>はアクセスするメモリ番地が定数となるメモリ参照です．
以下の例ではラベル<code>x</code>を使ってメモリ参照していますが，
これは直接メモリ参照になります．
アセンブル時に(つまり実行する前に)アドレスが具体的に(以下では<code>0x404028</code>番地)と決まるからです．</p>
<pre><code class="language-x86asmatt"># asm/movq-7.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-7.s
$ gdb ./a.out -x movq-7.txt
Breakpoint 1, main () at movq-7.s:10
10	    ret
9	    movq x, %rax
$1 = ❶ 999
# %raxの値が999なら成功
</code></pre>
<p>以下の図で<code>0x401106&lt;main&gt;</code>は「ラベル<code>main</code>が示すアドレスは<code>0x401106</code>番地」
「ラベル<code>x</code>が示すアドレスは<code>0x404028</code>番地」であることを示してます．</p>
<img src="figs/label2.svg" height="250px" id="fig:label2">
<p>そして<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の以下の3行で，以下は</p>
<pre><code class="language-x86asmatt">    .data
x:
    .quad 999 
</code></pre>
<p>「<code>.data</code>セクションにサイズが8バイトのデータとして値<code>999</code>を配置せよ」
「そのデータの先頭アドレスをラベル<code>x</code>として定義せよ」を意味しています
(<code>quad</code>が8バイトを意味しています)．
ですので，実行時には上図のように
「<code>.data</code>セクションのある場所(上図では<code>0x404028</code>番地)に値<code>999</code>が入っていて，
ラベル<code>x</code>の値は<code>0x404028</code>」となっています．</p>
<p>ですので，<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の<code>movq x, %rax</code>は
「ラベル<code>x</code>が表すアドレス(上図では<code>0x404028</code>番地)のメモリの中身(上図では<code>999</code>)
を<code>%rax</code>レジスタにコピーせよ」を意味します．</p>
<p>実行すると<code>movq x, %rax</code>の実行で，<code>x</code>中の<code>999</code>が<code>%rax</code>レジスタに
コピーされたことを確認できました❶．</p>
<p>ここで$マークの有無，つまり<code>x</code>と<code>$x</code>の違いに注意しましょう
(<a href="#label2">上図</a>も参照)．</p>
<pre><code class="language-x86asmatt">movq x, %rax    # x はメモリの中身を表す
movq $x, %rax   # $x はアドレスを表す
</code></pre>
<p>以下のように<code>movq $x, %rax</code>を実行すると，
<code>%rax</code>レジスタにはアドレス(ここでは<code>0x404028</code>番地)が
入っていることを確認できました❷．</p>
<details>
<summary>
-8(%rbp)の-8には(定数なのに)$マークが付かない
</summary>
<p><a href="#addr-mode-indirect">以下</a>でも説明しますが，
例えば<code>-8(%rbp)</code>とオペランドに書いた時，<code>-8</code>は($マークが無いのに)
定数として扱われます．
そして，<code>-8(%rbp)</code>は，<code>%rbp - 8</code>の計算結果をアドレスとするメモリの中身を意味します．　
ちなみにこの<code>-8</code>のことは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>では<strong>変位</strong> (displacement)と呼ばれています．
つまり「変位は定数だけど$マークはつきません」．</p>
</details>
<pre><code class="language-x86asmatt"># asm/movq-8.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq $x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-8.s
$ gdb ./a.out -x movq-8.txt
Breakpoint 1, main () at movq-8.s:10
10	    ret
9	    movq $x, %rax
$1 = 0x404028 ❷
nm ./a.out | egrep 'd x'
0000000000404028 d x
# %raxの値と nmコマンドによるxのアドレスが一致すれば成功
</code></pre>
<p>ちなみに，<code>x</code>のアドレスが<code>0x404028</code>になると分かっていれば，</p>
<pre><code class="language-x86asmatt">movq x, %rax          # これと
movq 0x404028, %rax   # これは同じ意味
</code></pre>
<p>上の2行は全く同じ意味(<code>0x404028</code>番地のメモリの中身)になります．
しかし，何番地になるか事前に分からないのが普通なので，
通常はラベル(ここでは<code>x</code>)を使います．</p>
<h3 id="addr-mode-indirect"><a class="header" href="#addr-mode-indirect">アドレッシングモード：間接メモリ参照</a></h3>
<p><strong>間接メモリ参照</strong>はアクセスするメモリ番地が変数となるメモリ参照です．
アセンブリ言語では変数という概念は無いので，
正確には「実行時に決まるレジスタの値を使って，
参照先のメモリアドレスを計算して決める」という参照方式です．
以下では3つの例が出てきます(<a href="#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>でより複雑な間接メモリ参照を説明します)．</p>
<div class="table-wrapper"><table><thead><tr><th>間接メモリ参照</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>(%rsp)</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>8(%rsp)</code></td><td><code>%rsp + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>%rip + foo</code></td></tr>
</tbody></table>
</div><br/>
<img src="figs/addr-mode-indirect.svg" height="250px" id="fig:addr-mode-indirect">
<p>以下の<a href="./asm/movq-9.s">movq-9.s</a>を<code>pushq $777</code>まで実行すると，
メモリの状態は上図のようになっています．
(<code>%rsp</code>が指す<code>777</code>のひとつ下のアドレスが<code>%rsp+8</code>なのは，
<code>pushq $777</code>命令が「サイズが8バイトの値<code>777</code>をスタックにプッシュしたから」です)．</p>
<pre><code class="language-x86asmatt"># asm/movq-9.s
    .data
foo:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    pushq $888
    pushq $777
    movq (%rsp), %rax
    movq 8(%rsp), %rbx
    movq foo(%rip), %rcx
    ret
    .size main, .-main
</code></pre>
<ul>
<li><code>(%rsp)</code> は「アドレスが <code>%rsp</code>の値のメモリ」なので値<code>777</code>が入っている部分を参照します</li>
<li><code>8(%rsp)</code> は「アドレスが <code>%rsp + 8</code>の値のメモリ」なので値<code>888</code>が入っている部分を参照します</li>
<li><code>foo(%rip)</code> はちょっと特殊です．この形式は <strong><code>%rip</code>相対アドレッシング</strong> といいます．
この形式の時，ラベル<code>foo</code>の値はプログラムカウンタ<code>%rip</code>中のアドレスを起点とした
<a href="#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">相対アドレス</a>
になります．ですので，<code>%rip + foo</code>は<code>foo</code>の
<a href="#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">絶対アドレス</a>
になるので，
<code>foo(%rip)</code>はラベル<code>foo</code>のメモリ部分，つまり<code>999</code>が入っている部分になります．</li>
</ul>
<details>
<summary>
gdbでの実行結果
</summary>
<pre><code>$ gcc -g movq-9.s
$ gdb ./a.out -x movq-9.txt
Breakpoint 1, main () at movq-9.s:14
14	    ret
11	    movq (%rsp), %rax
12	    movq 8(%rsp), %rbx
13	    movq foo(%rip), %rcx
$1 = 777
$2 = 888
$3 = 999
# 777, 888, 999なら成功
</code></pre>
</details>
<h3 id="メモリ参照"><a class="header" href="#メモリ参照">メモリ参照</a></h3>
<p><a href="#addr-mode-indirect">前節</a>では，
<code>(%rsp)</code>，<code>8(%rsp)</code>，<code>foo(%rip)</code>という間接メモリ参照の例を説明しました．
ここではメモリ参照の一般形を説明します．
以下がx86-64のメモリ参照の形式です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div><details>
<summary>
「segment: メモリ参照」という形式
</summary>
<p>実は「segment: メモリ参照」という形式もあるのですが，
あまり使わないので，ここでは省いて説明します．
興味のある人は<a href="x86-list.html#segment-override">こちら</a>を参照下さい．</p>
</details>
<p>disp (base, index, scale)
でアクセスするメモリのアドレスは
base + index * scale + disp で計算します．
disp(<code>%rip</code>)でアクセスするメモリのアドレスは
disp + <code>%rip</code>で計算します．
disp，base，index，scaleとして指定可能なものは次の節で説明します．</p>
<h3 id="メモリ参照で可能な組み合わせ64ビットモードの場合"><a class="header" href="#メモリ参照で可能な組み合わせ64ビットモードの場合">メモリ参照で可能な組み合わせ(64ビットモードの場合)</a></h3>
<h4 id="通常のメモリ参照"><a class="header" href="#通常のメモリ参照">通常のメモリ参照</a></h4>
<p>通常のメモリ参照では，disp，base，index，scaleに以下を指定できます．</p>
<img src="figs/memory-ref.svg" height="250px" id="fig:memory-ref">
<ul>
<li>disp には符号あり定数を指定する．ただし「64ビット定数]は無いことに注意．
アドレス計算時に64ビット長に符号拡張される．
dispは変位(displacement)を意味する．</li>
<li>base には上記のいずれかのレジスタを指定可能．省略も可．</li>
<li>index には上記のいずれかのレジスタを指定可能．省略も可．
<code>%rsp</code>を指定できないことに注意．</li>
<li>scale を省略すると <code>1</code> と同じ</li>
</ul>
<blockquote>
<p>注: dispの例外．
<code>mov␣</code>命令のみ，64ビットのdispを指定可能．
この場合，<code>movabs␣</code>というニモニックを使用可能．
メモリ参照はdispのみで，base，index，scaleは指定不可．
他方のオペランドは<code>%rax</code>のみ指定可能．</p>
<pre><code>movq     0x1122334455667788, %rax
movabsq  0x1122334455667788, %rax
movq     %rax, 0x1122334455667788
movabsq  %rax, 0x1122334455667788
</code></pre>
</blockquote>
<h4 id="rip相対参照"><a class="header" href="#rip相対参照"><code>%rip</code>相対参照</a></h4>
<img src="figs/rip-relative.svg" height="120px" id="fig:rip-relative">
<p><code>%rip</code>相対参照では32ビットのdispと<code>%rip</code>レジスタのみが指定可能です．</p>
<h3 id="メモリ参照の例"><a class="header" href="#メモリ参照の例">メモリ参照の例</a></h3>
<p>以下がメモリ参照の例です．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>指定したもの</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>8</code></td><td><code>[8]</code></td><td>disp</td><td><code>8</code></td></tr>
<tr><td><code>foo</code></td><td><code>[foo]</code></td><td>disp</td><td><code>foo</code></td></tr>
<tr><td><code>(%rbp)</code></td><td><code>[rbp]</code></td><td>base</td><td><code>%rbp</code></td></tr>
<tr><td><code>8(%rbp)</code></td><td><code>[rbp+8]</code></td><td>dispとbase</td><td><code>%rbp + 8</code></td></tr>
<tr><td><code>foo(%rbp)</code></td><td><code>[rbp+foo]</code></td><td>dispとbase</td><td><code>%rbp + foo</code></td></tr>
<tr><td><code>8(%rbp,%rax)</code></td><td><code>[rbp+rax+8]</code></td><td>dispとbaseとindex</td><td><code>%rbp + %rax + 8</code></td></tr>
<tr><td><code>8(%rbp,%rax, 2)</code></td><td><code>[rbp+rax*2+8]</code></td><td>dispとbaseとindexとscale</td><td><code>%rbp + %rax*2 + 8</code></td></tr>
<tr><td><code>(%rip)</code></td><td><code>[rip]</code></td><td>base</td><td><code>%rip</code></td></tr>
<tr><td><code>8(%rip)</code></td><td><code>[rip+8]</code></td><td>dispとbase</td><td><code>%rip + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>[rip+foo]</code></td><td>dispとbase</td><td><code>%rip + foo</code></td></tr>
<tr><td><code>%fs:-4</code></td><td><code>fs:[-4]</code></td><td><a href="./x86-list.html#segment-override">segment</a>とdisp</td><td><code>%fsのベースレジスタ - 4</code></td></tr>
</tbody></table>
</div><details>
<summary>
なんでこんな複雑なアドレッシングモード?
</summary>
<p>x86-64はRISCではなくCISCなので「よく使う1つの命令で複雑な処理が
できれば，それは善」という思想だからです(知らんけど)．
例えば，以下のCコードの配列<code>array[i]</code>へのアクセスはアセンブリコードで
<code>movl (%rdi,%rsi,4), %eax</code>の1命令で済みます．
(ここでは<code>sizeof(int)</code>が<code>4</code>なので，scaleが<code>4</code>になっています．
配列の先頭アドレスが<code>array</code>の，<code>i</code>番目の要素のアドレスは，
<code>array + i * sizeof(int)</code>で計算できることを思い出しましょう．
なお，<code>array.s</code>の出力を得るには，<code>gcc -S -O2 array.c</code>として下さい．
私の環境では<code>-O2</code>が無いと<code>gcc</code>は冗長なコードを吐きましたので)．</p>
<pre><code>// array.c
int foo (int array [], int i)
{
    return array [i];
}
</code></pre>
<pre><code>	.text
	.p2align 4
	.globl	foo
	.type	foo, @function
foo:
	endbr64
	movslq	%esi, %rsi
	movl	(%rdi,%rsi,4), %eax
	ret
	.size	foo, .-foo
</code></pre>
</details>
<h2 id="オペランドの表記方法"><a class="header" href="#オペランドの表記方法">オペランドの表記方法</a></h2>
<p>以下の機械語命令の説明で使う記法を説明します．
この記法はその命令に許されるオペランドの形式を表します．</p>
<h3 id="オペランド即値定数"><a class="header" href="#オペランド即値定数">オペランド，即値(定数)</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*op1*|  | 第1オペランド |
|*op2*|  | 第2オペランド |
|*imm*| `$100` |  *imm8*, *imm16*, *imm32*のどれか |
|*imm8*| `$100` | 8ビットの即値(定数) |
|*imm16*| `$100` | 16ビットの即値(定数) |
|*imm32*| `$100` | 32ビットの即値(定数) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>op1</em></td><td></td><td>第1オペランド</td></tr>
<tr><td><em>op2</em></td><td></td><td>第2オペランド</td></tr>
<tr><td rowspan="2"><em>imm</em></td><td><code>$100</code></td><td rowspan="2"><em>imm8</em>, <em>imm16</em>, <em>imm32</em>のどれか</td></tr>
<tr><td><code>$foo</code></td></tr>
<tr><td><em>imm8</em></td><td><code>$100</code></td><td>8ビットの即値(定数)</td></tr> 
<tr><td><em>imm16</em></td><td><code>$100</code></td><td>16ビットの即値(定数)</td></tr>
<tr><td><em>imm32</em></td><td><code>$100</code></td><td>32ビットの即値(定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>多くの場合，サイズを省略して単に<em>imm</em>と書きます．
特にサイズに注意が必要な時だけ，<em>imm32</em>などとサイズを明記します．</li>
<li><a href="./x86-list.html#mov-64bit-imm">一部例外を除き</a>，
x86-64では64ビットの即値を書けません(32ビットまでです)．</li>
</ul>
<h3 id="汎用レジスタ"><a class="header" href="#汎用レジスタ">汎用レジスタ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>r</em></td><td><code>%rax</code></td><td><em>r8</em>, <em>r16</em>, <em>r32</em>, <em>r64</em>のどれか</td></tr>
<tr><td><em>r8</em></td><td><code>%al</code></td><td>8ビットの汎用レジスタ</td></tr>
<tr><td><em>r16</em></td><td><code>%ax</code></td><td>16ビットの汎用レジスタ</td></tr>
<tr><td><em>r32</em></td><td><code>%eax</code></td><td>32ビットの汎用レジスタ</td></tr>
<tr><td><em>r64</em></td><td><code>%rax</code></td><td>64ビットの汎用レジスタ</td></tr>
</tbody></table>
</div>
<h3 id="メモリ参照-1"><a class="header" href="#メモリ参照-1">メモリ参照</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*r/m*  | `-8(%rbp)` |  *r/m8*, *r/m16*, *r/m32*, *r/m64*のどれか |
|*r/m8* | `-8(%rbp)` | *r8*  または 8ビットのメモリ参照 |
|*r/m16*| `-8(%rbp)` | *r16* または16ビットのメモリ参照 |
|*r/m32*| `-8(%rbp)` | *r32* または32ビットのメモリ参照 |
|*r/m64*| `-8(%rbp)` | *r64* または64ビットのメモリ参照 |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="4"><em>r/m</em></td><td><code>%rbp</code></td><td rowspan="4"><em>r/m8</em>, <em>r/m16</em>, <em>r/m32</em>, <em>r/m32</em>, <em>r/m64</em>のどれか</td></tr>
<tr><td><code>100</code></td></tr>
<tr><td><code>-8(%rbp)</code></td></tr>
<tr><td><code>foo(%rbp)</code></td></tr>
<tr><td><em>r/m8</em></td><td><code>-8(%rbp)</code></td><td><em>r8</em>  または 8ビットのメモリ参照</td></tr>
<tr><td><em>r/m16</em></td><td><code>-8(%rbp)</code></td><td><em>r16</em> また
は16ビットのメモリ参照</td></tr>
<tr><td><em>r/m32</em></td><td><code>-8(%rbp)</code></td><td><em>r32</em> また
は32ビットのメモリ参照</td></tr>
<tr><td><em>r/m64</em></td><td><code>-8(%rbp)</code></td><td><em>r64</em> また
は64ビットのメモリ参照</td></tr>
<tr><td><em>m</em></td><td><code>-8(%rbp)</code></td><td> メモリ参照</td></tr>
</tbody></table>
</div>
<h2 id="x86-64機械語命令転送など"><a class="header" href="#x86-64機械語命令転送など">x86-64機械語命令：転送など</a></h2>
<h3 id="nop命令-何もしない"><a class="header" href="#nop命令-何もしない"><code>nop</code>命令: 何もしない</a></h3>
<p><code>nop</code>は転送命令ではありませんが，最も簡単な命令ですので最初に説明します．</p>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
<tr><td><strong><code>nop</code></strong> <em>op1</em></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td><code>nop</code></td><td>何もしない</td><td><a href="./asm/nop.s">nop.s</a> <a href="./asm/nop.txt">nop.txt</a></td></tr>
<tr><td><strong><code>nop</code></strong> <em>r/m</em></td><td><code>nopl (%rax)</code></td><td>何もしない</td><td><a href="./asm/nop2.s">nop2.s</a> <a href="./asm/nop2.txt">nop2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./5-arch.html#status-reg">CF</a></th><th><a href="./5-arch.html#status-reg">OF</a></th><th><a href="./5-arch.html#status-reg">SF</a></th><th><a href="./5-arch.html#status-reg">ZF</a></th><th><a href="./5-arch.html#status-reg">PF</a></th><th><a href="./5-arch.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
<ul>
<li><code>nop</code>は何もしない命令です(ただしプログラムカウンタ<code>%rip</code>は増加します)．
フラグも変化しません．</li>
<li>機械語命令列の間を(何もせずに)埋めるために使います．</li>
<li><code>nop</code>の機械語命令は1バイト長です．
(なのでどんな長さの隙間にも埋められます)．</li>
<li><code>nop</code> <em>r/m</em> という形式の命令は2〜9バイト長の<code>nop</code>命令になります．
1バイト長の<code>nop</code>を9個並べるより，
9バイト長の<code>nop</code>を1個並べた方が，実行が早くなります．</li>
<li>「複数バイトの<code>nop</code>命令がある」という知識は，
逆アセンブル時に<code>nopl (%rax)</code>などを見て「なんじゃこりゃ」とビックリしないために必要です．</li>
</ul>
<h3 id="mov命令-データの転送コピー"><a class="header" href="#mov命令-データの転送コピー"><code>mov</code>命令: データの転送（コピー）</a></h3>
<div id="mov-plain">
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E6%96%87%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td><a href="./asm/movq-1.s">movq-1.s</a> <a href="./asm/movq-1.txt">movq-1.txt</a></td></tr>
<tr><td><code>movq %rax, -8(%rsp)</code></td><td><code>*(%rsp - 8) = %rax</code></td><td><a href="./asm/movq-2.s">movq-2.s</a> <a href="./asm/movq-2.txt">movq-2.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq -8(%rsp), %rax</code></td><td><code>%rax = *(%rsp - 8)</code></td><td><a href="./asm/movq-3.s">movq-3.s</a> <a href="./asm/movq-3.txt">movq-3.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, -8(%rsp)</code></td><td><code>*(%rsp - 8) = 999</code></td><td><a href="./asm/movq-5.s">movq-5.s</a> <a href="./asm/movq-5.txt">movq-5.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
</div>
<ul>
<li><code>mov</code>命令は第1オペランドの値を第2オペランドに転送(コピー)します．
例えば，<code>movq %rax, %rbx</code>は「<code>%rax</code>の値を<code>%rbx</code>にコピー」することを意味します．</li>
</ul>
<details>
<summary>
movq-1.sの実行例
</summary>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out -x movq-1.txt
Breakpoint 1, main () at movq-1.s:8
8	    ret
7	    movq %rax, %rbx
# p $rbx
$1 = 999
# %rbxの値が999なら成功
</code></pre>
</details>
<details>
<summary>
movq-2.sの実行例
</summary>
<pre><code>$ gcc -g movq-2.s
$ gdb ./a.out -x movq-2.txt
Breakpoint 1, main () at movq-2.s:8
8	    ret
7	    movq %rax, -8(%rsp)
# x/1gd $rsp-8
0x7fffffffde90:	999
# -8(%rsp)の値が999なら成功
</code></pre>
</details>
<ul>
<li>
<p>オペランドには，即値，レジスタ，メモリ参照を組み合わせて指定できますが，
メモリからメモリへの直接データ転送はできません．</p>
</li>
<li>
<p><code>␣</code>には<a href="./x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a>
(<code>q</code>, <code>l</code>, <code>w</code>, <code>b</code>)を指定します．
命令サフィックスは転送するデータのサイズを明示します
(順番に，8バイト，4バイト，2バイト，1バイトを示します)．</p>
<ul>
<li><code>movb $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>1バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movw $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>2バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movl $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>4バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movq $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>8バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
</ul>
</li>
</ul>
<div class="tab-wrap">
    <input id="mov1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="mov1"><code>movb $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov1.svg" height="300px" id="fig:mov1">
    </div>
    <input id="mov2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov2"><code>movw $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov2.svg" height="300px" id="fig:mov2">
    </div>
    <input id="mov3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov3"><code>movl $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov3.svg" height="300px" id="fig:mov3">
    </div>
    <input id="mov4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov4"><code>movq $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov4.svg" height="300px" id="fig:mov4">
    </div>
</div>
<h4 id="機械語命令のバイト列をアセンブリコードに直書きできる"><a class="header" href="#機械語命令のバイト列をアセンブリコードに直書きできる">機械語命令のバイト列をアセンブリコードに直書きできる</a></h4>
<p><code>movq %rax, %rbx</code>をコンパイルして逆アセンブルすると，
機械語命令のバイト列は<code>48 89 C3</code>となります．
<code>.byte</code>というアセンブラ命令を使うと，
アセンブラに指定したバイト列を出力できます．
例えば，次のように<code>.byte 0x48, 0x89, 0xC3</code>と書くと，
<code>.text</code>セクションに<code>0x48, 0x89, 0xC3</code>というバイト列を出力できます．</p>
<pre><code class="language-x86asmatt"># asm/byte.s
    .text
    .globl main
    .type main, @function
main:
    movq %rax, %rbx          # これと
    .byte 0x48, 0x89, 0xC3   # これは同じ意味
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:   ❶48 89 c3     ❸mov    %rax,%rbx
    112c:   ❷48 89 c3     ❹mov    %rax,%rbx
    112f:   c3               ret    
</code></pre>
<p>コンパイルして逆アセンブルしてみると，
❷<code>0x48, 0x89, 0xC3</code>を出力できています．
一方，❶<code>0x48, 0x89, 0xC3</code>にも同じバイト列が並んでいます．
これは❸<code>movq %rax, %rbx</code>命令の機械語命令バイト列ですね．
さらに❷<code>0x48, 0x89, 0xC3</code>の逆アセンブル結果として，
❹<code>movq %rax, %rbx</code>とも表示されています．</p>
<p>つまり，アセンブラにとっては，</p>
<ul>
<li><code>movq %rax, %rbx</code> というニモニック</li>
<li><code>.byte 0x48, 0x89, 0xC3</code> というバイト列</li>
</ul>
<p>は全く同じ意味になるのでした．
ですので，<code>.text</code>セクションにニモニックで機械語命令を書く代わりに，
<code>.byte</code>を使って直接，機械語命令のバイト列を書くことができます．</p>
<h4 id="異なる機械語のバイト列で同じ動作のmov命令がある"><a class="header" href="#異なる機械語のバイト列で同じ動作のmov命令がある">異なる機械語のバイト列で，同じ動作の<code>mov</code>命令がある</a></h4>
<ul>
<li>質問： <code>%rax</code>の値を<code>%rbx</code>にコピーしたい時，
<code>movq</code> <em>r</em>, <em>r/m</em> と <code>movq</code> <em>r/m</em>, <em>r</em> のどちらを使えばいいのでしょう?</li>
<li>答え： どちらを使ってもいいです．ただし，異なる機械語命令のバイト列に
なることがあります．</li>
</ul>
<p>実は<code>0x48, 0x89, 0xC3</code>というバイト列は，
<code>movq</code> <em>r</em>, <em>r/m</em> を使った時のものです．
一方，<code>movq</code> <em>r/m</em>, <em>r</em> という形式を使った場合は，
バイト列は <code>0x48, 0x8B, 0xD8</code>になります．確かめてみましょう．</p>
<pre><code class="language-x86asmatt"># asm/byte2.s
    .text
    .globl main
    .type main, @function
main:
    .byte 0x48, 0x89, 0xC3
    .byte 0x48, 0x8B, 0xD8
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte2.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:    ❶48 89 c3      ❸mov    %rax,%rbx
    112c:    ❷48 8b d8      ❹mov    %rax,%rbx
    112f:      c3             ret    
</code></pre>
<p>❶<code>48 89 c3</code>と❷<code>48 8b d8</code>は異なるバイト列ですが
逆アセンブル結果としては
❸<code>mov %rax,%rbx</code>と❹<code>mov %rax,%rbx</code>と，どちらも同じ結果になりました．</p>
<p>このように同じニモニック命令に対して，複数の機械語のバイト列が存在する時，
アセンブラは「実行が速い方」あるいは「バイト列が短い方」を適当に選んでくれます．
(そして，アセンブラが選ばない方をどうしても使いたい場合は，
<code>.byte</code>等を使って機械語のバイト列を直書きするしかありません)．</p>
<h3 id="xchg命令-オペランドの値を交換"><a class="header" href="#xchg命令-オペランドの値を交換"><code>xchg</code>命令: オペランドの値を交換</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>op1</em>, <em>op2</em></td><td>exchange</td><td><em>op1</em> と <em>op2</em> の値を交換する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xchg %rax, (%rsp)</code></td><td><code>%rax</code>と<code>(%rsp)</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
<tr><td><strong><code>xchg</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xchg (%rsp), %rax</code></td><td><code>(%rsp)</code>と<code>%rax</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>xchg</code>命令は<strong>アトミックに</strong>2つのオペランドの値を交換します．(LOCKプレフィクスをつけなくてもアトミックになります)</li>
<li>この<strong>アトミック</strong>な動作はロックなどの<strong>同期機構</strong>を作るために使えます．</li>
</ul>
<details>
<summary>
xchg.sの実行例
</summary>
<pre><code>$ gcc -g xchg.s
$ gdb ./a.out -x xchg.txt
Breakpoint 1, main () at xchg.s:9
9	    xchg %rax, (%rsp)
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
10	    xchg (%rsp), %rax
1: /x $rax = 0x1122334455667788
2: /x *(void **)($rsp) = 0x99aabbccddeeff00
11	    popq %rax
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
# 値が入れ替わっていれば成功
</code></pre>
</details>
<h3 id="lea命令-実効アドレスを計算"><a class="header" href="#lea命令-実効アドレスを計算"><code>lea</code>命令: 実効アドレスを計算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>op1</em>, <em>op2</em></td><td>load effective address</td><td><em>op1</em> の実効アドレスを <em>op2</em> に代入する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>m</em>, <em>r</em></td><td><code>leaq -8(%rsp, %rsi, 4), %rax</code></td><td><code>%rax=%rsp+%rsi*4-8</code></td><td><a href="./asm/leaq-2.s">leaq-2.s</a> <a href="./asm/leaq-2.txt">leaq-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>lea</code>命令は第1オペランド(常にメモリ参照)の実効アドレスを計算して，
第2オペランドに格納します．</li>
<li><code>lea</code>命令はアドレスを計算するだけで，メモリにはアクセスしません．</li>
</ul>
<details>
<summary>
leaq-2.sの実行例
</summary>
<pre><code>$ gcc -g lea.s
$ gdb ./a.out -x lea.txt
Breakpoint 1, main () at leaq-2.s:8
8	    ret
# p/x $rsp
$1 = 0x7fffffffde98
# p/x $rsi
$2 = 0x8
# p/x $rax
$3 = 0x7fffffffdeb0
# %rax == %rsp + %rsi * 4 なら成功
</code></pre>
</details>
<ul>
<li><strong>実効アドレス</strong>とは<a href="#addr-mode-direct">直接メモリ参照</a>や
<a href="#addr-mode-indirect">間接メモリ参照</a>で計算したアドレスことです．</li>
</ul>
<details>
<summary>
実効アドレスとリニアアドレスの違いは?→(ほぼ)同じ
</summary>
<br/>
<img src="figs/effective-addr.svg" height="300px" id="fig:effective-addr">
<ul>
<li><strong>実効アドレス</strong>(effective address)は
<a href="./6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">メモリ参照</a>で
disp (base, index, scale) や disp (<code>%rip</code>)から計算したアドレスのことです．</li>
<li>x86-64のアセンブリコード中のアドレスは<strong>論理アドレス</strong> (logical address)といい，
<strong>セグメント</strong>と<strong>実効アドレス</strong>のペアとなっています．
このペアをx86-64用語で<strong>farポインタ</strong>とも呼びます．
(本書ではfarポインタは扱いません)．</li>
<li>セグメントが示すベースアドレスと実効アドレスを加えたものが
<strong>リニアアドレス</strong>(linear address)です．
例えば64ビットアドレス空間だと，リニアアドレスは0番地から2<sup>64</sup>-1番地
まで一直線に並ぶのでリニアアドレスと呼ばれています．
リニアアドレスは<strong>仮想アドレス</strong>(virtual address)と等しくなります．</li>
<li>また，x86-64では<a href="./x86-list.html#segment-override">例外</a>を除き，
セグメントが示すベースアドレスが0番地なので，
<strong>実効アドレスとリニアアドレスは等しくなります</strong>．</li>
<li>リニアアドレス(仮想アドレス)はCPUのページング機構により，
物理アドレスに変換されて，最終的なメモリアクセスが行われます．</li>
</ul>
</details>
<ul>
<li>コンパイラは加算・乗算を高速に実行するため<code>lea</code>命令を使うことがあります．</li>
</ul>
<p>例えば，</p>
<pre><code class="language-x86asmatt">movq $4, %rax
addq %rbx, %rax
shlq $2, %rsi   # 左論理シフト．2ビット左シフトすることで%rsiを4倍にしている
addq %rsi, %rax
</code></pre>
<p>は，<code>%rax = %rbx + %rsi * 4 + 4</code>という計算を4命令でしていますが，
<code>lea</code>命令なら以下の1命令で済みます．</p>
<pre><code class="language-x86asmatt">leaq 4(%rbx, %rsi, 4), %rax
</code></pre>
<h3 id="pushとpop命令-スタックとデータ転送"><a class="header" href="#pushとpop命令-スタックとデータ転送"><code>push</code>と<code>pop</code>命令: スタックとデータ転送</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>op1</em></td><td>push</td><td><em>op1</em> をスタックにプッシュ</td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>op1</em></td><td>pop</td><td>スタックから <em>op1</em> にポップ</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>imm</em></td><td><code>pushq $999</code></td><td><code>%rsp-=8; *(%rsp)=999</code></td><td><a href="./asm/push1.s">push1.s</a> <a href="./asm/push1.txt">push1.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m16</em></td><td><code>pushw %ax</code></td><td><code>%rsp-=2; *(%rsp)=%ax</code></td><td><a href="./asm/push2.s">push2.s</a> <a href="./asm/push2.txt">push2.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m64</em></td><td><code>pushq %rax</code></td><td><code>%rsp-=8; *(%rsp)=%rax</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m16</em></td><td><code>popw %ax</code></td><td><code>*(%rsp)=%ax; %rsp += 2</code></td><td><a href="./asm/pop2.s">pop2.s</a> <a href="./asm/pop2.txt">pop2.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m64</em></td><td><code>popq %rbx</code></td><td><code>%rbx=*(%rsp); %rsp += 8</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<br/>
<div class="tab-wrap">
    <input id="push-pop1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="push-pop1"><code>pushq %rax前</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop1.svg" height="350px" id="fig:push-pop1">
    </div>
    <input id="push-pop2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop2"><code>pushq %rax後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop2.svg" height="350px" id="fig:push-pop2">
    </div>
    <input id="push-pop3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop3"><code>popq %rbx後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop3.svg" height="350px" id="fig:push-pop3">
    </div>
</div>
<ul>
<li><code>push</code>命令はスタックポインタ<code>%rsp</code>を<strong>減らしてから</strong>，
スタックトップ(スタックの一番上)にオペランドの値を格納します．</li>
<li><code>pop</code>命令はスタックトップの値をオペランドに<strong>格納してから</strong>，
スタックポインタを増やします．</li>
<li>64ビットモードでは，32ビットの<code>push</code>と<code>pop</code>はできません．</li>
<li>抽象データ型のスタックは(スタックトップに対する)プッシュ操作とポップ操作しか
できませんが，x86-64のスタック操作はスタックトップ以外の部分にも自由にアクセス可能です(例えば，<code>-8(%rsp)</code>や<code>-8(%rbp)</code>などへのメモリ参照で)．</li>
</ul>
<details>
<summary>
push1.sの実行例
</summary>
<pre><code>$ gcc -g push1.s
$ gdb ./a.out -x push1.txt
Breakpoint 1, main () at push1.s:6
6	    pushq $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push1.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde90
# x/1gd $rsp
0x7fffffffde90:	999
# %rsp が8減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
push2.sの実行例
</summary>
<pre><code>$ gcc -g push2.s
$ gdb ./a.out -x push2.txt
Breakpoint 1, main () at push2.s:6
6	    pushw $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push2.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde96
# x/1hd $rsp
0x7fffffffde96:	999
# %rsp が2減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
pop2.sの実行例
</summary>
<pre><code>$ gcc -g pop2.s
$ gdb ./a.out -x pop2.txt
Breakpoint 1, main () at pop2.s:7
7	    popw %ax
# p/x $rsp
$1 = 0x7fffffffde96
main () at pop2.s:8
8	    ret
# p/x $rsp
$2 = 0x7fffffffde98
# p/d $ax
$3 = 999
# %rsp が2増えて，%axの値が999なら成功
</code></pre>
</details>
<details>
<summary>
push-pop.sの実行例
</summary>
<pre><code>$ gcc -g push-pop.s
$ gdb ./a.out -x push-pop.txt
Breakpoint 1, main () at push-pop.s:8
8	    pushq %rax
# p/x $rsp
$1 = 0x7fffffffde98
main () at push-pop.s:9
9	    popq  %rbx
# p/x $rsp
$2 = 0x7fffffffde90
# x/8bx $rsp
0x7fffffffde90:	0x88	0x77	0x66	0x55	0x44	0x33	0x22	0x11
# %rsp の値が8減って，スタックトップ8バイトが 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11なら成功
</code></pre>
</details>
<h2 id="x86-64機械語命令算術論理演算"><a class="header" href="#x86-64機械語命令算術論理演算">x86-64機械語命令：算術論理演算</a></h2>
<h3 id="四則演算"><a class="header" href="#四則演算">四則演算</a></h3>
<p>32ビットで演算すると，64ビットレジスタの上位32ビットがクリアされる話．</p>
<h3 id="インクリメントデクリメント符号反転"><a class="header" href="#インクリメントデクリメント符号反転">インクリメント，デクリメント，符号反転</a></h3>
<h3 id="ビット論理演算"><a class="header" href="#ビット論理演算">ビット論理演算</a></h3>
<h3 id="シフト演算"><a class="header" href="#シフト演算">シフト演算</a></h3>
<h3 id="ローテート演算"><a class="header" href="#ローテート演算">ローテート演算</a></h3>
<h2 id="x86-64機械語命令比較とジャンプ"><a class="header" href="#x86-64機械語命令比較とジャンプ">x86-64機械語命令：比較とジャンプ</a></h2>
<h3 id="比較"><a class="header" href="#比較">比較</a></h3>
<h3 id="無条件ジャンプ"><a class="header" href="#無条件ジャンプ">無条件ジャンプ</a></h3>
<h3 id="status-reg"><a class="header" href="#status-reg">ステータスレジスタ</a></h3>
<h3 id="条件付きジャンプ"><a class="header" href="#条件付きジャンプ">条件付きジャンプ</a></h3>
<h2 id="x86-64機械語命令その他の命令"><a class="header" href="#x86-64機械語命令その他の命令">x86-64機械語命令：その他の命令</a></h2>
<p>###<code>nop</code>命令</p>
<p>endbr64, bnd, int3 など
rdtsc</p>
<h2 id="x86-64機械語命令関数呼び出しとリターン"><a class="header" href="#x86-64機械語命令関数呼び出しとリターン">x86-64機械語命令：関数呼び出しとリターン</a></h2>
<h3 id="call"><a class="header" href="#call"><code>call</code></a></h3>
<h3 id="caller-callee-save-regs"><a class="header" href="#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></h3>
<h3 id="arg-reg"><a class="header" href="#arg-reg">引数</a></h3>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="5-arch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="7-asmdir.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="5-arch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="7-asmdir.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
