<style type="text/css">
body { counter-reset: chapter 7; }
</style>

# アセンブラ命令

### アセンブラとアセンブラ命令

- **アセンブラ** (assembler)はアセンブリコード (`foo.s`)を
  オブジェクトファイル (`foo.o`)に変換するプログラムです．
  - 例えば，`gcc -c foo.s`とするとアセンブルできます．
    `gcc -c`は内部で`as`コマンドを呼んでいて，これがアセンブラ本体です．
    (`gcc`に`-v`オプションを付けると，`as`コマンドの実行が見えます)．
- **アセンブラ命令** (assembler directive)はアセンブラへの指示です．
  - 例えば，`.text`はアセンブラに「出力先を`.text`セクションに切り替えろ」と
    指示しています．
  - GNUアセンブラのアセンブラ命令は**すべてドット**`.`で始まります．
- アセンブラ命令はCPUが実行しない命令なので，
  **疑似命令**(psuedo instruction)とも呼ばれます．
  (が，分かりにくい用語なので本書では使いません)．
  
### アセンブラ命令と機械語命令

||例|何が実行|いつ実行|バイナリファイル中に|
|-|-|-|-|-|
|アセンブラ命令|`.text`|アセンブラ|アセンブル時|残らない|
|機械語命令|`addl $5, %eax`|CPU|`a.out`実行時|残る|

<img src="figs/add5-2.svg" height="200px" id="fig:add5-2">

- アセンブラがアセンブリコード(`*.s`)からオブジェクトファイル(`*.o`)を作る際に，
  - アセンブラ命令(例: `.text`)に従って処理をします．例えば，`addl $5, %eax`を
    バイト列に変換した結果 `0x83 0xC0 0x05`を`.text`セクションに出力します．
  - その結果，アセンブラ命令 `.text`はオブジェクトファイルには残りません．
   (オブジェクトファイル中に`.text`セクションはありますが，
    これはアセンブラ命令`.text`ではありません)．
- 一方，機械語命令 `addl $5, %eax`はオブジェクトファイルに残っています
  (バイト列 `0x83 0xC0 0x05`と見た目は変わっていますが)．
  `a.out`を実行したときに，CPUがこの機械語命令を実行します．

## アセンブラの主な仕事

### 概要

アセンブラの主なお仕事は大きく次の4つです．

- 機械語命令やデータを[2進数表現に変換](./4-data.md)する
  - 例: `pushq %rax` を `0x50` に変換する
  - 例: `.string "%d\n"` を `0x25 0x64 0x0A 0x00`に変換する
    (`.string`は自動的に**ヌル文字** `0x00`を最後に付加します)
  - アセンブラにとって，機械語命令もデータも
    「2進数にして出力する」という意味で，どちらも単なるデータです．

- 変換した2進数を指定された**セクション**に出力する
- **記号表** (symbol table)を作って，ラベルをアドレスに変換する
- 最後に変換したデータをバイナリ形式(LinuxではELF形式)にしてファイル出力する

### セクションへの出力

#### セクションとは

バイナリファイルの構造はざっくり以下の図のようになっています．

<img src="figs/section.svg" height="250px" id="fig:text-binary">

- 基本的に，バイナリ (オブジェクトファイル`*.o`や実行可能ファイル`a.out`)は
  **セクション** (section)という単位で区切られていて，それぞれ別の目的でデータが格納されます．
- **ヘッダ** (header)は目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．

#### 代表的なセクション

|セクション名| 説明 |
|-|-|
|`.text`|機械語命令(例：`pushq %rbp`)を置くセクション|
|`.data`|初期化済みの静的変数の値(例：`0x1234`)を置くセクション|
|`.bss`|未初期化(実行時に0で初期化する)の静的変数の値を置くセクション|
|`.rodata`|読み込みのみ(read only)の値(例：`"hello\n"`)を置くセクション|

#### 各セクションに出力する例

例えば，以下のアセンブリコード`foo.s`があるとします
(`.rodata`セクションを指定する際は，`.section`が必要です)．

```x86asmatt
# foo.s
.text            # .textセクションに出力せよ
pushq %rbp
movq %rsp, %rbp
.data            # .dataセクションに出力せよ
.long 0x11223344
.section .rodata # .rodataセクションに出力せよ
.string "hello\n"
```

<img src="figs/section2.svg" height="200px" id="fig:section2">

この`foo.s`をアセンブラが処理すると以下になります．

- `pushq %rbp`を2進数にすると `0x55`，
  `movq %rsp, %rbp`を2進数にすると `0x48 0x89 0xe5` なので，
  これら合計4バイトを`.text`セクションに出力します．
- `.data`は「`.data`セクションに出力せよ」
  「`.long`は指定したデータを4バイトの2進数として出力せよ」という意味です．
  `0x11223344`を2進数にすると `0x44 0x33 0x22 0x11`なので
  これら4バイトを`.data`セクションに出力します．
  (出力が逆順になっているように見えるのは
  x86-64が[リトルエンディアン](./3-binary.md#リトルエンディアン)だからです．)
- `.section .rodata`は「`.rodata`セクションに出力せよ」
  「`.string`は指定した文字列をASCIIコードの2進数として出力せよ」という意味です．
  `"hello\n"`を2進数にすると `0x68 0x65 0x6c 0x6c 0x64 0x0a 0x00`なので，
  これら7バイトを`.rodata`セクションに出力します．
  (最後の'\0'はヌル文字です．C言語では文字列定数の最後に自動的に
   ヌル文字が追加されますが，アセンブリ言語では必ずしもそうではありません．
  `.string`はヌル文字を自動的に追加します．
  一方，(ここでは使っていませんが)`.ascii`はヌル文字を自動的に追加しません)．
  ASCIIコードは`man ascii`で確認できます．

#### セクションを確認する

- セクションの内容は`objdump -h`や`readelf -S`コマンドで表示できます．

- `objdump -h` の例と読み方

```bash
$ gcc -g -c add5.c
$ objdump -h add5.o
add5.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000013  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000053  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000053  2**0
                  ALLOC
~  3 .debug_info   00000066  0000000000000000  0000000000000000  00000053  2**0
~                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
~  4 .debug_abbrev 0000004d  0000000000000000  0000000000000000  000000b9  2**0
~                  CONTENTS, READONLY, DEBUGGING, OCTETS
~  5 .debug_aranges 00000030  0000000000000000  0000000000000000  00000106  2**0
~                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
~  6 .debug_line   0000004f  0000000000000000  0000000000000000  00000136  2**0
~                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
~  7 .debug_str    00000093  0000000000000000  0000000000000000  00000185  2**0
~                  CONTENTS, READONLY, DEBUGGING, OCTETS
~  8 .debug_line_str 00000089  0000000000000000  0000000000000000  00000218  2**0
~                  CONTENTS, READONLY, DEBUGGING, OCTETS
~  9 .comment      0000002c  0000000000000000  0000000000000000  000002a1  2**0
~                  CONTENTS, READONLY
~ 10 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000002cd  2**0
~                  CONTENTS, READONLY
~ 11 .note.gnu.property 00000020  0000000000000000  0000000000000000  000002d0  2**3
~                  CONTENTS, ALLOC, LOAD, READONLY, DATA
~ 12 .eh_frame     00000038  0000000000000000  0000000000000000  000002f0  2**3
~                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

| 欄 | 例 | 説明 |
|-|-|-|
|Idx| 1 | セクションの通し番号 |
|Name|`.text`| セクションの名前|
|Size|`00000013`| セクションのサイズ (16進数，バイト)|
|VMA|`00000000`| 実行時のセクションのアドレス (virtual memory address, 16進数)|
|LMA|`00000000`| ロード時のセクションのアドレス (load memory address, 16進数)|
|File Off|`00000040`|ファイルオフセット(16進数，バイト)|
|Algn|`2**0`| セクションのアラインメント制約(バイト), `2**n`は\\(2^n\\)を意味|

<br/>

|属性| 説明 |
|-|-|
|CONTENTS| このセクションには中身がある(つまり中身が空のセクションもある) |
|ALLOC   | ロード時にこのセクションのためにメモリを割り当てる必要がある |
|LOAD    | このセクションは実行するためにメモリ上にロードする必要がある |
|READONLY| メモリ上では「読み込みのみ許可(書き込み禁止)」と設定する必要がある |
|CODE    | このセクションは実行可能な機械語命令を含んでいる |
|RELOC   |このセクションは再配置情報を含んでいる|


- `readelf -S` の例と読み方

```bash
$ gcc -g -c add5.c
$ readelf -S add5.o
There are 21 section headers, starting at offset 0x640:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000013  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
~  [ 4] .debug_info       PROGBITS         0000000000000000  00000053
~       0000000000000066  0000000000000000           0     0     1
~  [ 5] .rela.debug_info  RELA             0000000000000000  00000410
~       00000000000000c0  0000000000000018   I      18     4     8
~  [ 6] .debug_abbrev     PROGBITS         0000000000000000  000000b9
~       000000000000004d  0000000000000000           0     0     1
~  [ 7] .debug_aranges    PROGBITS         0000000000000000  00000106
~       0000000000000030  0000000000000000           0     0     1
~  [ 8] .rela.debug_[...] RELA             0000000000000000  000004d0
~       0000000000000030  0000000000000018   I      18     7     8
~  [ 9] .debug_line       PROGBITS         0000000000000000  00000136
~       000000000000004f  0000000000000000           0     0     1
~  [10] .rela.debug_line  RELA             0000000000000000  00000500
~       0000000000000060  0000000000000018   I      18     9     8
~  [11] .debug_str        PROGBITS         0000000000000000  00000185
~       0000000000000093  0000000000000001  MS       0     0     1
~  [12] .debug_line_str   PROGBITS         0000000000000000  00000218
~       0000000000000089  0000000000000001  MS       0     0     1
~  [13] .comment          PROGBITS         0000000000000000  000002a1
~       000000000000002c  0000000000000001  MS       0     0     1
~  [14] .note.GNU-stack   PROGBITS         0000000000000000  000002cd
~       0000000000000000  0000000000000000           0     0     1
~  [15] .note.gnu.pr[...] NOTE             0000000000000000  000002d0
~       0000000000000020  0000000000000000   A       0     0     8
~  [16] .eh_frame         PROGBITS         0000000000000000  000002f0
~       0000000000000038  0000000000000000   A       0     0     8
~  [17] .rela.eh_frame    RELA             0000000000000000  00000560
~       0000000000000018  0000000000000018   I      18    16     8
~  [18] .symtab           SYMTAB           0000000000000000  00000328
~       00000000000000d8  0000000000000018          19     8     8
~  [19] .strtab           STRTAB           0000000000000000  00000400
~       000000000000000d  0000000000000000           0     0     1
~  [20] .shstrtab         STRTAB           0000000000000000  00000578
~       00000000000000c6  0000000000000000           0     0     1
~Key to Flags:
~  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
~  L (link order), O (extra OS processing required), G (group), T (TLS),
~  C (compressed), x (unknown), o (OS specific), E (exclude),
~  D (mbind), l (large), p (processor specific)
```

| 欄 | 例 | 説明 |
|-|-|-|
|[Nr]     |[1]|セクションの通し番号|
|Name     |`.text`|セクションの名前|
|Type     |`PROGBITS`|セクションのタイプ (以下参照)|
|Address  |`0000000000000000`|セクションのアドレス|
|Offset   |`00000040`|ファイルオフセット(16進数，バイト)|
|Size     |`0000000000000013`|セクションのサイズ (16進数，バイト)|
|EntSize  |`0000000000000000`|表中の固定長のエントリのサイズ (エントリがない場合は0)|
|Flags    |`AX`|セクションのフラグ (以下参照)|
|Link     |`0`|関連するセクションの通し番号([Nr]) (存在しない場合は0)|
|Info     |`0`|関連情報 (ない場合は0)|
|Align    |`1`|セクションのアラインメント制約(バイト)|

<br/>

|セクションのタイプ| 説明 |
|-|-|
|NULL     |このセクションは使われていない|
|PROGBITS |このセクションはプログラムがフォーマットと意味を決める情報を含む|
|NOBITS   |未初期化の領域を含む (ファイル中ではサイズゼロ)|
|RELA     |このセクションは再配置情報を含む (調整用の値(addend)を含む)|
|NOTE     |言語処理系が定義・使用するメモ書き|
|SYMTAB   |このセクションは記号表 (symbol table)|
|STRTAB   |このセクションは文字列表 (string table)|

<br/>

|フラグ | 説明 |
|-|-|
|W (write)     |このセクションは実行時に書き込み可能にしておく必要がある|
|A (alloc)     |ロード時にこのセクションのためにメモリを割り当てる必要がある|
|X (execute)   |このセクションは実行可能な機械語命令を含む|
|M (merge)     |このセクション中のデータは重複を避けるためにマージ可能|
|S (strings)   |このセクションはヌル終端の文字列を含む|
|I (info)      |このセクションはセクションのタイプに依存した付加情報を保持してる|
|L (link order)|このセクションはリンカに対して特別な順序を要求する|
|O (extra OS processing required) |このセクションはOS固有の特別な処理が必要である|
|G (group)     |このセクションはセクショングループのメンバーである|
|T (TLS)       |このセクションはスレッドローカルストレージを持つ|
|C (compressed)|このセクションの内容は圧縮されている (AやNOBITSとの併用はNG)|
|x (unknown)   |このセクションは不明なセクションである|
|o (OS specific)|OS固有の意味を持つ|
|E (exclude)   |このセクションは参照もメモリ割り当てもされなければ削除される|
|D (mbind)     |このセクションは特別なメモリ領域に置く必要がある．Infoがそのメモリタイプを示す|
|l (large)     |このセクションは(2GB以上の)largeコードモデルである|
|p (processor specific) |プロセッサ固有の意味を持つ|

- `readelf -t` で，より詳細なセクション情報を表示可能
- `readelf -n`で`NOTE`セクションの内容を表示可能


### 記号表とアドレスへの変換

```x86asmatt
{{#include asm/sym-main.s}}
```

```x86asmatt
{{#include asm/sym-sub.s}}
```

```
$ gcc -c sym-main.s
$ gcc -c sym-sub.s
$ gcc sym-main.o sym-sub.o
$ nm sym-main.o
0000000000000000 T main
              ❶ U x
$ nm sym-sub.o
❷ 0000000000000000 D x 
$ nm a.out | egrep ' x'
❸ 0000000000004010 D x

$ objdump -D ./a.out
0000000000001129 <main>:
    1129: 8b 05 e1 2e 00 00    	mov  ❹ 0x2ee1(%rip),%eax  # 4010 <x>
 ❻ 112f: c3                   	ret    
(中略)
0000000000004010 <x>:
 ❺ 4010: e7 03                 out    %eax,$0x3
$ bc
obase=16
ibase=16
4010-112F
❼ 2EE1
```

- **アセンブラは記号表を作り**，ラベルを見つけるたびに記号表に加えます．
  記号表はリンク時にも使うので，アセンブラは記号表をオブジェクトファイルに埋め込みます．
  最終的に，記号表の情報を使って，**ラベルをアドレスに変換**します．
- 例えば，上記の例ではラベル`x`を記号表で管理して，最終的にアドレス`0x4010`に変換しています．
  - `sym-main.s`の `movl x(%rip), %eax` ではラベル`x`が登場するので，
    記号表に加えられます．`sym-main.s`中には定義が無いので，
    `nm`コマンドで記号表を見ると「`x`は未定義 (`❶ U x`)」となっています．
  - 一方，`sym-sub.s`中にラベル`x`の定義があるので，
    `nm`で調べると，「`x`の(仮の)アドレスは0番地 ❷」と表示されます．
  -  `sym-main.o`と`sym-sub.o`をリンクした`a.out`を調べると，
    「`x`のアドレスは0x4010番地 ❸」となってます．
  - `objdump -D`で(`.data`セクションも含めて)逆アセンブルすると，
    `x`のアドレスは確かに❹`0x4010`番地となっていて，
    `movl x(%rip), %eax`中のラベル`x`は相対アドレス❹`0x2EE1`に
    なっています(❺ 0x4010 - ❻ 0x112F = ❼ 0x2EE1)．
  

### バイナリ形式として出力

- ここまでの処理で，アセンブラはセクション別に2進数のバイト列を生成しています．
- アセンブラはこれらのバイト列を**バイナリ形式**のフォーマットに従って
  ファイルに出力します．
- 本書の範囲ではバイナリ形式の詳細を知る必要はありませんが，
  以下でELFバイナリ形式の全体の構造だけ説明します．
  この知識がないと`readelf`コマンドを使う際に「ヘッダが3種類ある」と混乱するからです．

#### ELFバイナリ形式の構造

- ELFには3種類のヘッダがあります

|ヘッダの種類|表示コマンド|説明|
|-|-|-|
|ELFヘッダ|`readelf -h`|ELFファイル全体の目次とメタ情報．必ずファイル先頭に存在|
|セクションヘッダ|`readelf -S`|セクションの目次|
|プログラムヘッダ|`readelf -l`|セグメントの目次|

<br/>

<img src="figs/elf-header.svg" height="400px" id="fig:elf-header">

- **ELFのセクション**はリンクのための処理の単位です．
- **ELFのセグメント**は複数のセクションが1つになったもので，
  実行時にメモリにロードするための処理の単位です．
  - セクションと区別するために，「セグメント」という異なる名前が付いているがかえって紛らわしい．
- ELFヘッダ以外は，配置する場所や順番に決まりはないです．
  (セクションヘッダは(ヘッダという名前なのに)ファイルの最後に配置されることが多いです)．
  セクションヘッダとプログラムヘッダの位置(オフセット)は
  ELFヘッダ中に書かれています．

<details>
<summary>
ELFとDWARF
</summary>

バイナリ形式 ELF は executable linkage format の略です．
「北欧神話でおなじみのエルフ(ELF)と来ればドワーフ(DWARF)も欲しいでしょ」
というダジャレで，
(元々はELF形式のために)DWARFという名前のデバッグ情報形式が生まれたようです．
</details>

## GNUアセンブラの文法

### 文

<img src="figs/gas-stmt.svg" height="120px" id="fig:gas-stmt">

- GNUアセンブラの**文**(statement)はアセンブリコードの構成要素であり，
  上記の6つのいずれもが1つの文になります．

- 文は改行かセミコロン`;`で区切ります．
  - セミコロンで区切れば，複数の文を1行に書いて良いです．
    以下はどちらでもOKです

    ```x86asmatt
    pushq %rbp
    movq %rsp, %rbp
    ```

    ```x86asmatt
    pushq %rbp; movq %rsp, %rbp
    ```


### コメント

- GNUアセンブラのコメントは(C言語と同様に)プログラムのメモ書きです．
  アセンブラは単に無視します．
- 行コメント: シャープ記号`#`から行末までがコメントになります

    ```x86asmatt
    # これは行コメントです
    ```

    > 注: 行コメントに使う記号はアーキテクチャ依存です．
    > 例えば，x86-64は`#`ですが，ARMは`@`，H8は`;`，SPARCは`!`です．

- ブロックコメント: C言語と同じで`/*`から`*/`までがコメントです．
  C言語と同様にブロックは入れ子禁止です(ブロックコメントの中にブロックコメントは書けません)

    ```x86asmatt
    /* これはブロックコメントです．
       複数行でもOKです           */
    ```

- 入れ子のコメントを書くには，C前処理命令 `#if 0`と`#endif`を使います．
  - ただし，ファイル拡張子を(大文字の)`.S`にする必要があります．
  - 拡張子を`.S`にするとC前処理が実行されるので，`#define`や`#include`も使えます．
  

  ```
  #if 0
  これはC前処理命令を使ったコメントです．
  これは入れ子にできます．
  #endif
  ```

### 定数

<div class="table-wrapper"><table><thead><tr><th>種類</th><th>説明</th><th>例</th></tr></thead><tbody>
<tr><td>10進数定数</td><td><code>0</code>で始まらない</td><td><code>pushq $74</code></td></tr>
<tr><td>16進数定数</td><td><code>0x</code>か<code>0X</code>で始まる</td><td><code>pushq $0x4A</code></td></tr>
<tr><td>8進数定数</td><td><code>0</code>で始まる</td><td><code>pushq $0112</code></td></tr>
<tr><td>2進数定数</td><td><code>0b</code>か<code>0B</code>で始まる</td><td><code>pushq $0b01001010</code></td></tr>
<tr><td rowspan="3">文字定数</td><td><code>'</code>(クオート)で始まる</td><td><code>pushq $'J</code></td></tr>
<tr><td><code>'</code>(クオート)で囲む</td><td><code>pushq $'J'</code></td></tr>
<tr><td><code>\</code>バックスラッシュ<br/>でエスケープ可</td><td><code>pushq $'\n</code></td></tr>
<tr><td>文字列定数</td><td><code>"</code>(ダブルクオート)で囲む</td><td><code>.string "Hello\n"</code></td></tr>
</tbody></table>
</div>  

- 上の例の最初の4つの定数は全部，値が同じです
- GNUアセンブラでは文字定数の値は[ASCIIコード](./4-data.md#ASCII)です．
  上の例では，文字`'J'`の値は`74`です．
- バックスラッシュでエスケープできる文字は，
  `\b`, `\f`, `\n`, `\r`, `\t`,  `\"`, `\\` です．
  また`\123`は8進数，`\x4F`は16進数で指定した文字コードになります．
- 文字列定数では，`.string`と`.asciz`は自動的にヌル文字終端しますが，
  `.ascii`はヌル文字終端しません(必要なら明示的に`\0`と書く必要があります)．
  文字列定数は即値や変位には使えません．

### 式

```x86asmatt
leaq main+10(%rip), %rax # 加算
movq $1<<12, %rax        # 左シフト
movq $1024*1024, %rax    # 乗算
```

- 定数やラベルを書ける場所 (即値や変位)には**式**を書けます．
- ただし，式には静的に(アセンブル時に)計算できるものだけが書けます．
  - レジスタやメモリの値は参照できません．
- 上の例では加算，左シフト，乗算を使った例です．

- 単項演算子

|演算子|意味|
|-|-|
|`-`|2の補数による負数|
|`~`|ビットごとの反転 (1の補数)|

- 2項演算子

|演算子|意味|
|-|-|
|`*`|乗算|
|`/`|除算|
|`%`|剰余|
|`<<`|左シフト|
|`>>`|右シフト|

<br/>

|演算子|意味|
|-|-|
|<code>&#124;</code>|ビットOR|
|`&`|ビットAND|
|`^`|ビットXOR|
|`!`|ビットOR NOT (a|~bと同じ)|

<br/>

|演算子|意味|
|-|-|
|`+`|加算|
|`-`|減算|
|`==`|等しい|
|`!=`|等しくない|
|`<>`|等しくない|
|`<`|小さい|
|`>`|大きい|
|`<=`|以下|
|`>=`|以上|

<br/>

|演算子|意味|
|-|-|
|`&&`|論理AND|
|<code>&#124;&#124;</code>|論理OR|

- 一番上が最も優先度が高く，順番に下に行くほど優先度が下がります．

<!--
- `+`と`-`以外はリンクで変化しない値でなければいけません．
-->

- 述語演算子は，真の時は`-1` (つまり全ビットが1)，負の時は`0` (つまり全ビットが0)を返します．
- 2023/9: `=`が入ってる演算子を使うと，
  `foo.s:9: Error: invalid character '=' in operand 1`というエラーがでます．なぜなんだぜ

## ラベルと識別子

PICの場合，絶対アドレスを得る方法はないのか
(動的に LEA命令を使わず)

### ロケーションカウンタ
### シンボル
### ラベル
### 特別なドットラベル `.`


## アセンブラ命令

### セクション指定
### データ配置
### 出力アドレス調整 (アラインメント)
#### ロケーションカウンタ

### シンボル情報
### マクロ

## AT&T形式とIntel形式
