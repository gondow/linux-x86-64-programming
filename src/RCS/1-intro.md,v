head	1.4;
access;
symbols;
locks
	gondow:1.4; strict;
comment	@# @;


1.4
date	2023.07.22.10.01.23;	author gondow;	state Exp;
branches;
next	1.3;

1.3
date	2023.07.20.08.19.51;	author gondow;	state Exp;
branches;
next	1.2;

1.2
date	2023.07.19.08.21.34;	author gondow;	state Exp;
branches;
next	1.1;

1.1
date	2023.07.18.09.22.14;	author gondow;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@<style type="text/css">
body { counter-reset: chapter 2; }
</style>

# アセンブリ言語とバイナリファイル

## 機械語とアセンブリ言語とは何か？（短い説明）

**機械語**（マシン語）：
- CPUが直接実行できる唯一の言語．
- 機械語命令を2進数（バイナリ，数字の列）で表現．

**アセンブリ言語**：
- 機械語を記号で表現したプログラミング言語．
- 例1：機械語命令`01010101`をアセンブリ言語では`pushq %rbp`という記号（**ニモニック**，mnemonic）で表す（x86-64の場合，以下同様）．
- 例2：メモリのアドレス`1000`番地をアセンブリ言語では`add5`などの記号（**ラベル**）で表す．

<img src="figs/machine-asm.svg" height="100px" id="fig:machine-asm">


<details>
<summary>
pushq %rbpとは
</summary>

>「レジスタ`%rbp`中の値をスタックにプッシュする」という命令です．
</details>

2進数の機械語命令と，機械語命令のニモニックは概ね，1対1に対応しており，
機械的に変換できます．ただし，その変換方法を覚える必要はありません．
[アセンブル](#アセンブル)や[逆アセンブル](#逆アセンブル)してくれる
コマンド（プログラム）にやってもらえばいいのです．

ただ，アセンブリ言語の仕組みを理解するには，オブジェクトファイル`*.o`や
実行可能ファイル`a.out`の中身や仕組みを理解する必要があるため，
以下ではバイナリファイルの説明が多くなっています．

## 機械語とアセンブリ言語の具体例（逆アセンブル）{#逆アセンブル}

まず以下の簡単なCのプログラム`add5.c`を用意して下さい．

##### `add5.c`{#add5.c}
```C
int add5 (int n)
{
    return n + 5;
}
```

`add5.c`を`gcc -c`で処理すると，
**オブジェクトファイル**`add5.o`ができます．
この`add5.o`に対して`objdump -d`を実行すると，
**逆アセンブル**(disassemble)した結果が表示されます．

```bash
$ gcc -c add5.c
$ ls
add5.c  add5.o
$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add5>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 05             	add    $0x5,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
```

逆アセンブルとは，`a.out`や`*.o`中の機械語命令を
アセンブリ言語のニモニック表現に変換することです．
上の実行例で，左側に機械語命令，右側にニモニックが表示されています．
（一番左側の数字は，先頭からのバイト数（16進表記）です）．
例えば，`55`は機械語命令（を16進数で表記したもの），
`55`の右側の`push %rbp`が，`55`に対応するニモニックです．
16進数が使われているのは，2進数で表記すると長くなってしまうからです．

## Cコードをアセンブリコードにコンパイルする

[`add5.c`](#add5.c)に対して，
以下のコマンドを実行して，`add5.s`を作成して下さい．
これで「アセンブリ言語で書かれたプログラム（アセンブリコード）」がどんなものかを見れます．

```bash
$ gcc -S add5.c
$ ls
add5.c  add5.s
```

<!-- ![gcc-S](figs/gcc-S.svg) -->
<img src="figs/gcc-S.svg" height="50px" id="fig:gcc-S">

`-S`オプションをつけて処理すると，
`gcc`はCのプログラム(`add5.c`)からアセンブリコード(`add5.s`)を生成します．
この処理を「狭義のコンパイル」と呼びます
（[広義のコンパイル](#広義のコンパイル)はCのプログラムから実行可能ファイル(`a.out`)を
生成する処理を指します）．
`gcc -S`は「コンパイラ」と呼ばれます．コンパイルするコマンドだからです．


`add5.s`の中身は例えば以下となります．

> 注意：
> gccのバージョンの違いにより，同じLinuxでも`add5.s`の中身が以下と異なることがあります．

以下では表示が長いので省略しています．
全てを表示するには右にある<i class="fa fa-eye"></i>ボタンを押して下さい．
（ここでは`add5.s`の中身は理解できなくてOKです）．

```bash
$ cat add5.s
	.file	"add5.c"
	.text
	.globl	add5
	.type	add5, @@function
add5:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
~	.cfi_def_cfa_offset 16
~	.cfi_offset 6, -16
~	movq	%rsp, %rbp
~	.cfi_def_cfa_register 6
~	movl	%edi, -4(%rbp)
~	movl	-4(%rbp), %eax
~	addl	$5, %eax
~	popq	%rbp
~	.cfi_def_cfa 7, 8
~	ret
~	.cfi_endproc
~.LFE0:
~	.size	add5, .-add5
~	.ident	"GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0"
~	.section	.note.GNU-stack,"",@@progbits
~	.section	.note.gnu.property,"a"
~	.align 8
~	.long	 1f - 0f
~	.long	 4f - 1f
~	.long	 5
~0:
~	.string	 "GNU"
~1:
~	.align 8
~	.long	 0xc0000002
~	.long	 3f - 2f
~2:
~	.long	 0x3
~3:
~	.align 8
~4:
```

このうち実行に関係する部分だけを残したアセンブリコードが以下になります．
（コメントで各行の意味を書きますが，ここでは雰囲気だけの理解でOKです）．

##### `add5.s`{#add5.s}
```x86asmatt
# add5.s
    .text
    .globl add5
    .type add5, @@function
add5:
    pushq %rbp
    movq  %rsp, %rbp
    movl  %edi, -4(%rbp)
    movl  -4(%rbp), %eax
    addl  $5, %eax
    popq  %rbp
    ret
    .size  add5, .-add5
```

消した行の説明を以下に書きますが，読み飛ばしてOKです．
<details>
<summary>
.cfi_とは
</summary>

> `.cfi`で始まるもの（アセンブラ命令）は call frame information を扱う命令です．
> 本書の範囲では不要です．詳細は[dwarf5仕様書](https://dwarfstd.org/doc/DWARF5.pdf)を参照下さい．
</details>

<details>
<summary>
.fileと.identとは
</summary>

> `.file`と`.ident`はコメントとほぼ同じでアセンブラは単に無視します．
</details>

<details>
<summary>
.section .note.とは
</summary>

> 以下の2つはセキュリティ上，実際には重要です（本書では消してしまいますが）．
> `.section .note.GNU-stack,"",@@progbits`はスタック上の機械語命令を実行不可と指定しています．
> `.section .note.gnu.property,"a"`はIntel CETというセキュリティ技術の一部である IBT (indirect branch tracking)と SHSTK (shadow stack) のための指示です．
</details>

<details>
<summary>
endbr64とは
</summary>

> `endbr64`もセキュリティ上，重要です．
> 間接ジャンプは脆弱性の大きな原因です．
> `endbr64`はセキュリティ技術であるIntel CET技術の命令であり，
> 間接ジャンプ先の命令が`endbr64`以外の時は実行エラーとする，というものです．
> 本書の学習者としては「`endbr64`はセキュリティ上，重要だけど，アセンブリ言語を学習する立場では「`endbr64`は`nop`命令(何も実行しない命令)」と思えば十分です．
</details>

短くした`add5.s`の各行の意味を以下のコメントで説明します．
ここでは雰囲気だけの理解でOKです．

<details>
<summary>
コメントとは
</summary>

> `#`から行末までがコメントになります．
> C言語のコメントと同様，コメントは人間が読むためだけのもので，
> 言語処理系は単にコメントを無視し，プログラムの実行には影響を与えません．
</details>

```x86asmatt
# add5.s (コメントで説明)
    .text   # 以下を2進数に変換してテキストセクション（機械語命令を置く場所）に出力せよ
    .globl add5  # シンボルadd5をグローバルとせよ
    .type add5, @@function # シンボルadd5の型を関数とせよ
add5:  # シンボル（ラベル）add5の値を「この場所のアドレス」とする
    pushq %rbp  # レジスタ%rbpをスタックにプッシュせよ
    movq  %rsp, %rbp  # レジスタ%rspの値をレジスタ%rbpにコピーせよ
    movl  %edi, -4(%rbp) # レジスタ%edi(引数n)の値をアドレス %rbp-4 のメモリにコピーせよ
    movl  -4(%rbp), %eax # アドレス %rbp-4 のメモリの値をレジスタ%eaxにコピーせよ
    addl  $5, %eax # レジスタ%eaxに整数定数5を加えよ
    popq  %rbp # スタックから値をポップしてレジスタ%rbpに格納せよ
    ret   # この関数からリターンせよ (スタックから値(これはリターンアドレス)をポップして，そのアドレスにジャンプせよ)
    .size  add5, .-add5 # シンボルadd5のサイズは .-add5とせよ
```

<details>
<summary>
 %rspと%rbpとは
</summary>

> %rspはスタックポインタ，%rbpはベースポインタと呼ばれるレジスタです．
> 現在実行中の関数のための**スタックフレーム**の領域の両端を%rspと%rbpは指しています．スタックフレームは新しい関数呼び出しがあると，スタック上に追加（プッシュ）され，その関数呼び出しからリターンすると，スタック上から除去（ポップ）されます．
最初の`pushq %rbp`と`movq  %rsp, %rbp`はスタックフレームを作るための命令です．
また，最後の`ret`の直前の`popq %rbp`命令はスタックフレームを除去するための命令です．
</details>

<details>
<summary>
.-add5 とは
</summary>

> `.-add5`はアドレスの引き算をしています．`.`は特別なラベルで「この行のアドレス」を意味します．`add5`は`add5:`のアドレスを意味します．
ですので，`.-add5`は「最後の`ret`命令の次のアドレスから，
最初の`pushq %rbp`命令のアドレスを引いた値」になります．
つまり引き算の結果は「関数`add5`中の機械語命令の合計サイズ（単位はバイト）」です．
</details>

## アセンブリコードをオブジェクトファイルにアセンブルする{#アセンブル}

[`add5.s`](#add5.s)に対して，以下のコマンドを実行すると，
`add5.o`が生成されます．この処理を**アセンブル**(assemble)といいます．
そして，アセンブルを行うプログラム（コマンド）を
**アセンブラ**(assembler)と呼びます．
`gcc -c`は内部的にアセンブラ`as`を呼び出します．
`as`は本書で使用する[GNUアセンブラ](https://sourceware.org/binutils/docs-2.40/as/index.html)のコマンド名です．

```
$ gcc -c add5.s
$ ls
add5.c add5.o add5.s
```

<img src="figs/assemble.svg" height="50px" id="fig:assemble">

アセンブル処理は[逆アセンブル](#逆アセンブル)とちょうど逆の関係です．

<img src="figs/assemble2.svg" height="70px" id="fig:assemble2">

## バイナリファイルの中身を見る

### 16進ダンプ{#hexdump}
`add5.c`や`add5.s`はテキストファイルですが，
`add5.o`はバイナリファイルです．
バイナリファイルなので，`less`コマンドでは中身を読めません．

```
$ less add5.o
^?ELF^B^A^A^@@^@@^@@^@@^@@^@@^@@^@@^@@^A^@@>^@@^A^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@X^B
^@@^@@^@@^@@^@@^@@^@@^@@^@@^@@@@^@@^@@^@@^@@^@@@@^@@^L^@@^K^@@<F3>^O^^<FA>UH<89><E5><89>}<FC><8B>E
（長いので省略）
```

<details>
<summary>
ELFとは
</summary>

> 上の`less`コマンドの結果にELFという文字が見える理由を説明します．
ELFはLinuxが採用している**バイナリ形式**(binary format)です．
このELFのバイナリファイルの先頭4バイトには**マジックナンバー**という
バイナリファイルを識別する特別な数値が入っています．
ELFバイナリのマジックナンバーは `7F 45 4C 46`です．
`45 4C 46`はASCII文字で `E L F` なので，lessコマンドが`ELF`と表示したわけです． 
</details>

バイナリファイルの中身を読むには例えば`od`コマンドを使います．

```
$ od -t x1 add5.o
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00
（長いので省略）
```

一番左の数字が「先頭からのバイト数(16進表記)」，
その右側に並んでいるのが「1バイトごとに16進表記したファイルの中身」です．
（1バイトのデータは2桁の16進数で表せることを思い出しましょう．
例えば，`add5.o`の中身の先頭4バイトの値は`7F 45 4C 46`です）．

`-t x1`というオプションは「1バイトごとに16進数で表示せよ」という意味です．
このような出力を**16進ダンプ**(hex dump)と言います．
他に16進ダンプするコマンドとして，`xxd`や`hexdump`などがあります．

ちなみに，`add5.c`はテキストファイルですが，内容は2進数で保存されて
いますので，`od`コマンドで中身を表示できます．

```
$ od -t x1 add5.c
0000000 69 6e 74 20 61 64 64 35 20 28 69 6e 74 20 6e 29
0000020 0a 7b 0a 20 20 20 20 72 65 74 75 72 6e 20 6e 20
0000040 2b 20 35 3b 0a 7d 0a
0000047
```

先頭の`69`はASCII文字`i`の文字コード，
同様に，次の`6e`は文字`n`，その次の`74`は文字`t`なので，
`add5.c`の先頭3文字が`int`であることを確認できます．
ASCIIコード表は`man ascii`コマンドで閲覧できます．

### コンピュータの中のデータはすべて`0`と`1`から成る{#everything-binary}

ここで大事なことを復習しましょう．
それは
**「コンピュータの中のデータは，どんな種類のデータであっても，
機械語命令であっても，すべて`0`と`1`だけで表現されている」**
ということです．
ですので，テキストはバイナリでもあるのです．
- テキスト=文字として表示可能な2進数だけを含むデータ
- バイナリ=文字以外の2進数も含んだデータ

<img src="figs/text-binary.svg" height="100px" id="fig:text-binary">

> 注意：
> 本書で，テキスト(text)という言葉には2種類の意味があることに注意して下さい．
> - 1つは「文字」を意味します．例：「テキストファイル」（文字が入ったファイル）
> - もう1つは「機械語命令列」を意味します．例：「[テキストセクション](#.text)」（機械語命令列が格納されるセクション）

### 2進数と符号化

[前節](#everything-binary)で説明した通り，
コンピュータ中では全てのものを0と1の2進数で表現する必要があります．
そのため，データの種類ごとに2進数での表現方法，つまり**符号化**
(encoding)の方法が定められています．
例えば，
- 文字`U`をASCII文字として符号化すると，`01010101`になります．
- `pushq %rbp`をx86-64の機械語命令として符号化すると，`01010101`になります．

おや，どちらも同じ`01010101`になってしまいました．
この2進数が`P`なのか`pushq %rbp`なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．

<img src="figs/encode.svg" height="130px" id="fig:encode">

別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する[`.text`セクション](#.text)にある
2進数のデータ列は「`.text`セクションに存在するから」という理由で
機械語命令として解釈されます．

### `file`コマンド

[16進ダンプ](#hexdump)以外の方法で，`add5.o`の中身を見てみます．
まずは`file`コマンドです．

```
$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable, x86-64, ❹version 1 (SYSV), ❺not stripped
```

これで，`add5.o`が64ビットの❶ELFバイナリであることが分かりました．
<details>
<summary>
❷LSBとは
</summary>

> 多バイト長のデータをバイト単位で格納する順序を**バイトオーダ**(byte order)といいます．
> LSBは最下位バイトから順に格納するバイトオーダ (Least Significant Byte first)，
> つまりリトルエンディアンを意味しています．
> 多バイト長データで最下位のバイトをLeast Significant Byte (**LSB**)，
> 最上位のバイトをMost Significant Byte (**MSB**)と呼びます．
> 例えば，`0x11223344`という4バイトのデータのLSBは`0x44`，MSBは`0x11`です．
> 多バイト長データをメモリに格納する時，
> - LSBから先にメモリに格納する方法を**リトルエンディアン** (little endian)
> - MSBから先にメモリに格納する方法を**ビッグエンディアン** (big endian)
> と呼びます．
> <img src="figs/endian.svg" height="150px" id="fig:endian">
> 
> x86-64のバイトオーダがリトルエンディアンのため，ELFバイナリもリトルエンディアンになっています．
> リトルエンディアンでの注意は16進ダンプする時に，多バイト長データが逆順に表示されることです．
> 以下で多バイト長データ❶`0x11223344`を`.text`セクションに配置してアセンブルした
> `little.o`を逆アセンブルすると，❷`44 33 22 11`と逆順に表示されています．
>
> ```
> $ cat little.s
> .text
> ❶.long 0x11223344
> $ gcc -c little.s
> $ objdump -h little.o
> foo.o:     file format elf64-x86-64
> Sections:
> Idx Name          Size      VMA               LMA               File off  Algn
>   0 .text         00000004  0000000000000000  0000000000000000  00000040  2**0
>                   CONTENTS, ALLOC, LOAD, READONLY, CODE
>   1 .data         00000000  0000000000000000  0000000000000000  00000044  2**0
>                   CONTENTS, ALLOC, LOAD, DATA
>   2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0
>                   ALLOC
> $ od -t x1 -j0x40 little.o | head -n1
> 0000100 ❷44 33 22 11 00 00 00 00 00 00 00 00 00 00 00 00
> ```
> <details>
> <summary>
> エンディアンの由来とは
> </summary>
>
> **エンディアン**(endian)という言葉はガリバー旅行記から来ています．
> お話の中で，卵の殻は尖った方からむくべき派 (little endian)と
> 丸い方からむくべき派 (big endian)が争うのです．なのでインディアンとは何の関係もありません．
> </details>
</details>

<!--
これは嘘でしたｗ
> LSBはLinuxの標準である[Linux Standard Base](https://refspecs.linuxfoundation.org/lsb.shtml)の略です．LSBはELFバイナリの規格であるSystem V ABIを含んでいます．
ABIはapplication binary interfaceの略です．
-->

<details>
<summary>
❸relocatableとは
</summary>

> バイナリ中のアドレスを再配置 (relocate)できるバイナリのことをrelocatableであるといいます．オブジェクトファイルはリンク時や実行時にアドレスを変更できるよう，
relocatableであることが多いです．
</details>

<details>
<summary>
❹version 1 (SYSV)とは
</summary>

> LinuxのABI（バイナリ互換規約）である[System V ABI](https://wiki.osdev.org/System_V_ABI)
に準拠していることを表しています．
</details>

<details>
<summary>
❺not strippedとは
</summary>

> バイナリには実行に直接関係ない**記号表**や**デバッグ情報**などが
> 含まれていることがよくあります．
> この「実行に直接関係ない情報」が削除されたバイナリのことを
> stripped binaryと呼びます．
> `strip`コマンドで「実行に直接関係ない情報」を削除できます．
> 削除された分，サイズが少し減っています．
> ```
> $ ls -l add5.o
> -rw-rw-r-- 1 gondow gondow 1368 Jul 19 10:09 add5.o
> $ strip add5.o
> $ ls -l add5.o
> -rw-rw-r-- 1 gondow gondow 880 Jul 19 14:58 add5.o
> ```
</details>

なお，`file`コマンドはバイナリ以外のファイルにも使えます．

```
$ file add5.c
add5.c: ASCII text
$ file add5.s
add5.s: assembler source, ASCII text
$ file .
.:  directory
$ file /dev/null
/dev/null: character special (1/3)
```

### セクションと`objdump -h`コマンド{#.text}


バイナリファイルの構造はざっくり以下の図のようになっています．

<img src="figs/section.svg" height="250px" id="fig:text-binary">

- 最初のヘッダ以外の四角を**セクション**(section)と呼びます．
- バイナリはセクションという単位で区切られていて，それぞれ別の目的でデータが格納されます．
- ヘッダは目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．

ヘッダの情報は`objdump -h`で表示できます．

```
$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS, ALLOC, LOAD, DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
```

ここでは「`.text`，`.data`，`.bss`という3つのセクションがある」ことを
見ればOKです．

<details>
<summary>
readelfコマンドとは
</summary>

> `objdump`は汎用のコマンド（ELFバイナリ以外のバイナリにも使える）ため，
> ELF特有の情報を表示できないことがあります．
> ELF専用のコマンドである`readelf`を使えば，ELF特有の情報も表示できます．
> 例えば，以下では`readelf`を使って記号表(`.symtab`)のセクションがあることを確認できました．
>
> ```
> $ readelf -S add5.o セクションヘッダを表示
>There are 12 section headers, starting at offset 0x258:
>Section Headers:
>  [Nr] Name              Type             Address           Offset
>       Size              EntSize          Flags  Link  Info  Align
>  [ 0]                   NULL             0000000000000000  00000000
>       0000000000000000  0000000000000000           0     0     0
>  [ 1] .text             PROGBITS         0000000000000000  00000040
>       0000000000000013  0000000000000000  AX       0     0     1
>  [ 2] .data             PROGBITS         0000000000000000  00000053
>       0000000000000000  0000000000000000  WA       0     0     1
>  [ 3] .bss              NOBITS           0000000000000000  00000053
>       0000000000000000  0000000000000000  WA       0     0     1
>（中略）↓これが記号表 (symbol table)
>  [ 9] .symtab           SYMTAB           0000000000000000  000000d8
>       00000000000000f0  0000000000000018          10     9     8
> ```
</details>

<details>
<summary>
VMAとLMAとは
</summary>

> VMAはvirtual memory addressの略で「このセクションがメモリ上で実行される時のメモリアドレス」です．一方，LMAはload memory addressの略で「このセクションをメモリ上に配置する時のメモリアドレス」です．
> 通常，セクションをメモリに配置した後で，移動せずにそのまま実行するため，VMAとLMAは同じアドレスになります．
</details>

<details>
<summary>
File offとは
</summary>

> File offはファイルオフセットを表しています．このセクションがバイナリファイルの先頭から何バイト目から始まっているかを16進表記で表しています．
</details>

<details>
<summary>
Algnとは
</summary>

> Algnは**アラインメント**(alignment)を表しています．
> 例えば「このセクションをメモリ上に配置する時，その先頭アドレスが8の倍数になるようにしてほしい」という状況の時，この部分が`2**3`となります（2の3乗=8）．
</details>

<details>
<summary>
CONTENTS, ALLOC, LOAD, READONLY, CODEとは
</summary>

> これらはセクションフラグと呼ばれるセクションの属性値です．
> - CONTENTS  このセクションには中身がある（つまり中身が空のセクションもある）
> - ALLOC     ロード時にこのセクションのためにメモリを割り当てる必要がある
> - LOAD      このセクションは実行するためにメモリ上にロードする必要がある
> - READONLY  メモリ上では「読み込みのみ許可（書き込み禁止）」と設定する必要がある
> - CODE      このセクションは実行可能な機械語命令を含んでいる
</details>

3つのセクション `.text`，`.data`，`.bss` の役割は以下の通りです：
- `.text`セクションは機械語命令を格納します．例えば，`pushq %rbp`を表す`0x55`は`.text`セクションに格納されます．
- `.data`セクションは初期化済みの静的変数の値を格納します．例えば，大域変数`int x=999;`があったとき，999の2進数表現が`.data`セクションに格納されます．
- `.bss`セクションは未初期化の静的変数の値を格納します．例えば，大域変数`int y;`があったとき，（概念的には）初期値0の2進数表現が`.bss`セクションに格納されます．

<details>
<summary>
なぜ概念的
</summary>

> 実はファイル中では`.bss`セクションにはサイズ情報などごくわずかの情報しか持っていません．実行時にメモリ上に`.bss`セクションを作る際に，実際に必要なメモリを確保して，そのメモリ領域をすべてゼロで初期化すれば十分だからです（ファイル中に大量のゼロの並びを保持する必要はありません）．
</details>

さらに代表的なセクションである`.rodata`も説明します．
- `.rodata`セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数`"hello"`は書き込み禁止なので，`"hello"`の2進数表現が`.rodata`セクションに格納されます．

バイナリファイルには上記以外のセクションも数多く使われますが，
まずはこの基本の4種類 (`.text`, `.data`, `.bss`, `.rodata`) を覚えましょう．

### 記号表の中身を表示させる(`nm`コマンド)

バイナリファイル中には**記号表**(symbol table)があることが多いです．
記号表とは「変数名や関数名がバイナリ中では何番地のアドレスになっているか」という情報です．
`nm`コマンドでバイナリファイル中の記号表を表示できます．
まず，以下の`foo.c`を準備して下さい．

```
// foo.c
int g1 = 999;
int g2;
int s1 = 888;
int s2;
int main ()
{
    static int s3 = 777;
    static int s4;
}
```

そしてコンパイルして，`nm`コマンドで記号表の中身を表示させます．

```
$ gcc -c foo.c
$ nm foo.o
0000000000000000 D g1
0000000000000004 C g2
0000000000000000 T main
0000000000000004 D s1
0000000000000004 C s2
0000000000000008 d s3.1916
0000000000000000 b s4.1917
```

この出力の読み方は以下の通りです．
- `D`と`d`は`.data`セクションのシンボル，`C`と`b`は`.dss`セクションのシンボル，`T`と`t`は`.text`セクションのシンボルであることを表す
- 大文字はグローバル（ファイルをまたがって有効なシンボル），小文字はファイルローカルなシンボルであることを表す
- ファイルローカルなシンボルは同名のシンボルを区別するために，`.19196`や`.1917`などが付加されることがある．
- 左側の`00`，`04`，`08`がシンボルに対応するアドレスですが，再配置前(relocation前)なので仮のアドレスです．

### ASLRとPIE（ちょっと脱線）

オブジェクトファイルのセクションごとの仮のアドレスは，
リンク後の`a.out`では具体的なアドレスになります

```
$ gcc foo.c
$ nm ./a.out | egrep g1
0000000000004010 D g1
$ nm ./a.out | egrep main
                 U __libc_start_main@@@@GLIBC_2.2.5
0000000000001129 T main
```

<details>
<summary>
U __libc_start_main@@@@GLIBC_2.2.5とは
</summary>

> バイナリ中で参照されているけど定義がないシンボルがあると，
> `nm`コマンドはundefinedを意味する`U`を表示します．
> 実は`a.out`は`main`関数を呼び出す前に`__libc_start_main`という
> GLIBC中の関数を呼び出します．`__libc_start_main`は
> 様々な初期化を行った後，`main`関数を呼び出すのが主な役割です．
</details>

出力が長くなるので，`g1`と`main`のアドレスだけ載せています．
`g1`のアドレスは`4010`番地，`main`のアドレスは`1129`番地となりました．
ただし，このまま実行すると，`g1`や`main`のアドレスはこれらのアドレスにはならず，
実行するたびに変わります．
これは**ASLR**や**PIE**というセキュリティ対策機能のためです．

確かめてみましょう．
以下の`foo2.c`を普通にコンパイルして実行してみます．

```C
// foo2.c
#include <stdio.h>
int g1 = 999;
int main ()
{
    printf ("%p, %p\n", &g1, main);
}
```

以下の通り，`g1`や`main`のアドレスは実行するたびに変わりますし，
`nm`が出力したアドレスとも異なります．

```
$ gcc foo.c
$ ./a.out
0x557f2361e010, 0x557f2361b149
$ ./a.out
0x55a40e6f5010, 0x55a40e6f2149
$ ./a.out
0x562750663010, 0x562750660149
$ 
```

ここではASLRとPIEの機能を無効にして，アドレスが変わらなくなることを確認します．

```
$ sudo sysctl -w kernel.randomize_va_space=0
$ gcc -no-pie foo2.c
$ nm ./a.out | egrep main
                 U __libc_start_main@@@@GLIBC_2.2.5
0000000000401136 T main
$ nm ./a.out | egrep g1
0000000000404030 D g1
$ ./a.out
&g1=0x404030, main=0x401136
$ ./a.out
&g1=0x404030, main=0x401136
$ ./a.out
&g1=0x404030, main=0x401136
```

ASLRとPIEの機能をオフにすることで，アドレスが変わらなくなり，
かつ`nm`が出力するアドレスと同じになることが確認できました．

> 注意：
> 不用意なASLRとPIEの無効化はセキュリティ機能を下げるので避けるべきです．
> しかしデバッグ作業ではアドレスが変わらなくなるので
> ASLRとPIEの無効化が有用な場合もあります．
> なお，デバッガ中ではASLRは無効化されていることが多いです．


<details>
<summary>
ASLRとは
</summary>

> ASLR (address space layout randomizationの略)は，
> アドレス空間の配置をランダム化する機能です．
> テキスト（実行コード），ライブラリ，スタック，ヒープなどをメモリ上に
> 配置するアドレスを実行するたびにランダムに変化させます．
> 以下を実行するとASLRは無効化され，
> ```
> $ sudo sysctl -w kernel.randomize_va_space=0
> ```
> 以下を実行するとASLRは有効化されます．
> ```
> $ sudo sysctl -w kernel.randomize_va_space=1
> ```
</details>

<details>
<summary>
PIEとは
</summary>

> PIE (position independent executableの略)は位置独立実行可能ファイルを意味します．
> 通常，動的ライブラリは位置独立コードPIC (position independent code)としてコンパイルされます．
> 動的ライブラリはメモリ上で共有されるため，どのアドレスに配置してもそのまま再配置せずに，実行したいからです．
> PIEは動的ライブラリだけでなく，`a.out`も位置独立にした実行可能ファイルを指します．
> `-no-pie`オプションでコンパイルすると，PIEを無効化できます．
> ```
> $ gcc -no-pie foo2.c
> ```
</details>

## 逆アセンブル再び{#逆アセンブル再び}

[逆アセンブル](#逆アセンブル)で説明した通り，
`objdump -d ./a.out`で逆アセンブル結果が表示されます（再掲）．

```
$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add5>:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 05             	add    $0x5,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
```

`objdump`コマンドは`add5.o`の`.text`セクションを抽出し，
そのデータを機械語命令として解釈して，対応するニモニックを出力しています．

この出力によれば，`.text`セクションの先頭4バイトは`F3 0F 1E FA`で，
この4バイトが`endbr64`命令になります
（x86-64の命令長は可変長で，1バイト〜15バイトです）．

以下では`.text`セクションの先頭4バイトが`F3 0F 1E FA`であることを確認します．

セクションのヘッダを出力するコマンド[`objdump -h`](#.text)の出力を再掲します．

```
$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS, ALLOC, LOAD, DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
```

`.text`セクションの`File off`の欄を見ると`00000040`とあります．
これは`.text`セクションが`add5.o`の先頭から16進数で40バイト
目（以後，0x40と表記します）にあることを意味しています．

`od`コマンドの`-j`オプションを使うと，指定したバイト数だけ，
先頭をスキップしてくれます．
この`-j`オプションを使って，0x40バイトスキップして，
`.text`セクションの最初だけを16進ダンプします
（`head -n3`は先頭の3行だけ表示します）．

```
$ od -t x1 -j0x40 add5.o | head -n3
0000100 f3 0f 1e fa 55 48 89 e5 89 7d fc 8b 45 fc 83 c0
0000120 05 5d c3 00 47 43 43 3a 20 28 55 62 75 6e 74 75
0000140 20 39 2e 34 2e 30 2d 31 75 62 75 6e 74 75 31 7e
```

この結果を見ると，`.text`セクションの最初の4バイトは
`F3 0F 1E FA`であることが分かります．
これは上の[逆アセンブルの結果](#逆アセンブル再び)の先頭4バイトと一致しており，
`endbr64`命令が，`add5.o`の先頭から0x40バイト目に存在することが分かりました．

## 広義のコンパイルとリンク{#広義のコンパイル}

ここでは広義のコンパイル，つまりCのプログラム`foo.c`から
実行可能ファイル`a.out`を生成する処理の中身を見ていきます．
いちばん大事なのは最後の**リンク**(link)です．

<img src="figs/compile-all.svg" height="300px" id="fig:compile-all">

- ❶ Cの前処理，すなわち`#include`や`#define`などの前処理命令の処理と，マクロ（例えば`<stdio.h>`が定義する`NULL`や`EOF`）の展開を行います．`gcc -E`コマンドで実行できますが，内部的にはカッコ内の`cpp`や`cc1`コマンドが実行されています（現在は`cc1`）．
- ❷ 狭義のコンパイル処理で，Cのプログラムをアセンブリコードに変換します．
- ❸ アセンブラ(`as`コマンド)によるアセンブル処理で，オブジェクトファイル`foo.o`を生成します．`foo.o`中にはバイナリの機械語命令が入っています．
- ❹ `foo.o`だけでは実行可能ファイルは作れません．例えば，`printf`などのライブラリ関数の実体は，
`libc.a`([静的ライブラリ](#静的ライブラリ))や`libc.so`([動的ライブラリ](動的ライブラリ))の中にあるからです．
また，`main`関数を呼び出すためのCスタートアップルーチン(多くの場合，`crt*.o`というファイル名)も必要です．
また，分割コンパイルの機能を使った結果，`foo.o`は他のC言語のプログラムをアセンブルしたオブジェクトファイル`*.o`が必要なことがよくあります．
「このような他のバイナリと`foo.o`を合体させて`a.out`を生成する処理」のことを**リンク**(link)と呼びます．


広義のコンパイルで具体的にどのような処理が行われてるのかを見るには，
`-v`をつけて`gcc -v`とコンパイルすれば表示されます．
（以下では表示を省略しています．全てを表示するには<i class="fa fa-eye"></i>ボタンを押して下さい）．

```bash
$ gcc -v main.c add5.s
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:hsa
OFFLOAD_TARGET_DEFAULT=1
~Target: x86_64-linux-gnu
~Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.4.0-1ubuntu1~20.04.1' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-Av3uEd/gcc-9-9.4.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
~Thread model: posix
~gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1) 
~COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
~ /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpbase main.c -mtune=generic -march=x86-64 -auxbase main -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccCXQ4A8.s
~GNU C17 (Ubuntu 9.4.0-1ubuntu1~20.04.1) version 9.4.0 (x86_64-linux-gnu)
~	compiled by GNU C version 9.4.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP
~
~GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
~ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"
~ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed"
~ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/include"
~#include "..." search starts here:
~#include <...> search starts here:
~ /usr/lib/gcc/x86_64-linux-gnu/9/include
~ /usr/local/include
~ /usr/include/x86_64-linux-gnu
~ /usr/include
~End of search list.
~GNU C17 (Ubuntu 9.4.0-1ubuntu1~20.04.1) version 9.4.0 (x86_64-linux-gnu)
~	compiled by GNU C version 9.4.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP
~
~GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
~Compiler executable checksum: c0c95c0b4209efec1c1892d5ff24030b
~COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
~ as -v --64 -o /tmp/cc5GcDo8.o /tmp/ccCXQ4A8.s
~GNU assembler version 2.34 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.34
~COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
~ as -v --64 -o /tmp/ccbDFcB5.o add5.s
~GNU assembler version 2.34 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.34
~COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/
~LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../:/lib/:/usr/lib/
~COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
~ /usr/lib/gcc/x86_64-linux-gnu/9/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper -plugin-opt=-fresolution=/tmp/ccMs14z7.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/cc5GcDo8.o /tmp/ccbDFcB5.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/9/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o
~COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
```

## バイナリファイルの種類

実行可能ファイル`a.out`に関連するバイナリファイルには
以下の4種類があります：
- オブジェクトファイル(`*.o`)
- 実行可能ファイル(`a.out`)
- 静的ライブラリファイル(`lib*.a`)
- 動的ライブラリファイル(`lib*so`)

### オブジェクトファイル(`*.o`){#オブジェクトファイル}

**オブジェクトファイル**とはLinuxでファイル名の拡張子が`.o`なファイルです．
オブジェクトファイルは機械語命令を含んでいますが，
このオブジェクトファイル単体では実行することができません．
実行を可能にするには[**リンク**](#広義のコンパイル)(link)処理を経て，
[**実行可能ファイル**](#実行可能ファイル)
を作成する必要があります．

オブジェクトファイルは**再配置可能オブジェクトファイル**
(relocatable object file)と呼ばれることもあります．
オブジェクトファイルはリンク時に再配置（アドレス調整）が可能だからです．

### 実行可能ファイル(`a.out`){#実行可能ファイル}

**実行可能ファイル**(executable file)はその名前の通り，OSに実行を依頼すればそのままで実行できるバイナリファイルのことです．
例えば，hello wordの実行可能ファイル`a.out`はシェル上で以下のように実行できます．

```
$ ./a.out
hello, world
```

`ls`などのシェル上で実行可能なコマンドも実行可能ファイルです（スクリプトで実行可能ファイルではないこともあります）．

```
$ which ls
/usr/bin/ls
$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, ❶interpreter /lib64/ld-linux-x86-64.so.2, ❷BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd, for GNU/Linux 3.2.0, stripped
$ ls
a.out add5.c add5.o add5.s
```

<p id="interpreter">
<details>
<summary>
❶interpreterとは
</summary>

> ELFバイナリの動的リンカのことを（なぜか）interpreterと呼びます．
> プログラミング言語処理系のインタプリタとは何の関係もありません．
> ELFバイナリでは動的リンカのフルパスを指定することができ，バイナリに埋め込みます．
> この場合は `/lib64/ld-linux-x86-64.so.2` が埋め込まれてます．
> OSが`a.out`を実行する際に，
> OSはまず動的リンカ(interpreter)をメモリにロードして，
> ロードした動的リンカに制御を渡します．
> 動的リンカは`a.out`中の他の部分や，動的ライブラリをメモリにロードし，
> 動的リンクを行ってから，`a.out`の**エントリポイント**
> (最初に実行を開始するアドレス)にジャンプします．
> その後，いくつかの初期化を行ってから，`main`関数が呼び出されます．
> 
> `a.out`のエントリポイントは`readelf -h`コマンドで確認できます．
> エントリポイントは`0x401050`番地でした❶．
> 
> ```
> $ readelf -h ./a.out
> ELF Header:
>   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
>   Class:                             ELF64
>   Data:                              2's complement, little endian
>   Version:                           1 (current)
>   OS/ABI:                            UNIX - System V
>   ABI Version:                       0
>   Type:                              EXEC (Executable file)
>   Machine:                           Advanced Micro Devices X86-64
>   Version:                           0x1
> ❶Entry point address:               0x401050
>   Start of program headers:          64 (bytes into file)
>   Start of section headers:          16832 (bytes into file)
>   Flags:                             0x0
>   Size of this header:               64 (bytes)
>   Size of program headers:           56 (bytes)
>   Number of program headers:         13
>   Size of section headers:           64 (bytes)
>   Number of section headers:         36
>   Section header string table index: 35
> ```
> 
> 逆アセンブルすると`0x401050`番地は`_start`という関数がありました❷．
> `a.out`は`_start`関数から実行が始まることが分かりました．
>
> ```
> $ objdump -d ./a.out | egrep 401050 -A 5
> 0000000000401050 ❷ <_start>:
>   401050:	f3 0f 1e fa          	endbr64 
>   401054:	31 ed                	xor    %ebp,%ebp
>   401056:	49 89 d1             	mov    %rdx,%r9
>   401059:	5e                   	pop    %rsi
>   40105a:	48 89 e2             	mov    %rsp,%rdx
>   40105d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
> ```
</details>
</p>

<details>
<summary>
❷BuildID[sha1]とは
</summary>

>  BuildIDはバイナリファイルが同じかどうかを識別するユニークな番号（背番号）です．
> ここでは`2f15`で始まる40桁の16進数が `/usr/bin/ls`のBuildIDです．
> BuildIDはLinux ELF特有の機能です．
> `strip`してもBuildIDは変化しないので，`strip`前後のファイルが同じかの確認に使えます．
>
> ```
> $ gcc hello.c
> $ cp a.out a.out.stripped
> $ strip a.out.stripped
> $ file a.out a.out.stripped
> a.out:          ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba, for GNU/Linux 3.2.0, not stripped
> a.out.stripped: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba, for GNU/Linux 3.2.0, stripped
> ```
>
> ここでは説明しませんが**コアファイル**(core file)にもBuildIDが入っており，
> そのコアファイルを出力した`a.out`を探すことができます．
>
> ちなみにsha1はSHA-1を意味しており，SHA-1は160ビットのハッシュを生成するハッシュ関数です．
> `git`のハッシュにはSHA-1が使われています．
> `sha1sum`コマンドでSHA-1のハッシュを計算できます．
> 
> ```
> $ sha1sum ./a.out
> ff99525ad6a48d78d35d3108401af935a6ca9bbe  ./a.out
> ```
> 
> この結果から分かる通り，BuildIDのハッシュは，単純に`a.out`から作ったハッシュ値ではありません．
> ELFバイナリのヘッダとセクションの一部からハッシュを計算しているようですが，正確な情報は見つかりませんでした．
</details>


### 静的ライブラリ(`lib*.a`){#静的ライブラリ}

**静的ライブラリ**(static library)は[**静的リンク**](#静的リンクと動的リンク)
するときに使われるライブラリです．
**ライブラリ**とは複数のオブジェクトファイルを１つのファイルにまとめたもの（**アーカイブ**）です．

LinuxなどのUNIX系のOSでは静的ライブラリのファイル拡張子は`.a`が多いです．
またWindowsでは`.lib`です．
`printf`の実体が入っているC標準ライブラリの
静的ライブラリのファイル名は`libc.a`です．

### 動的ライブラリ(`lib*so`){#動的ライブラリ}

**動的ライブラリ**(dynamic library)は[**動的リンク**](#静的リンクと動的リンク)
するときに使われるライブラリです．
動的ライブラリは**共有ライブラリ**(shared library)とも呼ばれます．
動的ライブラリは複数のプロセスからメモリ上で共有されるからです．

Linuxでは動的ライブラリのファイル拡張子は`.so`です(shared objectの略)．
処理系の都合でファイル拡張子に数字がつくことがあります（例：`.so.6`）．
動的ライブラリのファイル拡張子はUnix系のOSでも様々です．
Windowsでは`.dll`です．

## 静的リンクと動的リンク{#静的リンクと動的リンク}

静的ライブラリは静的リンクに使われるライブラリで，
動的ライブラリは動的リンクに使われるライブラリです．

### 静的リンク

**静的リンク**とは**コンパイル時**にリンクを行う手法です．
仕組みは単純ですが，ファイルやメモリの使用量が増える欠点があります．
[この図](#fig:compile-all)で説明したリンクは実は静的リンクでした．

静的リンクしたファイル`a.out`はリンク済みなので，
ライブラリ関数(例えば`printf`)の実体も`a.out`の中に入っています．

<img src="figs/static-link-printf.svg" height="200px" id="fig:static-link-printf">

`a.out`ごとに`printf`のコピーが作られるので，
ファイルの使用量が無駄に増えてしまいます．
また`a.out`中の`printf`は実行時にもメモリ上で**共有されない**ので，
メモリの使用量も無駄に増えてしまいます．


### 静的リンクでコンパイルしてみる

```
// hello.c
#include <stdio.h>
int main (int ac, char **ag)
{
    printf ("hello (%d)\n", ac);
}
```

静的リンクするには`-static`オプションをつけます（`-static`無しだと動的リンクになります）．
`printf`に第2引数を与えているのは，こうしないと，コンパイラが勝手に
`printf`の呼び出しを`puts`に変更してしまうからです．

`a.out`を`file`コマンドで確認すると`statically linked`とあり，
静的リンクできているようです．

```
$ gcc -static hello.c
$ file ./a.out
./a.out: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=40fe6c0daaf2d49fabad4d37bc34fcdd12cb8da9, for GNU/Linux 3.2.0, not stripped
$ ./a.out
hello (1)
```

<details>
<summary>
練習問題：静的にリンクした`a.out`中に`printf`の実体があることを確認せよ
</summary>

> `a.out`を逆アセンブルし，`<main>:`を含む行から14行を表示させる．
>   `main`関数は(`printf`ではなく)`_IO_printf`を呼び出していることを確認．
> ``` 
> $ objdump -d ./a.out | egrep -A 14 "<main>:"
> 0000000000401cb5 <main>:
>   401cb5:	f3 0f 1e fa          	endbr64 
>   401cb9:	55                   	push   %rbp
>   401cba:	48 89 e5             	mov    %rsp,%rbp
>   401cbd:	48 83 ec 10          	sub    $0x10,%rsp
>   401cc1:	89 7d fc             	mov    %edi,-0x4(%rbp)
>   401cc4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
>   401cc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
>   401ccb:	89 c6                	mov    %eax,%esi
>   401ccd:	48 8d 3d 30 33 09 00 	lea    0x93330(%rip),%rdi        # 495004 <_IO_stdin_used+0x4>
>   401cd4:	b8 00 00 00 00       	mov    $0x0,%eax
>   401cd9:	e8 72 ec 00 00       	callq  410950 <_IO_printf>
>   401cde:	b8 00 00 00 00       	mov    $0x0,%eax
>   401ce3:	c9                   	leaveq 
>   401ce4:	c3                   	retq   
> ``` 
>
> > 注：ここでは`egrep -A 14`としてますが，皆さんが試す時は，
> > ```
> > $ objdump -d ./a.out | less
> > ```
> > としてから，`/<main>:`とリターンを入力して検索する方が便利でしょう．
> 
> 次に同じく`a.out`を逆アセンブルし，`<_IO_printf>:'を含む行から数行を表示させる．
> 
> ``` 
> $ objdump -d ./a.out | egrep -A 5 "<_IO_printf>:"
> 0000000000410950 <_IO_printf>:
>   410950:	f3 0f 1e fa          	endbr64 
>   410954:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
>   41095b:	49 89 fa             	mov    %rdi,%r10
>   41095e:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
>   410963:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
> ``` 
> 
> これは`_IO_printf`の定義なので，`a.out`に`printf`の実体があることを確認できた．
> なお，以下の`nm`コマンドでも，`a.out`に`printf`の実体があることを確認できる．
> 
> ```
> $ nm ./a.out | egrep _IO_printf
> 0000000000410950 T _IO_printf
> ```
>
> 実は`_IO_printf`も`printf`も実体は同じ．処理系の都合で，
> 「実体は同じだけど別の名前をつける」ことがあり，それをエイリアス（別名）という．
> 410950番地で調べると，これを確認できる．
>
> ```
> $ nm ./a.out | egrep 410950
> 0000000000410950 T _IO_printf
> 0000000000410950 T __printf
> 0000000000410950 T printf
> ```
</details>


### 動的リンク

**動的リンク**とは実行開始時の**ロード時**（`a.out`をメモリにコピーする時）
あるいは**実行途中**にメモリ上でリンクを行う手法です．
現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．

動的リンクしたファイル`a.out`には
「ライブラリ関数(例えば`printf`)とのリンクが必要だよ」という
小さな参照情報だけが入っており，`printf`の実体は入っていません．
実際のリンクは実行時にメモリ上で行います．

<img src="figs/dynamic-link-printf.svg" height="200px" id="fig:dynamic-link-printf">

`a.out`には`printf`を含まないので，ファイルの使用量を抑えられます．
また`a.out`中の`printf`は実行時にはメモリ上で**共有される**ので，
メモリの使用量も抑えられます．

ファイルサイズを比較してみると，静的リンクした`a.out-static`は約870KB，
動的リンクした`a.out-dynamic`は約17KBで，50倍ものサイズ差がありました．

```
$ gcc -static -o a.out-static hello.c
$ gcc -o a.out-dynamic hello.c
$ ls -l a.out*
-rwxrwxr-x 1 gondow gondow  16696 Jul 20 17:52 a.out-dynamic
-rwxrwxr-x 1 gondow gondow 871832 Jul 20 17:51 a.out-static
```

### 動的リンクでコンパイルしてみる

Linuxでは`-static`オプションをつけなければ動的リンクになります．

```
$ gcc hello.c
$ file a.out
a.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba, for GNU/Linux 3.2.0, not stripped
$ ./a.out
hello (1)
```

実行時にリンクが必要な動的ライブラリの情報は`ldd`コマンドで表示できます．

```
$ ldd ./a.out
	❶linux-vdso.so.1 (0x00007ffd21638000)
	❷libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcfef5c1000)
	❸/lib64/ld-linux-x86-64.so.2 (0x00007fcfef7d8000)

```

この`a.out`は`linux-vsdo.so.1`，`libc.so.6`，`ld-linux-x86-64.so.2`という
3つの動的ライブラリと実行時にリンクする必要があることを表示しています．
`libc.so.6`は（`LD_LIBRARY_PATH`などの設定がなければ）
絶対パス`/lib/x86_64-linux-gnu/libc.so.6`とリンクされます．

<details>
<summary>
❶linux-vdso.so.1とは
</summary>

> vDSO (virtual dynamic shared objectの略)で，カーネル空間で実行する必要が無い
> システムコール(例えば`gettimeofday`)を高速に実行するための仕組みです．
> - [Implementing virtual system calls](https://lwn.net/Articles/615809/)
> - [man vdso](https://man7.org/linux/man-pages/man7/vdso.7.html)
</details>

<details>
<summary>
❷libc.so.6とは
</summary>

> C標準ライブラリが入った動的ライブラリです．
> `nm -D`コマンドで調べると，`printf`の実体が入っていることが分かります．
> (`-D`は共有ライブラリで使われる動的シンボルを表示させるオプションです）
> 
> ```
> $ nm -D /lib/x86_64-linux-gnu/libc.so.6 | egrep ' T printf'
> 0000000000061c90 T printf
> 0000000000061100 T printf_size
> 0000000000061bb0 T printf_size_info
> ```
</details>

<details>
<summary>
❸ld-linux-x86-64.so.2とは
</summary>

> 動的リンクを行うプログラム（共有ライブラリ），つまり動的リンカです．
> [interpreterとは](#interpreter)も参照下さい．
> > - [man ld-linux.so](https://man7.org/linux/man-pages/man8/ld.so.8.html)
</details>

<details>
<summary>
練習問題：動的にリンクした`a.out`中に`printf`の実体が無いことを確認せよ
</summary>

`nm`コマンドで`a.out`には`main`を始めごく少数の
関数しか定義しておらず，その中に`printf`は入っていないことが以下で確認できます．

```
$ nm ./a.out | egrep ' T '
00000000000011f8 T _fini
00000000000011f0 T __libc_csu_fini
0000000000001180 T __libc_csu_init
0000000000001149 T main
0000000000001060 T _start
```

また`nm`の出力を`printf`で検索すると，GLIBC中の`printf`への参照はあるが
`a.out`中では未定義(`U`)となっていることが分かります．

```
$ nm ./a.out | egrep 'printf'
                 U printf@@@@GLIBC_2.2.5
```

なお逆アセンブルすると`<printf@@plt>`という小さな関数が見つかりますが，
これは`printf`の実体ではありません．

```
$ objdump -d ./a.out | egrep -A 5 "<printf"
0000000000001050 <printf@@plt>:
    1050:	f3 0f 1e fa          	endbr64 
    1054:	f2 ff 25 75 2f 00 00 	bnd jmpq ❶*0x2f75(%rip)        # 3fd0 <printf@@GLIBC_2.2.5>
    105b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
```

`<printf@@plt>`は`printf`を呼び出す単なる踏み台で，
PLT (procedure linkage table)という仕組みです．
PLTは`printf`の最初の呼び出しまで`printf`の**アドレス解決**
(address resolution)を遅延します．具体的には次の2ステップになります．

- `printf@@plt`の間接ジャンプ先❶の初期値は「動的リンクする関数（動的リンカ）」になっているため，最初に`printf@@plt`が呼ばれると，動的リンクを行い，その結果，間接ジャンプ先が「`printf`の実体」に変更されます❷．
そして動的リンカは何もなかったかのように`printf`を呼び出します．
（ちなみに`printf@@plt`の間接ジャンプで参照するメモリ領域は GOT (global offset table)と呼ばれます）
- その結果，2回目以降の以下の間接ジャンプ❶では`printf`が呼ばれます．

つまり，GOTに`printf`のアドレスを格納することが，ここではアドレス解決になっています．

<img src="figs/plt-printf.svg" height="400px" id="fig:plt-printf">

</details>

### 静的ライブラリを作成してみる

<p id="main.c-static">

```C
// main.c
#include <stdio.h>
int add5 (int n);
int main (void)
{
    printf ("%d\n", add5 (10));
}
```
</p>

<p id="add5.c-static">

```C
// add5.c
int add5 (int n)
{
    return n + 5;
}
```
</p>

```
$ gcc -c add5.c   
$ ar rcs libadd5.a add5.o  ❶
$ ar t libadd5.a
add5.o  ❷
$ file libadd5.a
libadd5.a: current ar archive
$ gcc ❸-static -o a.out-static main.c ❹-L. ❺-ladd5
$ file a.out-static
file ./a.out-static
./a.out-static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=1bf84a77504302513d6219e4b27316309d08ed2d, for GNU/Linux 3.2.0, not stripped
$ ./a.out-static 
15 ❻
```


- ❶ `ar rcs`コマンドで`add5.o`から`libadd5.a`を作成します．
- ❷  `ar t`コマンドで`libadd5.a`の中身を調べます．中身は`add5.o`だけでした．
- ❸❹❺ `gcc`で`main.c`と`libadd5.a`を静的リンクします．
  静的リンクするために❸`-static`オプションが必要です．
  `libadd5.a`がカレントディレクトリにあることを伝えるために❹`-L.`が必要です．
  静的リンクする静的ライブラリが`libadd5.a`であることを伝えるために
  ❺`-ladd5`が必要です．（前の`add`と後の`.a`は自動的に付加されます）
- ❻ 実行してみると，静的ライブラリ`libadd5.a`中の`add5`関数を呼び出せました．

### 動的ライブラリを作成してみる

[`add5.c`](#add5.c-static)と[`main.c`](#main.c-static)は同じものを使います．

```
$ gcc -c add5.c   
$ gcc ❶-fPIC ❷-shared -o libadd5.so add5.c
$ file libadd5.so
libadd5.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=415ef51f32145b59c51e836a25959f0f66039768, not stripped
$ gcc -o a.out-dynamic main.c -ladd5 -L. ❸-Wl,-rpath .
$ file ./a.out-dynamic
./a.out-dynamic: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a5d4f8ef61cef4e0b063376333f07170d312c546, for GNU/Linux 3.2.0, not stripped
$ ldd ./a.out
	linux-vdso.so.1 (0x00007ffff7fcd000)
	libadd5.so => ❹./libadd5.so (0x00007ffff7fbd000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dad000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
$ ./a.out-dynamic
15 ❺ 
```

- ❶❷ `add5.c`から動的ライブラリ`libadd5.so`を作ります．
  `libadd5.so`を**位置独立コード**(PIC)にするために，❶`-fPIC`が必要です．
  `libadd5.so`を**共有オブジェクト**(shared object)にするために，❷`-shared`が必要です．
- ❸ `gcc`で`main.c`と`libadd5.so`を動的リンクします．
  実行時に動的ライブラリを探索するパスを❸`-Wl,-rpath .`で指定しています．
  ここでは`libadd5.so`をカレントディレクトリに置いているためです．
  （セキュリティ上，実際に使う際は絶対パスを指定する方が安全でしょう）．
  ちなみに`-Wl,-rpath .`を`gcc`に指定すると，
  [`ld`コマンド](https://man7.org/linux/man-pages/man1/ld.1.html)
  に`-rpath .`というオプションが渡されます	．
- ❹ `ldd`コマンドで調べると，`a.out-dynamic`中の`libadd5.so`は
  `./libadd5.so`を参照していることを確認できました．
- ❺ 実行してみると，動的ライブラリ`libadd5.so`中の`add5`関数を呼び出せました．


<details>
<summary>
位置独立コードとは
</summary>

> **位置独立コード**(position independent code, PIC)とはメモリ上の
> どこにロードしても，そのまま実行できるコードです．
> 位置独立コードでは絶対アドレスは使わず（再配置が必要になってしまうから），
> 相対アドレスか間接アドレス参照だけを使います．
> 位置独立コードにすることで，メモリ上で動的ライブラリを共有できるため，
> メモリ使用量を抑えることができます．
</details>

## デバッグ情報

-g をつけるとデバッグ情報が付加される．
addr2line の話．逆もできる話．
objdump -d するとソースコードも表示される話．
gdb のバックトレースでソースコードのファイル名や行番号も表示される話．
objdumpやreadelfコマンドでデバッグ情報を表示できる話．
llvm_dwarfdump

## デバッグ情報 gdb

   `-g`付きで逆アセンブルするとソースコードも表示される．

### addr2line とその逆
### デバッグ情報を直接見る

## 実行時のメモリレイアウト
### pmap
@


1.3
log
@*** empty log message ***
@
text
@d397 1
a397 1
add5.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
d400 1
a400 1
これで，`add5.o`が64ビットのELFバイナリであることが分かりました．
d403 1
a403 1
LSBとは
d406 48
d456 1
a456 1
</details>
d460 1
a460 1
relocatableとは
d469 1
a469 1
version 1 (SYSV)とは
d478 1
a478 1
not strippedとは
d958 1
a958 1
/usr/bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd, for GNU/Linux 3.2.0, stripped
d963 97
d1079 1
d1099 8
d1156 6
d1198 3
a1200 3
**動的リンク**とは**ロード時**（`a.out`をメモリにコピーする時）
  あるいは**実行途中**にメモリ上でリンクを行う手法です．
  現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．
d1202 4
a1205 1
<img src="figs/dynamic-link.svg" height="200px" id="fig:dynamic-link">
d1207 1
a1207 2
#### ldd コマンド
#### 動的ライブラリの作成
d1209 232
d1448 1
d1454 5
a1458 1
## addr2line
@


1.2
log
@*** empty log message ***
@
text
@d1 4
d11 1
a11 1
- 2進数（バイナリ，数字の列）で表現．
d14 2
a15 2
- 機会語を記号で表現したプログラミング言語．
- 例1：機械語命令`01010101`をアセンブリ言語では`pushq %rbp`という記号（**ニモニック**，mnemonic）で表す．
d34 4
d42 2
a43 1
```C{#add5.c}
d99 2
a100 2
（「広義のコンパイル」はCのプログラムから実行可能ファイル(`a.out`)を
生成する処理を指します(xxx)）．
d160 2
a161 1
```x86asmatt{#add5.s}
d214 1
a214 1
> 本書の学習者としては「endbr64はセキュリティ上，重要だけど，アセンブリ言語を学習する立場からは「`nop`命令(何も実行しない命令)」と思えば十分です．
d235 1
a235 1
add5:
d272 4
d310 1
a310 1
このELFのバイナリファイルの先頭4バイトには**マジックナンバー**という，
d326 3
a328 1
その右側に並んでいるのが「1バイトごとに16進表記した中身」です．
d350 1
a350 1
### コンピュータの中のデータはすべて`0`と`1`から成る
d364 3
a366 3
> 本書で，テキスト(text)には2種類の別の意味があることに注意して下さい．
> - 1つはテキストは「文字」を意味します．例：「テキストファイル」
> - もう1つは「機械語命令列」を意味します．例：「[テキストセクション](#.text)」
d368 22
d424 1
a424 1
> LinuxのABIである[System V ABI](https://wiki.osdev.org/System_V_ABI)
a563 3
さらに代表的なセクションである`.rodata`も説明します．
- `.rodata`セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数`"hello"`は書き込み禁止なので，`"hello"`の2進数表現が`.rodata`セクションに格納されます．

d572 3
d576 1
a576 1
まずはこの4種類 (`.text`, `.data`, `.bss`, `.rodata`) を覚えましょう．
a577 2
### 逆アセンブル再び

d580 475
a1054 1
## nm
a1059 3

## 広義のコンパイルとリンク

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# アセンブリ言語の概要
d3 1
a3 1
## Cコードからアセンブリコードを出力してみる
d5 27
d34 1
a34 1
```C
d41 35
a75 1
次に以下のコマンドを実行して，`add5.s`を作成して下さい．
d149 1
d151 1
a151 1
```x86asmatt
d153 3
a155 3
	.text
	.globl	add5
	.type	add5, @@function
d157 8
a164 9
	endbr64
	pushq	%rbp
	movq	%rsp, %rbp
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$5, %eax
	popq	%rbp
	ret
	.size	add5, .-add5
d167 6
a172 1
> 読み飛ばし可：
d175 1
d177 5
a181 1
> 読み飛ばし可：
d183 7
d193 360
@
