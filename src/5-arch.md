<style type="text/css">
body { counter-reset: chapter 4; }
</style>

# アーキテクチャ

## 一般的なコンピュータの構成要素

### コンピュータの基本構造

<img src="figs/basic-arch.svg" height="250px" id="fig:basic-arch">

- コンピュータでは上図のように，**CPU**，**メインメモリ**(以後，単にメモリ)，
  **入出力装置**が，**バス**(bus)と呼ばれる信号線でつながっています．

- CPUは**制御装置**，**ALU**(演算装置)，**レジスタ**から構成されています
- **バス**はデジタルの信号線です．
  アドレスバス，データバス，制御バスがあります(図にはこの区別は書いていません)．

- 上図には**キャッシュ**や[**MMU**](./5-arch.md#仮想メモリ)などがありませんが，
  本書の範囲ではこの図の知識で十分です．

### CPUの基本構成

- 制御装置 = [フェッチ実行サイクル](./5-arch.md#フェッチ実行サイクル)をひたすら繰り返します
- ALU = 四則演算や論理演算などを計算します
- レジスタ
  - 高速・小容量・固定長のメモリです
  - 特定の役割を持つ**専用レジスタ**(例: プログラムカウンタ`%rip`)と，
    様々な用途に使える**汎用レジスタ**(例: `%rax`)に概ね分かれています．

### メモリ

<img src="figs/memory-byte-addr.svg" height="250px" id="fig:memory-byte-addr">

- メモリはRAMです．揮発性があります(電源が切れると記憶内容は失われます)．
- メモリは巨大なバイトの配列です
  - メモリのアドレスを指定して，メモリの内容を読み書きします
  - バイト単位だけでなく，4バイトや8バイトなどの連続するメモリ領域も読み書きできます
- 通常，メモリには1バイトごとに連番のアドレスがつきます
  これを**バイトアドレッシング**といいます．

> 実際の物理アドレスには，RAMだけでなく，ROMや memory-mapped I/O
> (メモリのアドレスを使ってアクセスする入出力装置，例えばフレームバッファ)も
> マップされています．ただし，これらは通常はユーザプロセスからは見えないので気にしなくて良いです．

### フェッチ実行サイクル

<img src="figs/fetch-cycle.svg" height="150px" id="fig:fetch-cycle">

- CPUは次の動作をひたすら繰り返します


  1. **フェッチ**(fetch)
    - プログラムカウンタ(`%rip`)が指す機械語命令を
      メモリからCPUに読み込みます
    - 次の機械語命令を指すように，プログラムカウンタの値を増やします
  2. **デコード**(decode)
    - 読み込んだ命令を解析して，実行の準備をする
    - 例えば，必要ならメモリからオペランドの値をCPUに読み込みます
  3. **実行**(execute)
    - 読み込んだ機械語命令を実行します

## x86-64のレジスタ
### 汎用レジスタ

<img src="figs/gp-regs.svg" height="350px" id="fig:gp-regs">

- 上記16個のレジスタが**汎用レジスタ**(general-purpose register)です．
  原則として，プログラマが自由に使えます．
- ただし，`%rsp`は**スタックポインタ**，`%rbp`は**ベースポインタ**と呼び，
  [一番上のスタックフレームの上下を指す](./2-asm-intro.md#stack-rsp-rbp)
  という役割があります．
  (ただし，[-fomit-frame-pointer](./2-asm-intro.md#-fomit-frame-pointer)
  オプションでコンパイルされた`a.out`中では，`%rbp`はベースポインタとしてではなく，
  汎用レジスタとして使われています)．

#### [caller-save/callee-saveレジスタ](./6-inst.md#caller-callee-save-regs)

| | 汎用レジスタ |
|-|-|
|caller-saveレジスタ| `%rax`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%r8`〜`%r11`|
|callee-saveレジスタ| `%rbx`, `%rbp`, `%rsp`, `%r12`〜`%r15`|

#### [引数](./6-inst.md#arg-reg)

|引数|レジスタ|
|-|-|
|第1引数 | `%rdi` |
|第2引数 | `%rsi` |
|第3引数 | `%rdx` |
|第4引数 | `%rcx` |
|第5引数 | `%r8` |
|第6引数 | `%r9` |

### プログラムカウンタ（命令ポインタ）

<img src="figs/rip.svg" height="100px" id="fig:rip">

### ステータスレジスタ（フラグレジスタ）


<img src="figs/rflags.svg" height="100px" id="fig:rflags">

#### 本書で扱うフラグ

ステータスレジスタのうち，本書は以下の6つのフラグを扱います．
フラグの値が1になることを「フラグがセットされる」「フラグが立つ」と表現します．
またフラグの値が0になることを「フラグがクリアされる」「フラグが消える」と表現します．

|フラグ|名前|説明|
|-|-|-|
|`CF`|キャリーフラグ |算術演算で結果の最上位ビットにキャリーかボローが生じるとセット．それ以外はクリア．符号**なし**整数演算でのオーバーフロー状態を表す．|
|`OF`|オーバーフローフラグ |符号ビット(MSB)を除いて，整数の演算結果が大きすぎるか小さすぎるかするとセット．それ以外はクリア．2の補数表現での符号**あり**整数演算のオーバーフロー状態を表す．|
|`ZF`|ゼロフラグ |結果がゼロの時にセット．それ以外はクリア．|
|`SF`|符号フラグ |符号あり整数の符号ビット(MSB)と同じ値をセット．(0は正の数，1は負の数であることを表す)|
|`PF`|パリティフラグ |結果の最下位バイトの値1のビットが偶数個あればセット，奇数個であればクリア．|
|`AF`|調整フラグ |算術演算で，結果のビット3にキャリーかボローが生じるとセット．それ以外はクリア．BCD演算で使用する(本書ではほとんど使いません)．|

#### CFフラグが立つ例

```x86asmatt
{{#include asm/cf.s}}
```

```
$ gcc -g cf.s
$ gdb ./a.out
(gdb) b 8
Breakpoint 1 at 0x112d: file cf.s, line 8.
(gdb) r
Breakpoint 1, main () at cf.s:8
8	    ret
(gdb) p $al
$1 = ❶ 0
(gdb) p $eflags
$2 = [ ❷ CF PF AF ZF IF ]
(gdb) quit
```

<img src="figs/cf.svg" height="150px" id="fig:cf">

- `movb $0xFF, %al`と`addb $1, %al`で，1バイト符号**なし**整数の加算`0xFF+1`をすると，オーバーフローが起きて`%al`の値は❶ 0になります．
(1バイト符号**なし**整数の範囲は0〜255です．`0xFF+1`は255+1=256となり
(1バイト符号**なし**整数として)オーバーフローが起きています)．
- `p $eflags`でステータスフラグを調べると，❷ CF フラグが立っています．

#### OFフラグが立つ例

```x86asmatt
{{#include asm/of.s}}
```

```
$ gcc -g of.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file of.s, line 6.
(gdb) r
Breakpoint 1, main () at of.s:6
6	    movb $0x7F, %al
(gdb) si
7	    addb $1, %al  # オーバーフローでOFが立つ
(gdb) si
main () at of.s:8
8	    ret
(gdb) p $al
$1 = ❶ -128
(gdb) p $eflags
$1 = [ AF SF IF ❷ OF ]
(gdb) ❸ p/u $al
$2 = ❹ 128
(gdb) quit
```

<img src="figs/of.svg" height="150px" id="fig:of">

- `movb $0x7F, %al`と`addb $1, %al`で，1バイト符号**あり**整数の加算`0x7F+1`をすると，オーバーフローが起きて`%al`の値は❶ -128になります．
(1バイト符号**あり**整数の範囲は-128〜127です．`0x7F+1`は127+1=128となり
(1バイト符号**あり**整数として)オーバーフローが起きています)．
- `p $eflags`でステータスフラグを調べると，❷ OF フラグが立っています．
- なお，符号なし(❸`u`)オプションをつけて`%al`レジスタの値を表示させると，
  符号なしの結果として正しい❹ 128という結果になりました．
  (x86-64は符号なし・符号ありを区別せず，どちらに対しても正しい結果を
  計算します)．

### レジスタの別名

#### `%rax`レジスタの別名 (`%rbx`, `%rcx`, `%rdx`も同様)

<img src="figs/reg-alias1.svg" height="150px" id="fig:reg-alias1">

- `%rax`の下位32ビットは`%eax`としてアクセス可能
- `%eax`の下位16ビットは`%ax`としてアクセス可能
- `%ax`の上位8ビットは`%ah`としてアクセス可能
- `%ax`の下位8ビットは`%al`としてアクセス可能

xxx 具体例

#### `%rbp`レジスタの別名 (`%rsp`, `%rdi`, `%rsi`も同様)

<img src="figs/reg-alias2.svg" height="150px" id="fig:reg-alias2">

- `%rbp`の下位32ビットは`%ebp`としてアクセス可能
- `%ebp`の下位16ビットは`%bp`としてアクセス可能
- `%bp`の下位8ビットは`%bpl`としてアクセス可能

#### `%r8`レジスタの別名 (`%r9`〜`%r15`も同様)

<img src="figs/reg-alias3.svg" height="150px" id="fig:reg-alias3">

- `%r8`の下位32ビットは`%r8d`としてアクセス可能
- `%r8d`の下位16ビットは`%r8w`としてアクセス可能
- `%r8w`の下位8ビットは`%r8b`としてアクセス可能

#### 同時に使えない制限

- 一部のレジスタは`%ah`, `%bh`, `%ch`, `%dh`と一緒には使えない．
- 例：`movb %ah, (%r8)` や `movb %ah, %bpl`はエラーになる．
- 正確には`REX`プリフィクス付きの命令では，`%ah`, `%bh`, `%ch`, `%dh`を使えない．

### 32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする

- 例:`movl $0xAABBCCDD, %eax`を実行すると`%rax`の上位32ビットが全てゼロになる
- 例: `movw $0x1122, %ax`や`movb $0x11, %al`では上位をゼロにすることはない

<details>
<summary>
上位32ビットをゼロにする実行例
</summary>

<img src="figs/zero-upper32.svg" height="250px" id="fig:zero-upper32">

```x86asmatt
{{#include asm/zero-upper32.s}}
```

```
$ gcc -g zero-upper32.s
$ gdb ./a.out -x zero-upper32.txt
Breakpoint 1, main () at zero-upper32.s:7
7	    movl $0xAABBCCDD, %eax
6	    movq $0x1122334455667788, %rax
7	    movl $0xAABBCCDD, %eax
$1 = 0x1122334455667788
8	    movq $0x1122334455667788, %rax
$2 = 0xaabbccdd
# 以下が出力されれば成功
# $1 = 0x1122334455667788
# $2 = 0xaabbccdd
```
</details>

## オペレーティングシステムの存在

### OSは邪魔!?

<img src="figs/os-nuisance.svg" height="250px" id="fig:os-nuisance">

- アセンブリ言語の利点はCPUや
  周辺機器のハードウェア(入出力装置)がよく見えることです
- でもユーザプロセス(皆さんが普通に実行しているプログラム)は
  OS上で動作するので，OSはCPUやハードウェアの詳細を見せない働きをします
  - この**抽象化**のおかげで，通常のアプリケーションを開発する際に，
    CPUやハードウェアの詳細を気にすること無くプログラミングできるわけですが．
- 例えば，OSは以下を隠しています．以下でもう少し詳しく説明します．
  - OSによる**マルチタスク処理**:
    ユーザプロセスはCPUを専有しているように見えます．
  - **ハードウェアの詳細**(例: ハードディスク):
    ユーザプロセスは**システムコール**経由でハードウェア等にアクセスします．
  - **物理メモリ**: ユーザプロセスは仮想メモリのみアクセス可能で，
    物理メモリへの直接アクセスはできません．
  - **割り込み** (interrupt): ハードウェアがCPUに**非同期的に**(asyncronously)送る信号が割り込みです．
    ユーザプロセスが割り込みを直接受け取ることはありません．
    　　
### OSによるマルチタスク処理

<img src="figs/multi-task.svg" height="110px" id="fig:multi-task">

- ユーザプロセスから見ると「ずっとCPUやレジスタを専有している」ように見えます．
- メモリはユーザプロセスごとに割り当てられますが，
  CPUの数は少ないので，OSはCPU上で実行するユーザプロセスを定期的に切り替えています．
  - このユーザプロセスの切り替えにはタイマー割り込みを使っています．
    タイマー割り込みが発生すると，OSがブート時に設定した割り込みハンドラを
    CPUが自動的に起動します．
  - その際，ユーザプロセスが使っていたCPUのレジスタ値は**メモリに退避**します．
    実行再開時にはレジスタ値を**メモリから回復**します．
- ユーザプロセスのプログラムを書く時は，
  マルチタスクのことを気にする必要はありません(ただしリアルタイムシステムなどは除く)．
    
### システムコール

<img src="figs/syscall.svg" height="130px" id="fig:syscall">

- ユーザプロセスは直接，周辺機器のハードウェアを操作できません．
  ユーザプロセスが直接操作するのは面倒だし危険なので，
  通常，OSが「ユーザプロセスによるハードウェア操作」を禁止しているからです．
- そのため，ユーザプロセスは**システムコール**を使って，
  ハードウェア操作をカーネル(OS本体)に依頼します．
  - ユーザプロセスが動作するアドレス空間を**ユーザ空間**，
    カーネルが動作するアドレス空間を**カーネル空間**と呼びます．
    カーネル空間ではCPUの**特権命令**を実行することが可能です．
  - `printf`などのライブラリ関数の呼び出しには`call`命令と`ret`命令を使います．
    一方，`write`などのシステムコールの呼び出しは
    トラップ命令(ソフトウェア割り込み命令)である，
    `syscall`/`sysret`，`sysenter`/`sysexit`，`int`/`iret`などを使います．
    システムコールの呼び出しにはユーザ空間からカーネル空間への切り替えが
    必要だからです．
- システムコール内では入出力命令(`in`, `out`, `mov`)を実行することで
  ハードウェアの操作を行います．
  ハードウェア側から来る割り込みは，予めOSが設定した割り込みハンドラが対処します．
  ユーザ空間ではCPUの特権命令を実行できないので，
  ユーザプロセス内ではこれらの操作をできません．
  
### 仮想メモリ

<img src="figs/paging.svg" height="300px" id="fig:paging">

- OSはx86-64のページング機能などを使って**仮想メモリ**を有効化しています．
  - 上図でプロセスAとプロセスBは物理メモリの一部を仮想メモリとして
    (仮想アドレスを使って)アクセスできる状態です．
  - `printf`はプロセスAとプロセスBで共有しています．
  - 共有している`printf`以外は，プロセスはお互いに他のプロセスのメモリの中身にアクセスできません．
  
<img src="figs/mmu.svg" height="200px" id="fig:mmu">

- 仮想メモリが有効な状態では，
  CPUが扱うアドレス(`%rip`やメモリ参照でアクセスするアドレス)
  はすべて仮想アドレスです．
  CPU上で動作するプログラム(`a.out`)は
  物理メモリのアドレスを使ってのアクセスはできません．

- 仮想アドレスから物理アドレスへの変換:
  - OSは「仮想アドレスと物理アドレスの対応表」である**ページテーブル**を
  　物理メモリ上で管理します．
  - 実際の変換はCPU内の**MMU**(memory management unit)が高速に行います．
    MMUはCPUから仮想アドレスを受け取り，それを物理アドレスに変換してから，
    バス上で物理アドレスを使って物理メモリにアクセスします．

### 割り込みとシグナル

<img src="figs/interrupt.svg" height="150px" id="fig:interrupt">

- CPUはバスを介して周辺機器とつながってます．
  例えば，キーボードのキーを押すと，キーを押すたび，離すたびに，
  CPUに割り込みを伝えます．
- **割り込み**(interrupt)は周辺機器側からCPUに**非同期的**(asynchronously)に
  送る信号です． 
- CPUは割り込みを受け取ると，(ブート時にOSが設定した)割り込みハンドラを自動的に
  起動して，その割り込みに対処します．
- 一部の割り込みはユーザプロセスに**UNIXシグナル**として配送されます．
  例えば，ユーザプロセスはタイマー割り込みを直接，受け取ることはできませんが，
  (`alarm`や`setitimer`などのシステムコールを使えば)
  `SIGALRM`というUNIXシグナルを受け取ることができます．
