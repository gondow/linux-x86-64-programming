<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x86-64機械語命令 - Linuxで学ぶx86-64アセンブリ言語</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="4-encoding.html"><strong aria-hidden="true">4.</strong> データ表現，2進数，2の補数</a></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど</div></li><li class="chapter-item expanded "><a href="6-inst.html" class="active"><strong aria-hidden="true">6.</strong> x86-64機械語命令</a></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> GNUアセンブラ命令</div></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> ABI: アプリケーション・バイナリ・インタフェース</div></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> デバッガの使い方</div></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 6; }
</style>
<h1 id="x86-64機械語命令"><a class="header" href="#x86-64機械語命令">x86-64機械語命令</a></h1>
<h2 id="how-to-execute-x86-inst"><a class="header" href="#how-to-execute-x86-inst">x86-64機械語命令の実行方法</a></h2>
<h3 id="概要"><a class="header" href="#概要">概要</a></h3>
<p>機械語命令を実行しても，単に<code>a.out</code>を実行するだけでは
意図通りに実行できたかの確認が難しいです．
(アセンブリコード内から<code>printf</code>を呼び出せばいいのですが，
そのコードもうざいので)．
そこで本書では<strong>デバッガを使って</strong>機械語命令の実行と確認を行います．</p>
<p>以下では例として<code>movq $999, %rax</code>という機械語命令を実行してみます．
(これらのファイルは<a href="https://github.com/gondow/linux-x86-64-programming/tree/main/src/asm">サンプルコード</a>から入手できます)．
<code>movq $999, %rax</code>は「定数<code>999</code>を<code>%rax</code>レジスタに格納する」という命令ですので，
実行後，<code>%rax</code>レジスタに<code>999</code>という値が入っていれば，
うまく実行できたことを確認できます．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p>実行確認のための<code>gdb</code>のコマンド列を書いたファイルも用意しています．</p>
<div id="asm/movq-4.txt">
<pre><code># asm/movq-4.txt
b 7
r
list 6,6
p $rax
echo # %raxの値が999なら成功\n
quit
</code></pre>
</div>
<h3 id="デバッガ上で実行gdbコマンドを手入力"><a class="header" href="#デバッガ上で実行gdbコマンドを手入力">デバッガ上で実行：<code>gdb</code>コマンドを手入力</a></h3>
<p><code>asm/movq-4.txt</code>中の<code>gdb</code>コマンドを
以下のように1行ずつ入力してみて下さい．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶
(gdb) b 7 ❷
Breakpoint 1 at 0x1130: file movq-4.s, line 6.
(gdb) r ❸
Breakpoint 1, main () at movq-4.s:6
6	    ret
(gdb) list 6,6 ❹
5	    movq $999, %rax
(gdb) p $rax ❺
$1 = 999
(gdb) quit
</code></pre>
<ul>
<li>❶ コンパイルした<code>a.out</code>を<code>gdb</code>上で実行</li>
<li>❷ ブレークポイントを7行目(<code>movq $999, %rax</code>の次の行)に設定 (<code>b</code>はbreakの略)</li>
<li>❸ 実行開始 (<code>r</code> は run の略)</li>
<li>❹ ソースコードの6行目だけを表示</li>
<li>❺ レジスタ<code>%rax</code>の値を(10進表記で)表示 (<code>p</code>はprintの略)</li>
<li><a href="#asm/movq-4.txt"><code>movq-4.txt</code></a>
の最後の行 <code>echo # %raxの値が999なら成功\n</code>は，
「どうなると正しく実行できたか」を確認するメッセージですので，
ここでは入力不要です．
❺の結果と一致したので「正しい実行」と確認できました．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力--xオプションを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力--xオプションを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>-x</code>オプションを使う)</a></h3>
<p><code>gdb</code>コマンドを手入力して，よく使う<code>gdb</code>コマンドを覚えることは良いことです．
とはいえ，手入力は面倒なので，自動入力も使いましょう．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶ -x movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	 ❷ movq $999, %rax
❸ $1 = 999 
❹ # %raxの値が999なら成功
(gdb) 

</code></pre>
<ul>
<li>❶ <code>-x movq-4.txt</code> というオプションをつけると，指定したファイル(ここでは<code>movq-4.txt</code>)の中に書かれている<code>gdb</code>コマンドを1行ずつ順番に実行してくれます</li>
<li><code>list 6,6</code>を実行した結果，❷6行目の<code>movq $999, %rax</code> が表示されています</li>
<li><code>p $rax</code>を実行した結果，<code>%rax</code>レジスタの値が❸999であると表示されています．
(<code>$1</code>は<code>gdb</code>が扱う変数です．ここでは無視して下さい)</li>
<li><code>echo # %raxの値が999なら成功\n</code> を<code>gdb</code>が実行した結果，
❹ <code># %raxの値が999なら成功</code>というメッセージが表示されています．
このメッセージと❸の実行結果を見比べれば「実行結果が正しい」ことを確認できます．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>source</code>コマンドを使う)</a></h3>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) ❶ source movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	    movq $999, %rax
$1 = 999
# %raxの値が999なら成功
</code></pre>
<p><code>gdb</code>は通常通りに実行開始して，
❶ <code>source</code>コマンドを使えば，<code>movq-4.txt</code>中の<code>gdb</code>コマンドを実行できます．
<code>-x</code>オプションと<code>source</code>コマンドは好きな方を使って下さい．</p>
<h2 id="アドレッシングモード-オペランドの表記方法"><a class="header" href="#アドレッシングモード-オペランドの表記方法">アドレッシングモード (オペランドの表記方法)</a></h2>
<h3 id="アドレッシングモードの概要"><a class="header" href="#アドレッシングモードの概要">アドレッシングモードの概要</a></h3>
<p>機械語命令は命令(<strong>オペコード</strong>(opcode))と
その引数の<strong>オペランド</strong>(operand)から構成されています．
例えば，<code>movq $999, %rax</code>という命令では，
<code>movq</code>がオペコードで，<code>$999</code>と<code>%rax</code>がオペランドです．</p>
<img src="figs/opcode-operand.svg" height="100px" id="fig:opcode-operand">
<p><strong>アドレッシングモード</strong>とはオペランドの書き方のことです．
(元々は「メモリのアドレスを指定する記法」という意味で「アドレッシングモード」という用語が使われています).
x86-64では大きく，以下の4種類の書き方ができます．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td></tr>
<tr><td><code>movq foo, %rax</code></td></tr>
<tr><td rowspan="3">
<p><a href="#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベルであり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="addr-mode-imm"><a class="header" href="#addr-mode-imm">アドレッシングモード：即値（定数）</a></h3>
<h4 id="定数-999"><a class="header" href="#定数-999">定数 <code>$999</code></a></h4>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-4.s"><code>movq-4.s</code></a>の6行目の
<code>movq $999, %rax</code>は「定数<code>999</code>をレジスタ<code>%rax</code>に格納する」という意味です．
デバッガで動作を確認します
(デバッガの操作手順は<a href="./asm/movq-4.txt"><code>movq-4.txt</code></a>にもあります)．</p>
<pre><code>$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-4.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-4.s:6
6	    movq $999, %rax
(gdb) si
main () at movq-4.s:7
7	    ret
(gdb) p $rax
$1 = 999
</code></pre>
<p>確かに<code>%rax</code>レジスタ中に<code>999</code>が格納されていました．</p>
<h4 id="ラベル-main"><a class="header" href="#ラベル-main">ラベル <code>$main</code></a></h4>
<pre><code class="language-x86asmatt"># asm/movq-6.s
    .text
    .globl main
    .type main, @function
main:
    movq $main, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-6.s">movq-6.s</a>の6行目の<code>movq $main, %rax</code>は
「ラベル<code>main</code>が表すアドレスを<code>%rax</code>レジスタに格納する」という意味です．
<code>gdb</code>で確かめます．</p>
<pre><code>$ gcc ❶ -no-pie -g movq-6.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at ❷ 0x40110a: file movq-6.s, line 7.
(gdb) r
Breakpoint 1, main () at movq-6.s:7
7   ❸  movq $main, %rax
(gdb) ❹ si
main () at movq-6.s:8
8	ret
(gdb) p/x $rax
$1 = ❺ 0x40110a 
</code></pre>
<ul>
<li>まず❶ <code>-no-pie</code>オプションをつけてコンパイルして下さい．
(<code>-static</code>オプションを使ってもうまくいくと思います)</li>
</ul>
<details>
<summary>
なぜ -no-pieオプション
</summary>
<p><code>-no-pie</code>オプションをつけないと以下のエラーが出てしまうからです．</p>
<pre><code>$ gcc -g movq-6.s
/usr/bin/ld: /tmp/ccqHsPbg.o: relocation R_X86_64_32S against symbol `main' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld: failed to set dynamic section sizes: bad value
collect2: error: ld returned 1 exit status
</code></pre>
<p><code>-no-pie</code>は「位置独立実行可能ファイル
(<a href="./3-binary.html#ASLR-PIE">PIE</a>，<a href="./3-binary.html#PIE">PIE</a>)を生成しない」
というオプションです．
最近のLinuxの<code>gcc</code>では，PIEがデフォルトで有効になっている事が多いです．
<a href="./3-binary.html#PIC">PIC</a>(位置独立コード)やPIEは「再配置(アドレス調整)無しに
どのメモリ番地に配置しても，そのまま実行可能」という機械語命令列です．
そのため，PIEやPICのメモリ参照では<strong>絶対アドレス</strong>(absolute address)が使えません．</p>
<p><code>-no-pie</code>オプションが無いと，
アセンブラは<code>movq $main, %rax</code>という命令中の<code>main</code>というラベルを
「絶対アドレスだ」と解釈してエラーにするようです．</p>
<details>
<summary>
絶対アドレス，相対アドレスとは
</summary>
<div id="絶対アドレス・相対アドレス">
<img src="figs/absolute-addr.svg" height="250px" id="fig:absolute-addr">
<p><strong>絶対アドレス</strong>とは「メモリの先頭0番地から何バイト目か」で示すアドレスです．
上図で青色のメモリ位置の絶対アドレスは<code>0x1000</code>番地となります．
一方，<strong>相対アドレス</strong>(relative address)は(0番地ではなく)別の何かを起点とした差分のアドレスです．
x86-64では<code>%rip</code>レジスタ(プログラムカウンタ)を起点とすることが多いです．
上図では青色のメモリ位置の相対アドレスは
<code>%rip</code>を起点とすると，<code>-0x500</code>番地となります(<code>0x1000 - 0x1500 = -0x500</code>)．</p>
<p>また，相対アドレスに起点のアドレスを足すと絶対アドレスになります
(<code>-0x500 + 0x1500 = 0x1000</code>)．</p>
</div>
</details>
<p>なぜ PICやPIEで絶対アドレスが使えないかと言うと，
機械語命令列を何番地に置くかで，絶対アドレスが変化してしまうからです．</p>
<details>
<summary>
もうちょっと具体的に
</summary>
<p>例えば，<code>movq $main, %rax</code>という命令は
<code>main</code>関数のアドレスを<code>%rax</code>レジスタに格納するわけですが，
このアドレスが絶対アドレスの場合，出力される機械語命令に
絶対アドレスが埋め込まれてしまいます．</p>
<pre><code>$ gcc -no-pie -g movq-6.s
$ objdump -d ./a.out
(一部略)
000000000040110a &lt;main&gt;:
  40110a:  48 c7 c0 ❷ 0a 11 40 00    mov ❶$0x40110a,%rax
  401111:  c3                        ret    
</code></pre>
<p>上の逆アセンブル結果を見ると，確かに<code>main</code>関数のアドレス❶ <code>0x40110a</code>が
機械語命令列に❷埋め込まれています．
(x86-64は<a href="./3-binary.html#LSB">リトルエンディアン</a>なので，バイトの並びが逆順に見えることに注意)．</p>
<p>相対アドレスだと大丈夫なことも見てみます．
<a href="./asm/leaq-1.s"><code>leaq-1.s</code></a>中の
<code>leaq main(%rip), %rax</code>は，
「<code>%rip</code>を起点とした<code>main</code>の相対アドレスと，
<code>%rip</code>の値との和を<code>%rax</code>レジスタに格納する」という命令です．
(<code>lea</code> は load effective address の略です．effective addressは日本語では<strong>実効アドレス</strong>です)．</p>
<pre><code class="language-x86asmatt"># asm/leaq-1.s
    .text
    .globl main
    .type main, @function
main:
    leaq main(%rip), %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g leaq-1.s
$ objdump -d ./a.out
(一部略)
0000000000001129 &lt;main&gt;:
 ❶ 1129:  48 8d 05 ❸ f9 ff ff ff    lea    ❷ -0x7(%rip),%rax  # 1129 &lt;main&gt;
 ❹ 1130:  c3                      ret    
</code></pre>
<p>上のように逆アセンブルすると以下が分かります．</p>
<ul>
<li><code>main</code>関数の(ファイル<code>a.out</code>中での)アドレスは❶ <code>0x1129</code>番地</li>
<li><code>leaq main(%rip), %rax</code>の <code>%rip</code>の値は❸ <code>0x1130</code>番地
(プログラムカウンタ <code>%rip</code>は「次に実行する機械語命令のアドレス」を保持しています)．</li>
<li>機械語命令に埋め込まれているアドレスは相対アドレスで，
❶ <code>0x1129</code> - ❸ <code>0x1130</code> = ❷ <code>-0x7</code> = ❸ <code>0xFFFFFFF9</code> です．</li>
</ul>
<p>❶ <code>0x1129</code> や ❹ <code>0x1130</code> のアドレスは，
<code>main</code>関数がどのアドレスに配置されるかで変化します．
しかし，この相対アドレス❷ <code>-0x7</code> は
<code>main</code>関数がどのアドレスに配置されても変化しないので，
この機械語命令はPICやPIEとして使えるわけです．</p>
<p>❷ <code>-0x7</code> が ❸ <code>0xFFFFFFF9</code> として埋め込まれているのは，
<a href="xxx">2の補数表現</a>だからですね</p>
<p>なお，相対アドレスが固定にならない場合(例えば，<code>printf</code>関数のアドレス)もあります．
その場合は<a href="./3-binary.html#GOT-PLT">GOTやPLT</a>を使います．
<code>printf</code>関数のアドレスを機械語命令列(<code>.text</code>セクション)に埋め込むのではなく，
別の書込み可能なセクション(例：<code>got</code>セクション)に格納し，
そのアドレスを使って<strong>間接コール</strong>(indirect call)するのです．</p>
</details>
</details>
<details>
<summary>
-staticオプションとは
</summary>
<p><code>-static</code>オプションは(動的リンクではなく)
<a href="./3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
せよという，<code>gcc</code>への指示になります．</p>
</details>
<ul>
<li>
<p><code>main</code>関数の先頭にブレークポイントを設定します．
<code>main</code>関数の先頭アドレスが❷ <code>0x40110a</code>と分かります．</p>
</li>
<li>
<p>❸ <code>movq $main, %rax</code>の実行直前で止まっているので，
❹ <code>si</code>で1命令実行を進めます．</p>
</li>
<li>
<p>❺ <code>%rax</code>レジスタ中に<code>main</code>関数のアドレス❷ <code>0x40110a</code>が入っていました．</p>
</li>
</ul>
<h3 id="addr-mode-reg"><a class="header" href="#addr-mode-reg">アドレッシングモード：レジスタ参照</a></h3>
<pre><code class="language-x86asmatt"># asm/movq-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    movq %rax, %rbx
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-1.s"><code>movq-1.s</code></a>中の<code>movq %rax, %rbx</code>は
「<code>%rax</code>レジスタ中の値を<code>%rbx</code>に格納する」という意味です．</p>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-1.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-1.s:6
6	    ❶ movq $999, %rax
(gdb) si
7	    ❷ movq %rax, %rbx
(gdb) si
main () at movq-1.s:8
8	    ret
(gdb) p $rax
$1 = ❸ 999
(gdb) p $rbx
$2 = ❹ 999
</code></pre>
<p><code>gdb</code>上での実行で，❶ 定数<code>999</code>が<code>%rax</code>に格納され，
❷ <code>%rax</code>中の<code>999</code>がさらに<code>%rbx</code>に格納されたことを
❸❹確認できました．</p>
<h3 id="addr-mode-direct"><a class="header" href="#addr-mode-direct">アドレッシングモード：直接メモリ参照</a></h3>
<p><strong>直接メモリ参照</strong>はアクセスするメモリ番地が定数となるメモリ参照です．
以下の例ではラベル<code>x</code>を使ってメモリ参照していますが，
これは直接メモリ参照になります．
アセンブル時に(つまり実行する前に)アドレスが具体的に(以下では<code>0x404028</code>番地)と決まるからです．</p>
<pre><code class="language-x86asmatt"># asm/movq-7.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-7.s
$ gdb ./a.out -x movq-7.txt
Breakpoint 1, main () at movq-7.s:10
10	    ret
9	    movq x, %rax
$1 = ❶ 999
# %raxの値が999なら成功
</code></pre>
<img src="figs/label2.svg" height="250px" id="fig:label2">
<p>まず<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の以下の3行で，</p>
<pre><code class="language-x86asmatt">    .data
x:
    .quad 999 
</code></pre>
<p>「<code>.data</code>セクションにサイズが8バイトのデータとして値<code>999を配置せよ」 「そのデータの先頭アドレスをラベル</code>x<code>として定義せよ」を意味しています． ですので，実行時には上図のように 「</code>.data<code>セクションのある場所(上図では</code>0x404028<code>番地)に値</code>999<code>が入っていて， ラベル</code>x<code>の値は</code>0x404028`」となっています．</p>
<p>ですので，<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の<code>movq x, %rax</code>は
「ラベル<code>x</code>が表すアドレス(上図では<code>0x404028</code>番地)のメモリの中身(上図では<code>999</code>)
を<code>%rax</code>レジスタにコピーせよ」を意味します．</p>
<p>実行すると<code>movq x, %rax</code>の実行で，<code>x</code>中の<code>999</code>が<code>%rax</code>レジスタに
コピーされたことを確認できました❶．</p>
<p>ここで$マークの有無，つまり<code>x</code>と<code>$x</code>の違いに注意しましょう
(<a href="#label2">上図</a>も参照)．</p>
<pre><code class="language-x86asmatt">movq x, %rax    # x はメモリの中身を表す
movq $x, %rax   # $x はアドレスを表す
</code></pre>
<p>以下のように<code>movq $x, %rax</code>を実行すると，
<code>%rax</code>レジスタにはアドレス(ここでは<code>0x404028</code>番地)が
入っていることを確認できました❷．</p>
<details>
<summary>
-8(%rbp)の-8には(定数なのに)$マークが付かない
</summary>
<p><a href="#addr-mode-indirect">以下</a>でも説明しますが，
例えば<code>-8(%rbp)</code>とオペランドに書いた時，<code>-8</code>は($マークが無いのに)
定数として扱われます．
そして，<code>-8(%rbp)</code>は，<code>%rbp - 8</code>の計算結果をアドレスとするメモリの中身を意味します．　
ちなみにこの<code>-8</code>のことは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>では<strong>変位</strong> (displacement)と呼ばれています．
つまり「変位は定数だけど$マークはつきません」．</p>
</details>
<pre><code class="language-x86asmatt"># asm/movq-8.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq $x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-8.s
$ gdb ./a.out -x movq-8.txt
Breakpoint 1, main () at movq-8.s:10
10	    ret
9	    movq $x, %rax
$1 = 0x404028 ❷
nm ./a.out | egrep 'd x'
0000000000404028 d x
# %raxの値と nmコマンドによるxのアドレスが一致すれば成功
</code></pre>
<p>ちなみに，<code>x</code>のアドレスが<code>0x404028</code>になると分かっていれば，</p>
<pre><code class="language-x86asmatt">movq x, %rax          # これと
movq 0x404028, %rax   # これは同じ意味
</code></pre>
<p>上の2行は全く同じ意味(<code>0x404028</code>番地のメモリの中身)になります．
しかし，何番地になるか事前に分からないのが普通なので，
通常はラベル(ここでは<code>x</code>)を使います．</p>
<h3 id="addr-mode-indirect"><a class="header" href="#addr-mode-indirect">アドレッシングモード：間接メモリ参照</a></h3>
<p><strong>間接メモリ参照</strong>はアクセスするメモリ番地が変数となるメモリ参照です．
アセンブリ言語では変数という概念は無いので，
正確には「実行時に決まるレジスタの値を使って，
参照先のメモリアドレスを計算して決める」という参照方式です．
以下では3つの例が出てきます(<a href="#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>でより複雑な間接メモリ参照を説明します)．</p>
<div class="table-wrapper"><table><thead><tr><th>間接メモリ参照</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>(%rsp)</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>8(%rsp)</code></td><td><code>%rsp + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>%rip + foo</code></td></tr>
</tbody></table>
</div><br/>
<img src="figs/addr-mode-indirect.svg" height="250px" id="fig:addr-mode-indirect">
<p>以下の<a href="./asm/movq-9.s">movq-9.s</a>を<code>pushq $777</code>まで実行すると，
メモリの状態は上図のようになっています．
(<code>%rsp</code>が指す<code>777</code>のひとつ下のアドレスが<code>%rsp+8</code>なのは，
<code>pushq $777</code>命令が「サイズが8バイトの値<code>777</code>をスタックにプッシュしたから」です)．</p>
<pre><code class="language-x86asmatt"># asm/movq-9.s
    .data
foo:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    pushq $888
    pushq $777
    movq (%rsp), %rax
    movq 8(%rsp), %rbx
    movq foo(%rip), %rcx
    ret
    .size main, .-main
</code></pre>
<ul>
<li><code>(%rsp)</code> は「アドレスが <code>%rsp</code>の値のメモリ」なので値<code>777</code>が入っている部分を参照します</li>
<li><code>8(%rsp)</code> は「アドレスが <code>%rsp + 8</code>の値のメモリ」なので値<code>888</code>が入っている部分を参照します</li>
<li><code>foo(%rip)</code> はちょっと特殊です．この形式は <strong><code>%rip</code>相対アドレッシング</strong> といいます．
この形式の時，ラベル<code>foo</code>の値はプログラムカウンタ<code>%rip</code>中のアドレスを起点とした
<a href="#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">相対アドレス</a>
になります．ですので，<code>%rip + foo</code>は<code>foo</code>の
<a href="#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">絶対アドレス</a>
になるので，
<code>foo(%rip)</code>はラベル<code>foo</code>のメモリ部分，つまり<code>999</code>が入っている部分になります．</li>
</ul>
<details>
<summary>
gdbでの実行結果
</summary>
<pre><code>$ gcc -g movq-9.s
$ gdb ./a.out -x movq-9.txt
Breakpoint 1, main () at movq-9.s:14
14	    ret
11	    movq (%rsp), %rax
12	    movq 8(%rsp), %rbx
13	    movq foo(%rip), %rcx
$1 = 777
$2 = 888
$3 = 999
# 777, 888, 999なら成功
</code></pre>
</details>
<h3 id="メモリ参照"><a class="header" href="#メモリ参照">メモリ参照</a></h3>
<p>RIP相対とラベル</p>
<p>セグメントレジスタを使った参照(スレッドローカルストレージ)</p>
<h2 id="x86-64機械語命令-転送など"><a class="header" href="#x86-64機械語命令-転送など">x86-64機械語命令 (転送など)</a></h2>
<h2 id="x86-64機械語命令-算術論理演算"><a class="header" href="#x86-64機械語命令-算術論理演算">x86-64機械語命令 (算術論理演算)</a></h2>
<h3 id="四則演算"><a class="header" href="#四則演算">四則演算</a></h3>
<h3 id="インクリメントデクリメント符号反転"><a class="header" href="#インクリメントデクリメント符号反転">インクリメント，デクリメント，符号反転</a></h3>
<h3 id="ビット論理演算"><a class="header" href="#ビット論理演算">ビット論理演算</a></h3>
<h3 id="シフト演算"><a class="header" href="#シフト演算">シフト演算</a></h3>
<h3 id="ローテート演算"><a class="header" href="#ローテート演算">ローテート演算</a></h3>
<h2 id="x86-64機械語命令-比較とジャンプ"><a class="header" href="#x86-64機械語命令-比較とジャンプ">x86-64機械語命令 (比較とジャンプ)</a></h2>
<h3 id="比較"><a class="header" href="#比較">比較</a></h3>
<h3 id="無条件ジャンプ"><a class="header" href="#無条件ジャンプ">無条件ジャンプ</a></h3>
<h3 id="条件付きジャンプ"><a class="header" href="#条件付きジャンプ">条件付きジャンプ</a></h3>
<h4 id="status-reg"><a class="header" href="#status-reg">ステータスレジスタ</a></h4>
<h3 id="その他の命令"><a class="header" href="#その他の命令">その他の命令</a></h3>
<p>endbr64, bnd, int3 など
rdtsc</p>
<h2 id="x86-64機械語命令-関数呼び出しとリターン"><a class="header" href="#x86-64機械語命令-関数呼び出しとリターン">x86-64機械語命令 (関数呼び出しとリターン)</a></h2>
<h3 id="call"><a class="header" href="#call"><code>call</code></a></h3>
<h3 id="caller-callee-save-regs"><a class="header" href="#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></h3>
<h3 id="arg-reg"><a class="header" href="#arg-reg">引数</a></h3>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="4-encoding.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="8-inline.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="4-encoding.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="8-inline.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
