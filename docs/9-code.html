<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GCCが生成したアセンブリコードを読む - Linuxで学ぶx86-64アセンブリ言語</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

        <!-- MathJax -->
        <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要 90%</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル 90%</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="5-arch.html"><strong aria-hidden="true">4.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど 90%</a></li><li class="chapter-item "><a href="4-data.html"><strong aria-hidden="true">5.</strong> データ表現，2進数，2の補数 90%</a></li><li class="chapter-item "><a href="6-inst.html"><strong aria-hidden="true">6.</strong> x86-64機械語命令 90%</a></li><li class="chapter-item "><a href="7-asm.html"><strong aria-hidden="true">7.</strong> アセンブラ命令 90%</a></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ 90%</a></li><li class="chapter-item expanded "><a href="9-code.html" class="active"><strong aria-hidden="true">9.</strong> GCCが生成したアセンブリコードを読む</a></li><li class="chapter-item "><a href="10-gdb.html"><strong aria-hidden="true">10.</strong> デバッガgdbの使い方 90%</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧 80%</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集 10%</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 9; }
</style>
<h1 id="gccが生成したアセンブリコードを読む"><a class="header" href="#gccが生成したアセンブリコードを読む">GCCが生成したアセンブリコードを読む</a></h1>
<p>この章では単純なCのプログラムをGCCがどのようなアセンブリコードに変換するかを見ていきます．
これより以前の章で学んだ知識を使えば，C言語のコードが意外に簡単にアセンブリコードに変換できることが分かると思います．
(実際にコンパイラの授業で構文解析の手法を学び，
最適化器を実装しなければ，コンパイラは学部生でも十分簡単に作れます)．</p>
<h2 id="制御文"><a class="header" href="#制御文">制御文</a></h2>
<h3 id="if文"><a class="header" href="#if文">if文</a></h3>
<pre><code>// if.c
int x = 111;
int main ()
{
    if (x &gt; 100) {
        x++;
    }
}
</code></pre>
<img src="figs/if.svg" height="250px" id="fig:if">
<ul>
<li>ifの条件式<code>x &gt; 100</code>は反転して「<code>x &lt;= 100</code>なら，then部分をスキップして，thenの直後(ラベル<code>.L2</code>)にジャンプする」というコードを出力しています．
(反転する必然性はありません．<code>x &gt; 0</code>を評価してその結果が<code>0</code>に等しければ，<code>.L2</code>にジャンプするコードでも(実行速度を除けば)同じ動作になります)</li>
<li>then部分では「<code>x</code>に1を加える」コードを出力しています．</li>
</ul>
<details>
<summary>
なぜGCCはinc命令を使わないの?
</summary>
<p><code>incl x(%rip)</code>なら1命令で済みますよね．
もし<code>-O</code>や<code>-O2</code>などの最適化オプションを付ければ，
GCCは<code>inc</code>を使うかも知れませんが，
そうしてしまうと，(最適化が賢すぎて)元のif文の構造がガラリと変わってしまう可能性があるため避けています．
この章では全て「最適化オプションを付けていないので，GCCは無駄なコードを出力することがある」と考えて下さい．</p>
</details>
<h3 id="if-else文"><a class="header" href="#if-else文">if-else文</a></h3>
<pre><code>// if-else.c
int x = 111;
int main ()
{
    if (x &gt; 100) {
        x++;
    } else {
        x--;
    }
}
</code></pre>
<img src="figs/if-else.svg" height="330px" id="fig:if-else">
<ul>
<li>ifの条件式<code>x &gt; 100</code>は反転して「<code>x &lt;= 100</code>なら，then部分をスキップして，thenの直後(ラベル<code>.L2</code>)にジャンプする」というコードを出力しています．</li>
<li>then部分では「<code>x</code>に1を加える．次にelse部分をスキップするために<code>.L3</code>にジャンプする」コードを出力しています．</li>
<li>else部分では「<code>x</code>から1減らす」コードを出力しています．</li>
</ul>
<h3 id="while文"><a class="header" href="#while文">while文</a></h3>
<pre><code>// while.c
int x = 111;
int main ()
{
    while (x &gt; 100) {
        x--;
    }
}
</code></pre>
<img src="figs/while.svg" height="330px" id="fig:while">
<ul>
<li>while条件判定はwhileボディのコードの後に置かれています(これは必然ではありません)．
最初にwhileループに入る時，<code>.L2</code>にジャンプします．</li>
<li>whileの条件式<code>x &gt; 100</code>が成り立つ間は，<code>.L3</code>に繰り返しジャンプします．</li>
<li>「whileボディ」実行後に必ず「while条件判定」が必要になるので，これでうまくいきます．</li>
</ul>
<h3 id="for文"><a class="header" href="#for文">for文</a></h3>
<pre><code>// for.c
int x = 111;
int main ()
{
    for (int i = 0; i &lt; 10; i++) {
        x--;
    }
}
</code></pre>
<img src="figs/for.svg" height="330px" id="fig:for">
<ul>
<li>ほぼwhile文と同じです．違いは「for初期化」 (<code>int i = 0</code>)があることと，
「forボディ」の直後に「for更新」(<code>i++</code>)があることだけです．</li>
<li>GCCが条件判定のコードを，
<code>i &lt; 10</code> (<code>cmpl $10, -4(%rbp); jl .L3</code>)ではなく，
<code>i &lt;= 9</code> (<code>compl $9, -4(%rbp); jl .l3</code>)としています．
どちらも同じなのですが，なぜこうしたのか，GCCの気持ちは分かりません．</li>
</ul>
<h3 id="switch文-単純比較"><a class="header" href="#switch文-単純比較">switch文 (単純比較)</a></h3>
<pre><code>// switch.c
int x = 111;
int main ()
{
    switch (x) {
    case 1:
        x++;
        break;
    case 111:
        x--;
        break;
    default:
        x = 0;
        break;
    }
}
</code></pre>
<img src="figs/switch.svg" height="500px" id="fig:switch">
<ul>
<li>ジャンプテーブルを使わない，単純に比較するコード生成です．
例えば，<code>case 1:</code>は，<code>if (x == 1)</code>と同様のコード生成になっています．</li>
<li>この方法ではcaseが\(n\)個あると，\(n\)回比較する必要があるので，
\(O(n)\)の時間がかかってしまいます．</li>
</ul>
<h3 id="switch-jump-table"><a class="header" href="#switch-jump-table">switch文 (ジャンプテーブル)</a></h3>
<pre><code>// switch2.c
int x = 111;
int main ()
{
    switch (x) {
    case 1:  x++;   break;
    case 2:  x--;   break;
    case 3:  x = 3; break;
    case 4:  x = 4; break;
    case 5:  x = 5; break;
    default: x = 0; break;
    }
}
</code></pre>
<pre><code>// switch3.c
int x = 111;
int main ()
{
    void *jump_table [] = {&amp;&amp;L2, &amp;&amp;L8, &amp;&amp;L7, &amp;&amp;L6, &amp;&amp;L5, &amp;&amp;L3} ; // ❶
    goto *jump_table [x]; // ❷

L8: // case 1:
    x++;   goto L9;
L7: // case 2:
    x--;   goto L9;
L6: // case 3:
    x = 3; goto L9;
L5: // case 4:
    x = 4; goto L9;
L3: // case 5:
    x = 5; goto L9;
L2: // default:
    x = 0; goto L9;
L9:
}
</code></pre>
<img src="figs/switch2.svg" height="1000px" id="fig:switch2">
<ul>
<li><code>switch2.c</code>をジャンプテーブルを使って書き換えたのが<code>switch3.c</code>です．
❶と❷の部分はGCC拡張機能で「ラベルの値を配列変数に格納し❶」，
「<code>goto</code>で格納したラベルにジャンプ❷」することができます．</li>
<li>変数<code>x</code>の値をジャンプテーブル(配列)のインデックスとして，
ジャンプ先アドレスを取得し，間接ジャンプしています．
<ul>
<li><code>movl %eax, %eax</code>はレジスタ<code>%rax</code>の上位32ビットをゼロクリアしています．</li>
<li><code>notrack</code>はIntel CET (control-flow enforcement technology)による拡張命令です．
<code>notrack</code>付きの場合，間接ジャンプ先が<code>endbr64</code>ではなくても例外は発生しなくなります．</li>
</ul>
</li>
<li>ジャンプテーブルを使うと，\(O(1)\)でcase文を選択できます．
ただし，ジャンプテーブルが使えるのはcaseが指定する範囲がある程度，
密な場合に限ります(巨大な配列を使えば，疎な場合でも扱えますが…)．</li>
</ul>
<h2 id="定数"><a class="header" href="#定数">定数</a></h2>
<h3 id="整数定数"><a class="header" href="#整数定数">整数定数</a></h3>
<pre><code>// const-int.c
int main ()
{
    return 999;
}
</code></pre>
<pre><code class="language-x86asmatt">main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❶ $999, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>整数定数 <code>999</code> は❶即値 (<code>$999</code>)としてコード生成されています</li>
</ul>
<h3 id="文字定数"><a class="header" href="#文字定数">文字定数</a></h3>
<pre><code>// const-char.c
int main ()
{
    return 'A';
}
</code></pre>
<pre><code class="language-x86asmatt">main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❶ $65, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>文字定数は❶即値 (<code>$65</code>, 65は文字<code>A</code>のASCIIコード)としてコード生成されています</li>
</ul>
<h3 id="文字列定数"><a class="header" href="#文字列定数">文字列定数</a></h3>
<pre><code>// const-string.c
#include &lt;stdio.h&gt;
int main ()
{
    puts (&quot;hello\n&quot;);
}
</code></pre>
<pre><code class="language-x86asmatt">❶  .section  .rodata
❷ .LC0:
❸  .string &quot;hello\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    leaq ❹ .LC0(%rip), %rax
    movq    %rax, %rdi
    call    puts@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>文字列定数 <code>&quot;hello\n&quot;</code>の実体は❶<code>.rodata</code>セクションに置かれます．
❸<code>.string</code>命令で<code>&quot;hello\n&quot;</code>のバイナリ値を配置し，
その先頭アドレスを❷ラベル<code>.LC0:</code>と定義しています．</li>
<li>式中の<code>&quot;hello\n&quot;</code>の値は「その文字列の先頭アドレス」ですので，
❹ <code>.LC0(%rip)</code>と参照しています(ここでは文字列の先頭アドレスが<code>%rax</code>に格納されます)</li>
</ul>
<h3 id="配列"><a class="header" href="#配列">配列</a></h3>
<pre><code>// array3.c
int a [] = {111, 222, 333};
int main ()
{
    return a [2];
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  a
    .data
    .align 8
    .type   a, @object
    .size   a, 12
❶ a:
❷  .long   111
❷  .long   222
❷  .long   333

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❸ 8+a(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>配列はメモリ上で連続する領域に配置されます．
この場合は❷ <code>.long</code>命令で4バイトずつ，<code>111</code>, <code>222</code>, <code>333</code>の2進数を隙間なく配置しています．個人的には <code>.long 111, 222, 333</code>と１行で書いてくれる方が嬉しいのですが…
(なお，配列とは異なり，構造体の場合はメンバー間や最後にパディング(隙間)が入ることがあります)</li>
<li>配列の先頭アドレスを❶ラベル<code>a:</code>と定義しています．</li>
<li><code>a[2]</code>の参照は❸ <code>8+a(%rip)</code>という<code>%rip</code>相対のメモリ参照になっています．
指定したインデックスが定数(<code>2</code>)だったため，変位が <code>8+a</code>になっています．
(<code>a[i]</code>などとインデックスが変数の場合はアセンブラの足し算は使えません)．</li>
</ul>
<h3 id="構造体"><a class="header" href="#構造体">構造体</a></h3>
<pre><code>// struct5.c
struct foo {
    char x1;
    int x2;
};
struct foo f = {10, 20};
int main ()
{
    return f.x2;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8
    .type   f, @object
    .size   f, 8
❶ f:
❷  .byte   10 # x1
❸  .zero   3  # 3バイトのパディング
❹  .long   20 # x2

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❺ 4+f(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>構造体<code>foo</code>がメモリ上に配置される際，アラインメント制約を満たすために
<a href="./4-data.html#alignment-padding">パディング</a>が入ることがあります．</li>
<li>ここでは，メンバー❷<code>x1</code>と❹<code>x2</code>の間に❸3バイトのパディングが入っています．</li>
<li>構造体メンバーの参照 <code>foo.x2</code>は
❺<code>4+f(%rip)</code>という<code>%rip</code>相対のメモリ参照になっています．</li>
</ul>
<h3 id="共用体"><a class="header" href="#共用体">共用体</a></h3>
<pre><code>// union2.c
#include &lt;stdio.h&gt;
union foo {
    char x1 [5];
    int  x2;
};
union foo f = {.x1[0] = 'a'};

int main ()
{
    f.x2 = 999;
    return f.x2;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8
    .type   f, @object
❶  .size   f, 8
❷ f:
❸  .byte   97
❹  .zero   4
❺  .zero   3

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❻ f(%rip)
    movl ❼ f(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>共用体は以下を除き，構造体と一緒です
<ul>
<li>同時に1つのメンバーにしか代入できない</li>
<li>全てのメンバーはオフセット0でアクセスする</li>
<li>共用体のサイズは最大サイズを持つメンバ＋パディングのサイズになる
<ul>
<li>上の例では最大サイズのメンバ <code>char x1 [5]</code>に3バイトのパディングがついて，
共用体 <code>f</code>のサイズは8バイトになってます</li>
</ul>
</li>
</ul>
</li>
<li>上の例では<strong>指示付き初期化子</strong>(designated initializer)の記法
(<code>union foo f = {.x1[0] = 'a'};</code>)を使って，メンバ<code>x1</code>を初期化しています．
❸<code>'a'</code>の値が<code>.byte</code>で配置され，残りの7バイトは❹❺<code>0</code>で初期化されています．</li>
<li>共用体<code>f</code>への代入や参照はメモリ参照❻❼<code>f(%rip)</code>でアクセスされています．</li>
</ul>
<h2 id="変数"><a class="header" href="#変数">変数</a></h2>
<h3 id="初期化済みの静的変数"><a class="header" href="#初期化済みの静的変数">初期化済みの静的変数</a></h3>
<pre><code>// var-init-static.c
int x = 999;
int main ()
{
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
❶  .data
    .align 4
    .type   x, @object
    .size   x, 4
❷ x:
❸  .long   999

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❹ x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>初期化済みの静的変数の実体は❶<code>.data</code>セクションに配置されます．
初期値 (<code>999</code>)を(この場合は<code>int</code>型なので)<code>.long</code>命令で
<code>999</code>のバイナリ値を配置し，その先頭アドレスをラベル<code>x:</code>と定義しています．</li>
<li>変数<code>x</code>の参照は❹<code>x(%rip)</code>という<code>%rip</code>相対のメモリ参照です．</li>
</ul>
<h3 id="未初期化の静的変数"><a class="header" href="#未初期化の静的変数">未初期化の静的変数</a></h3>
<pre><code>// var-uninit-static.c
int x;
int main ()
{
    x = 999;
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
❶  .bss
    .align 4
    .type   x, @object
    .size   x, 4
❷ x:
❸  .zero   4

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❹ x(%rip)
    movl    ❺ x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>未初期化の静的変数の実体は❶ <code>.bss</code>セクションに配置されます．
<code>.bss</code>セクション中の変数は❸ゼロで初期化されます．
初期化した4バイトの先頭アドレスをラベル❷ <code>x:</code>と定義しています．
<ul>
<li>ただし<code>.bss</code>セクションが実際にゼロで初期化されるのは実行直前です</li>
</ul>
</li>
<li>変数<code>x</code>の参照は，メモリ参照❹❺ <code>x(%rip)</code>でアクセスされています．</li>
</ul>
<h3 id="自動変数-static無しの局所変数"><a class="header" href="#自動変数-static無しの局所変数">自動変数 (<code>static</code>無しの局所変数)</a></h3>
<pre><code>// var-auto.c
int main ()
{
    int x;
    x = 999;
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❶ -4(%rbp)
    movl ❷ -4(%rbp), %eax
    popq    %rbp
    ret
</code></pre>
<img src="figs/stack-layout3.svg" height="300px" id="fig:stack-layout3">
<ul>
<li>自動変数は実行時にスタック上にその実体が配置されます．
上の例では変数<code>x</code>は❶❷<code>-4(%rbp)</code>から始まる4バイトに割り当てられ，
アクセスされています．
(この変数<code>x</code>は<a href="./2-asm-intro.html#redzone">レッドゾーン</a>に配置されています)</li>
</ul>
<h3 id="実引数"><a class="header" href="#実引数">実引数</a></h3>
<pre><code>// arg.c
void foo (long a1, long a2, long a3, long a4, long a5, long a6, long a7);
int main ()
{
    foo (10, 20, 30, 40, 50, 60, 70);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❹  subq    $8, %rsp    # パディング
❷  pushq   $70         # 第7引数
❶  movl    $60, %r9d   # 第6引数
❶  movl    $50, %r8d   # 第5引数
❶  movl    $40, %ecx   # 第4引数
❶  movl    $30, %edx   # 第3引数
❶  movl    $20, %esi   # 第2引数
❶  movl    $10, %edi   # 第1引数
❸  call    foo@PLT
❺  addq    $16, %rsp   # 第7引数とパディングを捨てる
    movl    $0, %eax
    leave
    ret
</code></pre>
<img src="figs/arg.svg" height="200px" id="fig:arg">
<ul>
<li>第6引数までは❶<a href="./6-inst.html#arg-reg">レジスタ渡し</a>になります．
第7引数以降は❷スタックに積んでから関数を呼び出します．</li>
<li><a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>
により
❸<code>call</code>命令実行時には<code>%rsp</code>の値は16の倍数である必要があります．
そのため，❹で8バイトのパディングをスタックに置いています．</li>
<li>関数からリターン後は❷でスタックに積んだ引数と❹パディングを❸スタック上から取り除きます．</li>
</ul>
<h3 id="仮引数"><a class="header" href="#仮引数">仮引数</a></h3>
<pre><code>// parameter.c
#include &lt;stdio.h&gt;
void
foo (long a1, long a2, long a3, long a4, long a5, long a6, long a7)
{
    printf (&quot;%ld\n&quot;, a1 + a7);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .section .rodata
.LC0:
    .string &quot;%ld\n&quot;
    .text
    .globl  foo
    .type   foo, @function
foo:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $48, %rsp
    movq ❶ %rdi, -8(%rbp)   # 第1引数
    movq ❶ %rsi, -16(%rbp)  # 第2引数
    movq ❶ %rdx, -24(%rbp)  # 第3引数
    movq ❶ %rcx, -32(%rbp)  # 第4引数
    movq ❶ %r8, -40(%rbp)   # 第5引数
    movq ❶ %r9, -48(%rbp)   # 第6引数
    movq    -8(%rbp), %rdx  
    movq ❷ 16(%rbp), %rax   # 第7引数
    addq    %rdx, %rax
    movq    %rax, %rsi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    nop
    leave
    ret
</code></pre>
<img src="figs/parameter.svg" height="400px" id="fig:parameter">
<ul>
<li>GCCはレジスタで受け取った第1〜第6引数をスタック上に❶置いています．
一方，第7引数はスタック渡しで，その場所は❻<code>16(%rbp)</code>でした．</li>
</ul>
<h2 id="式-expression"><a class="header" href="#式-expression">式 (expression)</a></h2>
<h3 id="単項演算子-unary-operator"><a class="header" href="#単項演算子-unary-operator">単項演算子 (unary operator)</a></h3>
<pre><code>// unary.c
int x = 111;
int main ()
{
    return -x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111
    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  negl    %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>単項演算は対応する命令，ここでは❶ <code>negl</code>を使うだけです．</li>
</ul>
<h3 id="二項演算子単純な加算"><a class="header" href="#二項演算子単純な加算">二項演算子(単純な加算)</a></h3>
<pre><code>// binop-add.c
int x = 111;
int main ()
{
    return x + 89;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  addl    $89, %eax
    popq    %rbp
        ret
</code></pre>
<ul>
<li>基本的に二項演算子も対応する命令 (ここでは❷<code>addl</code>)を使うだけです．</li>
</ul>
<h3 id="二項演算子割り算"><a class="header" href="#二項演算子割り算">二項演算子(割り算)</a></h3>
<pre><code>// binop-div.c
int x = 111, y = 9;
int main ()
{
    return x / y;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .globl  y
    .align 4
    .type   y, @object
    .size   y, 4
y:
    .long   9

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
    movl    y(%rip), %ecx
❷  cltd
❶  idivl   %ecx
    popq    %rbp
    ret
</code></pre>
<ul>
<li>割り算はちょっと注意が必要です．</li>
<li>例えば，32ビット符号ありの割り算を❶<code>idivl</code>命令で行う場合，
<code>%edx:%eax</code>を第1オペランドで割った商が<code>%eax</code> に入ります．</li>
<li>このため，<code>idivl</code>を使う前に❷<code>cltd</code>命令等を使って，
<code>%eax</code>を符号拡張した値を<code>%edx</code>に設定しておく必要があります
(<code>%edx</code>の値の設定を忘れるて<code>%idivl</code>を実行すると，割り算の結果がおかしくなります)</li>
</ul>
<h3 id="二項演算ポインタ演算"><a class="header" href="#二項演算ポインタ演算">二項演算(ポインタ演算)</a></h3>
<ul>
<li>復習: C言語のポインタ演算 (オペランドがポインタの場合の演算)は普通の加減算と意味が異なります．ポインタが指す先のサイズを使って計算する必要があります．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>演算</th><th>意味 (<code>int i, *p, *q</code>の場合)</th></tr></thead><tbody>
<tr><td><code>p + i</code></td><td><code>p + (i * sizeof (*p))</code></td></tr>
<tr><td><code>i + q</code></td><td><code>p + (i * sizeof (*p))</code></td></tr>
<tr><td><code>p + q</code></td><td>コンパイルエラー</td></tr>
<tr><td><code>p - i</code></td><td><code>p - (i * sizeof (*p))</code></td></tr>
<tr><td><code>i - q</code></td><td>コンパイルエラー</td></tr>
<tr><td><code>p - q</code></td><td><code>(p - q) / sizeof (*p)</code></td></tr>
</tbody></table>
</div>
<pre><code>// pointer-arith.c
#include &lt;stdio.h&gt;
int a [] = {0, 10, 20, 30};
int main ()
{
    printf (&quot;%p, %p\n&quot;, a, &amp;a[0]);     // 同じ
    printf (&quot;%p, %p, %p\n&quot;, &amp;a[2], a + 2, 2 + a); // 同じ
    printf (&quot;%p, %p\n&quot;, a, &amp;a[2] - 2); // 同じ
    printf (&quot;%ld\n&quot;, &amp;a[2] - &amp;a[0]);
    // printf (&quot;%p\n&quot;, &amp;a[2] + &amp;a[0]);    // コンパイルエラー
    // printf (&quot;%p\n&quot;, 2 - &amp;a[2]);        // コンパイルエラー
}
</code></pre>
<pre><code>$ gcc -g -no-pie pointer-arith.c
$ ./a.out
0x404030, 0x404030
0x404038, 0x404038, 0x404038
0x404030, 0x404030
2
</code></pre>
<img src="figs/array3.svg" height="400px" id="fig:array3">
<ul>
<li>復習: 式中で配列名(<code>a</code>)はその配列の先頭要素のアドレス(<code>&amp;a[0]</code>)を意味します．</li>
<li>復習: 式中で配列要素へのアクセス <code>a[i]</code>は，
<code>*(a+i)</code>や<code>*(i+a)</code>と書いても同じ意味です．</li>
<li>例えば，上の例で<code>a+2</code>は，配列の要素が<code>int</code>型で，<code>sizeof(int)</code>が4なので，
\(0x404030 + 2\times 4 = 0x404038\) という計算になります．
このため，<code>a+2</code>は<code>&amp;a[2]</code>と同じ値になります．</li>
</ul>
<pre><code>// pointer-arith2.c
int a [] = {0, 10, 20, 30};
int* foo ()
{
    return a + 2; // ❶
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  a
    .data
    .align 16
    .type   a, @object
    .size   a, 16
a:
    .long   0
    .long   10
    .long   20
    .long   30

    .text
    .globl  foo
    .type   foo, @function
foo:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    leaq ❷ 8+a(%rip), %rax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>上の例でCコード中の❶<code>a+2</code>は，アセンブリコード中では❷<code>8+a</code>になっています．
配列要素のサイズ4をかけ算して，\(a + 2\times 4\)という計算をするからです．</li>
</ul>
<h3 id="アドレス演算子と逆参照演算子"><a class="header" href="#アドレス演算子と逆参照演算子">アドレス演算子<code>&amp;</code>と逆参照演算子<code>*</code></a></h3>
<pre><code>// op-addr.c
int x = 111;
int *p;
int main ()
{
    p = &amp;x;
    return *p;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .globl  p
    .bss
    .align 8
    .type   p, @object
    .size   p, 8
p:
    .zero   8

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  leaq    x(%rip), %rax
    movq    %rax, p(%rip)
❷  movq    p(%rip), %rax
❸  movl    (%rax), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>アドレス演算子<code>&amp;x</code>には変数<code>x</code>のアドレスを計算すれば良いので，<code>leaq</code>命令を使います．
具体的には❶<code>leaq x(%rip), %rax</code>で，<code>x</code>の絶対アドレスを<code>%rax</code>に格納しています．</li>
<li>逆参照演算子<code>*p</code>にはメモリ参照を使います．
まず❷<code>movq p(%rip), %rax</code>で変数<code>p</code>の中身を<code>%rax</code>に格納し，
❸<code>movl (%rax), %eax</code>とすれば，メモリ参照<code>(%rax)</code>で<code>p</code>が指す先の値を得られます．</li>
</ul>
<h3 id="比較演算子"><a class="header" href="#比較演算子">比較演算子</a></h3>
<pre><code>// pred.c
int x = 111;
int main ()
{
    return x &gt; 100;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  cmpl    $100, %eax
❷  setg    %al
❸  movzbl  %al, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li><code>&gt;</code>などの比較演算子には<a href="./x86-list.html#set"><code>set␣</code></a>命令を使います．</li>
<li>例えば，<code>x &gt; 100</code>の場合，
<ul>
<li>❶<code>cmpl</code>命令で比較を行い，</li>
<li>❷<code>setg</code>を使って「より大きい」という条件が成り立っているかどうかを<code>%al</code>に格納し</li>
<li>❸<code>movzbl</code>を使って，必要なサイズ(ここでは4バイト)にゼロ拡張しています</li>
</ul>
</li>
</ul>
<h3 id="論理andと論理or左から右への評価"><a class="header" href="#論理andと論理or左から右への評価">論理ANDと論理OR，「左から右への評価」</a></h3>
<pre><code>// land.c
int x = 111;
int main ()
{
    return 50 &lt; x &amp;&amp; x &lt; 200;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
    cmpl    $50, %eax
❶  jle     .L2             # if x &lt;= 50 goto .L2
    movl    x(%rip), %eax
    cmpl    $199, %eax
❷  jg      .L2             # if x &gt; 199 goto .L2
    movl    $1, %eax        # 結果に1をセット
    jmp     .L4
.L2:
    movl    $0, %eax        # 結果に0をセット
.L4:
    popq    %rbp
    ret
</code></pre>
<ul>
<li>
<p>多くの二項演算子では「両方のオペランドを計算してから，その二項演算子 (例えば加算)を行う」というコードを生成すればOKです．</p>
</li>
<li>
<p>しかし，論理AND (<code>&amp;&amp;</code>) や論理OR (<code>||</code>)ではそのやり方ではNGです．
論理ANDと論理ORは<strong>左から右への評価</strong> (left-to-right evaluation)を
行う必要があるからです．</p>
<ul>
<li>
<p>論理ANDでは，まず左オペランドを計算し，その結果が真の時だけ，
右オペランドを計算します．(左オペランドが偽ならば，右オペランドを計算せず，全体の結果を偽とする)</p>
</li>
<li>
<p>論理OR では，まず左オペランドを計算し，その結果が偽の時だけ，
右オペランドを計算します．(左オペランドが真ならば，右オペランドを計算せず，全体の結果を真とする)</p>
</li>
<li>
<p>要するに左オペランドだけで結果が決まる時は，右オペランドを計算してはいけないのです．
このおかげで，以下のようなコードが記述可能になります．
(右オペランド <code>*p &gt; 100</code>が評価されるのは<code>p</code>が<code>NULL</code>ではない場合のみになります)</p>
<pre><code>int *p;
if (p != NULL &amp;&amp; *p &gt; 100) { ...
</code></pre>
</li>
</ul>
</li>
<li>
<p>このため，上のコード例でも❶左オペランドが真の場合だけ，
❷右オペランドが計算されています．</p>
</li>
</ul>
<h3 id="assignment"><a class="header" href="#assignment">代入</a></h3>
<pre><code>// assign.c
int x = 111;
int main ()
{
    return x = 100;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $100, x(%rip)
❷  movl    x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>代入式は単純に❶<code>mov</code>命令を使えばOKです．</li>
<li>代入式には(代入するという副作用以外に)「代入した値そのものを
その代入式の評価結果とする」という役割もあります．
　そのため❷で，<code>return</code>で返す値を<code>%eax</code>に格納しています．</li>
</ul>
<h2 id="文-statement"><a class="header" href="#文-statement">文 (statement)</a></h2>
<h3 id="式文"><a class="header" href="#式文">式文</a></h3>
<pre><code>// exp-stmt.c
int x = 111;
int main ()
{
    x = 222;
    333;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $222, x(%rip)
    movl    $0, %eax
    popq    %rbp
    ret

</code></pre>
<ul>
<li>復習: 式にセミコロン<code>;</code>を付けたものが<strong>式文</strong>です．</li>
<li><code>x = 222;</code>という式文(代入文)は，<a href="./9-code.html#assignment">代入式</a>の
❶ <code>mov</code>命令をそのまま出力すればOKです．
<ul>
<li>式文中の式の計算にスタックを使った場合は，スタック上の値を捨てる必要があることがあります</li>
</ul>
</li>
<li><code>333;</code>は文法的に正しい式文なのですが，意味がないのでGCCはこの式文を無視しました</li>
</ul>
<h3 id="ブロック文"><a class="header" href="#ブロック文">ブロック文</a></h3>
<pre><code>// block-stmt.c
int x = 111;
int main ()
{
    {
        x = 222;
        x = 333;
        x = 444;
    }
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $222, x(%rip)  # 文1
❷  movl    $333, x(%rip)  # 文2
❸  movl    $444, x(%rip)  # 文3
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>復習: <strong>ブロック文</strong> (あるいは<strong>複合文</strong> (compound statement))は，
複数の文が並んだ文です．</li>
<li>ブロック文のコード出力は簡単で，文の並びの順番に，それぞれの
アセンブリコード❶❷❸を出力するだけです．</li>
</ul>
<h3 id="goto文とラベル文"><a class="header" href="#goto文とラベル文">goto文とラベル文</a></h3>
<pre><code>// goto.c
int x = 111;
int main ()
{
foo:
    x = 222;
    goto foo;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
.L2:
    movl    $222, x(%rip)
    jmp     .L2
</code></pre>
<ul>
<li>C言語のラベル<code>foo</code>はアセンブリコードでは<code>.L2</code>になっていますが，
(名前の重複に気をつければ)ラベルとして出力すればOKです</li>
<li><code>goto</code>文もそのまま無条件ジャンプ<code>jmp</code>にすればOKです</li>
</ul>
<h3 id="return文-intを返す"><a class="header" href="#return文-intを返す">return文 (<code>int</code>を返す)</a></h3>
<pre><code>// return.c
int x = 111;
int main ()
{
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    x(%rip), %eax
❷  popq    %rbp
❸  ret
</code></pre>
<ul>
<li><code>int</code>などの整数型を返す<code>return</code>文は簡単です．
❶返す値を<code>%rax</code>レジスタに格納し，❷スタックフレームの後始末をしてから，
❸<code>ret</code>命令で，リターンアドレスに制御を移せばOKです．</li>
</ul>
<h3 id="return文-構造体を返す"><a class="header" href="#return文-構造体を返す">return文 (構造体を返す)</a></h3>
<pre><code>// return2.c
struct foo {
    char x1;
    long x2;
};
struct foo f = {'A', 0x1122334455667788};
struct foo func ()
{
    return f;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 16
    .type   f, @object
    .size   f, 16
f:
    .byte   65
    .zero   7
    .quad   1234605616436508552

    .text
    .p2align 4
    .globl  func
    .type   func, @function
func:
    endbr64
❶  movq    8+f(%rip), %rdx
❷  movq    f(%rip), %rax
    ret
</code></pre>
<ul>
<li>
<p>復習: C言語では，配列や関数を，関数の引数に渡したり，関数から返すことはできません (配列へのポインタや，関数へのポインタなら可能ですが)．
一方，構造体や共用体は，関数の引数に渡したり，関数から返すことができます．</p>
</li>
<li>
<p>8バイトより大きい構造体や共用体を関数引数や返り値にする場合，
通常のレジスタ以外のレジスタやスタックを使ってやりとりをします．
具体的な方法は
<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>
が定めています．</p>
</li>
<li>
<p>上の例では<code>%rax</code>と<code>%rdx</code>を使って，構造体<code>f</code>を関数からリターンしています．
(コードが簡単になるように，ここでは<code>gcc -O2 -S</code>の出力を載せています)</p>
</li>
</ul>
<h2 id="関数"><a class="header" href="#関数">関数</a></h2>
<h3 id="関数定義"><a class="header" href="#関数定義">関数定義</a></h3>
<pre><code>// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  add5
    .type   add5, @function
❷ add5:                      # 関数名のラベル定義
    endbr64
    pushq   %rbp              # スタックフレーム作成
    movq    %rsp, %rbp        # スタックフレーム作成
❶  movl    %edi, -4(%rbp)    # 関数本体
❶  movl    -4(%rbp), %eax    # 関数本体
❶  addl    $5, %eax          # 関数本体
    popq    %rbp              # スタックフレーム破棄
    ret                       # リターン
    .size   add5, .-add5
</code></pre>
<ul>
<li>関数を定義するには関数本体のアセンブリコード❶の前に<strong>関数プロローグ</strong>，
後に<strong>関数エピローグ</strong>のコードを出力します．
また，関数の先頭で❷関数名のラベル(<code>add5;</code>)を定義します．</li>
<li>関数プロローグはスタックフレームの作成や，callee-saveレジスタの退避などを行います．</li>
<li>関数エピローグはcallee-saveレジスタの回復や，スタックフレームの破棄などを行い，<code>ret</code>でリターンします．</li>
</ul>
<h3 id="関数コール"><a class="header" href="#関数コール">関数コール</a></h3>
<pre><code>// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main ()
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $10, %edi
❷  call    add5@PLT
❸  movl    %eax, %esi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>関数コールをするには，<code>call</code>命令の前に引数をレジスタやスタック上に格納してから，
<code>call</code>命令を実行します．その後，<code>%rax</code>に入っている返り値を引き取ります．</li>
<li>上の例では，
<ul>
<li>❶で <code>10</code>を第1引数として<code>%edi</code>レジスタにセットしてから，</li>
<li>❷で <code>call</code>を実行して，制御を<code>add5</code>関数に移します</li>
<li>❸で<code>add5</code>の返り値 (<code>%eax</code>)を引き取っています</li>
</ul>
</li>
<li>デフォルトの動的リンクを前提としたコンパイルなので，
関数名が<code>add5</code>ではなく❷<code>add5@PLT</code>となっています
(<a href="./3-binary.html#GOT-PLT">PLTについてはこちら</a>を参照)</li>
</ul>
<h3 id="関数コール関数ポインタ"><a class="header" href="#関数コール関数ポインタ">関数コール(関数ポインタ)</a></h3>
<pre><code></code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp
❶  movq    add5@GOTPCREL(%rip), %rax # GOT領域のadd5のエントリ(中身はadd5の絶対アドレス)
    movq    %rax, -8(%rbp)
    movq    -8(%rbp), %rax
❷  movl    $10, %edi
❸  call    *%rax
    movl    %eax, %esi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    movl    $0, %eax
    leave
    ret
</code></pre>
<ul>
<li>上のコード例では<code>add5</code>を変数<code>fp</code>に代入して，
<code>fp</code>中の関数ポインタを使って，<code>add5</code>を呼び出しています．</li>
<li>これをアセンブリコードにすると❶ <code>movq add5@GOTPCREL(%rip), %rax</code>になります．
<code>add5@GOTPCREL</code>はGOT領域の<code>add5</code>のエントリなので，
メモリ参照<code>add5@GOTPCREL(%rip)</code>で，<code>add5</code>の絶対アドレスを取得できます
(<a href="./3-binary.html#GOT-PLT">GOT領域についてはこちら</a>を参照)</li>
<li>❷で第1引数(<code>10</code>)を<code>%edi</code>に渡して</li>
<li>❸<code>call *%rax</code>で<code>%rax</code>中の関数ポインタを間接コールしています</li>
</ul>
<h3 id="ライブラリ関数コール"><a class="header" href="#ライブラリ関数コール">ライブラリ関数コール</a></h3>
<pre><code>// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main ()
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $10, %edi
    call    add5@PLT
❷  movl    %eax, %esi
❶  leaq    .LC0(%rip), %rax
❶  movq    %rax, %rdi
❸  movl    $0, %eax
❹  call    printf@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>ここではライブラリ関数代表として，<code>printf</code>を呼び出すコードを見てみます．
<ul>
<li>❶で<code>printf</code>の第1引数である文字列<code>&quot;%d\n&quot;</code>の先頭アドレス
(<code>.LC0(%rip)</code>)を第1引数のレジスタ<code>%rdi</code>に格納します</li>
<li>❷は<code>add5</code>が返した値を，第2引数のレジスタ<code>%esi</code>に格納します</li>
<li>❸で<code>%eax</code>に<code>0</code>を格納しています．
<ul>
<li><code>%al</code>は<code>printf</code>などの可変長引数を持つ関数の<strong>隠し引数</strong>です</li>
<li><code>%al</code>にはベクタレジスタを使って渡す浮動小数点数の引数の数をセットします</li>
<li>これは<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>が定めています</li>
</ul>
</li>
<li>❹で<code>printf</code>をコールしています</li>
</ul>
</li>
</ul>
<h3 id="システムコール"><a class="header" href="#システムコール">システムコール</a></h3>
<pre><code>// syscall-exit.c
#include &lt;unistd.h&gt;
int main ()
{
    _exit (0);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $0, %edi
❶  call    _exit@PLT
</code></pre>
<ul>
<li><code>exit</code>はライブラリ関数なので，ここではシステムコールである<code>_exit</code>を呼び出しています．</li>
<li>が，<code>_exit</code>もただの<strong>ラッパ関数</strong>で，
<code>_exit</code>の中で実際のシステムコールを呼び出します．
このため，❶を見れば分かる通り，<code>_exit</code>の呼び出しは
ライブラリ関数の呼び出し方と同じになります．</li>
</ul>
<pre><code class="language-bash">$ objdump -d /lib/x86_64-linux-gnu/libc.so.6 | less
(中略)
00000000000eac70 &lt;_exit&gt;:
   eac70:       f3 0f 1e fa             endbr64 
   eac74:       4c 8b 05 95 e1 12 00    mov    0x12e195(%rip),%r8        # 218e10 &lt;_DYNAMIC+0x250&gt;
   eac7b:       be e7 00 00 00          mov    $0xe7,%esi
   eac80:       ba 3c 00 00 00          mov    $0x3c,%edx
   eac85:       eb 16                   jmp    eac9d &lt;_exit+0x2d&gt;
   eac87:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
   eac8e:       00 00 
   eac90:       89 d0                   mov    %edx,%eax
   eac92:       0f 05                ❶ syscall 
   eac94:       48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
   eac9a:       77 1c                   ja     eacb8 &lt;_exit+0x48&gt;
   eac9c:       f4                      hlt    
   eac9d:       89 f0                   mov    %esi,%eax
   eac9f:       0f 05                ❶ syscall 
<span class="boring">   eaca1:       48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
</span><span class="boring">   eaca7:       76 e7                   jbe    eac90 &lt;_exit+0x20&gt;
</span><span class="boring">   eaca9:       f7 d8                   neg    %eax
</span><span class="boring">   eacab:       64 41 89 00             mov    %eax,%fs:(%r8)
</span><span class="boring">   eacaf:       eb df                   jmp    eac90 &lt;_exit+0x20&gt;
</span><span class="boring">   eacb1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
</span><span class="boring">   eacb8:       f7 d8                   neg    %eax
</span><span class="boring">   eacba:       64 41 89 00             mov    %eax,%fs:(%r8)
</span><span class="boring">   eacbe:       eb dc                   jmp    eac9c &lt;_exit+0x2c&gt;
</span></code></pre>
<ul>
<li><code>_exit</code>関数の中身を逆アセンブルしてみると，
❶<code>syscall</code>命令を使ってシステムコールを呼び出している部分を見つけられます．
(お作法を正しく守れば，<code>_exit</code>を使わず，直接，<code>syscall</code>でシステムコールを呼び出すこともできます)</li>
</ul>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="8-inline.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="10-gdb.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="8-inline.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="10-gdb.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
