<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>バイナリファイル - Linuxで学ぶx86-64アセンブリ言語</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

        <!-- MathJax -->
        <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要</a></li><li class="chapter-item expanded "><a href="3-binary.html" class="active"><strong aria-hidden="true">3.</strong> バイナリファイル</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="5-arch.html"><strong aria-hidden="true">4.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど</a></li><li class="chapter-item "><a href="4-data.html"><strong aria-hidden="true">5.</strong> データ表現，2進数，2の補数</a></li><li class="chapter-item "><a href="6-inst.html"><strong aria-hidden="true">6.</strong> x86-64機械語命令</a></li><li class="chapter-item "><a href="7-asm.html"><strong aria-hidden="true">7.</strong> アセンブラ命令</a></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ</a></li><li class="chapter-item "><a href="9-code.html"><strong aria-hidden="true">9.</strong> GCCが生成したアセンブリコードを読む</a></li><li class="chapter-item "><a href="10-gdb.html"><strong aria-hidden="true">10.</strong> デバッガgdbの使い方</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 3; }
</style>
<h1 id="バイナリファイル"><a class="header" href="#バイナリファイル">バイナリファイル</a></h1>
<h2 id="バイナリファイルの中身を見る"><a class="header" href="#バイナリファイルの中身を見る">バイナリファイルの中身を見る</a></h2>
<h3 id="hexdump"><a class="header" href="#hexdump">16進ダンプ</a></h3>
<p><code>add5.c</code>や<code>add5.s</code>はテキストファイルですが，
<a href="./2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">2節のアセンブリ言語</a>で作成した
<code>add5.o</code>はバイナリファイルです．
バイナリファイルなので，<code>less</code>コマンドでは中身を読めません．</p>
<pre><code class="language-bash">$ less add5.o
^?❶ELF^B^A^A^@^@^@^@^@^@^@^@^@^A^@&gt;^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@X^B
^@^@^@^@^@^@^@^@^@^@@^@^@^@^@^@@^@^L^@^K^@&lt;F3&gt;^O^^&lt;FA&gt;UH&lt;89&gt;&lt;E5&gt;&lt;89&gt;}&lt;FC&gt;&lt;8B&gt;E
（長いので省略）
</code></pre>
<details id="ELF">
<summary>
❶ELFとは
</summary>
<p>上の<code>less</code>コマンドの結果にELFという文字が見える理由を説明します．
ELFはLinuxが採用している<strong>バイナリ形式</strong>(binary format)です．
このELFのバイナリファイルの先頭4バイトには<strong>マジックナンバー</strong>という
バイナリファイルを識別する特別な数値が入っています．
ELFバイナリのマジックナンバーは <code>7F 45 4C 46</code>です．
<code>45 4C 46</code>はASCII文字で <code>E L F</code> なので，lessコマンドが<code>ELF</code>と表示したわけです． </p>
</details>
<p>バイナリファイルの中身を読むには例えば<code>od</code>コマンドを使います．</p>
<pre><code class="language-bash">$ od -t x1 add5.o
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00
（長いので省略）
</code></pre>
<p>一番左の数字が「先頭からのバイト数(16進表記)」，
その右側に並んでいるのが「1バイトごとに16進表記したファイルの中身」です．
（1バイトのデータは2桁の16進数で表せることを思い出しましょう．
例えば，<code>add5.o</code>の中身の先頭4バイトの値は<code>7F 45 4C 46</code>です）．</p>
<p><code>-t x1</code>というオプションは「1バイトごとに16進数で表示せよ」という意味です．
このような出力を<strong>16進ダンプ</strong>(hex dump)と言います．
他に16進ダンプするコマンドとして，<code>xxd</code>や<code>hexdump</code>などがあります．</p>
<p>ちなみに，<code>add5.c</code>はテキストファイルですが，内容は2進数で保存されて
いますので，<code>od</code>コマンドで中身を表示できます．</p>
<pre><code class="language-bash">$ od -t x1 add5.c
0000000 69 6e 74 20 61 64 64 35 20 28 69 6e 74 20 6e 29
0000020 0a 7b 0a 20 20 20 20 72 65 74 75 72 6e 20 6e 20
0000040 2b 20 35 3b 0a 7d 0a
0000047
</code></pre>
<p>先頭の<code>69</code>はASCII文字<code>i</code>の文字コード，
同様に，次の<code>6e</code>は文字<code>n</code>，その次の<code>74</code>は文字<code>t</code>なので，
<code>add5.c</code>の先頭3文字が<code>int</code>であることを確認できます．
<a href="./4-data.html#ASCII">ASCIIコード</a>表は<code>man ascii</code>コマンドで閲覧できます．
（例えば，16進数の<code>0x69</code>は10進数の<code>105</code>です．
<a href="./4-data.html#ASCII">ASCIIコード</a>表の<code>105</code>番目の文字は<code>i</code>です．）</p>
<details>
<summary>
manコマンドとは
</summary>
<p><code>man</code>コマンドはLinux上でマニュアルを表示するコマンドです．</p>
<p>例えば<code>man ascii</code>を実行すると以下のように表示されます．</p>
<pre><code class="language-bash">$ man ascii

ASCII(7)                   Linux Programmer's Manual                  ASCII(7)

NAME
       ascii - ASCII character set encoded in octal， decimal， and hexadecimal

DESCRIPTION
       ASCII is the American Standard Code for Information Interchange.  It is
       a 7-bit code.  Many 8-bit codes (e.g.， ISO  8859-1)  contain  ASCII  as
       their  lower  half.  The international counterpart of ASCII is known as
       ISO 646-IRV.

       The following table contains the 128 ASCII characters.

       C program '\X' escapes are noted.

       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
       ────────────────────────────────────────────────────────────────────────
       000   0     00    NUL '\0' (null character)   100   64    40    @
       001   1     01    SOH (start of heading)      101   65    41    A
       002   2     02    STX (start of text)         102   66    42    B
（以下略）
</code></pre>
<p>デフォルトでは<code>less</code>コマンドで1ページずつ表示されるので，
スペースキーで次のページが，<code>b</code>を押せば前のページが表示されます．
終了するには<code>q</code>を押します．<code>h</code>を押せばヘルプを表示し，<code>/</code>で検索もできます．
例えば，<code>/backspace</code>と入力してリターンを押すと，<code>backspace</code>を検索してくれます．</p>
<p><code>man</code>コマンドは章ごとに分かれています．例えば</p>
<ul>
<li>1章はコマンド (例：<code>ls</code>)</li>
<li>2章はシステムコール (例：<code>open</code>)</li>
<li>3章はライブラリ関数 (例：<code>printf</code>)</li>
</ul>
<p>となっています．
<code>printf</code>というコマンドがあるので，
<code>man printf</code>とすると（ライブラリ関数ではなく）コマンドの<code>printf</code>の
マニュアルが表示されてしまいます．
ライブラリ関数の<code>printf</code>を見たい場合は
<code>man 3 printf</code>と章番号も指定します．</p>
</details>
<p>なお，<code>od</code>コマンドに<code>-c</code>オプションをつけると，
(文字として表示可能なバイトは)文字が表示されます．</p>
<pre><code class="language-bash">$ od -t x1 -c add5.c
0000000  69  6e  74  20  61  64  64  35  20  28  69  6e  74  20  6e  29
          i   n   t       a   d   d   5       (   i   n   t       n   )
0000020  0a  7b  0a  20  20  20  20  72  65  74  75  72  6e  20  6e  20
         \n   {  \n                   r   e   t   u   r   n       n    
0000040  2b  20  35  3b  0a  7d  0a
          +       5   ;  \n   }  \n
0000047
</code></pre>
<h3 id="everything-binary"><a class="header" href="#everything-binary">コンピュータの中のデータはすべて<code>0</code>と<code>1</code>から成る</a></h3>
<p>ここで大事なことを復習しましょう．
それは
<strong>「コンピュータの中のデータは，どんな種類のデータであっても，
機械語命令であっても，すべて<code>0</code>と<code>1</code>だけで表現されている」</strong>
ということです．
ですので，テキストはバイナリでもあるのです．</p>
<ul>
<li>テキスト=文字として表示可能な2進数だけを含むデータ</li>
<li>バイナリ=文字以外の2進数も含んだデータ</li>
</ul>
<img src="figs/text-binary.svg" height="100px" id="fig:text-binary">
<blockquote>
<p>注意：
本書で，テキスト(text)という言葉には2種類の意味があることに注意して下さい．</p>
<ul>
<li>1つは「文字」を意味します．例：「テキストファイル」（文字が入ったファイル）</li>
<li>もう1つは「機械語命令列」を意味します．例：「<a href="#.text">テキストセクション</a>」（機械語命令列が格納されるセクション）</li>
</ul>
</blockquote>
<h3 id="2進数と符号化"><a class="header" href="#2進数と符号化">2進数と符号化</a></h3>
<p><a href="#everything-binary">前節</a>で説明した通り，
コンピュータ中では全てのものを0と1の2進数で表現する必要があります．
そのため，データの種類ごとに2進数での表現方法，つまり<strong>符号化</strong>
(encoding)の方法が定められています．
例えば，</p>
<ul>
<li>文字<code>U</code>をASCII文字として符号化すると，<code>01010101</code>になります．</li>
<li><code>pushq %rbp</code>をx86-64の機械語命令として符号化すると，<code>01010101</code>になります．</li>
</ul>
<p>おや，どちらも同じ<code>01010101</code>になってしまいました．
この2進数が<code>U</code>なのか<code>pushq %rbp</code>なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．</p>
<img src="figs/encode.svg" height="130px" id="fig:encode">
<p>別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する<a href="#.text"><code>.text</code>セクション</a>にある
2進数のデータ列は「<code>.text</code>セクションに存在するから」という理由で
機械語命令として解釈されます．</p>
<h3 id="fileコマンド"><a class="header" href="#fileコマンド"><code>file</code>コマンド</a></h3>
<p><a href="#hexdump">16進ダンプ</a>以外の方法で，<code>add5.o</code>の中身を見てみます．
まずは<code>file</code>コマンドです．
<code>file</code>コマンドはファイルの種類の情報を教えてくれます．</p>
<pre><code class="language-bash">$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable， x86-64， ❹version 1 (SYSV)， ❺not stripped
</code></pre>
<p>これで，<code>add5.o</code>が64ビットの❶ELFバイナリであることが分かりました．
ELFはバイナリ形式(バイナリを格納するためのファイルフォーマット)の1つです．
Linuxを含めて多くのOSがELFをバイナリ形式として使っています．</p>
<details id="LSB">
<summary>
❷LSBとは
</summary>
<p>多バイト長のデータをバイト単位で格納する順序を<strong>バイトオーダ</strong>(byte order)といいます．
LSBは最下位バイトから順に格納するバイトオーダ (Least Significant Byte first)，
つまり<a href="4-data.html#%E3%83%90%E3%82%A4%E3%83%88%E3%82%AA%E3%83%BC%E3%83%80%E3%81%A8%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>
を意味しています．</p>
<p>x86-64のバイトオーダがリトルエンディアンのため，
このELFバイナリもリトルエンディアンになっています．
ELFバイナリがビッグエンディアンかリトルエンディアンかどうかを示すデータが，
ELFバイナリのヘッダに格納されています．
これは<code>readelf -h</code>コマンドで調べられます❶．</p>
<pre><code>$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:        ELF64
  Data:         2's complement, ❶little endian
  Version:      1 (current)
  OS/ABI:       UNIX - System V
(以下略)
</code></pre>
<p>リトルエンディアンでの注意は16進ダンプする時に，多バイト長データが逆順に表示されることです．
以下で多バイト長データ❶<code>0x11223344</code>を<code>.text</code>セクションに配置してアセンブルした
<code>little.o</code>を逆アセンブルすると，❸<code>44 33 22 11</code>と逆順に表示されています．
(<code>objdump -h</code>の出力から，<code>.text</code>セクションのオフセット(ファイルの先頭からのバイト数)が❷0x40バイトであることを使って，<code>od</code>コマンドに<code>-j0x40</code>オプションを使い，<code>.text</code>セクションの先頭付近の情報を表示しています)</p>
<pre><code class="language-bash">$ cat little.s
.text
❶.long 0x11223344
$ gcc -c little.s
$ objdump -h little.o
foo.o:     file format elf64-x86-64
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000004  0000000000000000  0000000000000000 ❷00000040  2**0
                  CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000044  2**0
                  CONTENTS， ALLOC， LOAD， DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0
                  ALLOC
$ od -t x1 -j0x40 little.o | head -n1
0000100 ❸44 33 22 11 00 00 00 00 00 00 00 00 00 00 00 00
</code></pre>
</details>
<!--
これは嘘でしたｗ
LSBはLinuxの標準である[Linux Standard Base](https://refspecs.linuxfoundation.org/lsb.shtml)の略です．LSBはELFバイナリの規格であるSystem V ABIを含んでいます．
ABIはapplication binary interfaceの略です．
-->
<details>
<summary>
❸relocatableとは
</summary>
<p>バイナリ中のアドレスを再配置 (relocate)できるバイナリのことを
再配置可能 (relocatable)であるといいます．オブジェクトファイルはリンク時や実行時にアドレスを変更できるよう，
relocatableであることが多いです．</p>
</details>
<details>
<summary>
❹version 1 (SYSV)とは
</summary>
<p>LinuxのABI（バイナリ互換規約）である<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>
に準拠していることを表しています．</p>
</details>
<details>
<summary>
❺not strippedとは
</summary>
<p>バイナリには実行に直接関係ない<strong>記号表</strong>や<strong>デバッグ情報</strong>などが
含まれていることがよくあります．
この「実行に直接関係ない情報」が削除されたバイナリのことを
stripped binaryと呼びます．
<code>strip</code>コマンドで「実行に直接関係ない情報」を削除できます．
削除された分，サイズが少し減っています．</p>
<pre><code class="language-bash">$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 1368 Jul 19 10:09 add5.o
$ strip add5.o
$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 880 Jul 19 14:58 add5.o
</code></pre>
</details>
<details>
<summary>
.textセクションだけ抜き出す
</summary>
<p>GNU binutilsの<code>objcopy</code>コマンドを使うと，特定のセクションだけ抜き出せます．
以下では<code>little.o</code>から<code>.text</code>セクションを抜き出して，ファイル<code>foo</code>に書き込んでいます．</p>
<pre><code>$ objcopy --dump-section .text=foo little.o
$ od -t x1 foo
0000000 44 33 22 11
0000004
</code></pre>
<p><code>objcopy</code>はセクションの注入も可能です．
以下ではファイル<code>foo</code>の内容を<code>little.o</code>の新しいセクション<code>.text2</code>として注入しています．
新しいセクション❶<code>.text2</code>が出来ていることが分かります．</p>
<pre><code>$ objcopy --add-section .text2=foo --set-section-flags .hoge=noload,readonly little.o
$ objdump -h little.o
little.o:     file format elf64-x86-64
Sections:
Idx Name       Size      VMA               LMA               File off  Algn
  0 .text      00000004  0000000000000000  0000000000000000  00000040  2**0
               CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data      00000000  0000000000000000  0000000000000000  00000044  2**0
               CONTENTS, ALLOC, LOAD, DATA
  2 .bss       00000000  0000000000000000  0000000000000000  00000044  2**0
               ALLOC
  3 ❶.text2     00000004  0000000000000000  0000000000000000  00000044  2**0
               CONTENTS, READONLY
</code></pre>
</details>
<p>なお，<code>file</code>コマンドはバイナリ以外のファイルにも使えます．</p>
<pre><code class="language-bash">$ file add5.c
add5.c: ASCII text
$ file add5.s
add5.s: assembler source， ASCII text
$ file .
.:  directory
$ file /dev/null
/dev/null: character special (1/3)
</code></pre>
<h3 id=".text"><a class="header" href="#.text">セクションと<code>objdump -h</code>コマンド</a></h3>
<p>バイナリファイルの構造はざっくり以下の図のようになっています．</p>
<img src="figs/section.svg" height="250px" id="fig:text-binary">
<ul>
<li>最初のヘッダ以外の四角を<strong>セクション</strong>(section)と呼びます．</li>
<li>バイナリはセクションという単位で区切られていて，それぞれ別の目的でデータが格納されます．</li>
<li>ヘッダは目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．</li>
</ul>
<p>ヘッダの情報は<code>objdump -h</code>で表示できます．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
(以下略)
</code></pre>
<p>ここでは「<code>.text</code>，<code>.data</code>，<code>.bss</code>という3つのセクションがある」ことを
見ればOKです．</p>
<details>
<summary>
VMAとLMAとは
</summary>
<p>VMAはvirtual memory addressの略で「メモリ上で実行される時の
このセクションのメモリアドレス」です．
一方，LMAはload memory addressの略で「メモリ上にロード(コピー，配置)する時の
このセクションのメモリアドレス」です．
通常，セクションをメモリにロードした後で，移動せずにそのまま実行するため，VMAとLMAは同じアドレスになります．
<code>add5.o</code>ではアドレスが決まってないので，VMAもLMAもゼロになっています．</p>
</details>
<details>
<summary>
File offとは
</summary>
<p>File offはファイルオフセットを表しています．このセクションがバイナリファイルの先頭から何バイト目から始まっているかを16進表記で表しています．</p>
</details>
<details>
<summary>
Algnとは
</summary>
<p>Algnは<strong>アラインメント</strong>(alignment)を表しています．
例えば「このセクションをメモリ上に配置する時，その先頭アドレスが8の倍数になるようにしてほしい」という状況の時，この部分が<code>2**3</code>となります（2の3乗=8）．</p>
</details>
<details>
<summary>
CONTENTS， ALLOC， LOAD， READONLY， CODEとは
</summary>
<p>これらはセクションフラグと呼ばれるセクションの属性値です．</p>
<ul>
<li>CONTENTS  このセクションには中身がある (例えば，<code>.bss</code>はCONTENTSが無いので(ファイル中では)中身が空のセクションです)</li>
<li>ALLOC     ロード時にこのセクションのためにメモリを割り当てる必要がある</li>
<li>LOAD      このセクションは実行するためにメモリ上にロードする必要がある</li>
<li>READONLY  メモリ上では「読み込みのみ許可（書き込み禁止）」と設定する必要がある</li>
<li>CODE      このセクションは実行可能な機械語命令を含んでいる</li>
</ul>
</details>
<br/>
<div id=".bss">
<p>3つのセクション <code>.text</code> ，<code>.data</code>，<code>.bss</code> の役割は以下の通りです：</p>
<ul>
<li><code>.text</code>セクションは機械語命令を格納します．例えば，<code>pushq %rbp</code>を表す<code>0x55</code>は<code>.text</code>セクションに格納されます．</li>
<li><code>.data</code>セクションは初期化済みの静的変数の値を格納します．例えば，大域変数<code>int x=999;</code>があったとき，999の2進数表現が<code>.data</code>セクションに格納されます．</li>
<li><code>.bss</code>セクションは未初期化の静的変数の値を格納します．例えば，大域変数<code>int y;</code>があったとき，（概念的には）初期値0の2進数表現が<code>.bss</code>セクションに格納されます．</li>
</ul>
</div>
<details>
<summary>
なぜ概念的
</summary>
<p>実はファイル中では<code>.bss</code>セクションにはサイズ情報などごくわずかの情報しか持っていません．実行時にメモリ上に<code>.bss</code>セクションを作る際に，実際に必要なメモリを確保して，そのメモリ領域をすべてゼロで初期化すれば十分だからです（ファイル中に大量のゼロの並びを保持する必要はありません）．</p>
<pre><code>// bss.c
int a [1024];
int main (void)
{
   return a[0];
}
</code></pre>
<p>例えば，<code>bss.c</code>の<code>int a[1024];</code> の変数<code>a</code>は未初期化なので，
変数<code>a</code>の実体は<code>.bss</code>セクションに置かれます．アセンブリコードを見てみると，</p>
<pre><code>$ gcc -S bss.c
$ cat bss.s
(関係する箇所以外は削除)
 ❶ .bss                # 以下を.bssセクションに出力
    .align 32           # 次の出力アドレスを32の倍数にせよ
    .type   a, @object  # ラベルaの型はオブジェクト(関数ではなくデータ)
    .size   a, 4096     # ラベルaのサイズは4096バイト
a:                      # ラベルaの定義
 ❷ .zero   4096        # 4096バイト分のゼロを出力せよ
</code></pre>
<p>❶<code>.bss</code>セクションに❷4096バイト分のゼロを出力するように見えますが，
ヘッダを見てみると，ファイル中の<code>.bss</code>セクションの中身は0バイトだと分かります．</p>
<pre><code>$ gcc -g bss.c
$ objdump -h ./a.out
Sections:
Idx Name          Size      VMA               LMA                File off  Algn
(中略)
23 ❸.bss     ❹ 00001020  0000000000004020  0000000000004020 ❺ 00003010  2**5
                ❼ALLOC
24   .comment    0000002b  0000000000000000  0000000000000000 ❻ 00003010  2**0
                  CONTENTS, READONLY
</code></pre>
<p>❸<code>.bss</code>セクションのサイズは16進数で❹ 0x1020バイト(10進数では4128バイト)ですが，
ファイルオフセットを比較してみると，❺と❻が同じ値(<code>000033010</code>)なので，
ファイル中での<code>.bss</code>セクションのサイズは0バイトだと分かります．
また，セクション属性が❼<code>ALLOC</code>のみで，
<code>CONTENTS</code>(中身がある)が無いことからも0バイトと分かります．</p>
</details>
<p>さらに代表的なセクションである<code>.rodata</code>も説明します．</p>
<ul>
<li><code>.rodata</code>セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数<code>&quot;hello&quot;</code>は書き込み禁止なので，<code>&quot;hello&quot;</code>の2進数表現が<code>.rodata</code>セクションに格納されます．</li>
</ul>
<p>バイナリファイルには上記以外のセクションも数多く使われますが，
まずはこの基本の4種類 (<code>.text</code>， <code>.data</code>， <code>.bss</code>， <code>.rodata</code>) を覚えましょう．</p>
<h3 id="nm"><a class="header" href="#nm">記号表の中身を表示させる(<code>nm</code>コマンド)</a></h3>
<p>バイナリファイル中には<strong>記号表</strong>(symbol table)があることが多いです．
記号表とは「変数名や関数名がバイナリ中では何番地のアドレスになっているか」という情報です．
<code>nm</code>コマンドでバイナリファイル中の記号表を表示できます．
まず，以下の<code>foo.c</code>を準備して下さい．</p>
<pre><code>// foo.c
int g1 = 999;
int g2;
static int s1 = 888;
static int s2;
int main ()
{
    static int s3 = 777;
    static int s4;
    int ❼i1 = 666;
    int ❼i2;
}
</code></pre>
<p>そしてコンパイルして，<code>nm</code>コマンドで記号表の中身を表示させます．</p>
<pre><code class="language-bash">$ gcc -c foo.c
$ nm foo.o
0000000000000000 ❶D g1
0000000000000000 ❸B g2
0000000000000000 ❺T main
0000000000000004 ❷d s1
0000000000000004 ❹b s2
0000000000000008 ❷d ❻s3.0
0000000000000008 ❹b ❻s4.1
</code></pre>
<p>この出力の読み方は以下の通りです．</p>
<ul>
<li>❶<code>D</code>と❷<code>d</code>は<code>.data</code>セクションのシンボル，❸<code>B</code>と❹<code>b</code>は<code>.bss</code>セクションのシンボル，❺<code>T</code>と<code>t</code>は<code>.text</code>セクションのシンボルであることを表す</li>
<li>大文字はグローバル（ファイルをまたがって有効なシンボル），小文字はファイルローカルなシンボルであることを表す</li>
<li><code>static</code>付きの局所変数を表すシンボルは
他の関数中の同名のシンボルと区別するために，
❻<code>.0</code>や<code>.1</code>などが付加されることがある．</li>
<li>左側の<code>00</code>，<code>04</code>，<code>08</code>がシンボルに対応するアドレスですが，再配置前(relocation前)なので仮のアドレス(各セクションの先頭からのオフセット)</li>
<li>(<code>static</code>のついてない)局所変数❼は記号表には含まれていない．
局所変数(自動変数)は実行時にスタック上に実体が確保されます．</li>
</ul>
<h3 id="ASLR-PIE"><a class="header" href="#ASLR-PIE">ASLRとPIE（ちょっと脱線）</a></h3>
<p>オブジェクトファイルのセクションごとの仮のアドレスは，
リンク後の<code>a.out</code>では具体的なアドレスになります</p>
<pre><code class="language-bash">$ gcc foo.c
$ nm ./a.out | egrep g1
0000000000004010 D g1
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000001129 T main
</code></pre>
<details>
<summary>
U __libc_start_main@@GLIBC_2.34とは
</summary>
<p>バイナリ中で参照されているけど定義がないシンボルがあると，
<code>nm</code>コマンドはundefinedを意味する<code>U</code>を表示します．
実は<code>a.out</code>は<code>main</code>関数を呼び出す前に<code>__libc_start_main</code>という
GLIBC中の関数を(<a href="#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>した上で)呼び出します．
<code>__libc_start_main</code>は
様々な初期化を行った後，(その名の通り)<code>main</code>関数を呼び出すのが主な役割です．</p>
<p>ちなみに<code>__libc_start_main</code>は<code>_start</code>が呼び出します．</p>
<pre><code>$ readelf -h ./a.out | egrep Entry
  Entry point address:           ❶ 0x1040
$ objdump -d ./a.out | egrep 1040
0000000000001040 ❷ &lt;_start&gt;:
    1040:	f3 0f 1e fa          	endbr64 
</code></pre>
<p><code>a.out</code>の<strong>エントリポイント</strong>(最初に実行するアドレス)は
❶ <code>0x1040</code>番地です．この番地には❷<code>_start</code>があるので，
<code>a.out</code>を実行すると最初に実行される関数は<code>_start</code>と分かります．</p>
</details>
<p>出力が長くなるので，<code>g1</code>と<code>main</code>のアドレスだけ載せています．
<code>g1</code>のアドレスは<code>0x4010</code>番地，<code>main</code>のアドレスは<code>0x1129</code>番地となりました．
ただし，このまま実行すると，<code>g1</code>や<code>main</code>のアドレスはこれらのアドレスにはならず，
実行するたびに変わります．
これは<strong>ASLR</strong>や<strong>PIE</strong>というセキュリティ対策機能のためです．</p>
<p>確かめてみましょう．
以下の<code>foo2.c</code>を普通にコンパイルして実行してみます．</p>
<pre><code class="language-C">// foo2.c
#include &lt;stdio.h&gt;
int g1 = 999;
int main ()
{
    printf (&quot;%p, %p\n&quot;, &amp;g1, main);
}
</code></pre>
<p>以下の通り，<code>g1</code>や<code>main</code>のアドレスは実行するたびに変わりますし，
<code>nm</code>が出力したアドレスとも異なります．</p>
<pre><code class="language-bash">$ gcc foo2.c
$ ./a.out
0x557f2361e010， 0x557f2361b149
$ ./a.out
0x55a40e6f5010， 0x55a40e6f2149
$ ./a.out
0x562750663010， 0x562750660149
$ 
</code></pre>
<p>ここではASLRとPIEの機能を無効にして，アドレスが変わらなくなることを確認します．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0  # ASLRをオフ
$ gcc -no-pie foo2.c                          # PIEをオフ
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000401136 T main
$ nm ./a.out | egrep g1
0000000000404030 D g1
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
</code></pre>
<p>ASLRとPIEの機能をオフにすることで，アドレスが変わらなくなり，
かつ<code>nm</code>が出力するアドレスと同じになることが確認できました．</p>
<blockquote>
<p>注意：
不用意なASLRとPIEの無効化はセキュリティ機能を下げるので避けるべきです．
しかしデバッグ作業ではアドレスが変わらなくなるので
ASLRとPIEの無効化が有用な場合もあります．
なお，デバッガ中ではASLRは無効化されていることが多いです．</p>
</blockquote>
<details>
<summary>
ASLRとは
</summary>
<p>ASLR (address space layout randomizationの略)は，
アドレス空間の配置をランダム化する機能です．
テキスト（実行コード），ライブラリ，スタック，ヒープなどをメモリ上に
配置するアドレスを実行するたびにランダムに変化させます．
以下を実行するとASLRは無効化され，</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
</code></pre>
<p>以下を実行するとASLRは有効化されます．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=1
</code></pre>
</details>
<details id="PIE">
<summary>
PIEとは
</summary>
<p>PIE (position independent executableの略)は位置独立実行可能ファイルを意味します．
通常，動的ライブラリは位置独立コードPIC (position independent code)としてコンパイルされます．
動的ライブラリはメモリ上で共有されるため，どのアドレスに配置してもそのまま再配置せずに，実行したいからです．
PIEは動的ライブラリだけでなく，<code>a.out</code>も位置独立にした実行可能ファイルを指します．
<code>-no-pie</code>オプションでコンパイルすると，PIEを無効化できます．</p>
<pre><code class="language-bash">$ gcc -no-pie foo2.c
</code></pre>
</details>
<h2 id="逆アセンブル再び"><a class="header" href="#逆アセンブル再び">逆アセンブル再び</a></h2>
<p><a href="./2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>で説明した通り，
<code>objdump -d ./a.out</code>で逆アセンブル結果が表示されます（再掲）．</p>
<pre><code class="language-bash">$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
</code></pre>
<p><code>objdump</code>コマンドは<code>add5.o</code>の<code>.text</code>セクションを抽出し，
そのデータを機械語命令として解釈して，対応するニモニックを出力しています．</p>
<p>この出力によれば，<code>.text</code>セクションの先頭4バイトは<code>F3 0F 1E FA</code>で，
この4バイトが<code>endbr64</code>命令になります
（x86-64の命令長は可変長で，1バイト〜15バイトです）．</p>
<p>以下では<code>.text</code>セクションの先頭4バイトが<code>F3 0F 1E FA</code>であることを確認します．</p>
<p>セクションのヘッダを出力するコマンド<a href="#.text"><code>objdump -h</code></a>の出力を再掲します．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA                File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000 ❶00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000   00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000   00000053  2**0
             ALLOC
</code></pre>
<p><code>.text</code>セクションの<code>File off</code>の欄を見ると❶<code>00000040</code>とあります．
これは<code>.text</code>セクションが<code>add5.o</code>の先頭から16進数で40バイト
目(以後，0x40と表記)にあることを意味しています．</p>
<p><code>od</code>コマンドの<code>-j</code>オプションを使うと，指定したバイト数だけ，
先頭をスキップしてくれます．
この<code>-j</code>オプションを使って，0x40バイトスキップして，
<code>.text</code>セクションの最初だけを16進ダンプします
（<code>head -n3</code>は先頭の3行だけ表示します）．</p>
<pre><code class="language-bash">$ od -t x1 -j0x40 add5.o | head -n3
0000100 ❶f3 0f 1e fa 55 48 89 e5 89 7d fc 8b 45 fc 83 c0
0000120   05 5d c3 00 47 43 43 3a 20 28 55 62 75 6e 74 75
0000140   20 39 2e 34 2e 30 2d 31 75 62 75 6e 74 75 31 7e
</code></pre>
<p>この結果❶を見ると，<code>.text</code>セクションの最初の4バイトは
<code>F3 0F 1E FA</code>であることが分かります．
これは上の<a href="#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB%E5%86%8D%E3%81%B3">逆アセンブルの結果</a>の先頭4バイトと一致しており，
<code>endbr64</code>命令が，<code>add5.o</code>の先頭から0x40バイト目に存在することが分かりました．</p>
<h2 id="広義のコンパイル"><a class="header" href="#広義のコンパイル">広義のコンパイルとリンク</a></h2>
<p>ここでは広義のコンパイル，つまりCのプログラム<code>foo.c</code>から
実行可能ファイル<code>a.out</code>を生成する処理の中身を見ていきます．
いちばん大事なのは最後の<strong>リンク</strong>(link)です．</p>
<img src="figs/compile-all.svg" height="300px" id="fig:compile-all">
<ul>
<li>❶ Cの前処理，すなわち<code>#include</code>や<code>#define</code>などの前処理命令の処理と，マクロ（例えば<code>&lt;stdio.h&gt;</code>が定義する<code>NULL</code>や<code>EOF</code>）の展開を行います．<code>gcc -E</code>コマンドで実行できますが，内部的にはカッコ内の<code>cpp</code>や<code>cc1</code>コマンドが実行されています（現在は<code>cc1</code>）．</li>
<li>❷ 狭義のコンパイル処理で，Cのプログラムをアセンブリコードに変換します．</li>
<li>❸ アセンブラ(<code>as</code>コマンド)によるアセンブル処理で，オブジェクトファイル<code>foo.o</code>を生成します．<code>foo.o</code>中にはバイナリの機械語命令が入っています．</li>
<li>❹ <code>foo.o</code>だけでは実行可能ファイルは作れません．例えば，<code>printf</code>などのライブラリ関数の実体は，
<code>libc.a</code>(<a href="#%E9%9D%99%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">静的ライブラリ</a>)や<code>libc.so</code>(<a href="#%E5%8B%95%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">動的ライブラリ</a>)の中にあるからです．
また，<code>main</code>関数を呼び出すためのCスタートアップルーチン(多くの場合，<code>crt*.o</code>というファイル名)も必要です．
また，分割コンパイルの機能を使った結果，<code>foo.o</code>は他のC言語のプログラムをアセンブルしたオブジェクトファイル<code>*.o</code>が必要なことがよくあります．
「このような他のバイナリと<code>foo.o</code>を合体させて<code>a.out</code>を生成する処理」のことを<strong>リンク</strong>(link)と呼びます．</li>
</ul>
<p>広義のコンパイルで具体的にどのような処理が行われてるのかを見るには，
<code>-v</code>をつけて<code>gcc -v</code>とコンパイルすれば表示されます．
（以下では表示を省略しています．全てを表示するには<i class="fa fa-eye"></i>ボタンを押して下さい）．</p>
<pre><code class="language-bash">$ gcc -v main.c add5.s |&amp; tee out
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
<span class="boring"> Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.3.0-1ubuntu1~22.04.1' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c，ada，c++，go，brig，d，fortran，objc，obj-c++，m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32，m64，mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-nvptx/usr，amdgcn-amdhsa=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
</span><span class="boring"> Thread model: posix
</span><span class="boring"> Supported LTO compression algorithms: zlib zstd
</span><span class="boring"> gcc version 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04.1) 
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpdir a- -dumpbase main.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include-fixed&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/../../../../x86_64-linux-gnu/include&quot;
</span><span class="boring"> #include &quot;...&quot; search starts here:
</span><span class="boring"> #include &lt;...&gt; search starts here:
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/include
</span><span class="boring">  /usr/local/include
</span><span class="boring">  /usr/include/x86_64-linux-gnu
</span><span class="boring">  /usr/include
</span><span class="boring"> End of search list.
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> Compiler executable checksum: e13e2dc98bfa673227c4000e476a9388
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/cc5o7Jgg.o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/ccUs2R16.o add5.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/
</span><span class="boring"> LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../:/lib/:/usr/lib/
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgnuv0i.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/cc5o7Jgg.o /tmp/ccUs2R16.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/11/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span></code></pre>
<h2 id="バイナリファイルの種類"><a class="header" href="#バイナリファイルの種類">バイナリファイルの種類</a></h2>
<p>実行可能ファイル<code>a.out</code>に関連するバイナリファイルには
以下の4種類があります：</p>
<ul>
<li>オブジェクトファイル(<code>*.o</code>)</li>
<li>実行可能ファイル(<code>a.out</code>)</li>
<li>静的ライブラリファイル(<code>lib*.a</code>)</li>
<li>動的ライブラリファイル(<code>lib*.so</code>)</li>
</ul>
<h3 id="オブジェクトファイル"><a class="header" href="#オブジェクトファイル">オブジェクトファイル(<code>*.o</code>)</a></h3>
<p><strong>オブジェクトファイル</strong>とはLinuxでファイル名の拡張子が<code>.o</code>なファイルです．
オブジェクトファイルは機械語命令を含んでいますが，
このオブジェクトファイル単体では実行することができません．
実行を可能にするには<a href="#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB"><strong>リンク</strong></a>(link)処理を経て，
<a href="#%E5%AE%9F%E8%A1%8C%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB"><strong>実行可能ファイル</strong></a>
を作成する必要があります．</p>
<p>オブジェクトファイルは<strong>再配置可能オブジェクトファイル</strong>
(relocatable object file)と呼ばれることもあります．
オブジェクトファイルはリンク時に再配置（アドレス調整）が可能だからです．</p>
<h3 id="実行可能ファイル"><a class="header" href="#実行可能ファイル">実行可能ファイル(<code>a.out</code>)</a></h3>
<p><strong>実行可能ファイル</strong>(executable file)はその名前の通り，OSに実行を依頼すればそのままで実行できるバイナリファイルのことです．
例えば，hello wordの実行可能ファイル<code>a.out</code>はシェル上で以下のように実行できます．</p>
<pre><code class="language-bash">$ ./a.out
hello， world
</code></pre>
<details>
<summary>
シェルとは
</summary>
<p><strong>シェル</strong> (shell)とは「ユーザが入力したコマンドを解釈実行するプログラム」です．
例えば，<code>bash</code>, <code>zsh</code>, <code>csh</code>, <code>sh</code>, <code>ksh</code>, <code>tcsh</code>などはすべてシェルです．
Linux上ではユーザが自由にどのシェルを使うかを選ぶことができます．
シェルという名前は(OSの実体を<strong>カーネル</strong>(核)と呼ぶのに対して)
シェルがユーザに最も近い位置，つまりコンピュータシステムの外殻にあることに
由来してます(シェルの英語の意味は貝殻の殻(から)です)．
シェルは，ユーザが指定した<code>a.out</code>などのプログラムの実行を，
システムコール<code>execve</code>等を使ってOS(カーネル)に依頼します．</p>
<p>ちなみに<strong>ターミナル</strong> (端末，terminal)，あるいはターミナルエミュレータは，
ユーザの入出力処理を行うプログラムであり，ターミナル上でシェルは動作しています．</p>
</details>
<p><code>ls</code>などのシェル上で実行可能なコマンドも実行可能ファイルです．</p>
<pre><code class="language-bash">$ which ls
/usr/bin/ls
$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， ❶interpreter /lib64/ld-linux-x86-64.so.2， ❷BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd， for GNU/Linux 3.2.0， stripped
$ ls
a.out add5.c add5.o add5.s
</code></pre>
<p id="interpreter">
<details>
<summary>
❶interpreterとは
</summary>
<p>ELFバイナリの動的リンカのことを（なぜか）interpreterと呼びます．
プログラミング言語処理系のインタプリタとは何の関係もありません．
ELFバイナリでは動的リンカのフルパスを指定することができ，
そのフルパス名をバイナリに埋め込みます．
この場合は <code>/lib64/ld-linux-x86-64.so.2</code> が埋め込まれています．
OSが<code>a.out</code>を実行する際に，
OSはまず動的リンカ(interpreter)をメモリにロードして，
ロードした動的リンカに制御を渡します．
動的リンカは<code>a.out</code>中の他の部分や，動的ライブラリをメモリにロードし，
動的リンクを行ってから，<code>a.out</code>の<strong>エントリポイント</strong>
(最初に実行を開始するアドレス)にジャンプします．
その後，いくつかの初期化を行ってから，<code>main</code>関数が呼び出されます．</p>
<p><code>a.out</code>のエントリポイントは<code>readelf -h</code>コマンドで確認できます．
エントリポイントは<code>0x401050</code>番地でした❶．</p>
<pre><code class="language-bash">$ readelf -h ./a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement， little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
❶Entry point address:               0x401050
  Start of program headers:          64 (bytes into file)
  Start of section headers:          16832 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         36
  Section header string table index: 35
</code></pre>
<p>逆アセンブルすると<code>0x401050</code>番地は<code>_start</code>という関数がありました❷．
<code>a.out</code>は<code>_start</code>関数から実行が始まることが分かりました．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep 401050 -A 5
0000000000401050 ❷ &lt;_start&gt;:
  401050:	f3 0f 1e fa          	endbr64 
  401054:	31 ed                	xor    %ebp，%ebp
  401056:	49 89 d1             	mov    %rdx，%r9
  401059:	5e                   	pop    %rsi
  40105a:	48 89 e2             	mov    %rsp，%rdx
  40105d:	48 83 e4 f0          	and    $0xfffffffffffffff0，%rsp
</code></pre>
</details>
</p>
<details>
<summary>
❷BuildID[sha1]とは
</summary>
<p>BuildIDはバイナリファイルが同じかどうかを識別するユニークな番号（背番号）です．
ここでは<code>2f15</code>で始まる40桁の16進数が <code>/usr/bin/ls</code>のBuildIDです．
BuildIDはLinux ELF特有の機能です．
<code>strip</code>してもBuildIDは変化しないので，<code>strip</code>前後のファイルが同じかの確認に使えます．</p>
<pre><code class="language-bash">$ gcc hello.c
$ cp a.out a.out.stripped
$ strip a.out.stripped
$ file a.out a.out.stripped
a.out:          ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
a.out.stripped: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， stripped
</code></pre>
<p>ここでは説明しませんが<a href="./10-gdb.html#core-file"><strong>コアファイル</strong></a> (core file)にもBuildIDが入っており，
そのコアファイルを出力した<code>a.out</code>を探すことができます．</p>
<p>ちなみにsha1はSHA-1を意味しており，SHA-1は160ビットのハッシュを生成するハッシュ関数です．
<code>git</code>のハッシュはSHA-1を使っています．
<code>sha1sum</code>コマンドでSHA-1のハッシュを計算できます．</p>
<pre><code class="language-bash">$ sha1sum ./a.out
ff99525ad6a48d78d35d3108401af935a6ca9bbe  ./a.out
</code></pre>
<p>この結果から分かる通り，BuildIDのハッシュは，単純に<code>a.out</code>から作ったハッシュ値ではありません．
ELFバイナリのヘッダとセクションの一部からハッシュを計算しているようですが，正確な情報は見つかりませんでした(どうやら未公開のようです)．</p>
</details>
<p>実行可能なコマンドには実行可能ファイルではなく，
スクリプトなことがあります．</p>
<pre><code class="language-bash">$ which shasum
/usr/bin/shasum
$ file /usr/bin/shasum
/usr/bin/shasum: Perl script text executable
$ head -3 /usr/bin/shasum
#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+&quot;$@&quot;}'
	if 0; # ^ Run only under a shell
</code></pre>
<p><code>shasum</code>コマンドは(実行可能ファイルではなく)Perlスクリプトでした．</p>
<h3 id="静的ライブラリ"><a class="header" href="#静的ライブラリ">静的ライブラリ(<code>lib*.a</code>)</a></h3>
<p><strong>静的ライブラリ</strong>(static library)は<a href="#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
するときに使われるライブラリです．
<strong>ライブラリ</strong>とは複数のオブジェクトファイルを１つのファイルにまとめたもの（<strong>アーカイブ</strong>）です．</p>
<p>LinuxなどのUNIX系のOSでは静的ライブラリのファイル拡張子は<code>.a</code>が多いです．
またWindowsでは<code>.lib</code>です．
<code>printf</code>の実体が入っているC標準ライブラリの
静的ライブラリのファイル名は<code>libc.a</code>です．</p>
<h3 id="動的ライブラリ"><a class="header" href="#動的ライブラリ">動的ライブラリ(<code>lib*.so</code>)</a></h3>
<p><strong>動的ライブラリ</strong>(dynamic library)は<a href="#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>動的リンク</strong></a>
するときに使われるライブラリです．
動的ライブラリは<strong>共有ライブラリ</strong>(shared library)とも呼ばれます．
動的ライブラリは複数のプロセスからメモリ上で共有されるからです．</p>
<p>Linuxでは動的ライブラリのファイル拡張子は<code>.so</code>です(shared objectの略)．
処理系の都合でファイル拡張子に数字がつくことがあります（例：<code>.so.6</code>）．
動的ライブラリのファイル拡張子はUnix系のOSでも様々です．
Windowsでは<code>.dll</code>です．</p>
<h2 id="静的リンクと動的リンク"><a class="header" href="#静的リンクと動的リンク">静的リンクと動的リンク</a></h2>
<p>静的ライブラリは静的リンクに使われるライブラリで，
動的ライブラリは動的リンクに使われるライブラリです．</p>
<h3 id="静的リンク"><a class="header" href="#静的リンク">静的リンク</a></h3>
<p><strong>静的リンク</strong>とは<strong>コンパイル時</strong>にリンクを行う手法です．
仕組みは単純ですが，ファイルやメモリの使用量が増える欠点があります．
<a href="#fig:compile-all">この図</a>で説明したリンクは実は静的リンクでした．</p>
<p>静的リンクしたファイル<code>a.out</code>はリンク済みなので，
ライブラリ関数(例えば<code>printf</code>)の実体も<code>a.out</code>の中に入っています．</p>
<img src="figs/static-link-printf.svg" height="200px" id="fig:static-link-printf">
<p><code>a.out</code>ごとに<code>printf</code>のコピーが作られるので，
ファイルの使用量が無駄に増えてしまいます．
また<code>a.out</code>中の<code>printf</code>は実行時にもメモリ上で<strong>共有されない</strong>ので，
メモリの使用量も無駄に増えてしまいます．</p>
<h3 id="静的リンクでコンパイルしてみる"><a class="header" href="#静的リンクでコンパイルしてみる">静的リンクでコンパイルしてみる</a></h3>
<pre><code class="language-C">// hello.c
#include &lt;stdio.h&gt;
int main (int ac, char **ag)
{
    printf (&quot;hello (%d)\n&quot;, ac);
}
</code></pre>
<p>静的リンクするには<code>-static</code>オプションをつけます（<code>-static</code>無しだと動的リンクになります）．
<code>printf</code>に第2引数を与えているのは，こうしないと，コンパイラが勝手に
<code>printf</code>の呼び出しを<code>puts</code>に変更してしまうことがあるからです．</p>
<p><code>a.out</code>を<code>file</code>コマンドで確認すると<code>statically linked</code>とあり❶，
静的リンクできたことが分かります．</p>
<pre><code class="language-bash">$ gcc -static hello.c
$ file ./a.out
./a.out: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， ❶statically linked， BuildID[sha1]=40fe6c0daaf2d49fabad4d37bc34fcdd12cb8da9， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<details>
<summary>
練習問題：静的にリンクしたa.out中にprintfの実体があることを確認せよ
</summary>
<p><code>a.out</code>を逆アセンブルし，❶<code>&lt;main&gt;:</code>を含む行から15行を表示させます．
(❷<code>-A 14</code>は「マッチした行の後ろ14行も表示する」というオプションです)．
<code>main</code>関数は(<code>printf</code>ではなく)❸<code>_IO_printf</code>を呼び出していることを確認できます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep ❷-A 14 ❶&quot;&lt;main&gt;:&quot;
0000000000401cb5 &lt;main&gt;:
  401cb5:	f3 0f 1e fa          	endbr64 
  401cb9:	55                   	push   %rbp
  401cba:	48 89 e5             	mov    %rsp，%rbp
  401cbd:	48 83 ec 10          	sub    $0x10，%rsp
  401cc1:	89 7d fc             	mov    %edi，-0x4(%rbp)
  401cc4:	48 89 75 f0          	mov    %rsi，-0x10(%rbp)
  401cc8:	8b 45 fc             	mov    -0x4(%rbp)，%eax
  401ccb:	89 c6                	mov    %eax，%esi
  401ccd:	48 8d 3d 30 33 09 00 	lea    0x93330(%rip)，%rdi        # 495004 &lt;_IO_stdin_used+0x4&gt;
  401cd4:	b8 00 00 00 00       	mov    $0x0，%eax
  401cd9:	e8 72 ec 00 00       	callq  410950 ❸&lt;_IO_printf&gt;
  401cde:	b8 00 00 00 00       	mov    $0x0，%eax
  401ce3:	c9                   	leaveq 
  401ce4:	c3                   	retq   
</code></pre>
<blockquote>
<p>注：ここでは<code>egrep -A 14</code>としてますが，皆さんが試す時は，</p>
<pre><code class="language-bash">$ objdump -d ./a.out | less
</code></pre>
<p>としてから，<code>/&lt;main&gt;:</code>とリターンを入力して検索する方が便利でしょう．</p>
</blockquote>
<p>次に同じく<code>a.out</code>を逆アセンブルし，`&lt;_IO_printf&gt;:'を含む行から数行を表示させます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;_IO_printf&gt;:&quot;
0000000000410950 &lt;_IO_printf&gt;:
  410950:	f3 0f 1e fa          	endbr64 
  410954:	48 81 ec d8 00 00 00 	sub    $0xd8，%rsp
  41095b:	49 89 fa             	mov    %rdi，%r10
  41095e:	48 89 74 24 28       	mov    %rsi，0x28(%rsp)
  410963:	48 89 54 24 30       	mov    %rdx，0x30(%rsp)
</code></pre>
<p>これは<code>_IO_printf</code>の定義なので，<code>a.out</code>に<code>printf</code>の実体があることを確認できました．
なお，以下の<code>nm</code>コマンドでも，<code>a.out</code>に<code>printf</code>の実体があることを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep _IO_printf
0000000000410950 T _IO_printf
</code></pre>
<p>実は<code>_IO_printf</code>も<code>printf</code>も実体は同じです．処理系の都合で，
「実体は同じだけど別の名前をつける」ことがあり，それをエイリアス（別名）といいます．
0x410950番地で調べると，これを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 410950
0000000000410950 T _IO_printf
0000000000410950 T __printf
0000000000410950 T printf
</code></pre>
</details>
<h3 id="動的リンク"><a class="header" href="#動的リンク">動的リンク</a></h3>
<p><strong>動的リンク</strong>とは実行を始める際の<strong>ロード時</strong>（<code>a.out</code>をメモリにコピーする時）
あるいは<strong>実行途中</strong>にメモリ上でリンクを行う手法です．
現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．</p>
<p>動的リンクしたファイル<code>a.out</code>には
「ライブラリ関数(例えば<code>printf</code>)とのリンクが必要だよ」という
小さな参照情報だけが入っており，<code>printf</code>の実体は入っていません．
実際のリンクは実行時にメモリ上で行います．</p>
<img src="figs/dynamic-link-printf.svg" height="200px" id="fig:dynamic-link-printf">
<p><code>a.out</code>には<code>printf</code>を含まないので，ファイルの使用量を抑えられます．
また<code>a.out</code>中の<code>printf</code>は実行時にはメモリ上で<strong>共有される</strong>ので，
メモリの使用量も抑えられます．</p>
<p>ファイルサイズを比較してみると，静的リンクした<code>a.out-static</code>は約870KB，
動的リンクした<code>a.out-dynamic</code>は約17KBで，50倍ものサイズ差がありました．</p>
<pre><code class="language-bash">$ gcc -static -o a.out-static hello.c
$ gcc -o a.out-dynamic hello.c
$ ls -l a.out*
-rwxrwxr-x 1 gondow gondow  16696 Jul 20 17:52 a.out-dynamic
-rwxrwxr-x 1 gondow gondow 871832 Jul 20 17:51 a.out-static
</code></pre>
<h3 id="動的リンクでコンパイルしてみる"><a class="header" href="#動的リンクでコンパイルしてみる">動的リンクでコンパイルしてみる</a></h3>
<p>Linuxでは<code>-static</code>オプションをつけなければ動的リンクになります．</p>
<pre><code class="language-bash">$ gcc hello.c
$ file a.out
a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<p>実行時にリンクが必要な動的ライブラリの情報は<code>ldd</code>コマンドで表示できます．</p>
<pre><code class="language-bash">$ ldd ./a.out
	❶linux-vdso.so.1 (0x00007ffd21638000)
	❷libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcfef5c1000)
	❸/lib64/ld-linux-x86-64.so.2 (0x00007fcfef7d8000)

</code></pre>
<p>この<code>a.out</code>は<code>linux-vsdo.so.1</code>，<code>libc.so.6</code>，<code>ld-linux-x86-64.so.2</code>という
3つの動的ライブラリと実行時にリンクする必要があることを表示しています．
<code>libc.so.6</code>は（<code>LD_LIBRARY_PATH</code>などの設定がなければ）
絶対パス<code>/lib/x86_64-linux-gnu/libc.so.6</code>とリンクされます．</p>
<details>
<summary>
❶linux-vdso.so.1とは
</summary>
<p>vDSO (virtual dynamic shared objectの略)で，カーネル空間で実行する必要が無い
システムコール(例えば<code>gettimeofday</code>)を高速に実行するための仕組みです．</p>
<ul>
<li><a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></li>
</ul>
</details>
<details>
<summary>
❷libc.so.6とは
</summary>
<p>C標準ライブラリが入った動的ライブラリです．
<code>nm -D</code>コマンドで調べると，<code>printf</code>の実体が入っていることが分かります．
(<code>-D</code>は共有ライブラリで使われる動的シンボルを表示させるオプションです）</p>
<pre><code class="language-bash">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | egrep ' T printf'
0000000000061c90 T printf
0000000000061100 T printf_size
0000000000061bb0 T printf_size_info
</code></pre>
<p><code>-D</code>オプションをつけないと「❶シンボルが無いよ」と言われてしまいます．
(動的シンボル以外は<code>strip</code>されているからです)</p>
<pre><code class="language-bash">$ nm /lib/x86_64-linux-gnu/libc.so.6
nm: /lib/x86_64-linux-gnu/libc.so.6: ❶no symbols
</code></pre>
</details>
<details>
<summary>
❸ld-linux-x86-64.so.2とは
</summary>
<p>動的リンクを行うプログラム（共有ライブラリ），つまり動的リンカです．
<a href="#interpreter">interpreterとは</a>も参照下さい．</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man ld-linux.so</a></li>
</ul>
</details>
<details id="LD_LIBRARY_PATH">
<summary>
LD_LIBRARY_PATHとは
</summary>
<p><code>a.out</code>実行時には，
動的リンカは動的ライブラリをある手順に従って検索します（詳細は<code>man ld</code>）．
通常はデフォルトのパス（<code>/lib</code>や<code>/usr/lib</code>など）にある動的ライブラリを使いますが，
環境変数<code>LD_LIBRARY_PATH</code>にディレクトリ（複数ある場合は
コロン<code>:</code>で区切る）をセットすることで検索パスを追加できます．
具体的には，
動的リンカは<code>LD_LIBRARY_PATH</code>で指定したディレクトリを
（デフォルトの検索パスよりも先に）検索し，
そこにある動的ライブラリを優先的に使います．
（<a href="#LD_RUN_PATH"><code>LD_RUN_PATH</code></a>も参照下さい）．</p>
</details>
<details>
<summary>
練習問題：動的にリンクしたa.out中にprintfの実体が無いことを確認せよ
</summary>
<p><code>nm</code>コマンドで<code>a.out</code>には<code>main</code>を始めごく少数の
関数しか定義しておらず，その中に<code>printf</code>は入っていないことが以下で確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep ' T '
00000000000011f8 T _fini
00000000000011f0 T __libc_csu_fini
0000000000001180 T __libc_csu_init
0000000000001149 T main
0000000000001060 T _start
</code></pre>
<p>また<code>nm</code>の出力を<code>printf</code>で検索すると，GLIBC中の<code>printf</code>への参照はあるが
<code>a.out</code>中では未定義(<code>U</code>)となっていることが分かります．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 'printf'
                 U printf@@GLIBC_2.34
</code></pre>
<div  id="GOT-PLT">
<p>なお逆アセンブルすると<code>&lt;printf@plt&gt;</code>という小さな関数が見つかりますが，
これは<code>printf</code>の実体ではありません．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;printf&quot;
0000000000001050 &lt;printf@plt&gt;:
    1050:	f3 0f 1e fa          	endbr64 
    1054:	f2 ff 25 75 2f 00 00 	bnd jmpq ❶*0x2f75(%rip)        # 3fd0 &lt;printf@GLIBC_2.34&gt;
    105b:	0f 1f 44 00 00       	nopl   0x0(%rax，%rax，1)
</code></pre>
<p><code>&lt;printf@plt&gt;</code>は<code>printf</code>を呼び出す単なる踏み台で，
PLT (procedure linkage table)という仕組みです．
PLTは<code>printf</code>の最初の呼び出しまで<code>printf</code>の<strong>アドレス解決</strong>
(address resolution)を遅延します．具体的には次の2ステップになります．</p>
<ul>
<li><code>printf@plt</code>の間接ジャンプ先❶の初期値は「動的リンクする関数（動的リンカ）」になっているため，最初に<code>printf@plt</code>が呼ばれると，動的リンクを行い，その結果，間接ジャンプ先が「<code>printf</code>の実体」に変更されます❷．
そして動的リンカは何もなかったかのように<code>printf</code>を呼び出します．
（ちなみに<code>printf@plt</code>の間接ジャンプで参照するメモリ領域は GOT (global offset table)と呼ばれます）</li>
<li>その結果，2回目以降の以下の間接ジャンプ❶では(動的リンカを経由せずに)<code>printf</code>が呼ばれます．</li>
</ul>
<p>つまり，GOTに<code>printf</code>のアドレスを格納することが，ここではアドレス解決になっています．</p>
<img src="figs/plt-printf.svg" height="400px" id="fig:plt-printf">
</div>
</details>
<h3 id="静的ライブラリを作成してみる"><a class="header" href="#静的ライブラリを作成してみる">静的ライブラリを作成してみる</a></h3>
<p id="main.c-static">
<pre><code class="language-C">// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main (void)
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
</p>
<p id="add5.c-static">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ ar rcs libadd5.a add5.o  ❶
$ ar t libadd5.a
add5.o  ❷
$ file libadd5.a
libadd5.a: current ar archive
$ gcc ❸-static -o a.out-static main.c ❹-L. ❺-ladd5
$ file a.out-static
file ./a.out-static
./a.out-static: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， statically linked， BuildID[sha1]=1bf84a77504302513d6219e4b27316309d08ed2d， for GNU/Linux 3.2.0， not stripped
$ ./a.out-static 
15 ❻
</code></pre>
<ul>
<li>❶ <code>ar rcs</code>コマンドで<code>add5.o</code>から<code>libadd5.a</code>を作成します．</li>
<li>❷  <code>ar t</code>コマンドで<code>libadd5.a</code>の中身を調べます．中身は<code>add5.o</code>だけでした．</li>
<li>❸❹❺ <code>gcc</code>で<code>main.c</code>と<code>libadd5.a</code>を静的リンクします．
静的リンクするために❸<code>-static</code>オプションが必要です．
<code>libadd5.a</code>がカレントディレクトリにあることを伝えるために❹<code>-L.</code>が必要です．
静的リンクする静的ライブラリが<code>libadd5.a</code>であることを伝えるために
❺<code>-ladd5</code>が必要です．（前の<code>lib</code>と後の<code>.a</code>は自動的に付加されます）</li>
<li>❻ 実行してみると，静的ライブラリ<code>libadd5.a</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<h3 id="動的ライブラリを作成してみる"><a class="header" href="#動的ライブラリを作成してみる">動的ライブラリを作成してみる</a></h3>
<p><a href="#add5.c-static"><code>add5.c</code></a>と<a href="#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ gcc ❶-fPIC ❷-shared -o libadd5.so add5.o
$ file libadd5.so
libadd5.so: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， BuildID[sha1]=415ef51f32145b59c51e836a25959f0f66039768， not stripped
$ gcc main.c -ladd5 -L. ❸-Wl，-rpath .
$ file ./a.out
./a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=a5d4f8ef61cef4e0b063376333f07170d312c546， for GNU/Linux 3.2.0， not stripped
$ ldd ./a.out
	linux-vdso.so.1 (0x00007ffff7fcd000)
	libadd5.so =&gt; ❹./libadd5.so (0x00007ffff7fbd000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dad000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
$ ./a.out
15 ❺ 
</code></pre>
<ul>
<li>❶❷ <code>add5.c</code>から動的ライブラリ<code>libadd5.so</code>を作ります．
<code>libadd5.so</code>を<strong>位置独立コード</strong>(PIC)にするために，❶<code>-fPIC</code>が必要です．
<code>libadd5.so</code>を<strong>共有オブジェクト</strong>(shared object)にするために，❷<code>-shared</code>が必要です．</li>
<li>❸ <code>gcc</code>で<code>main.c</code>と<code>libadd5.so</code>を動的リンクします．
実行時に動的ライブラリを探索するパスを❸<code>-Wl，-rpath .</code>で指定しています．
ここでは<code>libadd5.so</code>をカレントディレクトリに置いているためです．
（セキュリティ上，実際に使う際は絶対パスを指定する方が安全でしょう）．
ちなみに<code>-Wl，-rpath .</code>を<code>gcc</code>に指定すると，
<a href="https://man7.org/linux/man-pages/man1/ld.1.html"><code>ld</code>コマンド</a>
に<code>-rpath .</code>というオプションが渡されます	．</li>
<li>❹ <code>ldd</code>コマンドで調べると，<code>a.out</code>中の<code>libadd5.so</code>は
<code>./libadd5.so</code>を参照していることを確認できました．</li>
<li>❺ 実行してみると，動的ライブラリ<code>libadd5.so</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<details ID="LD_RUN_PATH">
<summary>
-rpath，LD_RUN_PATH，LD_LIBRARY_PATH
</summary>
<p>❸<code>-Wl，-rpath .</code>はコンパイル時に「動的ライブラリの検索パス」を<code>a.out</code>中に埋め込みます．
以下のコマンド等で確認できます（❻の部分）．</p>
<pre><code>$ readelf -d ./a.out | egrep PATH
 0x000000000000001d (RUNPATH)            Library runpath: ❻[.]
</code></pre>
<p><code>-Wl，-rpath .</code>で指定する検索パスは環境変数<code>LD_RUN_PATH</code>でも指定できます．
（複数の検索パスはコロン<code>:</code>で区切ります）．</p>
<pre><code>$ export LD_RUN_PATH=&quot;.&quot;
$ gcc main.c -ladd5 -L. 
$ readelf -d ./a.out | egrep PATH
 0x000000000000001d (RUNPATH)            Library runpath: [.]
</code></pre>
<p><a href="#LD_LIBRARY_PATH"><code>LD_LIBRARY_PATH</code></a>を使うと，
<code>a.out</code>中の検索パス以外の動的ライブラリを実行時に動的リンクできます．
例えば，以下で<code>ldd</code>コマンドを使うと，
<code>/tmp/libadd5.so</code>が使われることを確認できます❼．</p>
<pre><code>$ export LD_LIBRARY_PATH=&quot;/tmp&quot;
$ cp libadd5.so /tmp
$ ldd ./a.out
	libadd5.so =&gt; ❼/tmp/libadd5.so (0x00007ffffffb8000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fffffd8b000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffffffc4000)
</code></pre>
<p>なお<code>LD_LIBRARY_PATH</code>は危険で強力なので，なるべく使うのは避けるべきです．
使う場合は最新の注意を払って使いましょう．
なぜならば，例えば，<code>/tmp/libc.so.6</code>という悪意のある動的ライブラリがあると，
<code>/tmp/libc.so.6</code>中の<code>printf</code>が呼び出されてしまうからです．
（この<code>printf</code>の中身はコンピュータウイルスかも知れません）</p>
</details>
<details id="PIC">
<summary>
位置独立コードとは
</summary>
<p><strong>位置独立コード</strong>(position independent code， PIC)とはメモリ上の
どこにロードしても，そのまま実行できるコードです．
位置独立コードでは絶対アドレスは使わず（再配置が必要になってしまうから），
相対アドレスか間接アドレス参照だけを使います．
位置独立コードにすることで，メモリ上で動的ライブラリを共有できるため，
メモリ使用量を抑えることができます．</p>
</details>
<h2 id="デバッグ情報"><a class="header" href="#デバッグ情報">デバッグ情報</a></h2>
<h3 id="デバッグ情報とは"><a class="header" href="#デバッグ情報とは">デバッグ情報とは</a></h3>
<p><strong>デバッグ情報</strong>とは<code>gcc</code>に<code>-g</code>オプションをつけると
バイナリに付加される情報で，
デバッグ時に有用なソースコード中の情報を含んでいます．
例えば，変数の型情報や，ソースコード中の行番号が挙げられます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ file ./a.out
./a.out: ELF 64-bit LSB pie executable， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=68a01f5977ae542600062913c447a7ba7f2fad62， for GNU/Linux 3.2.0， ❷ with debug_info， not stripped
</code></pre>
<p>❶<code>-g</code>オプションをつけてコンパイルしてから，<code>file</code>コマンドで調べると，
❷デバッグ情報が含まれていることを確認できます．</p>
<p>コンパイラは様々なデバッグ情報の形式を扱えます．
LinuxのELFバイナリでは<a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARFデバッグ情報</a>
が使われることが多いです．(以下，DWARFを前提として説明します)</p>
<h3 id="no-debug-info"><a class="header" href="#no-debug-info">デバッグ情報が無いと，デバッガでファイル名や行番号が表示されない</a></h3>
<p>デバッグ情報無しでデバッガ<code>gdb</code>を使うとどうなるか試してみましょう．
<a href="#add5.c-static"><code>add5.c</code></a>と<a href="#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．
(<code>gdb</code>の使い方の詳細は<a href="./10-gdb.html">デバッガgdbの使い方</a>を参照下さい)．</p>
<pre><code class="language-bash">$ gcc ❶ main.c add5.c
$ gdb ./a.out
(gdb) ❷ b add5
Breakpoint 1 at 0x1175
(gdb) ❸ r
Starting program: /tmp/a.out 
Breakpoint 1， 0x0000555555555175 in ❹ add5 ()
(gdb) bt
#0 ❻ 0x0000555555555175 in ❺ add5 ()
#1    0x000055555555515b in    main ()
(gdb) quit
</code></pre>
<p><code>-g</code>オプション無しで❶コンパイルしています．
<code>add5</code>関数にブレークポイントを設定❷します．
<strong>ブレークポイント</strong>とはプログラムの実行を一時的に停止する場所です．
関数名<code>add5</code>でブレークポイントを指定したので，
実行すると<code>add5</code>関数の先頭で実行が一時停止します．</p>
<p>❸ runコマンド (<code>r</code>はrunコマンドの省略形)で実行した所，
<code>add5</code>関数でブレーク(実行を一時停止)できたのですが，
関数名<code>add5</code>だけが表示され，<strong>ファイル名や行番号が表示されません</strong>❹．
バックトレースを出力しても同様です❺．</p>
<p>バックトレースとは「<code>main</code>関数から現在実行中の関数までの，
関数呼び出し系列」のことです．
ここでは<code>main</code>関数が<code>add5</code>関数を呼び出しただけなので，
バックトレースは2行しかありません．
❻<code>0x0000555555555175</code>は<code>add5</code>関数が
<code>0x0000555555555175</code>番地の機械語命令を実行する直前で実行を停止していることを
示しています．</p>
<h3 id="デバッグ情報があるとデバッガでファイル名や行番号が表示される"><a class="header" href="#デバッグ情報があるとデバッガでファイル名や行番号が表示される">デバッグ情報があると，デバッガでファイル名や行番号が表示される</a></h3>
<p>今回はデバッグ情報ありでデバッガを使ってみます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1175: ❷ file add5.c， line 2.
(gdb) r
Starting program: /tmp/a.out 
Breakpoint 1， add5 (n=10) at ❸ add5.c:2
2	{
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:2
#1  0x000055555555515b in main () at main.c:5

$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: ❷ file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at ❸ add5.c:3
3	    return n + 5;
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:3
#1  0x000055555555515b in main () at main.c:5
</code></pre>
<ul>
<li>❶ <code>-g</code>をつけたので，<code>a.out</code>にはデバッグ情報が付加されています．</li>
<li><a href="#no-debug-info">先程</a>とは異なり，❷❸❹ファイル名<code>add5.c</code>や行番号<code>3</code>が付加されています．</li>
</ul>
<h3 id="デバッグ情報があると行番号とアドレスを相互変換できる"><a class="header" href="#デバッグ情報があると行番号とアドレスを相互変換できる">デバッグ情報があると，行番号とアドレスを相互変換できる．</a></h3>
<h4 id="addr2line"><a class="header" href="#addr2line">アドレス→行番号の変換</a></h4>
<p>デバッグ情報があるバイナリに対しては，
<code>addr2line</code>コマンドでアドレスを対応する行番号に変換できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ objdump -d ./a.out | egrep -A 4 &quot;&lt;main&gt;:&quot;
0000000000001149 &lt;main&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp，%rbp
    1151:	bf 0a 00 00 00       	mov    $0xa，%edi
$  addr2line -e ./a.out ❶ 0x1149
❷/tmp/main.c:4
</code></pre>
<p>上の実行例では<code>addr2line</code>コマンドで，
<code>0x1149</code>番地の機械語命令はソースコードでは❷<code>/tmp/main.c</code>の4行目に
対応していることが分かりました．</p>
<p>デバッガ上でも確かめてみましょう．</p>
<pre><code>(gdb) b main
Breakpoint 1 at 0x1151: file main.c， line 5.
(gdb) r
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
(gdb) ❶ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
(以下略)
(gdb) ❷ info line *0x0000555555555149 
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
(gdb) ❸ info line main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<ul>
<li>(objdumpコマンドでも可能ですが)
<code>gdb</code>上でも逆アセンブルできます．
逆アセンブルのコマンドは<code>disassemble</code>ですが長いので，
短縮名<code>disas</code>をここでは使っています．
(<code>gdb</code>は他のコマンドと区別できる範囲で，コマンド名を省略できます)．
<a href="#ASLR-PIE">ASLRとPIE</a>が有効な場合，
デバッガ上で逆アセンブルすると，実際のメモリのアドレスが表示されて便利です．
この場合，<a href="#addr2line">上</a>では<code>0x1149</code>番地だったのに，
<code>0x0000555555555149</code>番地に変わっています．</li>
<li><code>gdb</code>の❷<code>info line</code>コマンドを使うと，アドレスから行番号に変換できます．
<code>0x555555555149</code>番地は<code>main.c</code>の4行目に対応しており，
また，この行は機械語命令では<code>0x555555555149</code>番地から<code>0x555555555151</code>に
対応していると表示されています．</li>
<li><code>gdb</code>上では❸<code>info line</code>コマンドを使って，
行番号からアドレスへの変換もできます．</li>
</ul>
<p>なお，<code>gdb</code>で<code>layout asm</code>とすると逆アセンブル結果を常に表示できます．
ブレークポイント(左端の<code>b</code>や<code>B</code>)や次に実行する機械語命令の位置(<code>&gt;</code>)が
表示されて分かりやすいです．</p>
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<details>
<summary>
B+ってどういう意味
</summary>
<ul>
<li><code>B</code>は少なくても一度はブレークしたブレークポイント</li>
<li><code>b</code>は一度もブレークしていないブレークポイント</li>
<li><code>+</code>は有効化されているブレークポイント</li>
<li><code>-</code>は無効化されているブレークポイント</li>
</ul>
</details>
<h4 id="行番号アドレスの変換"><a class="header" href="#行番号アドレスの変換">行番号→アドレスの変換</a></h4>
<p>コマンドライン上で，行番号をアドレスに変換するには
(コマンドがちょっと長くなりますが)以下のように<code>gdb</code>を使います．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;info line main.c:4&quot; --batch
Line 4 of &quot;main.c&quot; starts at address ❶0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<p>上ではプログラムを実行せずにアドレスを取得したので，
<code>a.out</code>ファイル中のアドレス❶<code>0x1149</code>が表示されています．
実行時のアドレスを表示したいなら，以下のようにします
(バッチモードで，<code>b main</code>，<code>run</code>，<code>info line main.c:4</code>という3つのコマンドを実行しています)．
実行時のアドレス❷<code>0x555555555149</code>を表示できました．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;b main&quot; -ex &quot;r&quot; -ex &quot;info line main.c:4&quot; --batch
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
Line 4 of &quot;main.c&quot; starts at address ❷0x555555555149 &lt;main&gt; and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<p>以下のように<code>line2addr</code>などの名前でシェル関数を定義すれば，
短く書けます(が，そんなに頻繁には使わないかも)．</p>
<pre><code class="language-bash">$ function line2addr () {
&gt; command gdb $1 -ex &quot;info line $2&quot; --batch
&gt; }
$ line2addr ./a.out main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<h3 id="デバッグ情報があると逆アセンブル時にソースコードも表示できる"><a class="header" href="#デバッグ情報があると逆アセンブル時にソースコードも表示できる">デバッグ情報があると，逆アセンブル時にソースコードも表示できる</a></h3>
<p>デバッグ情報がある場合，
(<code>objdump -d</code>ではなく)<code>objdump -S</code>で逆アセンブルすると
ソースコードも表示できます．
❶関数<code>add5</code>の定義部分であること，
❷<code>return n + 5;</code>の行のコンパイル結果であること，
などが見やすくなります．</p>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ objdump -S ./add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
❶ int add5 (int n)
{
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
 ❷ return n + 5;
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
}
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<h3 id="デバッガでレジスタの値を確認する"><a class="header" href="#デバッガでレジスタの値を確認する">デバッガでレジスタの値を確認する</a></h3>
<p>デバッガでレジスタの値を確認できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./aout
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) p ❶ $rdi
$1 = 10
(gdb) ❷ info reg
Undefined info command: &quot;regs&quot;.  Try &quot;help info&quot;.
(gdb) info reg
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe048      140737488347208
rsi            0x7fffffffe038      140737488347192
rdi            0xa                 10
(以下略，qを押して表示を停止)
</code></pre>
<ul>
<li>❶ <code>gdb</code>では<code>%</code>ではなく<code>$</code>をつけてレジスタ名を指定します．
<code>p</code>は<code>print</code>コマンドの省略名です．<code>%rdi</code>の値が<code>10</code>であることが分かりました．
16進数で表示したい場合は，<code>p/x $rdi</code>と<code>/x</code>をつけます</li>
<li>❷ レジスタの値一覧は<code>info reg</code>で表示できます．ページャが起動されるので，<code>q</code>を押して表示を停止します．</li>
</ul>
<p><code>gdb</code>で<code>layout regs</code>とすると，レジスタの値を常に表示できます．</p>
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
<ul>
<li><code>layout regs</code>するとレジスタの値一覧が表示されます．
上から「レジスタ表示」「ソースコード表示」「コマンド入力」のためのウィンドウです．</li>
<li><code>focus regs</code>や，<code>ctrl-x o</code>などを入力すると，レジスタ表示ウィンドウが選択されます．
この状態で↓キーを押すと(あるいはマウスでスクロールされると）
レジスタ表示ウィンドウの表示をスクロールできます．</li>
<li><code>ctrl-x a</code>を入力すると，元の表示方法に戻ります．</li>
</ul>
<h3 id="デバッガでメモリの値を確認する"><a class="header" href="#デバッガでメモリの値を確認する">デバッガでメモリの値を確認する</a></h3>
<p><a href="#add5.c-static"><code>add5.c</code></a>と<a href="#main.c-static"><code>main.c</code></a>を
を実行し，<code>add5</code>関数のスタックフレームが作成された直後は
以下の図(<a href="./2-asm-intro.html#create-new-stack-frame">ここ</a>で使った図の再掲)
になっています．</p>
<img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
<p>これをデバッガで確認しましょう．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) disas
Dump of assembler code for function add5:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    %edi，-0x4(%rbp)
=&gt; 0x0000555555555183 &lt;+11&gt;:	mov    -0x4(%rbp)，%eax
   0x0000555555555186 &lt;+14&gt;:	add    $0x5，%eax
   0x0000555555555189 &lt;+17&gt;:	pop    %rbp
   0x000055555555518a &lt;+18&gt;:	ret    
(gdb) ❶ p/x $rsp
$1 = 0x7fffffffdf10
(gdb) ❷ p/x $rbp
$2 = 0x7fffffffdf10
(gdb) ❸ x/1gx 0x7fffffffdf10
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❹ x/1gx $rsp
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❺ x/8bx $rsp
0x7fffffffdf10:	0x20 0xdf 0xff 0xff 0xff 0x7f 0x00 0x00
</code></pre>
<ul>
<li>
<p>❶❷ <code>%rsp</code>と<code>%rbp</code>レジスタの値を調べると，どちらも
<code>0x7fffffffdf10</code>番地でした．</p>
</li>
<li>
<p>❸ <code>x/1gx 0x7fffffffdf10</code> はメモリの中身を表示するコマンドです．</p>
<ul>
<li><code>x</code>のコマンド名は examine memory から来ています．</li>
<li><code>/1gx</code>は出力形式を指定しています．
この場合は「8バイトのデータを16進表記で1つ表示」という意味です．</li>
</ul>
</li>
</ul>
<details>
<summary>
xコマンドの表示オプション
</summary>
<p><code>x</code>コマンドの表示オプションには以下があります(他にもあります)．</p>
<ul>
<li><code>x</code>  16進数</li>
<li><code>d</code>  符号あり10進数</li>
<li><code>u</code>  符号なし10進数</li>
<li><code>t</code>   2進数</li>
<li><code>c</code>  文字</li>
<li><code>s</code>  文字列</li>
</ul>
<p>データのサイズ指定には以下があります．</p>
<ul>
<li><code>b</code>  1バイト (byte)</li>
<li><code>h</code>  2バイト (halfword)</li>
<li><code>w</code>  4バイト (word)</li>
<li><code>g</code>  8バイト (giant)</li>
</ul>
</details>
<details>
<summary>
サイズの用語がバラバラ過ぎる！
</summary>
<p>以下の通り，GNUアセンブラ(AT&amp;T形式)，Intel形式，<code>gdb</code>で各サイズに対する
用語がバラバラです．混乱しやすいので要注意です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1バイト</th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>byte (b)</td><td>short (s)</td><td>long (l)</td><td>quad (q)</td></tr>
<tr><td>Intel形式</td><td>byte</td><td>word</td><td>double word (dword)</td><td>quad word (qword)</td></tr>
<tr><td><code>gdb</code></td><td>byte (b)</td><td>halfword (h)</td><td>word (w)</td><td>giant (g)</td></tr>
</tbody></table>
</div></details>
<ul>
<li>❹ 具体的なアドレス(ここでは<code>0x7fffffffdf10</code>)ではなく，
レジスタ名 (ここでは<code>$rsp</code>)を指定して，
　そのレジスタが指しているメモリの中身を表示できます．</li>
<li>❺ <code>/1gx</code>ではなく<code>/8bx</code>と表示形式を指定すると，
「1バイトのデータを16進表記で8個表示」という意味になります．
<code>0x7FFFFFFFDF10</code>から<code>0x7FFFFFFFDF17</code>までの各番地には，それぞれ，
以下の図の通り，
<code>0x20</code>，<code>0xDF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0x7F</code>，<code>0x00</code>，<code>0x00</code>という値が
メモリ中に入っていることが分かります．
この格納されている8バイトのデータ<code>0x00007fffffffdf20</code>はアドレスであり，
以下の図の一番下のアドレス(赤字の部分)を指しています．</li>
</ul>
<img src="figs/stack-add5-layout.svg" height="350px" id="fig:stack-add5-layout">
<pre><code>(上のデバッグの続き)
(gdb) ❻ x/1gx $rsp+8
0x7fffffffdf18:	0x000055555555515b
(gdb) ❼ x/8bx $rsp+8
0x7fffffffdf18:	0x5b	0x51	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) ❽ disas 0x000055555555515b
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
❾ 0x000055555555515b &lt;+18&gt;:	mov    %eax，%esi
   0x000055555555515d &lt;+20&gt;:	lea    0xea0(%rip)，%rax        # 0x555555556004
   0x0000555555555164 &lt;+27&gt;:	mov    %rax，%rdi
   0x0000555555555167 &lt;+30&gt;:	mov    $0x0，%eax
   0x000055555555516c &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x0000555555555171 &lt;+40&gt;:	mov    $0x0，%eax
   0x0000555555555176 &lt;+45&gt;:	pop    %rbp
   0x0000555555555177 &lt;+46&gt;:	ret    
End of assembler dump.
</code></pre>
<ul>
<li>❻ <code>x/1gx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスの中身を表示させています．
<code>8(%rsp)</code>の意味は「<code>%rsp</code>の値に8を足したアドレス」です．
<code>gdb</code>中では「<code>$rsp + 8</code>」と入力します．</li>
<li>❼ <code>x/8bx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスを1バイトごとに表示しました．
上記の図の通り， 
<code>0x7FFFFFFFDF18</code>から<code>0x7FFFFFFFDF1F</code>までの各番地には，それぞれ，
<code>0x5B</code>，<code>0x51</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x00</code>，<code>0x00</code>が
格納されていることが分かりました．</li>
<li>❻の結果で得た<code>0x000055555555515b</code>番地を使って❽逆アセンブルしてみると，
❾この番地は「<code>call add5</code>」の次の命令 (この場合は <code>mov %eax， %esi</code>)であることが
分かりました．
このように，<strong>戻り番地</strong> (return address)は通常，
「その関数を呼び出した<code>call</code>命令の次の命令のアドレス」になります．</li>
</ul>
<details>
<summary>
戻り番地が通常ではない場合って?
</summary>
<p><strong>末尾コール最適化</strong> (tail-call optimization; TCO)が起こった時が該当します．</p>
<form class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="150px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="140px" id="fig:tail-call-opt2">
    </div>
</form>
<ul>
<li>上の「末尾コール最適化の前」の図では<code>main</code>関数が<code>A</code>を呼び，
関数<code>A</code>が<code>B</code>を呼んでいます．また逆の順番でリターンします．
しかし，<code>call B</code>の次の命令が<code>ret</code> (次の命令❷)になっているため，
関数<code>B</code>からリターンした後，関数<code>A</code>では何もせず，<code>main</code>にリターンしています．</li>
<li>そこで「末尾コール最適化の後」の図のように，関数<code>A</code>中の<code>call</code>命令を
無条件ジャンプ命令 <code>jmp</code>に書き換えて，関数<code>B</code>からは(<code>A</code>を経由せず)
直接，<code>main</code>関数のリターンするように書き換えて無駄なリターンを省くことができます．
これが末尾コール最適化です．</li>
<li>その結果，関数<code>B</code>のリターンアドレスは，関数<code>A</code>中の<code>call</code>命令の次のアドレス
(次の命令❷)ではなく，関数<code>main</code>中の「次の命令❶」となってしまいました．
これが戻り番地が通常ではない場合の一例です．</li>
</ul>
</details>
<h3 id="デバッグ情報を直接見る"><a class="header" href="#デバッグ情報を直接見る">デバッグ情報を直接見る</a></h3>
<p><code>objdump</code>，<code>readelf</code>，<code>llvm_dwarfdump</code>コマンドを使うと，
デバッグ情報の中身を直接見ることができます．</p>
<h4 id="objdump--w"><a class="header" href="#objdump--w"><code>objdump -W</code></a></h4>
<p>デバッグ情報には例えば，以下のものがあります</p>
<ul>
<li>デバッグ情報 (<code>.debug_info</code>)</li>
<li>行情報 (<code>.debug_line</code>)</li>
<li>アドレス情報 (<code>.debug_aranges</code>)</li>
<li>フレーム情報 (<code>.eh_frame</code>)</li>
<li>省略情報 (<code>.debug_abbrev</code>)</li>
</ul>
<p><code>objdump -W add5.o</code> とすると，<code>add5.o</code>中のデバッグ情報を全て表示します
<code>-Wi</code>， <code>-Wl</code>， <code>-Wr</code>， <code>-Wf</code>，<code>-Wa</code>とすると，
それぞれ，デバッグ情報，行情報，アドレス情報，フレーム情報，
省略情報だけを表示できます．</p>
<pre><code class="language-bash">$ objdump -W add5.o | less
add5.o:     file format elf64-x86-64

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string， offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string， offset: 0x5): add5.c
(以下略)
</code></pre>
<p>上記の出力例では例えば「ファイル名<code>add5.c</code>を省略番号<code>1</code>とします」という情報を含んでいます（詳細は省略し．
<strong>コンパイル単位</strong> (compile unit)とはファイルのことです．</p>
<p>例えば，以下の部分は
仮引数の情報として「変数名は❻<code>n</code>，
❷<code>add5.c</code>の❸1行目❹15カラム目で宣言されていて，
型は❺<code>&lt;0x5e&gt;</code>を見てね．変数の場所は❻<code>(DW_OP_fbreg: -20)</code>」となってます．</p>
<pre><code>&lt;2&gt;&lt;50&gt;: Abbrev Number: 3 (DW_TAG_formal_parameter)
    &lt;51&gt;   DW_AT_name        : ❶ n
    &lt;53&gt;   DW_AT_decl_file   : ❷ 1
    &lt;54&gt;   DW_AT_decl_line   : ❸ 1
    &lt;55&gt;   DW_AT_decl_column : ❹ 15
    &lt;56&gt;   DW_AT_type        : ❺ &lt;0x5e&gt;
    &lt;5a&gt;   DW_AT_location    : 2 byte block: 91 6c ❻ (DW_OP_fbreg: -20)
</code></pre>
<details>
<summary>
❻DW_OP_fbreg: -20とは
</summary>
<p>「CFA (canonical frame address)から -20バイトのオフセットの位置」を意味しています．
CFAはDWARFデバッグ情報が定める仮想的なレジスタでCPUごとに異なります．
x86-64の場合は「<code>call</code>命令を実行する直前の<code>%rsp</code>の値」なので，以下になります．
(<code>call</code>命令が戻り番地をスタックにプッシュすることを思い出しましょう)．
引数<code>n</code>(下図で赤い部分)の先頭アドレスは，
CFAからちょうど-20バイトの場所にあることが確認できました．</p>
<img src="figs/stack-layout-CFA.svg" height="400px" id="fig:stack-layout">
<p><a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>でコンパイルされていなければ，
(通常は関数の先頭で<code>push %rbp</code>するので)以下の式が成り立ちます．</p>
<pre><code class="language-math">CFA == %rbp + 16
</code></pre>
<p>なお，<code>fbreg</code> は frame base registerの略だと思います．</p>
</details>
<details>
<summary>
Abbrev Number (省略番号)とは
</summary>
<p>例えば，以下のDIE（<a href="#DIE">デバッグ情報の部品</a>）で Abbrev Number は ❶4となっています．</p>
<pre><code class="language-bash">$ objdump -Wi add5.o
(一部略)
&lt;1&gt;&lt;5e&gt;: Abbrev Number: ❶4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : 4
    &lt;60&gt;   DW_AT_encoding    : 5         (signed)
    &lt;61&gt;   DW_AT_name        : int
</code></pre>
<p><code>objdump -Wa</code>で<code>.debug_abbrev</code>を表示すると4番目のエントリは
以下となっています．つまり，</p>
<ul>
<li>❷4番のAbbrev Number (省略番号)を持つDIEは ❸DW_TAG_base_type である</li>
<li>DW_TAG_base_typeには例えば，❹変数名の情報があり，その型は❺DW_FORM_stringである</li>
</ul>
<p>と分かります．</p>
<pre><code class="language-bash">$ objdump -Wa add5.o
(一部略)
❷4 ❸DW_TAG_base_type    [no children]
    DW_AT_byte_size    DW_FORM_data1
    DW_AT_encoding     DW_FORM_data1
  ❹DW_AT_name       ❺DW_FORM_string
    DW_AT value: 0     DW_FORM value: 0
</code></pre>
<p>要するに<code>.debug_abbrev</code>の情報は<code>.debug_info</code>のメタ情報(型情報)であり，
この場合，4という数字を保持するだけで，
「このDIEはDW_TAG_base_typeである．その内容は…(以下略)」
という情報を持てるのです．</p>
<p>これによりサイズの圧縮が可能になっています．
<code>objdump -W</code>はある程度は散っている情報をまとめて表示していて親切です．</p>
</details>
<details>
<summary>
LEB128とは
</summary>
<p>LEB128 (little endian base 128)は任意の大きさの整数を扱える
可変長の符号化方式です．直感的にはLEB128はUTF-8の整数版です．</p>
<p>LEB128はDWARFやWebAssemblyなどで使われています．
(ですので，DWARFデバッグ情報にはLEB128の符号化が使われている箇所があります．
デバッグ情報の16進ダンプを解析する際は注意しましょう)．</p>
<p>LEB128には符号ありと符号なしの2種類がありますが，以下では符号なしで説明します．</p>
<p>ここでは123456を符号なしLEB128形式に変換します．
結果は最下位バイトから，<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>の3バイトになります．
まず<code>bc</code>コマンドで2進数にします❶．</p>
<pre><code class="language-bash">$ bc
obase=2
123456
❶ 11110001001000000
</code></pre>
<p>次に以下のステップを踏みます．</p>
<form class="tab-wrap">
    <input id="LEB128-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="LEB128-1">ステップ1</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-1.svg" height="70px" id="fig:LEB128-1">
    </div>
    <input id="LEB128-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-2">ステップ2</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-2.svg" height="70px" id="fig:LEB128-2">
    </div>
    <input id="LEB128-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-3">ステップ3</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-3.svg" height="70px" id="fig:LEB128-3">
    </div>
    <input id="LEB128-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-4">ステップ4</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-4.svg" height="85px" id="fig:LEB128-4">
    </div>
</form>
<p>ステップ4の結果を<code>bc</code>コマンドで16進数にします❷．</p>
<pre><code class="language-bash">$ bc
obase=16
ibase=2
000001111100010011000000
❷ 7C4C0
</code></pre>
<p>結果の16進数❷<code>0x7C4C0</code> を1バイトごとに最下位バイトから出力すると，
最終的な結果は<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>となります．
LEB128の最上位バイトの最上位ビットは必ず0で，
それ以外のバイトはの最上位ビットは1なので，
サイズ情報がなくても，
元の整数に戻す際，どのバイトまで処理すればよいかが分かります．</p>
</details>
<p>型の情報<code>&lt;0x5e&gt;</code>は以下にありました．
「サイズは❼ 4バイト，❽符号あり，型名は❾<code>int</code>」です．</p>
<pre><code>&lt;1&gt;&lt;5e&gt;: Abbrev Number: 4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : ❼ 4
    &lt;60&gt;   DW_AT_encoding    : 5        ❽ (signed)
    &lt;61&gt;   DW_AT_name        : ❾ int
</code></pre>
<div id="DIE">
<p>上記の<code>.debug_info</code>中の情報である，
DW_TAG_formal_parameterやDW_TAG_base_typeなどは
DIE (debug information entry)というデバッグ情報の単位の1つです．
DIEは全体で木構造になっています．</p>
</div>
<img src="figs/DIE-tree.svg" height="150px" id="fig:DIE-tree">
<p>またデバッグ情報情報があちこちに散っています．
例えば，❷「ファイル1」の情報はどこにあるかというと</p>
<pre><code>    &lt;53&gt; ❷ DW_AT_decl_file   : 1
</code></pre>
<p>行情報にありました．
以下でエントリ1の情報を見ると，<code>add5.c</code>と分かりました．</p>
<pre><code class="language-bash">$ objdump -Wl add5.o | less
(中略)
The File Name Table (offset 0x2c, lines 2, columns 2):
  Entry Dir     Name
  0     0       (indirect line string, offset: 0x11): add5.c
  1     0       (indirect line string, offset: 0x18): add5.c
</code></pre>
<h4 id="readelf"><a class="header" href="#readelf"><code>readelf</code></a></h4>
<p><code>readelf</code>コマンドでも<code>objdump</code>と同様にDWARFデバッグ情報を表示できます．
以下は実行例です．</p>
<pre><code class="language-bash">$ readelf -wi ./add5.o
Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string, offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string, offset: 0x5): add5.c
    &lt;16&gt;   DW_AT_comp_dir    : (indirect line string, offset: 0x0): /tmp
    &lt;1a&gt;   DW_AT_low_pc      : 0x0
    &lt;22&gt;   DW_AT_high_pc     : 0x13
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
(以下略)
</code></pre>
<h2 id="メモリマップを見る"><a class="header" href="#メモリマップを見る">メモリマップを見る</a></h2>
<h3 id="pmapコマンドでメモリマップを見る"><a class="header" href="#pmapコマンドでメモリマップを見る"><code>pmap</code>コマンドでメモリマップを見る</a></h3>
<p><code>pmap</code>コマンドを使うと，
実行中のプログラム(プロセス)がどのメモリ領域を使用しているか
(メモリマップ)を調べられます．
(この出力は<code>/proc</code>ファイルシステムの <code>/proc/プロセス番号/maps</code>の内容から作られています)．</p>
<pre><code class="language-bash">$ cat 
❶ ^Z   
[1]+  Stopped                 cat
$ ps | egrep cat
❷  7687 pts/0    00:00:00 cat
$ ❸ pmap 7687
7687:   cat
❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
000055f74dafc000    132K rw---   [ anon ]
00007f63a7e00000   6628K r---- locale-archive
00007f63a8600000    160K r---- libc.so.6
00007f63a8628000   1620K r-x-- libc.so.6
00007f63a87bd000    352K r---- libc.so.6
00007f63a8815000     16K r---- libc.so.6
00007f63a8819000      8K rw--- libc.so.6
00007f63a881b000     52K rw---   [ anon ]
00007f63a8829000    148K rw---   [ anon ]
00007f63a885d000      8K rw---   [ anon ]
00007f63a885f000      8K r---- ld-linux-x86-64.so.2
00007f63a8861000    168K r-x-- ld-linux-x86-64.so.2
00007f63a888b000     44K r---- ld-linux-x86-64.so.2
00007f63a8897000      8K r---- ld-linux-x86-64.so.2
00007f63a8899000      8K rw--- ld-linux-x86-64.so.2
❹ 00007fff86f9f000 132K ❺rw---   ❻[ stack ]
00007fff86ff8000     16K r----   [ anon ]
00007fff86ffc000      8K r-x--   [ anon ]
ffffffffff600000      4K --x--   [ anon ]
 total             9560K
$ fg
❽ ^D
</code></pre>
<ul>
<li>
<p>まず <code>cat</code>コマンドを起動します．ファイル名を指定していないので，
標準入力からの入力待ちになります．
ここで❶ ctrl-z を入力して，<code>cat</code>コマンドの実行を中断 (suspend)します．
<code>pmap</code>コマンドは実行中のプロセスにしか実行できないため，
<code>cat</code>コマンドが実行中のまま終了しないように，こうしています．</p>
</li>
<li>
<p>次に<code>ps</code>コマンドで<code>cat</code>コマンドのプロセス番号を調べます．
❷7687がプロセス番号と分かりました．</p>
</li>
<li>
<p>❸プロセス番号7687を引数として<code>pmap</code>コマンドを実行します．</p>
</li>
<li>
<p>出力の各行が使用中のメモリ領域の情報を示しています．例えば，❹の行は次を意味しています．</p>
<p><code>❹ 00007fff86f9f000    132K ❺rw---   ❻[ stack ]
 </code></p>
<ul>
<li>❹アドレス`00007fff86f9f000'からサイズ132KBの領域を使用している．</li>
<li>このメモリ領域の❻アクセス権限は読み書きが可能で，実行は不可．
<ul>
<li><code>r</code> 読み込み可能</li>
<li><code>w</code> 書き込み可能</li>
<li><code>x</code> 実行可能</li>
</ul>
</li>
<li>このメモリ領域は❻スタックとして使用している</li>
</ul>
</li>
<li>
<p><code>cat</code>コマンド自身は以下の5つのメモリ領域を使用しています．</p>
<pre><code class="language-bash">❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
</code></pre>
<ul>
<li>アクセス権限が <code>r-x--</code>のものは，<code>.text</code>セクションでしょう．
(<code>.text</code>セクションは通常，実行可能かつ書き込み禁止にするからです)</li>
<li>アクセス権限が <code>rw----</code>のものは，<code>.data</code>セクションでしょう．
(<code>.data</code>セクションは通常，実行禁止かつ書き込み可能にするからです)</li>
<li>残りの3つのアクセス権限が <code>r----</code> のものは，<code>.rodata</code>セクションなどでしょう．
(詳細は調べていません)</li>
<li>使用しているサイズが4KBの倍数なのは，x86-64でよくある
<strong>ページ</strong>(page)サイズが4KBだからです．
(ページとは仮想記憶方式の1つであるページングで使われる，
固定長(例えば4KB)に区切ったメモリ領域のことです)．
プロセスは<code>mmap</code>システムコールを使って，OSからページ単位でメモリを割り当ててもらい，その際にページごとにアクセス権限を設定できます．</li>
</ul>
</li>
<li>
<p>最後に❽で，中断していた<code>cat</code>コマンドを<code>fg</code>コマンドで実行を再開し，
<code>ctrl-D</code>を入力して<code>cat</code>コマンドの実行を終了しています．</p>
</li>
</ul>
<h3 id="gdbでメモリマップを見る"><a class="header" href="#gdbでメモリマップを見る"><code>gdb</code>でメモリマップを見る</a></h3>
<p><code>gdb</code>でもメモリマップを見ることができます</p>
<pre><code class="language-bash">$ gdb /usr/bin/cat
(gdb) r
ctrl-z
Program received signal SIGTSTP, Stopped (user).
(gdb) info proc map
process 7821
Mapped address spaces:

          Start Addr           End Addr       Size     Offset  Perms  objfile
      0x555555554000     0x555555556000     0x2000        0x0  r--p   /usr/bin/cat
      0x555555556000     0x55555555a000     0x4000     0x2000 ❶r-xp   /usr/bin/cat
<span class="boring">      0x55555555a000     0x55555555c000     0x2000     0x6000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555c000     0x55555555d000     0x1000     0x7000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555d000     0x55555555e000     0x1000     0x8000  rw-p   /usr/bin/cat
</span><span class="boring">      0x55555555e000     0x55555557f000    0x21000        0x0  rw-p   [heap]
</span><span class="boring">      0x7ffff7400000     0x7ffff7a79000   0x679000        0x0  r--p   /usr/lib/locale/locale-archive
</span><span class="boring">      0x7ffff7c00000     0x7ffff7c28000    0x28000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7c28000     0x7ffff7dbd000   0x195000    0x28000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7dbd000     0x7ffff7e15000    0x58000   0x1bd000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e15000     0x7ffff7e19000     0x4000   0x214000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e19000     0x7ffff7e1b000     0x2000   0x218000  rw-p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e1b000     0x7ffff7e28000     0xd000        0x0  rw-p   
</span><span class="boring">      0x7ffff7f87000     0x7ffff7fac000    0x25000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbb000     0x7ffff7fbd000     0x2000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbd000     0x7ffff7fc1000     0x4000        0x0  r--p   [vvar]
</span><span class="boring">      0x7ffff7fc1000     0x7ffff7fc3000     0x2000        0x0  r-xp   [vdso]
</span><span class="boring">      0x7ffff7fc3000     0x7ffff7fc5000     0x2000        0x0  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fc5000     0x7ffff7fef000    0x2a000     0x2000  r-xp   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fef000     0x7ffff7ffa000     0xb000    0x2c000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffb000     0x7ffff7ffd000     0x2000    0x37000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x39000  rw-p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
</span><span class="boring">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0  --xp   [vsyscall]
</span></code></pre>
<details>
<summary>
アクセス権限rwxpの❶pとは
</summary>
<p><code>mmap</code>でメモリ領域をマップする際に，
フラグとして<code>MAP_PRIVATE</code>を指定すると<code>p</code>，
<code>MAP_SHARED</code>を指定すると<code>s</code>と表示されます．</p>
<ul>
<li>
<p><code>MAP_PRIVATE</code> マップした領域への変更はプロセス間で共有されません．
このマップは<strong>copy-on-write</strong>なので，書き込まれるまで自分専用のコピーは発生せず，共有されます．
(copy-on-writeとは「書き込みが起こるまでコピーを遅延する」というテクニックです)．</p>
</li>
<li>
<p><code>MAP_SHARED</code> マップした領域への変更はプロセス間で共有されます．
すなわちマップした領域に書き込みを行うと，
その変更は他のプロセスにも見えます．
ただし，<code>msync</code>を使う必要があります．</p>
</li>
</ul>
<p>❶<code>.text</code>セクションの共有設定も<code>p</code>となっています．
これは<code>.text</code>セクションも<code>mmap</code>の<code>MAP_PRIVATE</code>でマップしているからです．
動的リンクした実行可能ファイルの<code>.text</code>セクションは
物理メモリ上で共有されていますが，
その共有と<code>MAP_SHARED</code>は関係ないのです．</p>
<!--
ちなみに，そのプロセスが`mmap`で`MAP_SHARED`なマップをすれば，
表示が`s`になります(自分でやってみて確かめました)．

strace して .text を MAP_PRIVATE　してるのを確かめようとしたけど
よくわからんかった．
$ strace /lib64/ld-linux-x86-64.so.2 /usr/bin/cat
もやったんだけどね．
-->
</details>
<h2 id="relocation"><a class="header" href="#relocation">再配置情報</a></h2>
<h3 id="再配置情報の概要"><a class="header" href="#再配置情報の概要">再配置情報の概要</a></h3>
<p><strong>再配置情報</strong>(relocation information)とは「後でアドレス調整する時のために，
機械語命令中のどの場所をどんな方法で書き換えればよいか」を表す情報です．
オブジェクトファイル<code>*.o</code>は一般的に再配置情報を含んでいます．</p>
<pre><code class="language-C">// asm/reloc-main.c
#include &lt;stdio.h&gt;
extern int x;
int main ()
{
    printf (&quot;%d\n&quot;, x);
}
</code></pre>
<pre><code class="language-C">// asm/reloc-sub.c
int x = 999;
</code></pre>
<p>例えば，上の<a href="./asm/reloc-main.c"><code>reloc-main.c</code></a>と
<a href="./asm/reloc-sub.c"><code>reloc-sub.c</code></a>を見て下さい．
<code>reloc-main.c</code>中で参照している変数<code>x</code>の実体は<code>reloc-main.c</code>中には無く，
実体は<code>reloc-sub.c</code>中にあります．</p>
<img src="figs/reloc-overview.svg" height="170px" id="fig:reloc-overview">
<p>ですので，<a href="./asm/reloc-main.s"><code>reloc-main.s</code></a>中の
<code>movq x(%rip), %eax</code>をアセンブルして<code>reloc-main.o</code>を作っても，
この時点では<code>x</code>のアドレスが不明なので，<strong>仮のアドレス</strong>(上図では<code>00 00 00 00</code>)
にするしかありません．
そこで，この<code>movq x(%rip), %eax</code>命令に対する<strong>再配置情報</strong>として
「この命令の2バイト目から4バイトを4バイト長の<code>%rip</code>相対アドレスで埋める」
という情報(<code>R_X86_64_PC32</code>，<a href="#R_X86_64_PC32">後述</a>)を
<code>reloc-main.o</code>中に保持しておき，リンク時に正しいアドレスを埋め込むのです．</p>
<img src="figs/reloc-overview2.svg" height="300px" id="fig:reloc-overview2">
<pre><code>$ gcc -c reloc-main.c
$ gcc -c reloc-sub.c
$ gcc reloc-main.o reloc-sub.o
</code></pre>
<details>
<summary>
なんでgccを3回?
</summary>
<p>通常は<code>gcc reloc-main.c reloc-sub.c</code>と，<code>gcc</code>を一回実行して
<code>a.out</code>を作ります．が，ここでは<code>reloc-main.o</code>の中の再配置情報を
見たいので，わざわざ別々に<code>reloc-main.o</code>と<code>reloc-sub.o</code>を作り，
最後にリンクして<code>a.out</code>を作っています．</p>
</details>
<p><code>reloc-main.o</code>と<code>reloc-sub.o</code>をリンクして<code>a.out</code>を作ると，
(様々な<code>*.o</code>中のセクションを一列に並べることで)
変数<code>x</code>のアドレスが<code>0x4010</code>に決まり，
上図の「次の命令」のアドレスも<code>0x1157</code>に決まりました．
仮のアドレスに埋めたかったのは，<code>%rip</code>相対番地でしたので，
<code>0x4010-0x1157=0x2EB9</code>と計算した<code>0x2EB9</code>番地を仮のアドレスの部分に埋めました．
これが再配置です．</p>
<details>
<summary>
様々な*.o中のセクションを一列に並べることで，とは
</summary>
<br/>
<img src="figs/reloc-overview4.svg" height="200px" id="fig:reloc-overview4">
<p>例えば上図で<code>foo2.o</code>中の変数<code>x</code>のアドレスは仮アドレス<code>0x1000</code>ですが，
<code>foo1.o</code>と<code>foo2.o</code>中のセクションを1列に並べると，
リンク後は「<code>a.out</code>の先頭アドレスが(例えば)<code>0x4000</code>なので，先頭から数えると，
(<code>0x4000 + 0x0500 + 0x1000 = 0x5500</code>という計算をして)
変数<code>x</code>のアドレスは<code>0x5500</code>に決まりますよね」という話です．</p>
</details>
<h3 id="objdump-dr"><a class="header" href="#objdump-dr"><code>objdump -dr</code> で再配置情報を見てみる</a></h3>
<pre><code>$ gcc -g -c reloc-main.c
$ objdump -dr reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	8b 05 ❶ 00 00 00 00    mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
		❷ a: R_X86_64_PC32	x-0x4
   e:	89 c6                	mov    %eax,%esi
  10:	48 8d 05 ❸ 00 00 00 00 	lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
		❹ 13: R_X86_64_PC32	.rodata-0x4
  17:	48 89 c7             	mov    %rax,%rdi
  1a:	b8 00 00 00 00       	mov    $0x0,%eax
  1f:	e8 00 00 00 00       	call   24 &lt;main+0x24&gt;
			20: R_X86_64_PLT32	printf-0x4
  24:	b8 00 00 00 00       	mov    $0x0,%eax
  29:	5d                   	pop    %rbp
  2a:	c3                   	ret    
</code></pre>
<p><a href="#%E5%86%8D%E9%85%8D%E7%BD%AE%E6%83%85%E5%A0%B1%E3%81%AE%E6%A6%82%E8%A6%81">前節</a>の説明を，実際に再配置情報を見ることで確かめます．
上の実行例は<code>objdump -dr</code>で<code>reloc-main.o</code>の逆アセンブルの結果と
再配置情報の両方を表示させたものです．</p>
<ul>
<li>❶を見ると<a href="#fig:reloc-overview">図</a>の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li><span id="R_X86_64_PC32">❷の<code>a: R_X86_64_PC32 x-0x4</code>が再配置情報です．</span>
<ul>
<li><code>a</code>は仮のアドレスを書き換える場所(<code>.text</code>セクションの先頭からのオフセット)です．
命令<code>mov 0x0(%rip), %eax</code>の先頭のオフセットが<code>0x8</code>なので，
<code>0x8</code>に<code>2</code>を足した値が<code>0xa</code>となっています
(この<code>mov</code>命令の最初の2バイトはオペコード)．</li>
<li><code>R_X86_64_PC32</code>は再配置の方法を表しています．
「<code>%rip</code>相対アドレスで4バイト(32ビット)としてアドレスを埋める」ことを意味しています．
(PCはプログラムカウンタ，つまり<code>%rip</code>を使うことを意味しています)．</li>
<li><code>x-0x4</code>は「変数<code>x</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PC32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>S + A - P</code>と定めています．</p>
<ul>
<li><code>S</code> はそのシンボルのアドレス (上の例では<code>0x4010</code>)</li>
<li><code>A</code> は調整用の値 (addend と呼びます．上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では<code>0x1157 - 4</code>番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x4010 + (-4) - (0x1157 - 4) = 0x2EB9
</code></pre>
<p>となります．</p>
</details>
<ul>
<li>❸は&quot;%d\n&quot;という文字列の仮アドレス，❹はその仮アドレスの再配置情報です．
❶❷と同様です．</li>
</ul>
<h3 id="readelf--rで再配置情報を見てみる"><a class="header" href="#readelf--rで再配置情報を見てみる"><code>readelf -r</code>で再配置情報を見てみる</a></h3>
<pre><code>$ readelf -r reloc-main.o | less
Relocation section '.rela.text' at offset 0x5b0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000a00000002 R_X86_64_PC32     0000000000000000 x - 4
000000000013  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000020  000b00000004 R_X86_64_PLT32    0000000000000000 printf - 4
(略)
</code></pre>
<p><code>readelf -r</code>でも<code>objdump -dr</code>と同様の結果が得られます．</p>
<h3 id="pltの再配置情報"><a class="header" href="#pltの再配置情報">PLTの再配置情報</a></h3>
<p><code>printf</code>の再配置情報も見てみましょう．</p>
<img src="figs/reloc-overview3.svg" height="300px" id="fig:reloc-overview3">
<pre><code>$ objdump -dr ./reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;main&gt;:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
                        a: R_X86_64_PC32        x-0x4
   e:   89 c6                   mov    %eax,%esi
  10:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
                        13: R_X86_64_PC32       .rodata-0x4
  17:   48 89 c7                mov    %rax,%rdi
  1a:   b8 00 00 00 00          mov    $0x0,%eax
  1f:   e8 ❶ 00 00 00 00       call   24 &lt;main+0x24&gt;
             ❷ 20: R_X86_64_PLT32      printf-0x4
  24:   b8 00 00 00 00          mov    $0x0,%eax
  29:   5d                      pop    %rbp
  2a:   c3                      ret    
</code></pre>
<pre><code>$ objdump -d ./a.out
0000000000001149 &lt;main&gt;:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       8b 05 b9 2e 00 00       mov    0x2eb9(%rip),%eax        # 4010 &lt;x&gt;
    1157:       89 c6                   mov    %eax,%esi
    1159:       48 8d 05 a4 0e 00 00    lea    0xea4(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1160:       48 89 c7                mov    %rax,%rdi
    1163:       b8 00 00 00 00          mov    $0x0,%eax
    1168:     ❸e8 e3 fe ff ff          call   1050 &lt;printf@plt&gt;
    116d:       b8 00 00 00 00          mov    $0x0,%eax
    1172:       5d                      pop    %rbp
    1173:       c3                      ret    
</code></pre>
<p><a href="#objdump-dr">先程の<code>x</code></a>の場合とほぼ同じです．</p>
<ul>
<li>❶を見ると<a href="#fig:reloc-overview3">図</a>の左側の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li>❷の<code>20: R_X86_64_PLT32 printf-0x4</code>が再配置情報です．
<ul>
<li><code>20</code>は仮のアドレスを書き換える場所(オフセット)です．</li>
<li><code>R_X86_64_PLT32</code>は再配置の方法を表しており
「<code>printf@plt</code>への<code>%rip</code>相対アドレス (4バイト(32ビット))を埋める」ことを意味しています．</li>
<li><code>printf-0x4</code>は「変数<code>printf@plt</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PLT32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>L + A - P</code>と定めています．</p>
<ul>
<li><code>L</code> はそのシンボルのPLTエントリのアドレス (上の例では<code>printf@plt</code>のアドレス<code>0x1050</code>)</li>
<li><code>A</code> は調整用のaddend (上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では<code>0x116D - 4</code>番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x1050 + (-4) - (0x116D - 4) = -0x11D = 0xFFFFFEE3
</code></pre>
<p>となります．</p>
</details>
<ul>
<li><code>a.out</code>中では「次の命令」が<code>0x116D</code>番地，<code>printf@plt</code>が<code>0x1050</code>番地と決まったので，<code>0x1050 - 0x116D = -0x11D = 0xFFFFFEE3</code>番地が
❸の部分に埋め込まれました．</li>
</ul>
<p><a href="#GOT-PLT">ここ</a>でも説明した通り，
<code>printf</code>の実体はCライブラリの中にあり，
(<code>gcc</code>のデフォルト動作である)<a href="#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>の場合，
PLTとGOTの仕組みを使って，<code>printf</code>を呼び出します．
これは<a href="#objdump-dr">先程の<code>x</code></a>の場合は
「(<code>main</code>関数中の)次の命令と変数<code>x</code>の相対アドレスは固定で決まる」のに対して，
<code>printf</code>の場合は固定で決まらないからです
(Cライブラリが実行時に何番地にロードされるか不明だから)．</p>
<img src="figs/plt-printf2.svg" height="300px" id="fig:plt-printf2">
<p>そこで，</p>
<ul>
<li><code>main</code>関数中では(<code>printf</code>を直接呼ぶのではなく)，
(<code>printf</code>のための踏み台である)<code>printf@plt</code>を呼び出す．</li>
<li><code>printf@plt</code>はGOT領域に実行時に書き込まれる<code>printf</code>のアドレスを使い，
間接ジャンプ (上図では<code>bnd jmp *0x2f75(%rip)</code>)して，
本物の<code>printf</code>を呼び出す．</li>
</ul>
<p>という仕組みになっています．</p>
<!--
どの関数を動的リンクすべきかの情報を，動的リンカに引数として
渡すために必要だったけど，今は渡してないように見える．
(`main`関数が`printf@plt`を呼ぶのではなく，
直接`call *0x2f75(%rip)`すればいいんじゃね？と言われると，
私もそれでいいじゃん，と思ってしまいます．
`ltrace`コマンドがPLTエントリをフックして実装している，などの利点があるのは
分かりますが，それ以外に理由はあるのでしょうか．
ご存知の方はぜひ教えてください．)
-->
<h2 id="ABI"><a class="header" href="#ABI">ABI と API</a></h2>
<p>ABIとAPIはどちらも<strong>互換性</strong>のための規格(お約束)ですが，
対象がそれぞれ，<strong>バイナリ</strong>，<strong>ソースコード</strong>，と異なります．</p>
<h3 id="abi"><a class="header" href="#abi">ABI</a></h3>
<ul>
<li>ABI = Application Binary Interface</li>
<li><strong>バイナリコード</strong>のためのインタフェース規格．</li>
<li>同じABIをサポートするシステム上では<strong>再コンパイル無し</strong>で
同じバイナリを使ったり実行できる．</li>
<li>ABIはコーリングコンベンション(関数呼び出し規約, calling convention)，
バイトオーダ，アラインメント，バイナリ形式などを定める</li>
<li>Linux AMD64のABI は<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a></li>
</ul>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<ul>
<li>API = Application Programming Interface</li>
<li><strong>ソースコード</strong>のためのインタフェース規格</li>
<li>同じAPIをサポートするシステム上では<strong>再コンパイルすれば</strong>
同じソースコードを実行できる．</li>
<li>例えば，POSIXはUNIXのAPIであり，LinuxはPOSIXにほぼ準拠している．<br />
POSIXはシステムコール，ライブラリ関数，マクロなどの形式や意味を定めている
<ul>
<li>POSIXは<a href="https://unixism.net/2020/07/getting-a-pdf-version-of-the-posix-standard-document/">ここ</a>に書いてあるとおり，<a href="https://www.opengroup.org/">opengroup.org</a>に登録することで無料で入手可能</li>
</ul>
</li>
</ul>
<!--
## セクションの抽出と注入

### 
https://www.baeldung.com/linux/file-elf-extract-raw-contents

https://stackoverflow.com/questions/1088128/adding-section-to-elf-file
-->

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="2-asm-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="5-arch.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="2-asm-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="5-arch.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/elasticlunr.js"></script>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
