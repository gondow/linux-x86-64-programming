<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linuxで学ぶx86-64アセンブリ言語</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> データ表現，2進数，2の補数</div></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど</div></li><li class="chapter-item "><a href="6-inst.html"><strong aria-hidden="true">6.</strong> x86-64機械語命令</a></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> GNUアセンブラ命令</div></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> インラインアセンブラ</div></li><li class="chapter-item "><div><strong aria-hidden="true">9.</strong> ABI: アプリケーション・バイナリ・インタフェース</div></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> デバッガの使い方</div></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">情報</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 1; }
</style>
<h1 id="前書き"><a class="header" href="#前書き">前書き</a></h1>
<h2 id="言い訳"><a class="header" href="#言い訳">言い訳</a></h2>
<p>本書はまだ執筆途中です．不完全な部分があることをお許しください．
しかしながら，誤りの指摘や改善のためのコメントは歓迎いたします．
本書のGithubリポジトリは<a href="https://github.com/gondow/linux-x86-64-programming">こちら</a>です．</p>
<h2 id="本書の目的"><a class="header" href="#本書の目的">本書の目的</a></h2>
<p>本書は筆者（権藤克彦）が<a href="https://www.titech.ac.jp/">東京工業大学</a>の
<a href="https://educ.titech.ac.jp/cs/">情報工学系</a>で
長年担当したアセンブリ言語の授業の資料をオンライン資料として
まとめ直したものです．
Intel x86-64，Linux，GNUアセンブラを前提として「アセンブリ言語とは何か」
「具体的にどうプログラミングすればいいのか」を分かりやすくお伝えすることが目的です．</p>
<p>ただし，本書では以下は扱っていません．</p>
<ul>
<li>浮動小数点命令</li>
<li>(デバイスドライバの実装に必要な)I/O命令</li>
<li>(OSの実装に必要な)特権命令</li>
<li>MMX/SSE/AVXなどの拡張命令</li>
</ul>
<p>いや，書いてもいいのですが分量が膨大になるので面倒くさいんです．
もしOS自作に興味があるなら書籍<a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a>を強くお勧めします．</p>
<h2 id="本書で使う環境"><a class="header" href="#本書で使う環境">本書で使う環境</a></h2>
<p>本書では以下の環境を使用しています．皆さんの環境がLinuxであれば多少違っても大丈夫なはずです．</p>
<ul>
<li>Ubuntu 22.04 LTS (OS)</li>
<li>GNU gcc-11.3.0 (コンパイラ)</li>
<li>GNU binutils-2.38 (バイナリ・ユーティリティ，GNUアセンブラ<code>as</code>を含む)</li>
<li>GNU gdb-12.1 (デバッガ)</li>
</ul>
<p>しかし，WindowsやmacOSの場合は，本書の内容と大きく異なってしまいます．
アセンブリ言語は環境への依存度が高く，そのため移植性がとても低いからです．</p>
<p>皆さんのパソコンがWindowsやmacOSだった場合，Linux環境を導入する方法として以下のようないろいろな方法があります．筆者のお勧めは</p>
<ul>
<li>WindowsならWSL2を使う</li>
<li>macOSなら仮想マシンVirtual Boxをインストールして，Ubuntuをインストールする</li>
</ul>
<p>です．デバッガはアセンブリ言語の実行結果を確認するために便利ですので，
ぜひ準備して下さい．</p>
<p>Linux環境を導入する方法：</p>
<ul>
<li><a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> (Windows Subsystem for Linux 2)を使えるように設定する</li>
<li><a href="https://www.virtualbox.org/">VirtualBox</a>や
<a href="https://www.vmware.com/jp/products/fusion.html">VMWare Fusion</a>
などの仮想マシンをインストールして，その仮想マシン上に<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．</li>
<li><a href="https://www.docker.com/">Docker</a>などのコンテナ実行環境をインストールして，その上で<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．</li>
<li>オンライン環境（例えば<a href="https://replit.com/">repl.it</a>）を使う．</li>
</ul>
<p>Linux環境の導入方法を書くと切りが無いので，皆さん自身でググって下さい．</p>
<p>私が使った Ubuntu 22.04 LTSには<code>gcc</code>などが未インストールなので，
以下のコマンドでインストールしました．</p>
<pre><code>$ sudo apt install build-essential
</code></pre>
<h2 id="本書のライセンス"><a class="header" href="#本書のライセンス">本書のライセンス</a></h2>
<p>Copyright (C) 2023 Katsuhiko Gondow</p>
<p>本書は<a href="https://creativecommons.org/licenses/by-nc/4.0/deed.ja">クリエイティブ・コモンズ4.0表示(CC-BY-NC 4.0)</a>で提供します．</p>
<h2 id="本書の作成公開環境"><a class="header" href="#本書の作成公開環境">本書の作成・公開環境</a></h2>
<ul>
<li>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></li>
<li>お絵かきツール <a href="https://www.drawio.com/">draw.io</a></li>
<li>公開環境 <a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></li>
</ul>
<h2 id="本書のお約束"><a class="header" href="#本書のお約束">本書のお約束</a></h2>
<h3 id="メモリの図では0番地が常に上"><a class="header" href="#メモリの図では0番地が常に上">メモリの図では0番地が常に上</a></h3>
<p>本書ではメモリの図を書く時，必ず0番地(低位アドレス)が上，
高位アドレスが下になるようにします．</p>
<img src="figs/oyakusoku-memory.svg" height="150px" id="fig:oyakusoku-memory">
<p>その結果，本書の図では「スタックは上に成長」，「ヒープは下に成長」することになります
(<a href="2-asm-intro.html#fig:memory-layout">メモリレイアウト</a>)．</p>
<h3 id="❶❷などの黒丸数字は説明用"><a class="header" href="#❶❷などの黒丸数字は説明用">❶❷などの黒丸数字は説明用</a></h3>
<p>実行結果中の❶や❷などの黒丸数字は，説明のために私が追加したものです．
実行結果の出力ではありません．
例えば，以下が例で，<code>file</code>コマンドの出力例です．
本文中の説明と実行結果のどこが対応しているのかを明示するために使います．</p>
<pre><code>$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable, x86-64, ❹version 1 (SYSV), ❺not stripped
</code></pre>
<p><a href="https://practicalbinaryanalysis.com/">Practical Binary Analysis</a>
という書籍がこうしていて便利なので真似させてもらっています．</p>
<h3 id="一部を隠してます"><a class="header" href="#一部を隠してます">一部を隠してます．</a></h3>
<p>「細かい説明」「演習問題の答え」などは<code>details</code>タグを使って隠しています．
最初は読み飛ばして構いません．読む場合は▶ボタンを押して下さい．</p>
<details>
<summary>
←このボタン(またはこの行)を押してみて下さい
</summary>
<blockquote>
<p>これが隠されていた内容です．</p>
</blockquote>
</details>
<h3 id="一部の図はタブ表示にしています"><a class="header" href="#一部の図はタブ表示にしています">一部の図はタブ表示にしています</a></h3>
<p>一部の図はタブ切り替えでパラパラ漫画のように表示しています．
一度に全部を表示するとゴチャゴチャする場合などに使います．
以下はタブ表示の例です．</p>
<div class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="100px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="93px" id="fig:tail-call-opt2">
    </div>
</div>
<h3 id="サンプルコードがあります"><a class="header" href="#サンプルコードがあります"><a href="./asm">サンプルコード</a>があります</a></h3>
<p><a href="./asm">サンプルコード</a>には2種類のファイルがあります．</p>
<ul>
<li><code>*.s</code> アセンブリコード</li>
<li><code>*.txt</code> <code>gdb</code>のコマンド列が書かれたファイル</li>
</ul>
<p>これらのファイルとデバッガ<code>gdb</code>を使って機械語命令を実行・確認する方法は，
<a href="./6-inst.html#how-to-execute-x86-inst">こちら</a>に説明があります．</p>
<p>サンプルコードを一括ダウンロードするには，例えば以下のようにして下さい．</p>
<pre><code></code></pre>
<!--
## todo リスト

- 実行の仕方へのリンク
- タブの絵が全て非表示なのはなぜ?
-->
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 2; }
</style>
<h1 id="アセンブリ言語の概要"><a class="header" href="#アセンブリ言語の概要">アセンブリ言語の概要</a></h1>
<h2 id="機械語とアセンブリ言語とは何か短い説明"><a class="header" href="#機械語とアセンブリ言語とは何か短い説明">機械語とアセンブリ言語とは何か？（短い説明）</a></h2>
<p><strong>機械語</strong>（マシン語）：</p>
<ul>
<li>CPUが直接実行できる唯一の言語．</li>
<li>機械語命令を2進数（バイナリ，数字の列）で表現．</li>
</ul>
<p><strong>アセンブリ言語</strong>：</p>
<ul>
<li>機械語を記号で表現したプログラミング言語．</li>
<li>例1：機械語命令<code>01010101</code>をアセンブリ言語では<code>pushq %rbp</code>という記号（<strong>ニモニック</strong>，mnemonic）で表す（x86-64の場合，以下同様）．</li>
<li>例2：メモリのアドレス<code>1000</code>番地をアセンブリ言語では<code>add5</code>などの記号（<strong>ラベル</strong>）で表す．</li>
</ul>
<img src="figs/machine-asm.svg" height="150px" id="fig:machine-asm">
<details>
<summary>
pushq %rbpとは
</summary>
<blockquote>
<p>「レジスタ<code>%rbp</code>中の値をスタックにプッシュする」という命令です．
<a href="2-asm-intro.html#push-rbp-pop-rbp">ここ</a>で説明します．</p>
</blockquote>
</details>
<p>2進数の機械語命令と，機械語命令のニモニックは概ね，1対1に対応しており，
機械的に変換できます．ただし，その変換方法を覚える必要はありません．
<a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブル</a>や<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>してくれる
コマンド（プログラム）にやってもらえばいいのです．</p>
<p>ただ，アセンブリ言語の仕組みを理解するには，オブジェクトファイル<code>*.o</code>や
実行可能ファイル<code>a.out</code>の中身や仕組みを理解する必要があるため，
<a href="./3-binary.html">バイナリファイル</a>の節では説明が多くなっています．</p>
<h2 id="逆アセンブル"><a class="header" href="#逆アセンブル">機械語とアセンブリ言語の具体例（逆アセンブル）</a></h2>
<p>まず以下の簡単なCのプログラム<code>add5.c</code>を用意して下さい．</p>
<p id="add5.c">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<p><code>add5.c</code>を<code>gcc -c</code>で処理すると，
<strong>オブジェクトファイル</strong><code>add5.o</code>ができます．
この<code>add5.o</code>に対して<code>objdump -d</code>を実行すると，
<strong>逆アセンブル</strong>(disassemble)した結果が表示されます．</p>
<pre><code class="language-bash">$ gcc -c add5.c
$ ls
add5.c  add5.o
$ objdump -d add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 05             	add    $0x5,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<p>逆アセンブルとは，<code>a.out</code>や<code>*.o</code>中の機械語命令を
アセンブリ言語のニモニック表現に変換することです．
上の実行例で，左側に機械語命令，右側にニモニックが表示されています．
(一番左側の数字は，<a href="./3-binary.html#.text"><code>.text</code>セクション</a>の先頭からのバイト数（16進表記）です）．
例えば，4バイト目にある<code>55</code>は機械語命令（を16進数で表記したもの），
<code>55</code>の右側の<code>push %rbp</code>が，<code>55</code>に対応するニモニックです．
16進数が使われているのは，2進数で表記すると長くなってしまうからです．</p>
<h2 id="cコードをアセンブリコードにコンパイルする"><a class="header" href="#cコードをアセンブリコードにコンパイルする">Cコードをアセンブリコードにコンパイルする</a></h2>
<p><a href="2-asm-intro.html#add5.c"><code>add5.c</code></a>に対して，
以下のコマンドを実行して，<code>add5.s</code>を作成して下さい．
これで「アセンブリ言語で書かれたプログラム（アセンブリコード）」がどんなものかを見れます．</p>
<pre><code class="language-bash">$ gcc -S add5.c
$ ls
add5.c  add5.s
</code></pre>
<!-- ![gcc-S](figs/gcc-S.svg) -->
<img src="figs/gcc-S.svg" height="70px" id="fig:gcc-S">
<p><code>-S</code>オプションをつけて処理すると，
<code>gcc</code>はCのプログラム(<code>add5.c</code>)からアセンブリコード(<code>add5.s</code>)を生成します．
この処理を「狭義のコンパイル」と呼びます
（<a href="./3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">広義のコンパイル</a>はCのプログラムから実行可能ファイル(<code>a.out</code>)を
生成する処理を指します）．
<code>gcc -S</code>は「コンパイラ」と呼ばれます．コンパイルするコマンドだからです．</p>
<p><code>add5.s</code>の中身は例えば以下となります．</p>
<blockquote>
<p>注意：
gccのバージョンの違いにより，同じLinuxでも<code>add5.s</code>の中身が以下と異なることがあります．</p>
</blockquote>
<p>以下では表示が長いので省略しています．
全てを表示するには右にある<i class="fa fa-eye"></i>ボタンを押して下さい．
（ここでは<code>add5.s</code>の中身は理解できなくてOKです）．</p>
<pre><code class="language-bash">$ cat add5.s
        .file   &quot;add5.c&quot;
        .text
        .globl  add5
        .type   add5, @function
add5:
.LFB0:
        .cfi_startproc
        endbr64
        pushq   %rbp
<span class="boring">        .cfi_def_cfa_offset 16
</span><span class="boring">        .cfi_offset 6, -16
</span><span class="boring">        movq    %rsp, %rbp
</span><span class="boring">        .cfi_def_cfa_register 6
</span><span class="boring">        movl    %edi, -4(%rbp)
</span><span class="boring">        movl    -4(%rbp), %eax
</span><span class="boring">        addl    $5, %eax
</span><span class="boring">        popq    %rbp
</span><span class="boring">        .cfi_def_cfa 7, 8
</span><span class="boring">        ret
</span><span class="boring">        .cfi_endproc
</span><span class="boring">.LFE0:
</span><span class="boring">        .size   add5, .-add5
</span><span class="boring">        .ident  &quot;GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0&quot;
</span><span class="boring">        .section        .note.GNU-stack,&quot;&quot;,@progbits
</span><span class="boring">        .section        .note.gnu.property,&quot;a&quot;
</span><span class="boring">        .align 8
</span><span class="boring">        .long   1f - 0f
</span><span class="boring">        .long   4f - 1f
</span><span class="boring">        .long   5
</span><span class="boring">0:
</span><span class="boring">        .string &quot;GNU&quot;
</span><span class="boring">1:
</span><span class="boring">        .align 8
</span><span class="boring">        .long   0xc0000002
</span><span class="boring">        .long   3f - 2f
</span><span class="boring">2:
</span><span class="boring">        .long   0x3
</span><span class="boring">3:
</span><span class="boring">        .align 8
</span><span class="boring">4:
</span></code></pre>
<p>このうち実行に関係する部分だけを残したアセンブリコードが以下になります．</p>
<p id="add5.s">
<pre><code class="language-x86asmatt"># add5.s
    .text
    .globl add5
    .type add5, @function
add5:
    pushq %rbp
    movq  %rsp, %rbp
    movl  %edi, -4(%rbp)
    movl  -4(%rbp), %eax
    addl  $5, %eax
    popq  %rbp
    ret
    .size  add5, .-add5
</code></pre>
</p>
<p>各行の意味は<a href="2-asm-intro.html#add5.s-content">次の次の節</a>で説明しますが，
ちょっとだけ説明します．</p>
<ul>
<li><code>.text</code>などドット<code>.</code>で始まる命令は<strong>アセンブラ命令</strong>です</li>
<li><code>add5:</code>など名前の後ろにコロン<code>:</code>があるものは<strong>ラベルの定義</strong>です</li>
<li><code>%rbp</code>など，パーセント<code>%</code>で始まるものは<strong>レジスタ</strong>です</li>
<li><code>$5</code>と，ドル<code>$</code>で始まるものは定数(<strong>即値</strong>)です．</li>
<li><code>addl $5, %eax</code>は「レジスタ<code>%eax</code>の値と定数の5を足し算した結果を
<code>%eax</code>レジスタに格納する」という動作を行う<strong>機械語命令</strong>です</li>
<li><code>#</code>から行末までは<strong>コメント</strong>です</li>
</ul>
<details>
<summary>
AT&T形式とIntel形式とは
</summary>
<blockquote>
<p>x86-64用のアセンブラには本書で扱うGNUアセンブラ以外にも，
<a href="https://github.com/netwide-assembler/nasm">NASM</a> (netwide assembler)などいくつかあり，
困ったことにアセンブリ言語の表記が異なります．
この表記方法には大きく2種類：<strong>AT&amp;T</strong>形式と<strong>Intel形式</strong>があります．
本書で扱うGNUアセンブラはAT&amp;T形式，NASMや<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>はIntel形式を使っています．</p>
<p>一番大きな違いは機械語命令の引数(<strong>オペランド</strong>といいます)の順番です．</p>
<ul>
<li>AT&amp;T形式は「左から右へ」，つまり代入先のオペランドを右に書きます</li>
<li>Intel形式は「右から左へ」，つまり代入先のオペランドを左に書きます</li>
</ul>
<img src="figs/att-intel.svg" height="100px" id="fig:att-intel">
<p>他にもAT&amp;T形式には<code>%</code>や<code>$</code>がつくなど，細かい違いがあります．
<a href="xxx">ここ(未執筆)</a>で詳しく説明します．</p>
<p>なお，<code>gcc</code>に<code>-S -masm=intel</code>とオプションを設定すると，
出力されるアセンブリコードをIntel形式に変更できます．</p>
<pre><code class="language-bash">$ gcc -S -masm=intel add5.c
</code></pre>
<pre><code class="language-x86asm">        .intel_syntax noprefix
        .text
        .globl  add5
        .type   add5, @function
add5:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR -4[rbp], edi
        mov     eax, DWORD PTR -4[rbp]
        add     eax, 5
        pop     rbp
        ret
        .size   add5, .-add5
</code></pre>
<p>(<code>DWORD</code>は4バイト (double word)を意味しています)</p>
</blockquote>
</details>
<p>なお，消した行の説明を以下に書きますが，読み飛ばしてOKです．</p>
<details>
<summary>
.cfi_とは
</summary>
<blockquote>
<p><code>.cfi</code>で始まるもの（アセンブラ命令）は call frame information を扱う命令です．
本書の範囲では不要です．詳細は<a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a>を参照下さい．</p>
</blockquote>
</details>
<details>
<summary>
.fileと.identとは
</summary>
<blockquote>
<p><code>.file</code>と<code>.ident</code>はコメントとほぼ同じでアセンブラは単に無視します．</p>
</blockquote>
</details>
<details>
<summary>
.section .note.とは
</summary>
<blockquote>
<p>以下の2つはセキュリティ上，実際には重要です（本書では消してしまいますが）．
<code>.section .note.GNU-stack,&quot;&quot;,@progbits</code>はスタック上の機械語命令を実行不可と指定しています．
<code>.section .note.gnu.property,&quot;a&quot;</code>はIntel CETというセキュリティ技術の一部である IBT (indirect branch tracking)と SHSTK (shadow stack) のための指示です．</p>
</blockquote>
</details>
<details>
<summary>
endbr64とは
</summary>
<blockquote>
<p><code>endbr64</code>もセキュリティ上，重要です．
間接ジャンプは脆弱性の大きな原因です．
<code>endbr64</code>はセキュリティ技術であるIntel CET技術の命令であり，
間接ジャンプ先の命令が<code>endbr64</code>以外の時は実行エラーとする，というものです．
本書の学習者としては「<code>endbr64</code>はセキュリティ上，重要だけど，アセンブリ言語を学習する立場では「<code>endbr64</code>は<code>nop</code>命令(何も実行しない命令)」と思えば十分です．</p>
</blockquote>
</details>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>の各行の意味の<a href="2-asm-intro.html#add5.s-content">説明</a>の前に，説明の都合上，
<strong>アセンブル</strong>と<strong>アセンブラ</strong>を説明します．</p>
<h2 id="アセンブル"><a class="header" href="#アセンブル">アセンブリコードをオブジェクトファイルにアセンブルする</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>に対して，以下のコマンドを実行すると，
<code>add5.o</code>が生成されます．この処理を<strong>アセンブル</strong>(assemble)といいます．
そして，アセンブルを行うプログラム（コマンド）を
<strong>アセンブラ</strong>(assembler)と呼びます．
<code>gcc -c</code>は内部的にアセンブラ<code>as</code>を呼び出します．
<code>as</code>は本書で使用する<a href="https://sourceware.org/binutils/docs-2.40/as/index.html">GNUアセンブラ</a>のコマンド名です．</p>
<pre><code class="language-bash">$ gcc -c add5.s
$ ls
add5.c add5.o add5.s
</code></pre>
<img src="figs/assemble.svg" height="50px" id="fig:assemble">
<p>アセンブル処理は<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>とちょうど逆の関係です．</p>
<img src="figs/assemble2.svg" height="70px" id="fig:assemble2">
<p><code>add5.o</code>はバイナリファイルです．
また，<code>add5.o</code>から作成する実行可能ファイル<code>a.out</code>もバイナリファイルです．
バイナリ(の中身)については次の章，<a href="./3-binary.html">3節.バイナリ</a>で説明します．</p>
<h2 id="add5.s-content"><a class="header" href="#add5.s-content">アセンブリ言語の構成要素</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>はアセンブリ言語のプログラムであり，
<strong>アセンブリコード</strong> (assembly code)と呼びます．
アセンブリコードは以下の4つを組み合わせて書きます．</p>
<ul>
<li>機械語命令 (例：<code>pushq %rbp</code>)</li>
<li>アセンブラ命令 (例：<code>.text</code>)</li>
<li>ラベル定義 (例：<code>add5:</code>)</li>
<li>コメント (例：<code># add5.s</code>)</li>
</ul>
<p>特に<strong>機械語命令</strong>(machine instruction)と<strong>アセンブラ命令</strong>(assembler directive)
の違いに注意して下さい．</p>
<ul>
<li>
<p>機械語命令はCPUが実行する命令です．
例えば，<code>pushq %rbp</code>は機械語命令(のニモニック)です．
この<code>pushq %rbp</code>は<code>a.out</code>が実行された時に<strong>CPUが</strong>実行します．</p>
<p>アセンブラがすることは例えば
<code>add5.s</code>中の<code>pushq %rbp</code>という機械語命令のニモニックを
<code>0x55</code>という2進数(ここでは16進数表記)に変換して，<code>add5.o</code>に出力するだけです．
アセンブラは<code>pushq %rbp</code>という機械語命令を実行しません．
アセンブラにとって，<code>pushq %rbp</code>も<code>0x55</code>も両方とも単なるデータに過ぎないので
す．</p>
</li>
<li>
<p>アセンブラ命令はアセンブラが実行する命令です．
例えば，<code>.text</code>はアセンブラ命令です．
本書が使用するGNUアセンブラではドット記号<code>.</code>で始まる命令は全てアセンブラ命令です．</p>
<p><a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブラ</a>は<code>add5.s</code>から<code>add5.o</code>を出力（アセンブル）します．
そのアセンブラに対して行う指示がアセンブラ命令です．
例えば，<code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」を
アセンブラに指示しています．
アセンブラはアセンブル時に<code>.text</code>というアセンブラ命令を実行します
(CPUが<code>a.out</code>を実行するときではありません）．</p>
</li>
</ul>
<h2 id="アセンブリ言語は1行に1つが基本"><a class="header" href="#アセンブリ言語は1行に1つが基本">アセンブリ言語は1行に1つが基本</a></h2>
<p>アセンブリ言語は基本的に1行に1つだけ，
「機械語命令」「アセンブラ命令」「ラベル定義」「コメント」
のいずれかを書くのが基本です．
ただし，複数を組み合わせて1行にできる場合もあります．
以下に可能な例を示します．</p>
<ul>
<li>OK <code>add5: pushq %rbp</code>   (ラベル定義と機械語命令)</li>
<li>OK <code>pushq %rbp; movq %rsp, %rbp</code>   (機械語命令と機械語命令，セミコロン<code>;</code>で区切る)</li>
<li>OK <code>pushq %rbp  # コメント</code> (機械語命令とコメント)</li>
<li>OK <code>.text  # コメント</code> (アセンブラ命令とコメント)</li>
</ul>
<h2 id="add5s中の-add5s"><a class="header" href="#add5s中の-add5s"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code># add5.s</code></a></h2>
<p><code># add5.s</code>は<code>gcc -S</code>の出力ではなく，私が付け加えた行です．
この行は<strong>コメント</strong>です．<code>#</code>から行末までがコメントとなり，
アセンブラは単にコメントを無視します．
つまりコメントは(C言語のコメントと同じで)人間が読むためだけのものです．</p>
<h2 id="add5s中のtext"><a class="header" href="#add5s中のtext"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>.text</code></a></h2>
<p><code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」と
アセンブラに指示しています．
<a href="./3-binary.html#.text">セクション</a>でも説明しますが，
<code>add5.o</code>や<code>a.out</code>などのバイナリファイルの中身は<strong>セクション</strong>という単位で
区切られています．
アセンブラが(機械語を含む)データを2進数に変換して出力する時，
「どのセクションに出力するのか」の指定が必要となるのです．</p>
<p><code>.text</code>セクション以外には，代表的なセクションとして，
<code>.data</code>セクション，<code>.rodata</code>セクションがあります．
それぞれの役割は以下の通りです．</p>
<ul>
<li><code>.text</code>    機械語命令(例：<code>pushq %rbp</code>)を置くセクション</li>
<li><code>.data</code>    初期化済みの静的変数の値(例：<code>0x1234</code>)を置くセクション</li>
<li><code>.rodata</code>  読み込みのみ(read only)の値(例：<code>&quot;hello\n\0&quot;</code>)を置くセクション</li>
</ul>
<p>例えば，以下のアセンブリコード<code>foo.s</code>があるとします
(<code>.rodata</code>セクションを指定する際は，<code>.section</code>が必要です)．</p>
<pre><code class="language-x86asmatt"># foo.s
.text            # .textセクションに出力せよ
pushq %rbp
movq %rsp, %rbp
.data            # .dataセクションに出力せよ
.long 0x11223344
.section .rodata # .rodataセクションに出力せよ
.string &quot;hello\n\0&quot;
</code></pre>
<p>この<code>foo.s</code>をアセンブラが処理すると以下になります(以下の図を見ながら読んで下さい)．</p>
<ul>
<li><code>pushq %rbp</code>を2進数にすると <code>0x55</code>，
<code>movq %rsp, %rbp</code>を2進数にすると <code>0x48 0x89 0xe5</code> なので，
これら合計4バイトを<code>.text</code>セクションに出力します．</li>
<li><code>.data</code>は「<code>.data</code>セクションに出力せよ」
「<code>.long</code>は指定したデータを4バイトの2進数として出力せよ」という意味です．
<code>0x11223344</code>を2進数にすると <code>0x44 0x33 0x22 0x11</code>なので
これら4バイトを<code>.data</code>セクションに出力します．
(出力が逆順になっているように見えるのは
x86-64が<a href="./3-binary.html#%E3%83%AA%E3%83%88%E3%83%AB%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>だからです．)</li>
<li><code>.section .rodata</code>は「<code>.rodata</code>セクションに出力せよ」
「<code>.ascii</code>は指定した文字列をASCIIコードの2進数として出力せよ」という意味です．
<code>&quot;hello\n\0&quot;</code>を2進数にすると <code>0x68 0x65 0x6c 0x6c 0x64 0x0a 0x00</code>なので，
これら7バイトを<code>.rodata</code>セクションに出力します．
(最後の'\0'はヌル文字です．C言語では文字列定数の最後に自動的に
ヌル文字が追加されますが，アセンブリ言語では必ずしもそうではありません．
<code>.ascii</code>はヌル文字を追加しません．)
ASCIIコードは<code>man ascii</code>で確認できます．</li>
</ul>
<img src="figs/section2.svg" height="200px" id="fig:section2">
<details>
<summary>
.bssセクションは?
</summary>
<blockquote>
<p><code>.text</code>，<code>.data</code>，<code>rodata</code>に加えて，<code>.bss</code>セクションも代表的なセクションですが，
ここでは説明を省略しました．
<a href="./3-binary.html#.bss"><code>.bss</code>セクション</a>は未初期化の静的変数の実体を格納するセクションなのですが，
ちょっと特殊だからです．
未初期化の静的変数はゼロで初期化されることになっているので，
バイナリファイル中では(サイズの情報等をのぞいて)実体は存在しません．
プログラム実行時に初めてメモリ上で<code>.bss</code>セクションの実体が確保され，
その領域はゼロで初期化されます．</p>
</blockquote>
</details>
<h2 id="add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a class="header" href="#add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>add5:</code>，<code>.globl add5</code>，<code>.type add5, @function</code>，<code>.size add5, .-add5</code></a></h2>
<h3 id="add5はラベルの定義"><a class="header" href="#add5はラベルの定義"><code>add5:</code>はラベルの定義</a></h3>
<p><code>add5:</code>は<code>add5</code>というラベルを定義しています．
ラベルはアドレスを表しています．
もっと具体的には「ラベルは，そのラベル直後の機械語命令や値が，
メモリ上に配置された時のアドレス」になります．</p>
<p>例えば，次のアセンブリコードがあり，</p>
<pre><code class="language-x86asmatt">add5:
    pushq %rbp 
</code></pre>
<p>この<code>pushq %rbp</code>命令の2進数表現<code>0x55</code>が<code>0x1234</code>番地に置かれたとします．</p>
<img src="figs/label.svg" height="150px" id="fig:label">
<p>この時，ラベル<code>add5</code>の値は<code>0x1234</code>になります．
（ここでは話を単純化しています．ラベルの値が最終的に決まるまで，
再配置(relocation)などの処理が入ります）</p>
<h3 id="ラベルの参照"><a class="header" href="#ラベルの参照">ラベルの参照</a></h3>
<p>で，大事なラベルの使い方（参照）です．
機械語命令のニモニック中で，<strong>アドレスを書ける場所にはラベルも書ける</strong>のです．
例えば，関数をコールする命令<code>call</code>命令で<code>add5</code>関数を呼び出す時，
以下の2行はどちらも同じ意味になります．
ラベル<code>add5</code>の値は<code>0x1234</code>になるからです．
（ここでも話を単純化しています．関数や変数のアドレスは
絶対アドレスではなく，相対アドレスなどが使われることがあるからです）．</p>
<pre><code class="language-x86asmatt">    call 0x1234
    call add5    
</code></pre>
<p>どちらの書き方でも，アセンブラのアセンブル結果は同じになります．
（もちろん通常はラベルを使います．具体的なアドレスを使って
アセンブリコードを書くのは人間にとってはつらいからです）．</p>
<h3 id="記号表がラベルを管理する"><a class="header" href="#記号表がラベルを管理する">記号表がラベルを管理する</a></h3>
<p>アセンブラはラベルのアドレスが何番地になるかを管理するために，
アセンブル時に<strong>記号表</strong>(symbol table)を作ります．
記号表中の情報は割と単純で，主に以下の6つです．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレス</th><th>配置される<br/>セクション</th><th>グローバル<br/>か否か</th><th>型</th><th>サイズ</th><th>ラベル名<br/>(シンボル名)</th></tr></thead><tbody>
<tr><td><code>0x1234</code></td><td><code>.text</code></td><td>グローバル</td><td>関数</td><td>15</td><td><code>add5</code></td></tr>
</tbody></table>
</div>
<p>ここで，<a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>のラベル<code>add5</code>が</p>
<ul>
<li>配置されるセクションが<code>.text</code>なのは，ラベルの定義<code>add5:</code>の前に<code>.text</code>が指定されているから</li>
<li>グローバルなのは，<code>.globl add5</code>と指定されているから</li>
<li>関数という型なのは，<code>.type add5, @function</code>と指定されているから</li>
<li>サイズが15バイトなのは，<code>.size  add5, .-add5</code>と指定されているから
(サイズ15バイトは<code>.-add5</code>から自動計算されます)</li>
</ul>
<p>です．
ここでグローバルの意味は，C言語のグローバル関数やグローバル変数と(ほぼ)同じです．
グローバルなシンボルは他のファイルからも参照できます．</p>
<details>
<summary>
ラベル or シンボル？
</summary>
<blockquote>
<p>アセンブラが扱うシンボルのうち，アドレスを表すシンボルのことをラベルと呼んでいます．
シンボルはアドレス以外の値も保持できます．
つまりシンボルの一部がラベルであり，<code>add5</code>は関数<code>add5</code>の先頭アドレスを表すシンボルなのでラベルです．</p>
</blockquote>
</details>
<details>
<summary>
.-add5 とは
</summary>
<blockquote>
<p><code>.-add5</code>はアドレスの引き算をしています．<code>.</code>は特別なラベルで「この行のアドレス」を意味します．<code>add5</code>は<code>add5:</code>のアドレスを意味します．
ですので，<code>.-add5</code>は「最後の<code>ret</code>命令の次のアドレスから，
最初の<code>pushq %rbp</code>命令のアドレスを引いた値」になります．
つまり引き算の結果は「関数<code>add5</code>中の機械語命令の合計サイズ（単位はバイト）」です．</p>
</blockquote>
</details>
<p><a href="./3-binary.html#nm"><code>nm</code>コマンド</a>を使うと記号表の中身を表示できます．</p>
<pre><code class="language-bash">$ nm ./a.out |egrep add5
0000000000001234 T add5
</code></pre>
<p>大文字<code>T</code>は「<code>.text</code>中のグローバルシンボル」であることを意味しています．
（小文字<code>t</code>だと「<code>.text</code>中のグローバルではないシンボル」という意味になります）．
この<code>nm</code>の出力では「<code>add5</code>が関数」という情報とサイズが表示できていません．
<code>readelf</code>コマンドを使うと，関数であることとサイズが❶15バイトであることを表示できます．</p>
<pre><code class="language-bash">$ readelf -s ./a.out | egrep add5
     1: 0000000000001234    ❶15 FUNC    GLOBAL DEFAULT    1 add5
</code></pre>
<details>
<summary>
readelfコマンドとは
</summary>
<blockquote>
<p><code>objdump</code>は汎用のコマンド（ELFバイナリ以外のバイナリにも使える）ため，
<a href="./3-binary.html#ELF">ELF</a>特有の情報を表示できないことがあります．
ELF専用のコマンドである<code>readelf</code>を使えば，ELF特有の情報も表示できます．
例えば，以下では<code>readelf</code>を使って記号表(❶<code>.symtab</code>)のセクションがあることを確認できました．</p>
<pre><code class="language-bash">$ readelf -S add5.o セクションヘッダを表示
There are 12 section headers, starting at offset 0x258:
Section Headers:
 [Nr] Name              Type             Address           Offset
      Size              EntSize          Flags  Link  Info  Align
 [ 0]                   NULL             0000000000000000  00000000
      0000000000000000  0000000000000000           0     0     0
 [ 1] .text             PROGBITS         0000000000000000  00000040
      0000000000000013  0000000000000000  AX       0     0     1
 [ 2] .data             PROGBITS         0000000000000000  00000053
      0000000000000000  0000000000000000  WA       0     0     1
 [ 3] .bss              NOBITS           0000000000000000  00000053
      0000000000000000  0000000000000000  WA       0     0     1
（中略）↓これが記号表 (symbol table)
 [ 9]❶.symtab           SYMTAB           0000000000000000  000000d8
      00000000000000f0  0000000000000018          10     9     8
</code></pre>
</blockquote>
</details>
<h2 id="stack-frame"><a class="header" href="#stack-frame"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>pushq %rbp</code>，<code>movq  %rsp, %rbp</code>，<code>popq  %rbp</code></a></h2>
<h3 id="movq-rsp-rbp"><a class="header" href="#movq-rsp-rbp"><code>movq %rsp, %rbp</code></a></h3>
<p><code>%rsp</code>と<code>%rbp</code>はどちらも<strong>レジスタ</strong>です．
(GNUアセンブラではレジスタの名前の先頭に必ず<code>%</code>が付きます)．
レジスタはCPU内の高速なメモリです．CPUはメモリにアクセスするよりも，
はるかに高速にレジスタにアクセスできます．
<code>%rsp</code>と<code>%rbp</code>はどちらも8バイト長のデータを格納できます．</p>
<p><code>movq %rsp, %rbp</code>という機械語命令は
「<code>%rsp</code>レジスタの値を<code>%rsp</code>にコピーする」という命令です．
<code>movq</code>のmovは「move (移動)」，qは「処理するサイズが8バイト」であることを意味しています．</p>
<details>
<summary>
なぜqが8バイト?
</summary>
<blockquote>
<p>qはクアッドワード(quad word)の略だからです．
以下の通り，クワッドワードは「ワード2バイトの4個分」なので8バイトになります．</p>
<ul>
<li><strong>ワード</strong>(word)は<strong>バイト</strong>(byte)と同様に情報量の単位ですが，
ワードが何バイトかはCPUごとに異なります．
x86-64ではワードは2バイトです．
x86の元祖であるIntel 8086が16ビットCPUだったことに由来します．</li>
<li><strong>クアッド</strong>(quad)は4を意味します．
例えば，quadrupleは「4倍の」，quad bikeは「4輪バイク」を意味します．</li>
</ul>
</blockquote>
</details>
<p>仮に<code>movq %rsp, %rbp</code>を実行する前に，
<code>%rsp</code>の値が<code>0x11223344</code>，<code>%rbp</code>の値が<code>0x55667788</code>とします．
<code>movq %rsp, %rbp</code>を実行すると，
<code>%rsp</code>の値が<code>%rbp</code>にコピーされるので，
<code>%rsp</code>の値も<code>%rbp</code>の値も<code>0x11223344</code>になります．
要するに，<code>movq</code>命令はC言語の代入文と同じです．</p>
<img src="figs/rsp-rbp.svg" height="150px" id="fig:rsp-rbp">
<h3 id="push-rbp-pop-rbp"><a class="header" href="#push-rbp-pop-rbp"><code>pushq %rbp</code>と<code>popq  %rbp</code></a></h3>
<p><code>pushq %rbp</code>は「スタックに<code>%rbp</code>の値を<strong>プッシュ</strong>する」機械語命令です．
以下の図のように，<code>%rbp</code>中の値をスタックの一番上にコピーします．
スタックはコピー先の部分を含めて上に成長します（赤枠の部分がスタック全体）．</p>
<img src="figs/push-rbp.svg" height="200px" id="fig:push-rbp">
<p><code>popq %rbp</code>は「スタックから<strong>ポップ</strong>した値を<code>%rbp</code>に格納する」という機械語命令です．
以下の図のように，スタックの一番上の値を<code>%rbp</code>にコピーします．
スタックはコピー元の部分だけ下に縮みます（赤枠の部分がスタック全体）．</p>
<img src="figs/pop-rbp.svg" height="200px" id="fig:pop-rbp">
<p>これだけだと，<code>pushq %rbp</code>や<code>popq %rbp</code>の役割がよく分かりませんね．
実はこの2つの命令は以下で説明する<strong>スタックフレーム</strong>の処理に関係しています．</p>
<h3 id="データ構造としてのスタック"><a class="header" href="#データ構造としてのスタック">データ構造としてのスタック</a></h3>
<p><strong>スタック</strong>(stack)は超基本的なデータ構造であり，
以下の図の通り，<strong>プッシュ操作</strong>と<strong>ポップ操作</strong>でデータの格納と取り出しを行います．</p>
<ul>
<li>プッシュはスタックの一番上にデータを格納します</li>
<li>ポップはスタックの一番上からデータを取り出します</li>
</ul>
<img src="figs/stack.svg" height="200px" id="fig:stack">
<p>最後に格納したデータが，取り出す時は先に取り出されるので，
<strong>後入れ先出し方式</strong>(LIFO: last in first out)とも呼ばれます．</p>
<p>スタックは関数呼び出しの実装に便利なデータ構造です．
関数呼び出しからリターンするときは，呼び出された順番とは逆順にリターンするからです．</p>
<details>
<summary>
キューqueueは?
</summary>
<blockquote>
<p>ちなみに超基本的なデータ構造として<strong>キュー</strong>(queue)も重要です．
こちらは先に格納したデータが，先に取り出されるので
<strong>先入れ先出し方式</strong>(FIFO: first in first out)になります．</p>
</blockquote>
</details>
<h3 id="スタックとスタックフレーム"><a class="header" href="#スタックとスタックフレーム">スタックとスタックフレーム</a></h3>
<p><strong>スタック</strong>とはプロセス（実行中のプログラム）が使用するメモリの領域の1つです．
ここでのスタックは関数呼び出しのためのスタックなので，
<strong>コールスタック</strong>(call stack)と呼ぶのが正式名称なのですが，
慣習に習って本書でも単にスタックと呼びます．</p>
<img src="figs/memory-layout.svg" height="300px" id="fig:memory-layout">
<p>関数を呼び出すと，<strong>スタックフレーム</strong>というデータがスタックに追加(プッシュ)されて，
スタックは上に成長します．その関数からリターンすると，
そのスタックフレームはスタックから削除(ポップ)されて縮みます．
スタックフレームは<strong>関数呼び出し1回分のデータ</strong>で，
局所変数，引数，返り値，戻り番地(リターンアドレス)，退避したレジスタの値などを含みます．</p>
<p>例えば，<code>main</code>関数が<code>add55</code>関数を呼び出して，<code>add5</code>からリターンすると以下の図になります．</p>
<img src="figs/stack-frame.svg" height="200px" id="fig:stack-frame">
<h3 id="rspとrbpは一番上のスタックフレームの上下を指す"><a class="header" href="#rspとrbpは一番上のスタックフレームの上下を指す"><code>%rsp</code>と<code>%rbp</code>は一番上のスタックフレームの上下を指す</a></h3>
<p>さて，ここでようやく<code>%rsp</code>レジスタと<code>%rbp</code>レジスタの出番です．
実は<code>%rsp</code>と<code>%rbp</code>は以下の図のように，
<strong>スタック上の一番上のスタックフレームの上下</strong>を指す役割を担っています．</p>
<img src="figs/stack-frame2.svg" height="200px" id="fig:stack-frame2">
<p>「レジスタがスタックを指す」というのは具体的に以下の図の状態です．
つまり，
スタックフレームの一番上のアドレス(例えば<code>0x11223344</code>)が
<code>%rsp</code>に入っていて，<code>%rsp</code>の値をそのアドレスとして使う意図がある場合，
「<code>%rsp</code>はスタックフレームの一番上を指す」と言い，
<a href="2-asm-intro.html#fig:stack-frame2">上の図</a>のように矢印で図表現します．
(<code>%rbp</code>も同様です)</p>
<img src="figs/stack-frame3.svg" height="170px" id="fig:stack-frame3">
<h3 id="stack-frame4"><a class="header" href="#stack-frame4"><code>%rsp</code>は常にスタックの一番上を指す</a></h3>
<p><code>pushq</code>命令で
プッシュすると<code>%rsp</code>はプッシュしたデータの一番上を指すようにずれるので，
<code>%rsp</code>は常にスタックの一番上(スタックトップ)を指します．
また，<code>%rbp</code>をプッシュしたので下図のように
プッシュした値もスタックフレームの一番下を指しています．</p>
<img src="figs/push-rbp-2.svg" height="120px" id="fig:push-rbp-2">
<p>同様に<code>popq</code>命令でポップした時はポップで取り出したデータ分だけ
<code>%rsp</code>が指す先は下にずれて，やはり<code>%rsp</code>はスタックトップを指します．
下図では保存した<code>%rbp</code>の値をポップして<code>%rbp</code>に格納したので，
この時だけ「ひとつ下のスタックフレームの一番下」を<code>%rbp</code>は指しています
(が，通常，この直後にリターンして一番上のスタックフレームは破棄されます．
ですので，すぐに「<code>%rsp</code>と<code>%rbp</code>は常に一番上のスタックフレームの上下を指す」
という状態に戻ります．)</p>
<img src="figs/pop-rbp-2.svg" height="150px" id="fig:pop-rbp-2">
<h3 id="create-new-stack-frame"><a class="header" href="#create-new-stack-frame"><code>pushq %rbp</code> と <code>movq %rsp, %rbp</code> は新しいスタックフレームを作る</a></h3>
<p>関数を呼び出すと，その関数のための新しくスタックフレームを作る必要があります．
誰が作るのかというと「呼び出された関数自身」が作ります(これはABI(xxx)が定める事項です)．</p>
<p>ここでは関数<code>main</code>が関数<code>add5</code>を<code>call</code>命令で呼び出すとして説明します．</p>
<pre><code class="language-x86asmatt">main:
   ...
   call add5
</code></pre>
<pre><code class="language-x86asmatt">add5:
   pushq %rbp
   movq %rsp, %rbp
</code></pre>
<p>これらの命令を実行した時のスタックの様子は以下の図のとおりです．
(「<code>call</code>前」等のボタンを押して，図を切り替えて下さい)</p>
<div class="tab-wrap">
    <input id="stack-frame4-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="stack-frame4-1"><code>call</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-1.svg" height="150px" id="fig:stack-frame4-1">
    </div>
    <input id="stack-frame4-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-2"><code>call</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-2.svg" height="150px" id="fig:stack-frame4-2">
    </div>
    <input id="stack-frame4-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-3"><code>push %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-3.svg" height="150px" id="fig:stack-frame4-3">
    </div>
    <input id="stack-frame4-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-4"><code>movq %rsp, %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
    </div>
</div>
<p>一つずつ説明していきます．</p>
<ul>
<li><code>call</code>命令実行前は<code>main</code>関数が一番上のスタックフレームです．
その上下を<code>%rsp</code>と<code>%rbp</code>が指しています．</li>
<li><code>call</code>命令を実行して<code>add5</code>関数に実行を移す際に，
<code>call</code>命令はスタック上に<strong>戻り番地</strong>(リターンアドレス)をプッシュします．
戻り番地とは「関数からリターンした時にどのアドレスに実行を戻せばよいか」
　を表す番地です．この場合では<code>call add5</code>命令の次のアドレスが戻り番地になります．</li>
<li><code>push %rbp</code>命令を実行すると，今の<code>%rbp</code>レジスタの値をスタック上にプッシュします．
<a href="2-asm-intro.html#push-rbp-2">上</a>の説明と見比べて下さい．
新しいスタックフレームを作る際に，<code>%rbp</code>に新しい値を設定する必要があるために，
今の<code>%rbp</code>の値をスタック上に退避（保存）するため，<code>pushq %rbp</code>が必要となります．</li>
<li>次に <code>movq %rsp, %rbp</code> を実行します．
実は<code>add5</code>のスタックフレームはとても小さくて「古い<code>%rbp</code>」しか入っていません．
ですので，<code>%rsp</code>の値を<code>%rbp</code>にコピーすれば，
「<code>add5</code>のスタックフレームの上下を<code>%rsp</code>と<code>%rsp</code>が指している」という状態にできます．
この動作も<a href="2-asm-intro.html#movq-rsp-rbp">上</a>で説明したので見比べて下さい．</li>
</ul>
<p>以上で，<code>add5</code>のための新しいスタックフレームを作れました．</p>
<h3 id="popq-rbpは今のスタックフレームを捨てる"><a class="header" href="#popq-rbpは今のスタックフレームを捨てる"><code>popq %rbp</code>は今のスタックフレームを捨てる</a></h3>
<p>これは<a href="2-asm-intro.html#create-new-stack-frame">前節</a>での説明のちょうど逆になります．</p>
<pre><code class="language-x86asmatt">popq %rbp
ret
</code></pre>
<p>を実行すると，スタックフレームは以下の図になります．</p>
<div class="tab-wrap">
    <input id="stack-frame5-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="stack-frame5-1"><code>popq %rbp</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-1.svg" height="150px" id="fig:stack-frame5-1">
    </div>
    <input id="stack-frame5-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-2"><code>popq %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-2.svg" height="150px" id="fig:stack-frame5-2">
    </div>
    <input id="stack-frame5-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-3"><code>ret</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-3.svg" height="150px" id="fig:stack-frame5-3">
    </div>
</div>
<ul>
<li>
<p><code>popq %rbp</code>の実行前は，スタックトップ付近はこの図の状態になっています．
(コンパイラがこの図の状態になるようにアセンブリコードを出力します．
自分でアセンブリコードを書く場合は，この図の状態になるように正しくプログラムする必要があります)
「この図の状態」をもう少し説明すると以下になります．</p>
<ul>
<li>スタックトップには <strong>古い<code>%rbp</code></strong> が格納されていて，
その <strong>古い<code>%rbp</code></strong> は1つ前のスタックフレームの一番下を指している．</li>
<li>スタックトップのひとつ下には<strong>戻り番地</strong>が格納されている．</li>
<li>さらにその下には<code>add5</code>を呼び出した関数(ここでは<code>main</code>)のスタックフレームがある．</li>
</ul>
</li>
<li>
<p><code>popq %rbp</code>を実行すると，<code>%rbp</code>は<code>main</code>関数のスタックフレームの一番下を
指すようになります．(<a href="2-asm-intro.html#push-rbp-pop-rbp">上の説明</a>と合わせて読んで下さい．)
また，ポップの結果，<code>%rsp</code>が指す先が下にずれて，戻り番地を指すように変わりました．</p>
</li>
<li>
<p><code>ret</code>命令はスタックトップから戻り番地をポップして，次に実行する命令を戻り番地に設定します．スタックの状態は<code>add5</code>を呼び出す前の状態に戻りました．</p>
</li>
</ul>
<details id="-fomit-frame-pointer">
<summary>
「この図の状態」の例外
</summary>
<blockquote>
<p><a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にならないことがあります．
<code>-fomit-frame-pointer</code>というオプション付きでコンパイルすると，
<code>%rbp</code>は「スタックフレームの一番下を指すポインタ(ベースポインタ)」として
使うのではなく，汎用レジスタ(好きな目的のために使えるレジスタ)として使われます．
このため，関数からリターンする直前に<a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にはなりません．
<code>-O2</code>などの最適化オプションを指定すると，
<code>-fomit-frame-pointer</code>も有効になることが多いです．</p>
</blockquote>
</details>
<details>
<summary>
全てのスタックフレームは「古い`%rbp`」で数珠つなぎ
</summary>
<blockquote>
<p>実は下の図のように全てのスタックフレームは「古い<code>%rbp</code>」で数珠つなぎ，
つまり<strong>線形リスト</strong>(linked list)になっています</p>
<img src="figs/stack-frame-list.svg" height="300px" id="fig:stack-frame-list">
</blockquote>
</details>
<details>
<summary>
戻り番地とプログラムカウンタ
</summary>
<blockquote>
<p>一般的にCPUは<strong>プログラムカウンタ</strong>と呼ばれる特別な役割を持つレジスタを備えています．
x86-64では<code>%rip</code>レジスタがプログラムカウンタです．
<code>ret</code>命令はスタックをポップして取り出した戻り番地を
プログラムカウンタ<code>%rip</code>に格納することで，「関数からリターンする」という
動作を実現しています．</p>
</blockquote>
</details>
<h2 id="add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a class="header" href="#add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の <code>movl  %edi, -4(%rbp)</code>， <code>movl  -4(%rbp), %eax</code>， <code>addl  $5, %eax</code></a></h2>
<p>ここでは以下の3命令を説明します．
直感的にはこの3命令で「<code>n + 5</code>」を計算しています．</p>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
  addl  $5, %eax
</code></pre>
<ul>
<li>
<p>まず<code>-4(%rbp)</code>を説明します．
これは「<code>%rbp</code>中のアドレスから4を引いた数」をアドレスとしてメモリを
読み書きすることを意味しています．以下の図はスタックをより正確に描いています．</p>
<ul>
<li>メモリは1バイトごとにアドレスが付いています．
古い<code>%rbp</code>や戻り番地のデータはそれぞれ8バイトなので，
アドレス8つ分(つまり8バイト)の場所を占めています．</li>
<li>多バイト長のデータはそのデータが占めている<strong>先頭のアドレス</strong>を使って
メモリを読み書きします．(本書の図ではメモリの0番地が常に上にあることを思い出してください)．
ですので，1バイトごとのアドレスで考えると，<code>%rbp</code>はスタックフレームの
一番下を指していません．</li>
<li>そして，<code>-4(%rbp)</code>は「<code>%rbp</code>から4を引いたアドレス」ですので，
以下の図で<code>-4(%rbp)</code>が指している場所を指しています．</li>
</ul>
</li>
</ul>
<img src="figs/stack-layout.svg" height="400px" id="fig:stack-layout">
<ul>
<li>
<p>次に<code>%edi</code>と<code>%eax</code>について説明します．</p>
<ul>
<li>以下の図のようにx86-64には8バイト長の<code>%rdi</code>と<code>%rax</code>という
汎用レジスタがあります(他にも汎用レジスタはありますがここでは割愛)．
その右半分にそれぞれ<code>%edi</code>と<code>%eax</code>という名前が付いています．
<code>%edi</code>と<code>%eax</code>は4バイト長です．</li>
<li><code>%rdi</code>レジスタは関数呼び出しでは<strong>第1引数</strong>を渡すために使われます．
<code>add5</code>の第1引数<code>n</code>は<code>int</code>型で，この場合は4バイト長だったため，
<code>%edi</code>に<code>n</code>の値が入っています．</li>
<li><code>%rax</code>レジスタは関数呼び出しでは<strong>返り値</strong>を返すために使われます．
<code>add5</code>の返り値の方が<code>int</code>型なので，<code>%eax</code>に値を入れてから
関数をリターンすれば，返り値が返せることになります．</li>
</ul>
</li>
</ul>
<img src="figs/edi-eax.svg" height="300px" id="fig:edi-eax">
<ul>
<li>次に以下の2つの命令を説明します．</li>
</ul>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
</code></pre>
<ul>
<li><code>movl</code>の<code>l</code>は4バイトのデータをコピーすることを表しています．ですので，
例えば，<code>movl  %edi, -4(%rbp)</code>は<code>%edi</code>中の4バイトデータを
先頭アドレスが<code>-4(%rbp)</code>から4バイト分の領域
(<a href="2-asm-intro.html#fig:stack-layout">この図</a>で一番上の赤い部分)
にコピーする命令になります．</li>
</ul>
<details>
<summary>
なぜl(エル)が4バイト
</summary>
<blockquote>
<p>l(エル)はlongの略で，GNUアセンブラでは以下の通り，longが4バイトを意味するからです．
Intelマニュアルなどでは4バイトのことをdouble wordと呼びます．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>short</td><td>long</td><td>quad</td></tr>
<tr><td>Intelマニュアル</td><td>word</td><td>double word</td><td>quad word</td></tr>
</tbody></table>
</div></blockquote>
</details>
<ul>
<li>
<p>この2つの命令で「<code>%edi</code>中の4バイトを<code>-4(%rbp)</code>にコピー」して，次に
「<code>-4(%rbp)</code>中の4バイトを<code>%eax</code>にコピー」しています．
「<code>%edi</code>から<code>%eax</code>に直接コピーすればいいんじゃね?」と思った方，正解です．
実はこの場合は(<code>-4(%rbp)</code>に格納しても使われないので)不要なのですが，
コンパイラは
「引数<code>n</code>の実体の場所を<code>-4(%rbp)</code>としたので，
<code>-4(%rbp)</code>にも<code>n</code>の値を格納する」という判断をしたようです．</p>
</li>
<li>
<p><code>addl  $5, %eax</code>命令を説明します．</p>
<ul>
<li>この命令は<code>%eax</code>の値と定数<code>5</code>の値を足し算した結果を<code>%eax</code>に格納します．</li>
<li>つまり，<code>n + 5</code>の結果がこの命令の実行後に<code>%eax</code>に入ります．</li>
<li>GNUアセンブラでは定数の先頭にはドルマーク<code>$</code>が付きます．
ただし，<code>-4(%rbp)</code>の<code>-4</code>など，ドルマークが付かないこともあります．</li>
</ul>
</li>
</ul>
<p>以上で<code>add5.s</code>の説明が終わりました(お疲れ様でした)．</p>
</details>
<details>
<summary>
即値とは
</summary>
<blockquote>
<p>上で<code>$5</code>は定数と説明しましたが，アセンブラ用語では
<strong>即値</strong>(immediate value)と呼びます．
それは機械語命令の2進数の中に
即値の値が埋め込まれており，即座に(つまりメモリやレジスタにアクセスすることなく)
値を取り出せることに由来しています．
x86-64のマニュアルなどで <em>imm32</em> などが出てきます．<em>imm32</em>は「32ビット長の即値」を意味しています．</p>
</blockquote>
</details>
</details>
<details>
<summary>
%rspの上に勝手に書き込んで良いのか(レッドゾーン)
</summary>
<blockquote>
<p>LinuxのABI <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>ではOKです．
LinuxのABIでは<code>%rsp</code>レジスタの上，128バイトの領域を<strong>レッドゾーン</strong>と呼び，
この領域には好きに読み書きして良いことになっています．
(ABIが「割り込みハンドラやシグナルハンドラが実行されても，
レッドゾーンの値は破壊されない」ことを保証しています．）
もちろん，自分自身で関数を呼び出すとレッドゾーン中の値は壊れるので，
レッドゾーンは<strong>葉関数</strong>(leaf function)，つまり関数を呼び出さない関数
が使うのが一般的です．
レッドゾーンのおかげで，<code>%rsp</code>をずらさずにメモリの読み書きができるので，
その分だけ実行が高速になります．</p>
<img src="figs/redzone.svg" height="300px" id="fig:redzone">
</blockquote>
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 3; }
</style>
<h1 id="バイナリファイル"><a class="header" href="#バイナリファイル">バイナリファイル</a></h1>
<h2 id="バイナリファイルの中身を見る"><a class="header" href="#バイナリファイルの中身を見る">バイナリファイルの中身を見る</a></h2>
<h3 id="hexdump"><a class="header" href="#hexdump">16進ダンプ</a></h3>
<p><code>add5.c</code>や<code>add5.s</code>はテキストファイルですが，
<a href="./2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">2節のアセンブリ言語</a>で作成した
<code>add5.o</code>はバイナリファイルです．
バイナリファイルなので，<code>less</code>コマンドでは中身を読めません．</p>
<pre><code class="language-bash">$ less add5.o
^?❶ELF^B^A^A^@^@^@^@^@^@^@^@^@^A^@&gt;^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@X^B
^@^@^@^@^@^@^@^@^@^@@^@^@^@^@^@@^@^L^@^K^@&lt;F3&gt;^O^^&lt;FA&gt;UH&lt;89&gt;&lt;E5&gt;&lt;89&gt;}&lt;FC&gt;&lt;8B&gt;E
（長いので省略）
</code></pre>
<details id="ELF">
<summary>
❶ELFとは
</summary>
<blockquote>
<p>上の<code>less</code>コマンドの結果にELFという文字が見える理由を説明します．
ELFはLinuxが採用している<strong>バイナリ形式</strong>(binary format)です．
このELFのバイナリファイルの先頭4バイトには<strong>マジックナンバー</strong>という
バイナリファイルを識別する特別な数値が入っています．
ELFバイナリのマジックナンバーは <code>7F 45 4C 46</code>です．
<code>45 4C 46</code>はASCII文字で <code>E L F</code> なので，lessコマンドが<code>ELF</code>と表示したわけです． </p>
</blockquote>
</details>
<p>バイナリファイルの中身を読むには例えば<code>od</code>コマンドを使います．</p>
<pre><code class="language-bash">$ od -t x1 add5.o
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00
（長いので省略）
</code></pre>
<p>一番左の数字が「先頭からのバイト数(16進表記)」，
その右側に並んでいるのが「1バイトごとに16進表記したファイルの中身」です．
（1バイトのデータは2桁の16進数で表せることを思い出しましょう．
例えば，<code>add5.o</code>の中身の先頭4バイトの値は<code>7F 45 4C 46</code>です）．</p>
<p><code>-t x1</code>というオプションは「1バイトごとに16進数で表示せよ」という意味です．
このような出力を<strong>16進ダンプ</strong>(hex dump)と言います．
他に16進ダンプするコマンドとして，<code>xxd</code>や<code>hexdump</code>などがあります．</p>
<p>ちなみに，<code>add5.c</code>はテキストファイルですが，内容は2進数で保存されて
いますので，<code>od</code>コマンドで中身を表示できます．</p>
<pre><code class="language-bash">$ od -t x1 add5.c
0000000 69 6e 74 20 61 64 64 35 20 28 69 6e 74 20 6e 29
0000020 0a 7b 0a 20 20 20 20 72 65 74 75 72 6e 20 6e 20
0000040 2b 20 35 3b 0a 7d 0a
0000047
</code></pre>
<p>先頭の<code>69</code>はASCII文字<code>i</code>の文字コード，
同様に，次の<code>6e</code>は文字<code>n</code>，その次の<code>74</code>は文字<code>t</code>なので，
<code>add5.c</code>の先頭3文字が<code>int</code>であることを確認できます．
ASCIIコード表は<code>man ascii</code>コマンドで閲覧できます．</p>
<details>
<summary>
manコマンドとは
</summary>
<blockquote>
<p><code>man</code>コマンドはLinux上でマニュアルを表示するコマンドです．</p>
<p>例えば<code>man ascii</code>を実行すると以下のように表示されます．</p>
<pre><code class="language-bash">$ man ascii

ASCII(7)                   Linux Programmer's Manual                  ASCII(7)

NAME
      ascii - ASCII character set encoded in octal， decimal， and hexadecimal

DESCRIPTION
      ASCII is the American Standard Code for Information Interchange.  It is
      a 7-bit code.  Many 8-bit codes (e.g.， ISO  8859-1)  contain  ASCII  as
      their  lower  half.  The international counterpart of ASCII is known as
      ISO 646-IRV.

      The following table contains the 128 ASCII characters.

      C program '\X' escapes are noted.

      Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
      ────────────────────────────────────────────────────────────────────────
      000   0     00    NUL '\0' (null character)   100   64    40    @
      001   1     01    SOH (start of heading)      101   65    41    A
      002   2     02    STX (start of text)         102   66    42    B
（以下略）
</code></pre>
<p>デフォルトでは<code>less</code>コマンドで1ページずつ表示されるので，
スペースキーで次のページが，<code>b</code>を押せば前のページが表示されます．
終了するには<code>q</code>を押します．<code>h</code>を押せばヘルプを表示し，<code>/</code>で検索もできます．
例えば，<code>/backspace</code>と入力してリターンを押すと，<code>backspace</code>を検索してくれます．</p>
<p><code>man</code>コマンドは章ごとに分かれています．例えば</p>
<ul>
<li>1章はコマンド (例：<code>ls</code>)</li>
<li>2章はシステムコール (例：<code>open</code>)</li>
<li>3章はライブラリ関数 (例：<code>printf</code>)</li>
</ul>
<p>となっています．
<code>printf</code>というコマンドがあるので，
<code>man printf</code>とすると（ライブラリ関数ではなく）コマンドの<code>printf</code>の
マニュアルが表示されてしまいます．
ライブラリ関数の<code>printf</code>を見たい場合は
<code>man 3 printf</code>と章番号も指定します．</p>
</blockquote>
</details>
<p>なお，<code>od</code>コマンドに<code>-c</code>オプションをつけると，
(文字として表示可能なバイトは)文字が表示されます．</p>
<pre><code class="language-bash">$ od -t x1 -c add5.c
0000000  69  6e  74  20  61  64  64  35  20  28  69  6e  74  20  6e  29
          i   n   t       a   d   d   5       (   i   n   t       n   )
0000020  0a  7b  0a  20  20  20  20  72  65  74  75  72  6e  20  6e  20
         \n   {  \n                   r   e   t   u   r   n       n    
0000040  2b  20  35  3b  0a  7d  0a
          +       5   ;  \n   }  \n
0000047
</code></pre>
<h3 id="everything-binary"><a class="header" href="#everything-binary">コンピュータの中のデータはすべて<code>0</code>と<code>1</code>から成る</a></h3>
<p>ここで大事なことを復習しましょう．
それは
<strong>「コンピュータの中のデータは，どんな種類のデータであっても，
機械語命令であっても，すべて<code>0</code>と<code>1</code>だけで表現されている」</strong>
ということです．
ですので，テキストはバイナリでもあるのです．</p>
<ul>
<li>テキスト=文字として表示可能な2進数だけを含むデータ</li>
<li>バイナリ=文字以外の2進数も含んだデータ</li>
</ul>
<img src="figs/text-binary.svg" height="100px" id="fig:text-binary">
<blockquote>
<p>注意：
本書で，テキスト(text)という言葉には2種類の意味があることに注意して下さい．</p>
<ul>
<li>1つは「文字」を意味します．例：「テキストファイル」（文字が入ったファイル）</li>
<li>もう1つは「機械語命令列」を意味します．例：「<a href="3-binary.html#.text">テキストセクション</a>」（機械語命令列が格納されるセクション）</li>
</ul>
</blockquote>
<h3 id="2進数と符号化"><a class="header" href="#2進数と符号化">2進数と符号化</a></h3>
<p><a href="3-binary.html#everything-binary">前節</a>で説明した通り，
コンピュータ中では全てのものを0と1の2進数で表現する必要があります．
そのため，データの種類ごとに2進数での表現方法，つまり<strong>符号化</strong>
(encoding)の方法が定められています．
例えば，</p>
<ul>
<li>文字<code>U</code>をASCII文字として符号化すると，<code>01010101</code>になります．</li>
<li><code>pushq %rbp</code>をx86-64の機械語命令として符号化すると，<code>01010101</code>になります．</li>
</ul>
<p>おや，どちらも同じ<code>01010101</code>になってしまいました．
この2進数が<code>P</code>なのか<code>pushq %rbp</code>なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．</p>
<img src="figs/encode.svg" height="130px" id="fig:encode">
<p>別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する<a href="3-binary.html#.text"><code>.text</code>セクション</a>にある
2進数のデータ列は「<code>.text</code>セクションに存在するから」という理由で
機械語命令として解釈されます．</p>
<h3 id="fileコマンド"><a class="header" href="#fileコマンド"><code>file</code>コマンド</a></h3>
<p><a href="3-binary.html#hexdump">16進ダンプ</a>以外の方法で，<code>add5.o</code>の中身を見てみます．
まずは<code>file</code>コマンドです．</p>
<pre><code class="language-bash">$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable， x86-64， ❹version 1 (SYSV)， ❺not stripped
</code></pre>
<p>これで，<code>add5.o</code>が64ビットの❶ELFバイナリであることが分かりました．</p>
<details>
<summary>
❷LSBとは
</summary>
<blockquote>
<p>多バイト長のデータをバイト単位で格納する順序を<strong>バイトオーダ</strong>(byte order)といいます．
LSBは最下位バイトから順に格納するバイトオーダ (Least Significant Byte first)，
つまりリトルエンディアンを意味しています．
多バイト長データで最下位のバイトをLeast Significant Byte (<strong>LSB</strong>)，
最上位のバイトをMost Significant Byte (<strong>MSB</strong>)と呼びます．
例えば，<code>0x11223344</code>という4バイトのデータのLSBは<code>0x44</code>，MSBは<code>0x11</code>です．
多バイト長データをメモリに格納する時，</p>
<ul>
<li>LSBから先にメモリに格納する方法を<div style="display:inline-block" id="リトルエンディアン"><strong>リトルエンディアン</div></strong> (little endian)</li>
<li>MSBから先にメモリに格納する方法を<strong>ビッグエンディアン</strong> (big endian)
と呼びます．</li>
</ul>
<img src="figs/endian.svg" height="150px" id="fig:endian">
<p>x86-64のバイトオーダがリトルエンディアンのため，ELFバイナリもリトルエンディアンになっています．
リトルエンディアンでの注意は16進ダンプする時に，多バイト長データが逆順に表示されることです．
以下で多バイト長データ❶<code>0x11223344</code>を<code>.text</code>セクションに配置してアセンブルした
<code>little.o</code>を逆アセンブルすると，❸<code>44 33 22 11</code>と逆順に表示されています．
(<code>objdump -h</code>の出力から，<code>.text</code>セクションのオフセット(ファイルの先頭からのバイト数)が❷0x40バイトであることを使って，<code>od</code>コマンドに<code>-j0x40</code>オプションを使い，<code>.text</code>セクションの先頭付近の情報を表示しています)</p>
<pre><code class="language-bash">$ cat little.s
.text
❶.long 0x11223344
$ gcc -c little.s
$ objdump -h little.o
foo.o:     file format elf64-x86-64
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000004  0000000000000000  0000000000000000 ❷00000040  2**0
                  CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000044  2**0
                  CONTENTS， ALLOC， LOAD， DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0
                  ALLOC
$ od -t x1 -j0x40 little.o | head -n1
0000100 ❸44 33 22 11 00 00 00 00 00 00 00 00 00 00 00 00
</code></pre>
<details>
<summary>
エンディアンの由来とは
</summary>
<p><strong>エンディアン</strong>(endian)という言葉はガリバー旅行記から来ています．
お話の中で，卵の殻は尖った方からむくべき派 (little endian)と
丸い方からむくべき派 (big endian)が争うのです．なのでインディアンとは何の関係もありません．</p>
</details>
</blockquote>
</details>
<!--
これは嘘でしたｗ
> LSBはLinuxの標準である[Linux Standard Base](https://refspecs.linuxfoundation.org/lsb.shtml)の略です．LSBはELFバイナリの規格であるSystem V ABIを含んでいます．
ABIはapplication binary interfaceの略です．
-->
<details>
<summary>
❸relocatableとは
</summary>
<blockquote>
<p>バイナリ中のアドレスを再配置 (relocate)できるバイナリのことをrelocatableであるといいます．オブジェクトファイルはリンク時や実行時にアドレスを変更できるよう，
relocatableであることが多いです．</p>
</blockquote>
</details>
<details>
<summary>
❹version 1 (SYSV)とは
</summary>
<blockquote>
<p>LinuxのABI（バイナリ互換規約）である<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>
に準拠していることを表しています．</p>
</blockquote>
</details>
<details>
<summary>
❺not strippedとは
</summary>
<blockquote>
<p>バイナリには実行に直接関係ない<strong>記号表</strong>や<strong>デバッグ情報</strong>などが
含まれていることがよくあります．
この「実行に直接関係ない情報」が削除されたバイナリのことを
stripped binaryと呼びます．
<code>strip</code>コマンドで「実行に直接関係ない情報」を削除できます．
削除された分，サイズが少し減っています．</p>
<pre><code class="language-bash">$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 1368 Jul 19 10:09 add5.o
$ strip add5.o
$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 880 Jul 19 14:58 add5.o
</code></pre>
</blockquote>
</details>
<p>なお，<code>file</code>コマンドはバイナリ以外のファイルにも使えます．</p>
<pre><code class="language-bash">$ file add5.c
add5.c: ASCII text
$ file add5.s
add5.s: assembler source， ASCII text
$ file .
.:  directory
$ file /dev/null
/dev/null: character special (1/3)
</code></pre>
<h3 id=".text"><a class="header" href="#.text">セクションと<code>objdump -h</code>コマンド</a></h3>
<p>バイナリファイルの構造はざっくり以下の図のようになっています．</p>
<img src="figs/section.svg" height="250px" id="fig:text-binary">
<ul>
<li>最初のヘッダ以外の四角を<strong>セクション</strong>(section)と呼びます．</li>
<li>バイナリはセクションという単位で区切られていて，それぞれ別の目的でデータが格納されます．</li>
<li>ヘッダは目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．</li>
</ul>
<p>ヘッダの情報は<code>objdump -h</code>で表示できます．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
(以下略)
</code></pre>
<p>ここでは「<code>.text</code>，<code>.data</code>，<code>.bss</code>という3つのセクションがある」ことを
見ればOKです．</p>
<details>
<summary>
VMAとLMAとは
</summary>
<blockquote>
<p>VMAはvirtual memory addressの略で「このセクションがメモリ上で実行される時のメモリアドレス」です．一方，LMAはload memory addressの略で「このセクションをメモリ上に配置する時のメモリアドレス」です．
通常，セクションをメモリに配置した後で，移動せずにそのまま実行するため，VMAとLMAは同じアドレスになります．
<code>add5.o</code>ではアドレスが決まってないので，VMAもLMAもゼロになっています．</p>
</blockquote>
</details>
<details>
<summary>
File offとは
</summary>
<blockquote>
<p>File offはファイルオフセットを表しています．このセクションがバイナリファイルの先頭から何バイト目から始まっているかを16進表記で表しています．</p>
</blockquote>
</details>
<details>
<summary>
Algnとは
</summary>
<blockquote>
<p>Algnは<strong>アラインメント</strong>(alignment)を表しています．
例えば「このセクションをメモリ上に配置する時，その先頭アドレスが8の倍数になるようにしてほしい」という状況の時，この部分が<code>2**3</code>となります（2の3乗=8）．</p>
</blockquote>
</details>
<details>
<summary>
CONTENTS， ALLOC， LOAD， READONLY， CODEとは
</summary>
<blockquote>
<p>これらはセクションフラグと呼ばれるセクションの属性値です．</p>
<ul>
<li>CONTENTS  このセクションには中身がある（つまり中身が空のセクションもある）</li>
<li>ALLOC     ロード時にこのセクションのためにメモリを割り当てる必要がある</li>
<li>LOAD      このセクションは実行するためにメモリ上にロードする必要がある</li>
<li>READONLY  メモリ上では「読み込みのみ許可（書き込み禁止）」と設定する必要がある</li>
<li>CODE      このセクションは実行可能な機械語命令を含んでいる</li>
</ul>
</blockquote>
</details>
<br/>
<div id=".bss">
3つのセクション `.text`，`.data`，`.bss` の役割は以下の通りです：
<ul>
<li><code>.text</code>セクションは機械語命令を格納します．例えば，<code>pushq %rbp</code>を表す<code>0x55</code>は<code>.text</code>セクションに格納されます．</li>
<li><code>.data</code>セクションは初期化済みの静的変数の値を格納します．例えば，大域変数<code>int x=999;</code>があったとき，999の2進数表現が<code>.data</code>セクションに格納されます．</li>
<li><code>.bss</code>セクションは未初期化の静的変数の値を格納します．例えば，大域変数<code>int y;</code>があったとき，（概念的には）初期値0の2進数表現が<code>.bss</code>セクションに格納されます．</li>
</ul>
</div>
<details>
<summary>
なぜ概念的
</summary>
<blockquote>
<p>実はファイル中では<code>.bss</code>セクションにはサイズ情報などごくわずかの情報しか持っていません．実行時にメモリ上に<code>.bss</code>セクションを作る際に，実際に必要なメモリを確保して，そのメモリ領域をすべてゼロで初期化すれば十分だからです（ファイル中に大量のゼロの並びを保持する必要はありません）．</p>
</blockquote>
</details>
<p>さらに代表的なセクションである<code>.rodata</code>も説明します．</p>
<ul>
<li><code>.rodata</code>セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数<code>&quot;hello&quot;</code>は書き込み禁止なので，<code>&quot;hello&quot;</code>の2進数表現が<code>.rodata</code>セクションに格納されます．</li>
</ul>
<p>バイナリファイルには上記以外のセクションも数多く使われますが，
まずはこの基本の4種類 (<code>.text</code>， <code>.data</code>， <code>.bss</code>， <code>.rodata</code>) を覚えましょう．</p>
<h3 id="nm"><a class="header" href="#nm">記号表の中身を表示させる(<code>nm</code>コマンド)</a></h3>
<p>バイナリファイル中には<strong>記号表</strong>(symbol table)があることが多いです．
記号表とは「変数名や関数名がバイナリ中では何番地のアドレスになっているか」という情報です．
<code>nm</code>コマンドでバイナリファイル中の記号表を表示できます．
まず，以下の<code>foo.c</code>を準備して下さい．</p>
<pre><code>// foo.c
int g1 = 999;
int g2;
int s1 = 888;
int s2;
int main ()
{
    static int s3 = 777;
    static int s4;
    int ❼i1 = 666;
    int ❼i2;
}
</code></pre>
<p>そしてコンパイルして，<code>nm</code>コマンドで記号表の中身を表示させます．</p>
<pre><code class="language-bash">$ gcc -c foo.c
$ nm foo.o
0000000000000000 ❶D g1
0000000000000000 ❸B g2
0000000000000000 ❺T main
0000000000000004 ❶D s1
0000000000000004 ❸B s2
0000000000000008 ❷d ❻s3.0
0000000000000008 ❹b ❻s4.1
</code></pre>
<p>この出力の読み方は以下の通りです．</p>
<ul>
<li>❶<code>D</code>と❷<code>d</code>は<code>.data</code>セクションのシンボル，❸<code>B</code>と❹<code>b</code>は<code>.bss</code>セクションのシンボル，❺<code>T</code>と<code>t</code>は<code>.text</code>セクションのシンボルであることを表す</li>
<li>大文字はグローバル（ファイルをまたがって有効なシンボル），小文字はファイルローカルなシンボルであることを表す</li>
<li><code>static</code>付きの局所変数を表すシンボルは同名のシンボルと区別するために，
❻<code>.0</code>や<code>.1</code>などが付加されることがある．</li>
<li>左側の<code>00</code>，<code>04</code>，<code>08</code>がシンボルに対応するアドレスですが，再配置前(relocation前)なので仮のアドレス(各セクションの先頭からのオフセット)</li>
<li>(<code>static</code>のついてない)局所変数❼は記号表には含まれていない．</li>
</ul>
<h3 id="ASLR-PIE"><a class="header" href="#ASLR-PIE">ASLRとPIE（ちょっと脱線）</a></h3>
<p>オブジェクトファイルのセクションごとの仮のアドレスは，
リンク後の<code>a.out</code>では具体的なアドレスになります</p>
<pre><code class="language-bash">$ gcc foo.c
$ nm ./a.out | egrep g1
0000000000004010 D g1
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000001129 T main
</code></pre>
<details>
<summary>
U __libc_start_main@@GLIBC_2.34とは
</summary>
<blockquote>
<p>バイナリ中で参照されているけど定義がないシンボルがあると，
<code>nm</code>コマンドはundefinedを意味する<code>U</code>を表示します．
実は<code>a.out</code>は<code>main</code>関数を呼び出す前に<code>__libc_start_main</code>という
GLIBC中の関数を(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>した上で)呼び出します．
<code>__libc_start_main</code>は
様々な初期化を行った後，<code>main</code>関数を呼び出すのが主な役割です．</p>
</blockquote>
</details>
<p>出力が長くなるので，<code>g1</code>と<code>main</code>のアドレスだけ載せています．
<code>g1</code>のアドレスは<code>4010</code>番地，<code>main</code>のアドレスは<code>1129</code>番地となりました．
ただし，このまま実行すると，<code>g1</code>や<code>main</code>のアドレスはこれらのアドレスにはならず，
実行するたびに変わります．
これは<strong>ASLR</strong>や<strong>PIE</strong>というセキュリティ対策機能のためです．</p>
<p>確かめてみましょう．
以下の<code>foo2.c</code>を普通にコンパイルして実行してみます．</p>
<pre><code class="language-C">// foo2.c
#include &lt;stdio.h&gt;
int g1 = 999;
int main ()
{
    printf (&quot;%p， %p\n&quot;， &amp;g1， main);
}
</code></pre>
<p>以下の通り，<code>g1</code>や<code>main</code>のアドレスは実行するたびに変わりますし，
<code>nm</code>が出力したアドレスとも異なります．</p>
<pre><code class="language-bash">$ gcc foo.c
$ ./a.out
0x557f2361e010， 0x557f2361b149
$ ./a.out
0x55a40e6f5010， 0x55a40e6f2149
$ ./a.out
0x562750663010， 0x562750660149
$ 
</code></pre>
<p>ここではASLRとPIEの機能を無効にして，アドレスが変わらなくなることを確認します．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
$ gcc -no-pie foo2.c
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000401136 T main
$ nm ./a.out | egrep g1
0000000000404030 D g1
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
</code></pre>
<p>ASLRとPIEの機能をオフにすることで，アドレスが変わらなくなり，
かつ<code>nm</code>が出力するアドレスと同じになることが確認できました．</p>
<blockquote>
<p>注意：
不用意なASLRとPIEの無効化はセキュリティ機能を下げるので避けるべきです．
しかしデバッグ作業ではアドレスが変わらなくなるので
ASLRとPIEの無効化が有用な場合もあります．
なお，デバッガ中ではASLRは無効化されていることが多いです．</p>
</blockquote>
<details>
<summary>
ASLRとは
</summary>
<blockquote>
<p>ASLR (address space layout randomizationの略)は，
アドレス空間の配置をランダム化する機能です．
テキスト（実行コード），ライブラリ，スタック，ヒープなどをメモリ上に
配置するアドレスを実行するたびにランダムに変化させます．
以下を実行するとASLRは無効化され，</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
</code></pre>
<p>以下を実行するとASLRは有効化されます．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=1
</code></pre>
</blockquote>
</details>
<details>
<summary>
PIEとは
</summary>
<blockquote>
<p>PIE (position independent executableの略)は位置独立実行可能ファイルを意味します．
通常，動的ライブラリは位置独立コードPIC (position independent code)としてコンパイルされます．
動的ライブラリはメモリ上で共有されるため，どのアドレスに配置してもそのまま再配置せずに，実行したいからです．
PIEは動的ライブラリだけでなく，<code>a.out</code>も位置独立にした実行可能ファイルを指します．
<code>-no-pie</code>オプションでコンパイルすると，PIEを無効化できます．</p>
<pre><code class="language-bash">$ gcc -no-pie foo2.c
</code></pre>
</blockquote>
</details>
<h2 id="逆アセンブル再び"><a class="header" href="#逆アセンブル再び">逆アセンブル再び</a></h2>
<p><a href="./2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>で説明した通り，
<code>objdump -d ./a.out</code>で逆アセンブル結果が表示されます（再掲）．</p>
<pre><code class="language-bash">$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
</code></pre>
<p><code>objdump</code>コマンドは<code>add5.o</code>の<code>.text</code>セクションを抽出し，
そのデータを機械語命令として解釈して，対応するニモニックを出力しています．</p>
<p>この出力によれば，<code>.text</code>セクションの先頭4バイトは<code>F3 0F 1E FA</code>で，
この4バイトが<code>endbr64</code>命令になります
（x86-64の命令長は可変長で，1バイト〜15バイトです）．</p>
<p>以下では<code>.text</code>セクションの先頭4バイトが<code>F3 0F 1E FA</code>であることを確認します．</p>
<p>セクションのヘッダを出力するコマンド<a href="3-binary.html#.text"><code>objdump -h</code></a>の出力を再掲します．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
</code></pre>
<p><code>.text</code>セクションの<code>File off</code>の欄を見ると<code>00000040</code>とあります．
これは<code>.text</code>セクションが<code>add5.o</code>の先頭から16進数で40バイト
目（以後，0x40と表記します）にあることを意味しています．</p>
<p><code>od</code>コマンドの<code>-j</code>オプションを使うと，指定したバイト数だけ，
先頭をスキップしてくれます．
この<code>-j</code>オプションを使って，0x40バイトスキップして，
<code>.text</code>セクションの最初だけを16進ダンプします
（<code>head -n3</code>は先頭の3行だけ表示します）．</p>
<pre><code class="language-bash">$ od -t x1 -j0x40 add5.o | head -n3
0000100 ❶f3 0f 1e fa 55 48 89 e5 89 7d fc 8b 45 fc 83 c0
0000120   05 5d c3 00 47 43 43 3a 20 28 55 62 75 6e 74 75
0000140   20 39 2e 34 2e 30 2d 31 75 62 75 6e 74 75 31 7e
</code></pre>
<p>この結果❶を見ると，<code>.text</code>セクションの最初の4バイトは
<code>F3 0F 1E FA</code>であることが分かります．
これは上の<a href="3-binary.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB%E5%86%8D%E3%81%B3">逆アセンブルの結果</a>の先頭4バイトと一致しており，
<code>endbr64</code>命令が，<code>add5.o</code>の先頭から0x40バイト目に存在することが分かりました．</p>
<h2 id="広義のコンパイル"><a class="header" href="#広義のコンパイル">広義のコンパイルとリンク</a></h2>
<p>ここでは広義のコンパイル，つまりCのプログラム<code>foo.c</code>から
実行可能ファイル<code>a.out</code>を生成する処理の中身を見ていきます．
いちばん大事なのは最後の<strong>リンク</strong>(link)です．</p>
<img src="figs/compile-all.svg" height="300px" id="fig:compile-all">
<ul>
<li>❶ Cの前処理，すなわち<code>#include</code>や<code>#define</code>などの前処理命令の処理と，マクロ（例えば<code>&lt;stdio.h&gt;</code>が定義する<code>NULL</code>や<code>EOF</code>）の展開を行います．<code>gcc -E</code>コマンドで実行できますが，内部的にはカッコ内の<code>cpp</code>や<code>cc1</code>コマンドが実行されています（現在は<code>cc1</code>）．</li>
<li>❷ 狭義のコンパイル処理で，Cのプログラムをアセンブリコードに変換します．</li>
<li>❸ アセンブラ(<code>as</code>コマンド)によるアセンブル処理で，オブジェクトファイル<code>foo.o</code>を生成します．<code>foo.o</code>中にはバイナリの機械語命令が入っています．</li>
<li>❹ <code>foo.o</code>だけでは実行可能ファイルは作れません．例えば，<code>printf</code>などのライブラリ関数の実体は，
<code>libc.a</code>(<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">静的ライブラリ</a>)や<code>libc.so</code>(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">動的ライブラリ</a>)の中にあるからです．
また，<code>main</code>関数を呼び出すためのCスタートアップルーチン(多くの場合，<code>crt*.o</code>というファイル名)も必要です．
また，分割コンパイルの機能を使った結果，<code>foo.o</code>は他のC言語のプログラムをアセンブルしたオブジェクトファイル<code>*.o</code>が必要なことがよくあります．
「このような他のバイナリと<code>foo.o</code>を合体させて<code>a.out</code>を生成する処理」のことを<strong>リンク</strong>(link)と呼びます．</li>
</ul>
<p>広義のコンパイルで具体的にどのような処理が行われてるのかを見るには，
<code>-v</code>をつけて<code>gcc -v</code>とコンパイルすれば表示されます．
（以下では表示を省略しています．全てを表示するには<i class="fa fa-eye"></i>ボタンを押して下さい）．</p>
<pre><code class="language-bash">$ gcc -v main.c add5.s |&amp; tee out
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
<span class="boring"> Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.3.0-1ubuntu1~22.04.1' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c，ada，c++，go，brig，d，fortran，objc，obj-c++，m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32，m64，mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-nvptx/usr，amdgcn-amdhsa=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
</span><span class="boring"> Thread model: posix
</span><span class="boring"> Supported LTO compression algorithms: zlib zstd
</span><span class="boring"> gcc version 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04.1) 
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpdir a- -dumpbase main.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include-fixed&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/../../../../x86_64-linux-gnu/include&quot;
</span><span class="boring"> #include &quot;...&quot; search starts here:
</span><span class="boring"> #include &lt;...&gt; search starts here:
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/include
</span><span class="boring">  /usr/local/include
</span><span class="boring">  /usr/include/x86_64-linux-gnu
</span><span class="boring">  /usr/include
</span><span class="boring"> End of search list.
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> Compiler executable checksum: e13e2dc98bfa673227c4000e476a9388
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/cc5o7Jgg.o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/ccUs2R16.o add5.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/
</span><span class="boring"> LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../:/lib/:/usr/lib/
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgnuv0i.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/cc5o7Jgg.o /tmp/ccUs2R16.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/11/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span></code></pre>
<h2 id="バイナリファイルの種類"><a class="header" href="#バイナリファイルの種類">バイナリファイルの種類</a></h2>
<p>実行可能ファイル<code>a.out</code>に関連するバイナリファイルには
以下の4種類があります：</p>
<ul>
<li>オブジェクトファイル(<code>*.o</code>)</li>
<li>実行可能ファイル(<code>a.out</code>)</li>
<li>静的ライブラリファイル(<code>lib*.a</code>)</li>
<li>動的ライブラリファイル(<code>lib*so</code>)</li>
</ul>
<h3 id="オブジェクトファイル"><a class="header" href="#オブジェクトファイル">オブジェクトファイル(<code>*.o</code>)</a></h3>
<p><strong>オブジェクトファイル</strong>とはLinuxでファイル名の拡張子が<code>.o</code>なファイルです．
オブジェクトファイルは機械語命令を含んでいますが，
このオブジェクトファイル単体では実行することができません．
実行を可能にするには<a href="3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB"><strong>リンク</strong></a>(link)処理を経て，
<a href="3-binary.html#%E5%AE%9F%E8%A1%8C%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB"><strong>実行可能ファイル</strong></a>
を作成する必要があります．</p>
<p>オブジェクトファイルは<strong>再配置可能オブジェクトファイル</strong>
(relocatable object file)と呼ばれることもあります．
オブジェクトファイルはリンク時に再配置（アドレス調整）が可能だからです．</p>
<h3 id="実行可能ファイル"><a class="header" href="#実行可能ファイル">実行可能ファイル(<code>a.out</code>)</a></h3>
<p><strong>実行可能ファイル</strong>(executable file)はその名前の通り，OSに実行を依頼すればそのままで実行できるバイナリファイルのことです．
例えば，hello wordの実行可能ファイル<code>a.out</code>はシェル上で以下のように実行できます．</p>
<pre><code class="language-bash">$ ./a.out
hello， world
</code></pre>
<p><code>ls</code>などのシェル上で実行可能なコマンドも実行可能ファイルです．</p>
<pre><code class="language-bash">$ which ls
/usr/bin/ls
$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， ❶interpreter /lib64/ld-linux-x86-64.so.2， ❷BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd， for GNU/Linux 3.2.0， stripped
$ ls
a.out add5.c add5.o add5.s
</code></pre>
<p id="interpreter">
<details>
<summary>
❶interpreterとは
</summary>
<blockquote>
<p>ELFバイナリの動的リンカのことを（なぜか）interpreterと呼びます．
プログラミング言語処理系のインタプリタとは何の関係もありません．
ELFバイナリでは動的リンカのフルパスを指定することができ，バイナリに埋め込みます．
この場合は <code>/lib64/ld-linux-x86-64.so.2</code> が埋め込まれています．
OSが<code>a.out</code>を実行する際に，
OSはまず動的リンカ(interpreter)をメモリにロードして，
ロードした動的リンカに制御を渡します．
動的リンカは<code>a.out</code>中の他の部分や，動的ライブラリをメモリにロードし，
動的リンクを行ってから，<code>a.out</code>の<strong>エントリポイント</strong>
(最初に実行を開始するアドレス)にジャンプします．
その後，いくつかの初期化を行ってから，<code>main</code>関数が呼び出されます．</p>
<p><code>a.out</code>のエントリポイントは<code>readelf -h</code>コマンドで確認できます．
エントリポイントは<code>0x401050</code>番地でした❶．</p>
<pre><code class="language-bash">$ readelf -h ./a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement， little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
❶Entry point address:               0x401050
  Start of program headers:          64 (bytes into file)
  Start of section headers:          16832 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         36
  Section header string table index: 35
</code></pre>
<p>逆アセンブルすると<code>0x401050</code>番地は<code>_start</code>という関数がありました❷．
<code>a.out</code>は<code>_start</code>関数から実行が始まることが分かりました．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep 401050 -A 5
0000000000401050 ❷ &lt;_start&gt;:
  401050:	f3 0f 1e fa          	endbr64 
  401054:	31 ed                	xor    %ebp，%ebp
  401056:	49 89 d1             	mov    %rdx，%r9
  401059:	5e                   	pop    %rsi
  40105a:	48 89 e2             	mov    %rsp，%rdx
  40105d:	48 83 e4 f0          	and    $0xfffffffffffffff0，%rsp
</code></pre>
</blockquote>
</details>
</p>
<details>
<summary>
❷BuildID[sha1]とは
</summary>
<blockquote>
<p>BuildIDはバイナリファイルが同じかどうかを識別するユニークな番号（背番号）です．
ここでは<code>2f15</code>で始まる40桁の16進数が <code>/usr/bin/ls</code>のBuildIDです．
BuildIDはLinux ELF特有の機能です．
<code>strip</code>してもBuildIDは変化しないので，<code>strip</code>前後のファイルが同じかの確認に使えます．</p>
<pre><code class="language-bash">$ gcc hello.c
$ cp a.out a.out.stripped
$ strip a.out.stripped
$ file a.out a.out.stripped
a.out:          ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
a.out.stripped: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， stripped
</code></pre>
<p>ここでは説明しませんが<strong>コアファイル</strong>(core file)にもBuildIDが入っており，
そのコアファイルを出力した<code>a.out</code>を探すことができます．</p>
<p>ちなみにsha1はSHA-1を意味しており，SHA-1は160ビットのハッシュを生成するハッシュ関数です．
<code>git</code>のハッシュにはSHA-1が使われています．
<code>sha1sum</code>コマンドでSHA-1のハッシュを計算できます．</p>
<pre><code class="language-bash">$ sha1sum ./a.out
ff99525ad6a48d78d35d3108401af935a6ca9bbe  ./a.out
</code></pre>
<p>この結果から分かる通り，BuildIDのハッシュは，単純に<code>a.out</code>から作ったハッシュ値ではありません．
ELFバイナリのヘッダとセクションの一部からハッシュを計算しているようですが，正確な情報は見つかりませんでした．</p>
</blockquote>
</details>
<p>実行可能なコマンドには実行可能ファイルではなく，
スクリプトなことがあります．</p>
<pre><code class="language-bash">$ which shasum
/usr/bin/shasum
$ file /usr/bin/shasum
/usr/bin/shasum: Perl script text executable
$ head -3 /usr/bin/shasum
#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+&quot;$@&quot;}'
	if 0; # ^ Run only under a shell
</code></pre>
<p><code>shasum</code>コマンドは(実行可能ファイルではなく)Perlスクリプトでした．</p>
<h3 id="静的ライブラリ"><a class="header" href="#静的ライブラリ">静的ライブラリ(<code>lib*.a</code>)</a></h3>
<p><strong>静的ライブラリ</strong>(static library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
するときに使われるライブラリです．
<strong>ライブラリ</strong>とは複数のオブジェクトファイルを１つのファイルにまとめたもの（<strong>アーカイブ</strong>）です．</p>
<p>LinuxなどのUNIX系のOSでは静的ライブラリのファイル拡張子は<code>.a</code>が多いです．
またWindowsでは<code>.lib</code>です．
<code>printf</code>の実体が入っているC標準ライブラリの
静的ライブラリのファイル名は<code>libc.a</code>です．</p>
<h3 id="動的ライブラリ"><a class="header" href="#動的ライブラリ">動的ライブラリ(<code>lib*.so</code>)</a></h3>
<p><strong>動的ライブラリ</strong>(dynamic library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>動的リンク</strong></a>
するときに使われるライブラリです．
動的ライブラリは<strong>共有ライブラリ</strong>(shared library)とも呼ばれます．
動的ライブラリは複数のプロセスからメモリ上で共有されるからです．</p>
<p>Linuxでは動的ライブラリのファイル拡張子は<code>.so</code>です(shared objectの略)．
処理系の都合でファイル拡張子に数字がつくことがあります（例：<code>.so.6</code>）．
動的ライブラリのファイル拡張子はUnix系のOSでも様々です．
Windowsでは<code>.dll</code>です．</p>
<h2 id="静的リンクと動的リンク"><a class="header" href="#静的リンクと動的リンク">静的リンクと動的リンク</a></h2>
<p>静的ライブラリは静的リンクに使われるライブラリで，
動的ライブラリは動的リンクに使われるライブラリです．</p>
<h3 id="静的リンク"><a class="header" href="#静的リンク">静的リンク</a></h3>
<p><strong>静的リンク</strong>とは<strong>コンパイル時</strong>にリンクを行う手法です．
仕組みは単純ですが，ファイルやメモリの使用量が増える欠点があります．
<a href="3-binary.html#fig:compile-all">この図</a>で説明したリンクは実は静的リンクでした．</p>
<p>静的リンクしたファイル<code>a.out</code>はリンク済みなので，
ライブラリ関数(例えば<code>printf</code>)の実体も<code>a.out</code>の中に入っています．</p>
<img src="figs/static-link-printf.svg" height="200px" id="fig:static-link-printf">
<p><code>a.out</code>ごとに<code>printf</code>のコピーが作られるので，
ファイルの使用量が無駄に増えてしまいます．
また<code>a.out</code>中の<code>printf</code>は実行時にもメモリ上で<strong>共有されない</strong>ので，
メモリの使用量も無駄に増えてしまいます．</p>
<h3 id="静的リンクでコンパイルしてみる"><a class="header" href="#静的リンクでコンパイルしてみる">静的リンクでコンパイルしてみる</a></h3>
<pre><code class="language-C">// hello.c
#include &lt;stdio.h&gt;
int main (int ac， char **ag)
{
    printf (&quot;hello (%d)\n&quot;， ac);
}
</code></pre>
<p>静的リンクするには<code>-static</code>オプションをつけます（<code>-static</code>無しだと動的リンクになります）．
<code>printf</code>に第2引数を与えているのは，こうしないと，コンパイラが勝手に
<code>printf</code>の呼び出しを<code>puts</code>に変更してしまうからです．</p>
<p><code>a.out</code>を<code>file</code>コマンドで確認すると<code>statically linked</code>とあり❶，
静的リンクできたことが分かります．</p>
<pre><code class="language-bash">$ gcc -static hello.c
$ file ./a.out
./a.out: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， ❶statically linked， BuildID[sha1]=40fe6c0daaf2d49fabad4d37bc34fcdd12cb8da9， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<details>
<summary>
練習問題：静的にリンクした`a.out`中に`printf`の実体があることを確認せよ
</summary>
<blockquote>
<p><code>a.out</code>を逆アセンブルし，❶<code>&lt;main&gt;:</code>を含む行から15行を表示させます．
(❷<code>-A 14</code>は「マッチした行の後ろ14行も表示する」というオプションです)．
<code>main</code>関数は(<code>printf</code>ではなく)❸<code>_IO_printf</code>を呼び出していることを確認できます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep ❷-A 14 ❶&quot;&lt;main&gt;:&quot;
0000000000401cb5 &lt;main&gt;:
  401cb5:	f3 0f 1e fa          	endbr64 
  401cb9:	55                   	push   %rbp
  401cba:	48 89 e5             	mov    %rsp，%rbp
  401cbd:	48 83 ec 10          	sub    $0x10，%rsp
  401cc1:	89 7d fc             	mov    %edi，-0x4(%rbp)
  401cc4:	48 89 75 f0          	mov    %rsi，-0x10(%rbp)
  401cc8:	8b 45 fc             	mov    -0x4(%rbp)，%eax
  401ccb:	89 c6                	mov    %eax，%esi
  401ccd:	48 8d 3d 30 33 09 00 	lea    0x93330(%rip)，%rdi        # 495004 &lt;_IO_stdin_used+0x4&gt;
  401cd4:	b8 00 00 00 00       	mov    $0x0，%eax
  401cd9:	e8 72 ec 00 00       	callq  410950 ❸&lt;_IO_printf&gt;
  401cde:	b8 00 00 00 00       	mov    $0x0，%eax
  401ce3:	c9                   	leaveq 
  401ce4:	c3                   	retq   
</code></pre>
<blockquote>
<p>注：ここでは<code>egrep -A 14</code>としてますが，皆さんが試す時は，</p>
<pre><code class="language-bash">$ objdump -d ./a.out | less
</code></pre>
<p>としてから，<code>/&lt;main&gt;:</code>とリターンを入力して検索する方が便利でしょう．</p>
</blockquote>
<p>次に同じく<code>a.out</code>を逆アセンブルし，`&lt;_IO_printf&gt;:'を含む行から数行を表示させます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;_IO_printf&gt;:&quot;
0000000000410950 &lt;_IO_printf&gt;:
  410950:	f3 0f 1e fa          	endbr64 
  410954:	48 81 ec d8 00 00 00 	sub    $0xd8，%rsp
  41095b:	49 89 fa             	mov    %rdi，%r10
  41095e:	48 89 74 24 28       	mov    %rsi，0x28(%rsp)
  410963:	48 89 54 24 30       	mov    %rdx，0x30(%rsp)
</code></pre>
<p>これは<code>_IO_printf</code>の定義なので，<code>a.out</code>に<code>printf</code>の実体があることを確認できました．
なお，以下の<code>nm</code>コマンドでも，<code>a.out</code>に<code>printf</code>の実体があることを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep _IO_printf
0000000000410950 T _IO_printf
</code></pre>
<p>実は<code>_IO_printf</code>も<code>printf</code>も実体は同じです．処理系の都合で，
「実体は同じだけど別の名前をつける」ことがあり，それをエイリアス（別名）といいます．
0x410950番地で調べると，これを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 410950
0000000000410950 T _IO_printf
0000000000410950 T __printf
0000000000410950 T printf
</code></pre>
</blockquote>
</details>
<h3 id="動的リンク"><a class="header" href="#動的リンク">動的リンク</a></h3>
<p><strong>動的リンク</strong>とは実行を始める際の<strong>ロード時</strong>（<code>a.out</code>をメモリにコピーする時）
あるいは<strong>実行途中</strong>にメモリ上でリンクを行う手法です．
現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．</p>
<p>動的リンクしたファイル<code>a.out</code>には
「ライブラリ関数(例えば<code>printf</code>)とのリンクが必要だよ」という
小さな参照情報だけが入っており，<code>printf</code>の実体は入っていません．
実際のリンクは実行時にメモリ上で行います．</p>
<img src="figs/dynamic-link-printf.svg" height="200px" id="fig:dynamic-link-printf">
<p><code>a.out</code>には<code>printf</code>を含まないので，ファイルの使用量を抑えられます．
また<code>a.out</code>中の<code>printf</code>は実行時にはメモリ上で<strong>共有される</strong>ので，
メモリの使用量も抑えられます．</p>
<p>ファイルサイズを比較してみると，静的リンクした<code>a.out-static</code>は約870KB，
動的リンクした<code>a.out-dynamic</code>は約17KBで，50倍ものサイズ差がありました．</p>
<pre><code class="language-bash">$ gcc -static -o a.out-static hello.c
$ gcc -o a.out-dynamic hello.c
$ ls -l a.out*
-rwxrwxr-x 1 gondow gondow  16696 Jul 20 17:52 a.out-dynamic
-rwxrwxr-x 1 gondow gondow 871832 Jul 20 17:51 a.out-static
</code></pre>
<h3 id="動的リンクでコンパイルしてみる"><a class="header" href="#動的リンクでコンパイルしてみる">動的リンクでコンパイルしてみる</a></h3>
<p>Linuxでは<code>-static</code>オプションをつけなければ動的リンクになります．</p>
<pre><code class="language-bash">$ gcc hello.c
$ file a.out
a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<p>実行時にリンクが必要な動的ライブラリの情報は<code>ldd</code>コマンドで表示できます．</p>
<pre><code class="language-bash">$ ldd ./a.out
	❶linux-vdso.so.1 (0x00007ffd21638000)
	❷libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcfef5c1000)
	❸/lib64/ld-linux-x86-64.so.2 (0x00007fcfef7d8000)

</code></pre>
<p>この<code>a.out</code>は<code>linux-vsdo.so.1</code>，<code>libc.so.6</code>，<code>ld-linux-x86-64.so.2</code>という
3つの動的ライブラリと実行時にリンクする必要があることを表示しています．
<code>libc.so.6</code>は（<code>LD_LIBRARY_PATH</code>などの設定がなければ）
絶対パス<code>/lib/x86_64-linux-gnu/libc.so.6</code>とリンクされます．</p>
<details>
<summary>
❶linux-vdso.so.1とは
</summary>
<blockquote>
<p>vDSO (virtual dynamic shared objectの略)で，カーネル空間で実行する必要が無い
システムコール(例えば<code>gettimeofday</code>)を高速に実行するための仕組みです．</p>
<ul>
<li><a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></li>
</ul>
</blockquote>
</details>
<details>
<summary>
❷libc.so.6とは
</summary>
<blockquote>
<p>C標準ライブラリが入った動的ライブラリです．
<code>nm -D</code>コマンドで調べると，<code>printf</code>の実体が入っていることが分かります．
(<code>-D</code>は共有ライブラリで使われる動的シンボルを表示させるオプションです）</p>
<pre><code class="language-bash">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | egrep ' T printf'
0000000000061c90 T printf
0000000000061100 T printf_size
0000000000061bb0 T printf_size_info
</code></pre>
<p><code>-D</code>オプションをつけないと「❶シンボルが無いよ」と言われてしまいます．</p>
<pre><code class="language-bash">$ nm /lib/x86_64-linux-gnu/libc.so.6
nm: /lib/x86_64-linux-gnu/libc.so.6: ❶no symbols
</code></pre>
</blockquote>
</details>
<details>
<summary>
❸ld-linux-x86-64.so.2とは
</summary>
<blockquote>
<p>動的リンクを行うプログラム（共有ライブラリ），つまり動的リンカです．
<a href="3-binary.html#interpreter">interpreterとは</a>も参照下さい．</p>
<blockquote>
<ul>
<li><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man ld-linux.so</a></li>
</ul>
</blockquote>
</blockquote>
</details>
<details>
<summary>
練習問題：動的にリンクした`a.out`中に`printf`の実体が無いことを確認せよ
</summary>
<blockquote>
<p><code>nm</code>コマンドで<code>a.out</code>には<code>main</code>を始めごく少数の
関数しか定義しておらず，その中に<code>printf</code>は入っていないことが以下で確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep ' T '
00000000000011f8 T _fini
00000000000011f0 T __libc_csu_fini
0000000000001180 T __libc_csu_init
0000000000001149 T main
0000000000001060 T _start
</code></pre>
<p>また<code>nm</code>の出力を<code>printf</code>で検索すると，GLIBC中の<code>printf</code>への参照はあるが
<code>a.out</code>中では未定義(<code>U</code>)となっていることが分かります．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 'printf'
                 U printf@@GLIBC_2.34
</code></pre>
<p>なお逆アセンブルすると<code>&lt;printf@plt&gt;</code>という小さな関数が見つかりますが，
これは<code>printf</code>の実体ではありません．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;printf&quot;
0000000000001050 &lt;printf@plt&gt;:
    1050:	f3 0f 1e fa          	endbr64 
    1054:	f2 ff 25 75 2f 00 00 	bnd jmpq ❶*0x2f75(%rip)        # 3fd0 &lt;printf@GLIBC_2.34&gt;
    105b:	0f 1f 44 00 00       	nopl   0x0(%rax，%rax，1)
</code></pre>
<p><code>&lt;printf@plt&gt;</code>は<code>printf</code>を呼び出す単なる踏み台で，
PLT (procedure linkage table)という仕組みです．
PLTは<code>printf</code>の最初の呼び出しまで<code>printf</code>の<strong>アドレス解決</strong>
(address resolution)を遅延します．具体的には次の2ステップになります．</p>
<ul>
<li><code>printf@plt</code>の間接ジャンプ先❶の初期値は「動的リンクする関数（動的リンカ）」になっているため，最初に<code>printf@plt</code>が呼ばれると，動的リンクを行い，その結果，間接ジャンプ先が「<code>printf</code>の実体」に変更されます❷．
そして動的リンカは何もなかったかのように<code>printf</code>を呼び出します．
（ちなみに<code>printf@plt</code>の間接ジャンプで参照するメモリ領域は GOT (global offset table)と呼ばれます）</li>
<li>その結果，2回目以降の以下の間接ジャンプ❶では<code>printf</code>が呼ばれます．</li>
</ul>
<p>つまり，GOTに<code>printf</code>のアドレスを格納することが，ここではアドレス解決になっています．</p>
<img src="figs/plt-printf.svg" height="400px" id="fig:plt-printf">
</blockquote>
</details>
<h3 id="静的ライブラリを作成してみる"><a class="header" href="#静的ライブラリを作成してみる">静的ライブラリを作成してみる</a></h3>
<p id="main.c-static">
<pre><code class="language-C">// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main (void)
{
    printf (&quot;%d\n&quot;， add5 (10));
}
</code></pre>
</p>
<p id="add5.c-static">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ ar rcs libadd5.a add5.o  ❶
$ ar t libadd5.a
add5.o  ❷
$ file libadd5.a
libadd5.a: current ar archive
$ gcc ❸-static -o a.out-static main.c ❹-L. ❺-ladd5
$ file a.out-static
file ./a.out-static
./a.out-static: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， statically linked， BuildID[sha1]=1bf84a77504302513d6219e4b27316309d08ed2d， for GNU/Linux 3.2.0， not stripped
$ ./a.out-static 
15 ❻
</code></pre>
<ul>
<li>❶ <code>ar rcs</code>コマンドで<code>add5.o</code>から<code>libadd5.a</code>を作成します．</li>
<li>❷  <code>ar t</code>コマンドで<code>libadd5.a</code>の中身を調べます．中身は<code>add5.o</code>だけでした．</li>
<li>❸❹❺ <code>gcc</code>で<code>main.c</code>と<code>libadd5.a</code>を静的リンクします．
静的リンクするために❸<code>-static</code>オプションが必要です．
<code>libadd5.a</code>がカレントディレクトリにあることを伝えるために❹<code>-L.</code>が必要です．
静的リンクする静的ライブラリが<code>libadd5.a</code>であることを伝えるために
❺<code>-ladd5</code>が必要です．（前の<code>add</code>と後の<code>.a</code>は自動的に付加されます）</li>
<li>❻ 実行してみると，静的ライブラリ<code>libadd5.a</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<h3 id="動的ライブラリを作成してみる"><a class="header" href="#動的ライブラリを作成してみる">動的ライブラリを作成してみる</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ gcc ❶-fPIC ❷-shared -o libadd5.so add5.c
$ file libadd5.so
libadd5.so: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， BuildID[sha1]=415ef51f32145b59c51e836a25959f0f66039768， not stripped
$ gcc -o a.out-dynamic main.c -ladd5 -L. ❸-Wl，-rpath .
$ file ./a.out-dynamic
./a.out-dynamic: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=a5d4f8ef61cef4e0b063376333f07170d312c546， for GNU/Linux 3.2.0， not stripped
$ ldd ./a.out
	linux-vdso.so.1 (0x00007ffff7fcd000)
	libadd5.so =&gt; ❹./libadd5.so (0x00007ffff7fbd000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dad000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
$ ./a.out-dynamic
15 ❺ 
</code></pre>
<ul>
<li>❶❷ <code>add5.c</code>から動的ライブラリ<code>libadd5.so</code>を作ります．
<code>libadd5.so</code>を<strong>位置独立コード</strong>(PIC)にするために，❶<code>-fPIC</code>が必要です．
<code>libadd5.so</code>を<strong>共有オブジェクト</strong>(shared object)にするために，❷<code>-shared</code>が必要です．</li>
<li>❸ <code>gcc</code>で<code>main.c</code>と<code>libadd5.so</code>を動的リンクします．
実行時に動的ライブラリを探索するパスを❸<code>-Wl，-rpath .</code>で指定しています．
ここでは<code>libadd5.so</code>をカレントディレクトリに置いているためです．
（セキュリティ上，実際に使う際は絶対パスを指定する方が安全でしょう）．
ちなみに<code>-Wl，-rpath .</code>を<code>gcc</code>に指定すると，
<a href="https://man7.org/linux/man-pages/man1/ld.1.html"><code>ld</code>コマンド</a>
に<code>-rpath .</code>というオプションが渡されます	．</li>
<li>❹ <code>ldd</code>コマンドで調べると，<code>a.out-dynamic</code>中の<code>libadd5.so</code>は
<code>./libadd5.so</code>を参照していることを確認できました．</li>
<li>❺ 実行してみると，動的ライブラリ<code>libadd5.so</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<details>
<summary>
位置独立コードとは
</summary>
<blockquote>
<p><strong>位置独立コード</strong>(position independent code， PIC)とはメモリ上の
どこにロードしても，そのまま実行できるコードです．
位置独立コードでは絶対アドレスは使わず（再配置が必要になってしまうから），
相対アドレスか間接アドレス参照だけを使います．
位置独立コードにすることで，メモリ上で動的ライブラリを共有できるため，
メモリ使用量を抑えることができます．</p>
</blockquote>
</details>
<h2 id="デバッグ情報"><a class="header" href="#デバッグ情報">デバッグ情報</a></h2>
<h3 id="デバッグ情報とは"><a class="header" href="#デバッグ情報とは">デバッグ情報とは</a></h3>
<p><strong>デバッグ情報</strong>とは<code>gcc</code>に<code>-g</code>オプションをつけると
バイナリに付加される情報で，
デバッグ時に有用なソースコード中の情報を含んでいます．
例えば，変数の型情報や，ソースコード中の行番号が挙げられます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ file ./a.out
./a.out: ELF 64-bit LSB pie executable， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=68a01f5977ae542600062913c447a7ba7f2fad62， for GNU/Linux 3.2.0， ❷ with debug_info， not stripped
</code></pre>
<p>❶<code>-g</code>オプションをつけてコンパイルしてから，<code>file</code>コマンドで調べると，
❷デバッグ情報が含まれていることを確認できます．</p>
<p>コンパイラは様々なデバッグ情報の形式を扱えます．
LinuxのELFバイナリでは<a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARFデバッグ情報</a>
が使われることが多いです．(以下，DWARFを前提として説明します)</p>
<h3 id="no-debug-info"><a class="header" href="#no-debug-info">デバッグ情報が無いと，デバッガでファイル名や行番号が表示されない</a></h3>
<p>デバッグ情報無しでデバッガ<code>gdb</code>を使うとどうなるか試してみましょう．
<a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc ❶ main.c add5.c
$ gdb ./a.out
(gdb) ❷ b add5
Breakpoint 1 at 0x1175
(gdb) ❸ r
Starting program: /tmp/a.out 
Breakpoint 1， 0x0000555555555175 in ❹ add5 ()
(gdb) bt
#0  ❻0x0000555555555175 in ❺ add5 ()
#1  0x000055555555515b in main ()
(gdb) quit
</code></pre>
<p><code>-g</code>オプション無しで❶コンパイルしています．
<code>add5</code>関数にブレークポイントを設定❷します．
<strong>ブレークポイント</strong>とはプログラムの実行を一時的に停止する場所です．
関数名<code>add5</code>でブレークポイントを指定したので，
実行すると<code>add5</code>関数の先頭で実行が一時停止します．</p>
<p>❸ runコマンド (<code>r</code>はrunコマンドの省略形)で実行した所，
<code>add5</code>関数でブレーク(実行を一時停止)できたのですが，
関数名<code>add5</code>だけが表示され，<strong>ファイル名や行番号が表示されません</strong>❹．
バックトレースを出力しても同様です❺．</p>
<p>バックトレースとは「<code>main</code>関数から現在実行中の関数までの
呼び出し系列」のことです．
ここでは<code>main</code>関数が<code>add5</code>関数を呼び出しただけなので，
バックトレースは2行しかありません．
❻<code>0x0000555555555175</code>は<code>add5</code>関数が
<code>0x0000555555555175</code>番地の機械語命令を実行する直前で実行を停止していることを
示しています．</p>
<h3 id="デバッグ情報があるとデバッガでファイル名や行番号が表示される"><a class="header" href="#デバッグ情報があるとデバッガでファイル名や行番号が表示される">デバッグ情報があると，デバッガでファイル名や行番号が表示される</a></h3>
<p>今回はデバッグ情報ありでデバッガを使ってみます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1175: ❷ file add5.c， line 2.
(gdb) r
Starting program: /tmp/a.out 
Breakpoint 1， add5 (n=10) at ❸ add5.c:2
2	{
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:2
#1  0x000055555555515b in main () at main.c:5

$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: ❷ file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at ❸ add5.c:3
3	    return n + 5;
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:3
#1  0x000055555555515b in main () at main.c:5
</code></pre>
<ul>
<li>❶ <code>-g</code>をつけたので，<code>a.out</code>にはデバッグ情報が付加されています．</li>
<li><a href="3-binary.html#no-debug-info">先程</a>とは異なり，❷❸❹ファイル名<code>add5.c</code>や行番号<code>3</code>が付加されています．</li>
</ul>
<h3 id="デバッグ情報があると行番号とアドレスを相互変換できる"><a class="header" href="#デバッグ情報があると行番号とアドレスを相互変換できる">デバッグ情報があると，行番号とアドレスを相互変換できる．</a></h3>
<h4 id="addr2line"><a class="header" href="#addr2line">アドレス→行番号の変換</a></h4>
<p>デバッグ情報があるバイナリに対しては，
<code>addr2line</code>コマンドでアドレスを対応する行番号に変換できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ objdump -d ./a.out | egrep -A 4 &quot;&lt;main&gt;:&quot;
0000000000001149 &lt;main&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp，%rbp
    1151:	bf 0a 00 00 00       	mov    $0xa，%edi
$  addr2line -e ./a.out ❶ 0x1149
❷/tmp/main.c:4
</code></pre>
<p>上の実行例では<code>addr2line</code>コマンドで，
<code>0x1149</code>番地の機械語命令はソースコードでは❷<code>/tmp/main.c</code>の4行目に
対応していることが分かりました．</p>
<p>デバッガ上でも確かめてみましょう．</p>
<pre><code>(gdb) b main
Breakpoint 1 at 0x1151: file main.c， line 5.
(gdb) r
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
(gdb) ❶ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
(以下略)
(gdb) ❷ info line *0x0000555555555149 
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
(gdb) ❸ info line main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<ul>
<li>(objdumpコマンドでも可能ですが)
<code>gdb</code>上でも逆アセンブルできます．
逆アセンブルのコマンドは<code>disassemble</code>ですが長いので，
短縮名<code>disas</code>をここでは使っています．
(<code>gdb</code>は他のコマンドと区別できる範囲で，コマンド名を省略できます)．
<a href="3-binary.html#ASLR-PIE">ASLRとPIE</a>が有効な場合，
デバッガ上で逆アセンブルすると，実際のメモリのアドレスが表示されて便利です．
この場合，<a href="3-binary.html#addr2line">上</a>では<code>0x1149</code>番地だったのに，
<code>0x0000555555555149</code>番地に変わっています．</li>
<li><code>gdb</code>の❷<code>info line</code>コマンドを使うと，アドレスから行番号に変換できます．
<code>0x555555555149</code>番地は<code>main.c</code>の4行目に対応しており，
また，この行は機械語命令では<code>0x555555555149</code>番地から<code>0x555555555151</code>に
対応していると表示されています．</li>
<li><code>gdb</code>上では❸<code>info line</code>コマンドを使って，
行番号からアドレスへの変換もできます．</li>
</ul>
<p>なお，<code>gdb</code>で<code>layout asm</code>とすると逆アセンブル結果を常に表示できます．
ブレークポイント(左端の<code>b</code>や<code>B</code>)や次に実行する機械語命令の位置(<code>&gt;</code>)が
表示されて分かりやすいです．</p>
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<details>
<summary>
B+ってどういう意味
</summary>
<ul>
<li><code>B</code>は少なくても一度はブレークしたブレークポイント</li>
<li><code>b</code>は一度もブレークしていないブレークポイント</li>
<li><code>+</code>は有効化されているブレークポイント</li>
<li><code>-</code>は無効化されているブレークポイント</li>
</ul>
</details>
<h4 id="行番号アドレスの変換"><a class="header" href="#行番号アドレスの変換">行番号→アドレスの変換</a></h4>
<p>コマンドライン上で，行番号をアドレスに変換するには
(コマンドがちょっと長くなりますが)以下のように<code>gdb</code>を使います．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;info line main.c:4&quot; --batch
Line 4 of &quot;main.c&quot; starts at address ❶0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<p>上ではプログラムを実行せずにアドレスを取得したので，
<code>a.out</code>ファイル中のアドレス❶<code>0x1149</code>が表示されています．
実行時のアドレスを表示したいなら，以下のようにします
(バッチモードで，<code>b main</code>，<code>run</code>，<code>info line main.c:4</code>という3つのコマンドを実行しています)．
実行時のアドレス❷<code>0x555555555149</code>を表示できました．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;b main&quot; -ex &quot;r&quot; -ex &quot;info line main.c:4&quot; --batch
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
Line 4 of &quot;main.c&quot; starts at address ❷0x555555555149 &lt;main&gt; and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<p>以下のように<code>line2addr</code>などの名前でシェル関数を定義すれば，
短く書けます(が，そんなに頻繁には使わないかも)．</p>
<pre><code class="language-bash">$ function line2addr () {
&gt; command gdb $1 -ex &quot;info line $2&quot; --batch
&gt; }
$ line2addr ./a.out main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<h3 id="デバッグ情報があると逆アセンブル時にソースコードも表示できる"><a class="header" href="#デバッグ情報があると逆アセンブル時にソースコードも表示できる">デバッグ情報があると，逆アセンブル時にソースコードも表示できる</a></h3>
<p>デバッグ情報がある場合，
(<code>objdump -d</code>ではなく)<code>objdump -S</code>で逆アセンブルすると
ソースコードも表示できます．
❶関数<code>add5</code>の定義部分であること，
❷<code>return n + 5;</code>の行のコンパイル結果であること，
などが見やすくなります．</p>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ objdump -S ./add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
❶ int add5 (int n)
{
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
 ❷ return n + 5;
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
}
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<h3 id="デバッガでレジスタの値を確認する"><a class="header" href="#デバッガでレジスタの値を確認する">デバッガでレジスタの値を確認する</a></h3>
<p>デバッガでレジスタの値を確認できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./aout
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) p ❶ $rdi
$1 = 10
(gdb) ❷ info reg
Undefined info command: &quot;regs&quot;.  Try &quot;help info&quot;.
(gdb) info reg
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe048      140737488347208
rsi            0x7fffffffe038      140737488347192
rdi            0xa                 10
(以下略，qを押して表示を停止)
</code></pre>
<ul>
<li>❶ <code>gdb</code>では<code>%</code>ではなく<code>$</code>をつけてレジスタ名を指定します．
<code>p</code>は<code>print</code>コマンドの省略名です．<code>%rdi</code>の値が<code>10</code>であることが分かりました．
16進数で表示したい場合は，<code>p/x $rdi</code>と<code>/x</code>をつけます</li>
<li>❷ レジスタの値一覧は<code>info reg</code>で表示できます．ページャが起動されるので，<code>q</code>を押して表示を停止します．</li>
</ul>
<p><code>gdb</code>で<code>layout regs</code>とすると，レジスタの値を常に表示できます．</p>
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
<ul>
<li><code>layout regs</code>するとレジスタの値一覧が表示されます．
上から「レジスタ表示」「ソースコード表示」「コマンド入力」のためのウィンドウです．</li>
<li><code>focus regs</code>や，<code>ctrl-x o</code>などを入力すると，レジスタ表示ウィンドウが選択されます．
この状態で↓キーを押すと(あるいはマウスでスクロールされると）
レジスタ表示ウィンドウの表示をスクロールできます．</li>
<li><code>ctrl-x a</code>を入力すると，元の表示方法に戻ります．</li>
</ul>
<h3 id="デバッガでメモリの値を確認する"><a class="header" href="#デバッガでメモリの値を確認する">デバッガでメモリの値を確認する</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>を
を実行し，<code>add5</code>関数のスタックフレームが作成された直後は
以下の図(<a href="./2-asm-intro#stack-frame4">この図</a>の再掲)になっています．</p>
<img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
<p>これをデバッガで確認しましょう．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) disas
Dump of assembler code for function add5:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    %edi，-0x4(%rbp)
=&gt; 0x0000555555555183 &lt;+11&gt;:	mov    -0x4(%rbp)，%eax
   0x0000555555555186 &lt;+14&gt;:	add    $0x5，%eax
   0x0000555555555189 &lt;+17&gt;:	pop    %rbp
   0x000055555555518a &lt;+18&gt;:	ret    
(gdb) ❶ p/x $rsp
$1 = 0x7fffffffdf10
(gdb) ❷ p/x $rbp
$2 = 0x7fffffffdf10
(gdb) ❸ x/1gx 0x7fffffffdf10
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❹ x/1gx $rsp
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❺ x/8bx $rsp
0x7fffffffdf10:	0x20 0xdf 0xff 0xff 0xff 0x7f 0x00 0x00
</code></pre>
<ul>
<li>
<p>❶❷ <code>%rsp</code>と<code>%rbp</code>レジスタの値を調べると，どちらも
<code>0x7fffffffdf10</code>番地でした．</p>
</li>
<li>
<p>❸ <code>x/1gx 0x7fffffffdf10</code> はメモリの中身を表示するコマンドです．</p>
<ul>
<li><code>x</code>のコマンド名は examine memory から来ています．</li>
<li><code>/1gx</code>は出力形式を指定しています．
この場合は「8バイトのデータを16進表記で1つ表示」という意味です．</li>
</ul>
</li>
</ul>
<details>
<summary>
xコマンドの表示オプション
</summary>
<blockquote>
<p><code>x</code>コマンドの表示オプションには以下があります(他にもあります)．</p>
<ul>
<li><code>x</code>  16進数</li>
<li><code>d</code>  10進数</li>
<li><code>t</code>   2進数</li>
<li><code>c</code>  文字</li>
<li><code>s</code>  文字列</li>
</ul>
<p>データのサイズ指定には以下があります．</p>
<ul>
<li><code>b</code>  1バイト (byte)</li>
<li><code>s</code>  2バイト (short)</li>
<li><code>w</code>  4バイト (word)</li>
<li><code>g</code>  8バイト (giant)</li>
</ul>
</blockquote>
</details>
<details>
<summary>
サイズの用語がバラバラ過ぎる！
</summary>
<blockquote>
<p>以下の通り，GNUアセンブラ(AT&amp;T形式)，Intel形式，<code>gdb</code>で各サイズに対する
用語がバラバラです．混乱しやすいので要注意です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1バイト</th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>byte (b)</td><td>short (s)</td><td>long (l)</td><td>quad (q)</td></tr>
<tr><td>Intel形式</td><td>byte</td><td>word</td><td>double word (dword)</td><td>quad word (qword)</td></tr>
<tr><td><code>gdb</code></td><td>byte (b)</td><td>short (s)</td><td>word (w)</td><td>giant (g)</td></tr>
</tbody></table>
</div></blockquote>
</details>
<ul>
<li>❹ 具体的なアドレス(ここでは<code>0x7fffffffdf10</code>)ではなく，
レジスタ名 (ここでは<code>$rsp</code>)を指定して，
　そのレジスタが指しているメモリの中身を表示できます．</li>
<li>❺ <code>/1gx</code>ではなく<code>/8bx</code>と表示形式を指定すると，
「1バイトのデータを16進表記で8個表示」という意味になります．
<code>0x7FFFFFFFDF10</code>から<code>0x7FFFFFFFDF17</code>までの各番地には，それぞれ，
以下の図の通り，
<code>0x20</code>，<code>0xDF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0x7F</code>，<code>0x00</code>，<code>0x00</code>という値が
メモリ中に入っていることが分かります．
この格納されている8バイトのデータ<code>0x00007fffffffdf20</code>はアドレスであり，
以下の図の一番下のアドレス(赤字の部分)を指しています．</li>
</ul>
<img src="figs/stack-add5-layout.svg" height="350px" id="fig:stack-add5-layout">
<pre><code>(上のデバッグの続き)
(gdb) ❻ x/1gx $rsp+8
0x7fffffffdf18:	0x000055555555515b
(gdb) ❼ x/8bx $rsp+8
0x7fffffffdf18:	0x5b	0x51	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) ❽ disas 0x000055555555515b
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
❾ 0x000055555555515b &lt;+18&gt;:	mov    %eax，%esi
   0x000055555555515d &lt;+20&gt;:	lea    0xea0(%rip)，%rax        # 0x555555556004
   0x0000555555555164 &lt;+27&gt;:	mov    %rax，%rdi
   0x0000555555555167 &lt;+30&gt;:	mov    $0x0，%eax
   0x000055555555516c &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x0000555555555171 &lt;+40&gt;:	mov    $0x0，%eax
   0x0000555555555176 &lt;+45&gt;:	pop    %rbp
   0x0000555555555177 &lt;+46&gt;:	ret    
End of assembler dump.
</code></pre>
<ul>
<li>❻ <code>x/1gx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスの中身を表示させています．
<code>8(%rsp)</code>の意味は「<code>%rsp</code>の値に8を足したアドレス」です．
<code>gdb</code>中では「<code>$rsp + 8</code>」と入力します．</li>
<li>❼ <code>x/8bx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスを1バイトごとに表示しました．
上記の図の通り， 
<code>0x7FFFFFFFDF18</code>から<code>0x7FFFFFFFDF1F</code>までの各番地には，それぞれ，
<code>0x5B</code>，<code>0x51</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x00</code>，<code>0x00</code>が
格納されていることが分かりました．</li>
<li>❻の結果で得た<code>0x000055555555515b</code>番地を使って❽逆アセンブルしてみると，
❾この番地は「<code>call add5</code>」の次の命令 (この場合は <code>mov %eax， %esi</code>)であることが
分かりました．
このように，<strong>戻り番地</strong> (return address)は通常，
「その関数を呼び出した<code>call</code>命令の次の命令のアドレス」になります．</li>
</ul>
<details>
<summary>
戻り番地が通常ではない場合って?
</summary>
<blockquote>
<p><strong>末尾コール最適化</strong> (tail-call optimization; TCO)が起こった時が該当します．</p>
<div class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="150px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="140px" id="fig:tail-call-opt2">
    </div>
</div>
<ul>
<li>上の「末尾コール最適化の前」の図では<code>main</code>関数が<code>A</code>を呼び，
関数<code>A</code>が<code>B</code>を呼んでいます．また逆の順番でリターンします．
しかし，<code>call B</code>の次の命令が<code>ret</code> (次の命令❷)になっているため，
関数<code>B</code>からリターンした後，関数<code>A</code>では何もせず，<code>main</code>にリターンしています．</li>
<li>そこで「末尾コール最適化の後」の図のように，関数<code>A</code>中の<code>call</code>命令を
無条件ジャンプ命令 <code>jmp</code>に書き換えて，関数<code>B</code>からは(<code>A</code>を経由せず)
直接，<code>main</code>関数のリターンするように書き換えて無駄なリターンを省くことができます．
これが末尾コール最適化です．</li>
<li>その結果，関数<code>B</code>のリターンアドレスは，関数<code>A</code>中の<code>call</code>命令の次のアドレス
(次の命令❷)ではなく，関数<code>main</code>中の「次の命令❶」となってしまいました．
これが戻り番地が通常ではない場合の一例です．</li>
</ul>
</blockquote>
</details>
<h3 id="デバッグ情報を直接見る"><a class="header" href="#デバッグ情報を直接見る">デバッグ情報を直接見る</a></h3>
<p><code>objdump</code>，<code>readelf</code>，<code>llvm_dwarfdump</code>コマンドを使うと，
デバッグ情報の中身を直接見ることができます．</p>
<h4 id="objdump--w"><a class="header" href="#objdump--w"><code>objdump -W</code></a></h4>
<p>デバッグ情報には例えば，以下のものがあります</p>
<ul>
<li>デバッグ情報 (<code>.debug_info</code>)</li>
<li>行情報 (<code>.debug_line</code>)</li>
<li>アドレス情報 (<code>.debug_aranges</code>)</li>
<li>フレーム情報 (<code>.eh_frame</code>)</li>
<li>省略情報 (<code>.debug_abbrev</code>)</li>
</ul>
<p><code>objdump -W add5.o</code> とすると，<code>add5.o</code>中のデバッグ情報を全て表示します
<code>-Wi</code>， <code>-Wl</code>， <code>-Wr</code>， <code>-Wf</code>，<code>-Wa</code>とすると，
それぞれ，デバッグ情報，行情報，アドレス情報，フレーム情報，
省略情報だけを表示できます．</p>
<pre><code class="language-bash">$ objdump -W add5.o | less
add5.o:     file format elf64-x86-64

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string， offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string， offset: 0x5): add5.c
(以下略)
</code></pre>
<p>例えば，以下の部分は
仮引数の情報として「変数名は❻<code>n</code>，
❷<code>add5.c</code>の❸1行目❹15カラム目で宣言されていて，
型は❺<code>&lt;0x5e&gt;</code>を見てね．変数の場所は❻<code>(DW_OP_fbreg: -20)</code>」となってます．</p>
<pre><code>&lt;2&gt;&lt;50&gt;: Abbrev Number: 3 (DW_TAG_formal_parameter)
    &lt;51&gt;   DW_AT_name        : ❶ n
    &lt;53&gt;   DW_AT_decl_file   : ❷ 1
    &lt;54&gt;   DW_AT_decl_line   : ❸ 1
    &lt;55&gt;   DW_AT_decl_column : ❹ 15
    &lt;56&gt;   DW_AT_type        : ❺ &lt;0x5e&gt;
    &lt;5a&gt;   DW_AT_location    : 2 byte block: 91 6c ❻ (DW_OP_fbreg: -20)
</code></pre>
<details>
<summary>
❻DW_OP_fbreg: -20とは
</summary>
<blockquote>
<p>「CFA (canonical frame address)から -20バイトのオフセットの位置」を意味しています．
CFAはDWARFデバッグ情報が定める仮想的なレジスタでCPUごとに異なります．
x86-64の場合は「<code>call</code>命令を実行する直前の<code>%rsp</code>の値」なので，以下になります．
(<code>call</code>命令が戻り番地をスタックにプッシュすることを思い出しましょう)．
引数<code>n</code>(下図で赤い部分)の先頭アドレスは，
CFAからちょうど-20バイトの場所にあることが確認できました．</p>
<img src="figs/stack-layout-CFA.svg" height="400px" id="fig:stack-layout">
<p><a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>でコンパイルされていなければ，
(通常は関数の先頭で<code>push %rbp</code>するので)以下の式が成り立ちます．</p>
<pre><code class="language-math">CFA == %rbp + 16
</code></pre>
<p>なお，<code>fbreg</code> は frame base registerの略だと思います．</p>
</blockquote>
</details>
<details>
<summary>
Abbrev Number (省略番号)とは
</summary>
<blockquote>
<p>例えば，以下のDIEで Abbrev Number は ❶4となっています．</p>
<pre><code class="language-bash">$ objdump -Wi add5.o
...
&lt;1&gt;&lt;5e&gt;: Abbrev Number: ❶4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : 4
    &lt;60&gt;   DW_AT_encoding    : 5         (signed)
    &lt;61&gt;   DW_AT_name        : int
</code></pre>
<p><code>objdump -Wa</code>で<code>.debug_abbrev</code>を表示すると4番目のエントリは
以下となっています．つまり，</p>
<ul>
<li>❷4番のAbbrev Number (省略番号)を持つDIEは ❸DW_TAG_base_type である</li>
<li>DW_TAG_base_typeには例えば，❹変数名の情報があり，その型は❺DW_FORM_stringである</li>
</ul>
<p>と分かります．</p>
<pre><code class="language-bash">$ objdump -Wa add5.o
...
❷4 ❸DW_TAG_base_type    [no children]
    DW_AT_byte_size    DW_FORM_data1
    DW_AT_encoding     DW_FORM_data1
  ❹DW_AT_name       ❺DW_FORM_string
    DW_AT value: 0     DW_FORM value: 0
</code></pre>
<p>要するに<code>.debug_abbrev</code>の情報は<code>.debug_info</code>のメタ情報(型情報)であり，
この場合，4という数字を保持するだけで，
「このDIEはDW_TAG_base_typeである．その内容は…(以下略)」
という情報を持てるのです．</p>
<p>これによりサイズの圧縮が可能になっています．
<code>objdump -W</code>はある程度は散っている情報をまとめて表示していて親切です．</p>
</blockquote>
</details>
<details>
<summary>
LEB128とは
</summary>
<blockquote>
<p>LEB128 (little endian base 128)は任意の大きさの整数を扱える
可変長の符号化方式です．直感的にはLEB128はUTF-8の整数版です．</p>
<p>LEB128はDWARFやWebAssemblyなどで使われています．
(ですので，DWARFデバッグ情報にはLEB128の符号化が使われている箇所があります．
デバッグ情報の16進ダンプを解析する際は注意しましょう)．</p>
<p>LEB128には符号ありと符号なしの2種類がありますが，以下では符号なしで説明します．</p>
<p>ここでは123456を符号なしLEB128形式に変換します．
結果は最下位バイトから，<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>の3バイトになります．
まず<code>bc</code>コマンドで2進数にします❶．</p>
<pre><code class="language-bash">$ bc
obase=2
123456
❶ 11110001001000000
</code></pre>
<p>次に以下のステップを踏みます．</p>
<div class="tab-wrap">
    <input id="LEB128-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="LEB128-1">ステップ1</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-1.svg" height="70px" id="fig:LEB128-1">
    </div>
    <input id="LEB128-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-2">ステップ2</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-2.svg" height="70px" id="fig:LEB128-2">
    </div>
    <input id="LEB128-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-3">ステップ3</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-3.svg" height="70px" id="fig:LEB128-3">
    </div>
    <input id="LEB128-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-4">ステップ4</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-4.svg" height="85px" id="fig:LEB128-4">
    </div>
</div>
<p>ステップ4の結果を<code>bc</code>コマンドで16進数にします❷．</p>
<pre><code class="language-bash">$ bc
obase=16
ibase=2
000001111100010011000000
❷ 7C4C0
</code></pre>
<p>結果の16進数❷<code>0x7C4C0</code> を1バイトごとに最下位バイトから出力すると，
最終的な結果は<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>となります．
LEB128の最上位バイトの最上位ビットは必ず0で，
それ以外のバイトはの最上位ビットは1なので，
サイズ情報がなくても，
元の整数に戻す際，どのバイトまで処理すればよいかが分かります．</p>
</blockquote>
</details>
<p>型の情報<code>&lt;0x5e&gt;</code>は以下にありました．
「サイズは❼ 4バイト，❽符号あり，型名は❾<code>int</code>」です．</p>
<pre><code>&lt;1&gt;&lt;5e&gt;: Abbrev Number: 4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : ❼ 4
    &lt;60&gt;   DW_AT_encoding    : 5        ❽ (signed)
    &lt;61&gt;   DW_AT_name        : ❾ int
</code></pre>
<p>上記の<code>.debug_info</code>中の情報である，
DW_TAG_formal_parameterやDW_TAG_base_typeなどは
DIE (debug information entry)というデバッグ情報の単位の1つです．
DIEは全体で木構造になっています．</p>
<img src="figs/DIE-tree.svg" height="150px" id="fig:DIE-tree">
<p>またデバッグ情報情報があちこちに散っています．
例えば，❷「ファイル1」の情報はどこにあるかというと</p>
<pre><code>    &lt;53&gt; ❷ DW_AT_decl_file   : 1
</code></pre>
<p>行情報にありました．
以下でエントリ1の情報を見ると，<code>add5.c</code>と分かりました．</p>
<pre><code class="language-bash">$ objdump -Wl add5.o | less
(中略)
The File Name Table (offset 0x2c, lines 2, columns 2):
  Entry Dir     Name
  0     0       (indirect line string, offset: 0x11): add5.c
  1     0       (indirect line string, offset: 0x18): add5.c
</code></pre>
<h4 id="readelf"><a class="header" href="#readelf"><code>readelf</code></a></h4>
<p><code>readelf</code>コマンドでも<code>objdump</code>と同様にDWARFデバッグ情報を表示できます．
以下は実行例です．</p>
<pre><code class="language-bash">$ readelf -wi ./add5.o
Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string, offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string, offset: 0x5): add5.c
    &lt;16&gt;   DW_AT_comp_dir    : (indirect line string, offset: 0x0): /tmp
    &lt;1a&gt;   DW_AT_low_pc      : 0x0
    &lt;22&gt;   DW_AT_high_pc     : 0x13
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
(以下略)
</code></pre>
<h2 id="メモリマップを見る"><a class="header" href="#メモリマップを見る">メモリマップを見る</a></h2>
<h3 id="pmapコマンドでメモリマップを見る"><a class="header" href="#pmapコマンドでメモリマップを見る"><code>pmap</code>コマンドでメモリマップを見る</a></h3>
<p><code>pmap</code>コマンドを使うと，
実行中のプログラム(プロセス)がどのメモリ領域を使用しているか
(メモリマップ)を調べられます．
(この出力は<code>/proc</code>ファイルシステムの <code>/proc/プロセス番号/maps</code>の内容から作られています)．</p>
<pre><code class="language-bash">$ cat 
❶ ^Z   
[1]+  Stopped                 cat
$ ps | egrep cat
❷  7687 pts/0    00:00:00 cat
$ ❸ pmap 7687
7687:   cat
❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
000055f74dafc000    132K rw---   [ anon ]
00007f63a7e00000   6628K r---- locale-archive
00007f63a8600000    160K r---- libc.so.6
00007f63a8628000   1620K r-x-- libc.so.6
00007f63a87bd000    352K r---- libc.so.6
00007f63a8815000     16K r---- libc.so.6
00007f63a8819000      8K rw--- libc.so.6
00007f63a881b000     52K rw---   [ anon ]
00007f63a8829000    148K rw---   [ anon ]
00007f63a885d000      8K rw---   [ anon ]
00007f63a885f000      8K r---- ld-linux-x86-64.so.2
00007f63a8861000    168K r-x-- ld-linux-x86-64.so.2
00007f63a888b000     44K r---- ld-linux-x86-64.so.2
00007f63a8897000      8K r---- ld-linux-x86-64.so.2
00007f63a8899000      8K rw--- ld-linux-x86-64.so.2
❹ 00007fff86f9f000 132K ❺rw---   ❻[ stack ]
00007fff86ff8000     16K r----   [ anon ]
00007fff86ffc000      8K r-x--   [ anon ]
ffffffffff600000      4K --x--   [ anon ]
 total             9560K
$ fg
❽ ^D
</code></pre>
<ul>
<li>まず <code>cat</code>コマンドを起動します．ファイル名を指定していないので，
標準入力からの入力待ちになります．
ここで❶ ctrl-Z を入力して，<code>cat</code>コマンドの実行を中断 (suspend)します．
<code>pmap</code>コマンドは実行中のプロセスにしか実行できないため，
<code>cat</code>コマンドが実行中のまま終了しないように，こうしています．</li>
<li>次に<code>ps</code>コマンドで<code>cat</code>コマンドのプロセス番号を調べます．
❷7687がプロセス番号と分かりました．</li>
<li>❸プロセス番号7687を引数として<code>pmap</code>コマンドを実行します．</li>
<li>出力の各行が使用中のメモリ領域の情報を示しています．例えば，❹の行は次を意味しています．</li>
</ul>
<p><code>❹ 00007fff86f9f000    132K ❺rw---   ❻[ stack ]</code></p>
<ul>
<li>
<p>❹アドレス`00007fff86f9f000'からサイズ132KBの領域を使用している．</p>
</li>
<li>
<p>このメモリ領域の❻アクセス権限は読み書きが可能で，実行は不可．</p>
<ul>
<li><code>r</code> 読み込み可能</li>
<li><code>w</code> 書き込み可能</li>
<li><code>x</code> 実行可能</li>
</ul>
</li>
<li>
<p>このメモリ領域は❻スタックとして使用している</p>
</li>
<li>
<p><code>cat</code>コマンド自身は以下の5つのメモリ領域を使用しています．</p>
<ul>
<li>アクセス権限が <code>r-x--</code>のものは，<code>.text</code>セクションでしょう．
(<code>.text</code>セクションは通常，実行可能かつ書き込み禁止にするからです)</li>
<li>アクセス権限が <code>rw----</code>のものは，<code>.data</code>セクションでしょう．
(<code>.data</code>セクションは通常，実行禁止かつ書き込み可能にするからです)</li>
<li>残りの3つのアクセス権限が <code>r----</code> のものは，<code>.rodata</code>セクションなどでしょう．
(詳細は調べていません)</li>
<li>使用しているサイズが4KBの倍数なのは，x86-64でよくある
<strong>ページ</strong>(page)サイズが4KBだからです．
(ページとは仮想記憶方式の1つであるページングで使われる，
固定長(例えば4KB)に区切ったメモリ領域のことです)．
プロセスは<code>mmap</code>システムコールを使って，OSからページ単位でメモリを割り当ててもらい，その際にページごとにアクセス権限を設定できます．</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
</code></pre>
<ul>
<li>最後に❼で，中断していた<code>cat</code>コマンドを<code>fg</code>コマンドで実行を再開し，
<code>ctrl-D</code>を入力して<code>cat</code>コマンドの実行を終了しています．</li>
</ul>
<h3 id="gdbでメモリマップを見る"><a class="header" href="#gdbでメモリマップを見る"><code>gdb</code>でメモリマップを見る</a></h3>
<p><code>gdb</code>でもメモリマップを見ることができます</p>
<pre><code class="language-bash">$ gdb /usr/bin/cat
(gdb) r
ctrl-Z
Program received signal SIGTSTP, Stopped (user).
(gdb) info proc map
process 7821
Mapped address spaces:

          Start Addr           End Addr       Size     Offset  Perms  objfile
      0x555555554000     0x555555556000     0x2000        0x0  r--p   /usr/bin/cat
      0x555555556000     0x55555555a000     0x4000     0x2000 ❶r-xp   /usr/bin/cat
<span class="boring">      0x55555555a000     0x55555555c000     0x2000     0x6000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555c000     0x55555555d000     0x1000     0x7000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555d000     0x55555555e000     0x1000     0x8000  rw-p   /usr/bin/cat
</span><span class="boring">      0x55555555e000     0x55555557f000    0x21000        0x0  rw-p   [heap]
</span><span class="boring">      0x7ffff7400000     0x7ffff7a79000   0x679000        0x0  r--p   /usr/lib/locale/locale-archive
</span><span class="boring">      0x7ffff7c00000     0x7ffff7c28000    0x28000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7c28000     0x7ffff7dbd000   0x195000    0x28000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7dbd000     0x7ffff7e15000    0x58000   0x1bd000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e15000     0x7ffff7e19000     0x4000   0x214000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e19000     0x7ffff7e1b000     0x2000   0x218000  rw-p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e1b000     0x7ffff7e28000     0xd000        0x0  rw-p   
</span><span class="boring">      0x7ffff7f87000     0x7ffff7fac000    0x25000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbb000     0x7ffff7fbd000     0x2000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbd000     0x7ffff7fc1000     0x4000        0x0  r--p   [vvar]
</span><span class="boring">      0x7ffff7fc1000     0x7ffff7fc3000     0x2000        0x0  r-xp   [vdso]
</span><span class="boring">      0x7ffff7fc3000     0x7ffff7fc5000     0x2000        0x0  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fc5000     0x7ffff7fef000    0x2a000     0x2000  r-xp   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fef000     0x7ffff7ffa000     0xb000    0x2c000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffb000     0x7ffff7ffd000     0x2000    0x37000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x39000  rw-p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
</span><span class="boring">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0  --xp   [vsyscall]
</span></code></pre>
<details>
<summary>
アクセス権限rwxpのpとは
</summary>
<p><code>mmap</code>でメモリ領域をマップする際に，
フラグとして<code>MAP_PRIVATE</code>を指定すると<code>p</code>，
<code>MAP_SHARED</code>を指定すると<code>s</code>と表示されます．</p>
<ul>
<li>
<p><code>MAP_PRIVATE</code> マップした領域への変更はプロセス間で共有されません．
マップは<strong>copy-on-write</strong>なので，書き込まれるまで自分専用のコピーは発生せず，
共有されます．</p>
</li>
<li>
<p><code>MAP_SHARED</code> マップした領域への変更はプロセス間で共有されます．
すなわちマップした領域に書き込みを行うと，
その変更は他のプロセスにも見えます．
ただし，<code>msync</code>を使う必要があります．</p>
</li>
</ul>
<p>❶<code>.text</code>セクションの共有設定も<code>p</code>となっています．
これは<code>.text</code>セクションも<code>mmap</code>の<code>MAP_PRIVATE</code>でマップしているからです．
動的リンクした実行可能ファイルの<code>.text</code>セクションは
物理メモリ上で共有されていますが，
その共有と<code>MAP_SHARED</code>は関係ないのです．</p>
<!--
ちなみに，そのプロセスが`mmap`で`MAP_SHARED`なマップをすれば，
表示が`s`になります(自分でやってみて確かめました)．

strace して .text を MAP_PRIVATE　してるのを確かめようとしたけど
よくわからんかった．
$ strace /lib64/ld-linux-x86-64.so.2 /usr/bin/cat
もやったんだけどね．
-->
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 3; }
</style>
<h1 id="x86-64機械語命令"><a class="header" href="#x86-64機械語命令">x86-64機械語命令</a></h1>
<h2 id="how-to-execute-x86-inst"><a class="header" href="#how-to-execute-x86-inst">x86-64機械語命令の実行方法</a></h2>
<h3 id="概要"><a class="header" href="#概要">概要</a></h3>
<p>機械語命令を実行しても，単に<code>a.out</code>を実行するだけでは
意図通りに実行できたかの確認が難しいです．
(アセンブリコード内から<code>printf</code>を呼び出せばいいのですが，
そのコードもうざいので)．
そこで本書では<strong>デバッガを使って</strong>機械語命令の実行と確認を行います．</p>
<p>以下では例として<code>movq $999, %rax</code>という機械語命令を実行してみます．
(これらのファイルは<a href="https://github.com/gondow/linux-x86-64-programming/tree/main/src/asm">サンプルコード</a>から入手できます)．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p>実行確認のための<code>gdb</code>のコマンド列を書いたファイルも用意しています．</p>
<div id="asm/movq-4.txt">
<pre><code># asm/movq-4.txt
b 7
r
list 6,6
p $rax
echo # %raxの値が999なら成功\n
</code></pre>
</div>
<h3 id="デバッガ上で実行gdbコマンドを手入力"><a class="header" href="#デバッガ上で実行gdbコマンドを手入力">デバッガ上で実行：<code>gdb</code>コマンドを手入力</a></h3>
<p><code>asm/movq-4.txt</code>中の<code>gdb</code>コマンドを
以下のように1行ずつ入力してみて下さい．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶
(gdb) b 7 ❷
Breakpoint 1 at 0x1130: file movq-4.s, line 6.
(gdb) r ❸
Breakpoint 1, main () at movq-4.s:6
6	    ret
(gdb) list 6,6 ❹
5	    movq $999, %rax
(gdb) p $rax ❺
$1 = 999
(gdb) quit
</code></pre>
<ul>
<li>❶ コンパイルした<code>a.out</code>を<code>gdb</code>上で実行</li>
<li>❷ ブレークポイントを7行目(<code>movq $999, %rax</code>の次の行)に設定</li>
<li>❸ 実行開始</li>
<li>❹ ソースコードの6行目だけを表示</li>
<li>❺ レジスタ<code>%rax</code>の値を(10進表記で)表示</li>
<li><a href="6-inst.html#asm/movq-4.txt"><code>movq-4.txt</code></a>
の最後の行 <code>echo # %raxの値が999なら成功\n</code>は，
「どうなると正しく実行できたか」を確認するメッセージですので，
ここでは入力不要です．
❺の結果と一致したので「正しい実行」と確認できました．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力--xオプションを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力--xオプションを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>-x</code>オプションを使う)</a></h3>
<p><code>gdb</code>コマンドを手入力して，よく使う<code>gdb</code>コマンドを覚えることは良いことです．
とはいえ，手入力は面倒なので，自動入力も可能です．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶ -x movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	 ❷ movq $999, %rax
❸ $1 = 999 
❹ # %raxの値が999なら成功
(gdb) 

</code></pre>
<ul>
<li>❶ <code>-x movq-4.txt</code> というオプションをつけると，指定したファイル(ここでは<code>movq-4.txt</code>)の中に書かれている<code>gdb</code>コマンドを1行ずつ順番に実行してくれます</li>
<li><code>list 6,6</code>を実行した結果，❷6行目の<code>movq $999, %rax</code> が表示されています</li>
<li><code>p $rax</code>を実行した結果，<code>%rax</code>レジスタの値が❸999であると表示されています．
(<code>$1</code>は<code>gdb</code>が扱う変数です．ここでは無視して下さい)</li>
<li><code>echo # %raxの値が999なら成功\n</code> を<code>gdb</code>が実行した結果，
❹ <code># %raxの値が999なら成功</code>というメッセージが表示されています．
このメッセージと❸の実行結果を見比べれば「実行結果が正しい」ことを確認できます．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>source</code>コマンドを使う)</a></h3>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) ❶ source movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	    movq $999, %rax
$1 = 999
# %raxの値が999なら成功
</code></pre>
<p><code>gdb</code>は通常通りに実行開始して，
❶ <code>source</code>コマンドを使えば，<code>movq-4.txt</code>中の<code>gdb</code>コマンドを実行できます．
<code>-x</code>オプションと<code>source</code>コマンドは好きな方を使って下さい．</p>
<h2 id="アドレッシングモード-オペランドの表記方法"><a class="header" href="#アドレッシングモード-オペランドの表記方法">アドレッシングモード (オペランドの表記方法)</a></h2>
<h3 id="メモリ参照"><a class="header" href="#メモリ参照">メモリ参照</a></h3>
<h2 id="x86-64機械語命令-転送など"><a class="header" href="#x86-64機械語命令-転送など">x86-64機械語命令 (転送など)</a></h2>
<h2 id="x86-64機械語命令-算術論理演算"><a class="header" href="#x86-64機械語命令-算術論理演算">x86-64機械語命令 (算術論理演算)</a></h2>
<h3 id="四則演算"><a class="header" href="#四則演算">四則演算</a></h3>
<h3 id="インクリメントデクリメント符号反転"><a class="header" href="#インクリメントデクリメント符号反転">インクリメント，デクリメント，符号反転</a></h3>
<h3 id="ビット論理演算"><a class="header" href="#ビット論理演算">ビット論理演算</a></h3>
<h3 id="シフト演算"><a class="header" href="#シフト演算">シフト演算</a></h3>
<h3 id="ローテート演算"><a class="header" href="#ローテート演算">ローテート演算</a></h3>
<h2 id="x86-64機械語命令-比較とジャンプ"><a class="header" href="#x86-64機械語命令-比較とジャンプ">x86-64機械語命令 (比較とジャンプ)</a></h2>
<h3 id="比較"><a class="header" href="#比較">比較</a></h3>
<h3 id="無条件ジャンプ"><a class="header" href="#無条件ジャンプ">無条件ジャンプ</a></h3>
<h3 id="条件付きジャンプ"><a class="header" href="#条件付きジャンプ">条件付きジャンプ</a></h3>
<h2 id="x86-64機械語命令-関数呼び出しとリターン"><a class="header" href="#x86-64機械語命令-関数呼び出しとリターン">x86-64機械語命令 (関数呼び出しとリターン)</a></h2>
<h3 id="call"><a class="header" href="#call"><code>call</code></a></h3>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 11; }
</style>
<h1 id="x86-64-命令一覧"><a class="header" href="#x86-64-命令一覧">x86-64 命令一覧</a></h1>
<h2 id="概要と記号"><a class="header" href="#概要と記号">概要と記号</a></h2>
<h2 id="命令サフィックス"><a class="header" href="#命令サフィックス">命令サフィックス</a></h2>
<h2 id="レジスタ"><a class="header" href="#レジスタ">レジスタ</a></h2>
<h2 id="ステータスレジスタ"><a class="header" href="#ステータスレジスタ">ステータスレジスタ</a></h2>
<h2 id="プログラムカウンタ"><a class="header" href="#プログラムカウンタ">プログラムカウンタ</a></h2>
<h2 id="セグメントレジスタ"><a class="header" href="#セグメントレジスタ">セグメントレジスタ</a></h2>
<h2 id="レジスタの別名"><a class="header" href="#レジスタの別名">レジスタの別名</a></h2>
<h2 id="アドレッシングモードオペランドの記法"><a class="header" href="#アドレッシングモードオペランドの記法">アドレッシングモード(オペランドの記法)</a></h2>
<h3 id="アドレッシングモードの種類"><a class="header" href="#アドレッシングモードの種類">アドレッシングモードの種類</a></h3>
<h3 id="メモリ参照の形式"><a class="header" href="#メモリ参照の形式">メモリ参照の形式</a></h3>
<h3 id="メモリ参照の例"><a class="header" href="#メモリ参照の例">メモリ参照の例</a></h3>
<h3 id="メモリ参照で可能な組み合わせ-indexにrspは指定不可xxx"><a class="header" href="#メモリ参照で可能な組み合わせ-indexにrspは指定不可xxx">メモリ参照で可能な組み合わせ (indexに%rspは指定不可(xxx))</a></h3>
<h2 id="詳しい文法欄で用いるオペランドの記法と注意"><a class="header" href="#詳しい文法欄で用いるオペランドの記法と注意">「詳しい文法」欄で用いるオペランドの記法と注意</a></h2>
<h2 id="データ転送コピー"><a class="header" href="#データ転送コピー">データ転送(コピー)</a></h2>
<h3 id="データ転送コピー基本"><a class="header" href="#データ転送コピー基本">データ転送(コピー)：基本</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th>文法</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th>詳しい文法</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td></td></tr>
<tr><td></td><td><code>movq %rax, 4(%rbp)</code></td><td><code>*(%rbp + 4) = %rax</code></td><td></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq 4(%rbp), %rax</code></td><td><code>%rax = *(%rbp + 4)</code></td><td></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, 4(%rbp)</code></td><td><code>*(%rbp + 4) = 999</code></td><td></td></tr>
</tbody></table>
</div>
<hr />
<span style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th>CF</th><th>OF</th><th>SF</th><th>ZF</th><th>PF</th><th>AF</th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></span>
<hr />
<ul>
<li><code>␣</code>は<a href="x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a></li>
<li><code>mov</code>命令(および他のほとんどのデータ転送命令)はステータスフラグの値を変更しない</li>
<li><code>mov</code>命令はメモリからメモリへの直接データ転送はできない</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 12; }
</style>
<h1 id="リンク集"><a class="header" href="#リンク集">リンク集</a></h1>
<ul>
<li>デバッグ情報の仕様書 <a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a></li>
<li>WindowsのLinux環境 <a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> </li>
<li>仮想マシン <a href="https://www.virtualbox.org/">VirtualBox</a></li>
<li>コンテナ環境 <a href="https://www.docker.com/">Docker</a></li>
<li>オンライン開発環境 <a href="https://replit.com/">repl.it</a></li>
<li>OS自作本 <a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a></li>
<li>Linuxディストリビューション <a href="https://www.ubuntulinux.jp/home">Ubuntu</a></li>
<li>GNUアセンブラのマニュアル <a href="https://sourceware.org/binutils/docs-2.40/as/index.html">Using as</a></li>
<li>GCC 9.4のマニュアル <a href="https://gcc.gnu.org/onlinedocs/9.4.0/">9.4 Manuals</a></li>
<li>x86-64のマニュアル <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a></li>
<li>LinuxのABI <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a></li>
</ul>
<!-- - Linuxの標準 [Linux Standard Base (LSB)](https://refspecs.linuxfoundation.org/lsb.shtml) -->
<ul>
<li>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></li>
<li><a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></li>
<li>VDSO <a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></li>
<li>call frame informationの短い解説 <a href="https://www.imperialviolet.org/2017/01/18/cfi.html">CFI</a></li>
</ul>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
