<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linuxで学ぶx86-64アセンブリ言語</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要 90%</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル 90%</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="4-encoding.html"><strong aria-hidden="true">4.</strong> データ表現，2進数，2の補数 0%</a></li><li class="chapter-item "><a href="5-arch.html"><strong aria-hidden="true">5.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど 0%</a></li><li class="chapter-item "><a href="6-inst.html"><strong aria-hidden="true">6.</strong> x86-64機械語命令 80%</a></li><li class="chapter-item "><a href="7-asmdir.html"><strong aria-hidden="true">7.</strong> GNUアセンブラ命令 0%</a></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ 0%</a></li><li class="chapter-item "><a href="9-abi.html"><strong aria-hidden="true">9.</strong> ABI: アプリケーション・バイナリ・インタフェース 0%</a></li><li class="chapter-item "><a href="10-gdb.html"><strong aria-hidden="true">10.</strong> デバッガgdbの使い方 70%</a></li><li class="chapter-item "><div><strong aria-hidden="true">11.</strong> gccが生成したアセンブリコードを読む</div></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">12.</strong> x86-64命令一覧 30%</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">13.</strong> リンク集 10%</a></li><li class="chapter-item "><div><strong aria-hidden="true">14.</strong> AT&TスタイルとIntelスタイルの違い 0%</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 1; }
</style>
<h1 id="前書き"><a class="header" href="#前書き">前書き</a></h1>
<h2 id="言い訳"><a class="header" href="#言い訳">言い訳</a></h2>
<p>本書はまだ執筆途中です．不完全な部分があることをお許しください．
(書き進めることを優先して，内容のチェックが不十分です)．
しかしながら，誤りの指摘や改善のためのコメントは歓迎いたします．
本書のGithubリポジトリは<a href="https://github.com/gondow/linux-x86-64-programming">こちら</a>です．</p>
<h2 id="本書の目的"><a class="header" href="#本書の目的">本書の目的</a></h2>
<p>本書は筆者（権藤克彦）が<a href="https://www.titech.ac.jp/">東京工業大学</a>の
<a href="https://educ.titech.ac.jp/cs/">情報工学系</a>で
長年担当したアセンブリ言語の授業の資料をオンライン資料として
まとめ直したものです．
Intel x86-64，Linux，GNUアセンブラを前提として「アセンブリ言語とは何か」
「具体的にどうプログラミングすればいいのか」を分かりやすくお伝えすることが目的です．</p>
<p>ただし，本書では以下は扱っていません．</p>
<ul>
<li>浮動小数点命令</li>
<li>(デバイスドライバの実装に必要な)I/O命令</li>
<li>(OSの実装に必要な)特権命令</li>
<li>MMX/SSE/AVXなどの拡張命令</li>
</ul>
<p>いや，書いてもいいのですが分量が膨大になるので面倒くさいんです．
もしOS自作に興味があるなら書籍<a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a>を強くお勧めします．</p>
<h2 id="本書で使う環境"><a class="header" href="#本書で使う環境">本書で使う環境</a></h2>
<p>本書では以下の環境を使用しています．皆さんの環境がLinuxであれば多少違っても大丈夫なはずです．</p>
<ul>
<li>Ubuntu 22.04 LTS (OS)</li>
<li>GNU gcc-11.3.0 (コンパイラ)</li>
<li>GNU binutils-2.38 (バイナリ・ユーティリティ，GNUアセンブラ<code>as</code>を含む)</li>
<li>GNU gdb-12.1 (デバッガ)</li>
</ul>
<p>しかし，WindowsやmacOSの場合は，本書の内容と大きく異なってしまいます．
アセンブリ言語は環境への依存度が高く，そのため移植性がとても低いからです．</p>
<p>皆さんのパソコンがWindowsやmacOSだった場合，Linux環境を導入する方法として以下のようないろいろな方法があります．筆者のお勧めは</p>
<ul>
<li>WindowsならWSL2を使う</li>
<li>macOSなら仮想マシンVirtual Boxをインストールして，Ubuntuをインストールする</li>
</ul>
<p>です．デバッガはアセンブリ言語の実行結果を確認するために便利ですので，
ぜひ準備して下さい．</p>
<p>Linux環境を導入する方法：</p>
<ul>
<li><a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> (Windows Subsystem for Linux 2)を使えるように設定する</li>
<li><a href="https://www.virtualbox.org/">VirtualBox</a>や
<a href="https://www.vmware.com/jp/products/fusion.html">VMWare Fusion</a>
などの仮想マシンをインストールして，その仮想マシン上に<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．</li>
<li><a href="https://www.docker.com/">Docker</a>などのコンテナ実行環境をインストールして，その上で<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．</li>
<li>オンライン環境（例えば<a href="https://replit.com/">repl.it</a>）を使う．</li>
</ul>
<p>Linux環境の導入方法を書くと切りが無いので，皆さん自身でググって下さい．</p>
<p>私が使った Ubuntu 22.04 LTSには<code>gcc</code>などが未インストールなので，
以下のコマンドでインストールしました．</p>
<pre><code>$ sudo apt install build-essential
</code></pre>
<h2 id="本書のライセンス"><a class="header" href="#本書のライセンス">本書のライセンス</a></h2>
<p>Copyright (C) 2023 Katsuhiko Gondow</p>
<p>本書は<a href="https://creativecommons.org/licenses/by-nc/4.0/deed.ja">クリエイティブ・コモンズ4.0表示(CC-BY-NC 4.0)</a>で提供します．</p>
<h2 id="本書の作成公開環境"><a class="header" href="#本書の作成公開環境">本書の作成・公開環境</a></h2>
<ul>
<li>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></li>
<li>お絵かきツール <a href="https://www.drawio.com/">draw.io</a></li>
<li>公開環境 <a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></li>
</ul>
<h2 id="本書のお約束"><a class="header" href="#本書のお約束">本書のお約束</a></h2>
<h3 id="メモリの図では0番地が常に上"><a class="header" href="#メモリの図では0番地が常に上">メモリの図では0番地が常に上</a></h3>
<p>本書ではメモリの図を書く時，必ず0番地(低位アドレス)が上，
高位アドレスが下になるようにします．</p>
<img src="figs/oyakusoku-memory.svg" height="150px" id="fig:oyakusoku-memory">
<p>その結果，本書の図では「スタックは上に成長」，「ヒープは下に成長」することになります
(<a href="2-asm-intro.html#fig:memory-layout">メモリレイアウト</a>)．</p>
<h3 id="❶❷などの黒丸数字は説明用"><a class="header" href="#❶❷などの黒丸数字は説明用">❶❷などの黒丸数字は説明用</a></h3>
<p>実行結果中の❶や❷などの黒丸数字は，説明のために私が追加したものです．
実行結果の出力ではありません．
例えば，以下が例で，<code>file</code>コマンドの出力例です．
本文中の説明と実行結果のどこが対応しているのかを明示するために使います．</p>
<pre><code>$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable, x86-64, ❹version 1 (SYSV), ❺not stripped
</code></pre>
<p><a href="https://practicalbinaryanalysis.com/">Practical Binary Analysis</a>
という書籍がこうしていて便利なので真似させてもらっています．</p>
<h3 id="一部を隠してます"><a class="header" href="#一部を隠してます">一部を隠してます．</a></h3>
<p>「細かい説明」「演習問題の答え」などは<code>details</code>タグを使って隠しています．
最初は読み飛ばして構いません．読む場合は▶ボタンを押して下さい．</p>
<details>
<summary>
←このボタン(またはこの行)を押してみて下さい
</summary>
<p>これが隠されていた内容です．</p>
</details>
<h3 id="一部の図はタブ表示にしています"><a class="header" href="#一部の図はタブ表示にしています">一部の図はタブ表示にしています</a></h3>
<p>一部の図はタブ切り替えでパラパラ漫画のように表示しています．
一度に全部を表示するとゴチャゴチャする場合などに使います．
以下はタブ表示の例です．</p>
<form class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="100px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="93px" id="fig:tail-call-opt2">
    </div>
</form>
<h3 id="サンプルコードがあります"><a class="header" href="#サンプルコードがあります"><a href="https://github.com/gondow/linux-x86-64-programming/tree/main/docs/asm">サンプルコード</a>があります</a></h3>
<p><a href="https://github.com/gondow/linux-x86-64-programming/tree/main/docs/asm">サンプルコード</a>
には2種類のファイルがあります．</p>
<ul>
<li><code>*.s</code> アセンブリコード</li>
<li><code>*.txt</code> <code>gdb</code>のコマンド列が書かれたファイル</li>
</ul>
<p>これらのファイルとデバッガ<code>gdb</code>を使って機械語命令を実行・確認する方法は，
<a href="./6-inst.html#how-to-execute-x86-inst">こちら</a>に説明があります．
(サンプルコードの準備，めっちゃ大変だったので活用して頂けるととても嬉しいです)．</p>
<h3 id="説明せず擬似コードを使っている部分があります"><a class="header" href="#説明せず擬似コードを使っている部分があります">(説明せず)擬似コードを使っている部分があります</a></h3>
<p>例えば，<a href="./x86-list.html#mov-plain"><code>mov</code>命令の説明</a>では
<code>movq %rax, %rbx</code>の動作の説明として，<code>%rbx = %rax</code>と書いています．
<code>%rbx = %rax</code>はアセンブリ言語でも無くC言語でも無い，
C言語風の<strong>擬似コード</strong>(psuedo code)です．
「<code>%rax</code>レジスタの値を<code>%rbx</code>レジスタに格納する」という動作を
簡潔に表現する手段として使わせて下さい．</p>
<h3 id="2023819現在日本語検索には未対応です"><a class="header" href="#2023819現在日本語検索には未対応です">2023/8/19現在，日本語検索には<strong>未対応</strong>です．</a></h3>
<p>軽くググった所，ちょっと面倒くさそうなので後回しにしてます．</p>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 2; }
</style>
<h1 id="アセンブリ言語の概要"><a class="header" href="#アセンブリ言語の概要">アセンブリ言語の概要</a></h1>
<h2 id="機械語とアセンブリ言語とは何か短い説明"><a class="header" href="#機械語とアセンブリ言語とは何か短い説明">機械語とアセンブリ言語とは何か？（短い説明）</a></h2>
<p><strong>機械語</strong>（マシン語）：</p>
<ul>
<li>CPUが直接実行できる唯一の言語．</li>
<li>機械語命令を2進数（バイナリ，数字の列）で表現．</li>
</ul>
<p><strong>アセンブリ言語</strong>：</p>
<ul>
<li>機械語を記号で表現したプログラミング言語．</li>
<li>例1：機械語命令<code>01010101</code>をアセンブリ言語では<code>pushq %rbp</code>という記号（<strong>ニモニック</strong>，mnemonic）で表す（x86-64の場合，以下同様）．</li>
<li>例2：メモリのアドレス<code>1000</code>番地をアセンブリ言語では<code>add5</code>などの記号（<strong>ラベル</strong>）で表す．</li>
</ul>
<img src="figs/machine-asm.svg" height="150px" id="fig:machine-asm">
<details>
<summary>
pushq %rbpとは
</summary>
<p>レジスタ<code>%rbp</code>中の値をスタックにプッシュする」という命令です．
<a href="2-asm-intro.html#push-rbp-pop-rbp">ここ</a>で説明します．</p>
</details>
<p>2進数の機械語命令と，機械語命令のニモニックは概ね，1対1に対応しており，
機械的に変換できます．ただし，その変換方法を覚える必要はありません．
<a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブル</a>や<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>してくれる
コマンド（プログラム）にやってもらえばいいのです．</p>
<p>ただ，アセンブリ言語の仕組みを理解するには，オブジェクトファイル<code>*.o</code>や
実行可能ファイル<code>a.out</code>の中身や仕組みを理解する必要があるため，
<a href="./3-binary.html">バイナリファイル</a>の節では説明が多くなっています．</p>
<h2 id="逆アセンブル"><a class="header" href="#逆アセンブル">機械語とアセンブリ言語の具体例（逆アセンブル）</a></h2>
<p>まず以下の簡単なCのプログラム<code>add5.c</code>を用意して下さい．</p>
<p id="add5.c">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<p><code>add5.c</code>を<code>gcc -c</code>で処理すると，
<strong>オブジェクトファイル</strong><code>add5.o</code>ができます．
この<code>add5.o</code>に対して<code>objdump -d</code>を実行すると，
<strong>逆アセンブル</strong>(disassemble)した結果が表示されます．</p>
<pre><code class="language-bash">$ gcc -c add5.c
$ ls
add5.c  add5.o
$ objdump -d add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 05             	add    $0x5,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<p>逆アセンブルとは，<code>a.out</code>や<code>*.o</code>中の機械語命令を
アセンブリ言語のニモニック表現に変換することです．
上の実行例で，左側に機械語命令，右側にニモニックが表示されています．
(一番左側の数字は，<a href="./3-binary.html#.text"><code>.text</code>セクション</a>の先頭からのバイト数（16進表記）です）．
例えば，4バイト目にある<code>55</code>は機械語命令（を16進数で表記したもの），
<code>55</code>の右側の<code>push %rbp</code>が，<code>55</code>に対応するニモニックです．
16進数が使われているのは，2進数で表記すると長くなってしまうからです．</p>
<h2 id="cコードをアセンブリコードにコンパイルする"><a class="header" href="#cコードをアセンブリコードにコンパイルする">Cコードをアセンブリコードにコンパイルする</a></h2>
<p><a href="2-asm-intro.html#add5.c"><code>add5.c</code></a>に対して，
以下のコマンドを実行して，<code>add5.s</code>を作成して下さい．
これで「アセンブリ言語で書かれたプログラム（アセンブリコード）」がどんなものかを見れます．</p>
<pre><code class="language-bash">$ gcc -S add5.c
$ ls
add5.c  add5.s
</code></pre>
<!-- ![gcc-S](figs/gcc-S.svg) -->
<img src="figs/gcc-S.svg" height="70px" id="fig:gcc-S">
<p><code>-S</code>オプションをつけて処理すると，
<code>gcc</code>はCのプログラム(<code>add5.c</code>)からアセンブリコード(<code>add5.s</code>)を生成します．
この処理を「狭義のコンパイル」と呼びます
（<a href="./3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">広義のコンパイル</a>はCのプログラムから実行可能ファイル(<code>a.out</code>)を
生成する処理を指します）．
<code>gcc -S</code>は「コンパイラ」と呼ばれます．コンパイルするコマンドだからです．</p>
<p><code>add5.s</code>の中身は例えば以下となります．</p>
<blockquote>
<p>注意：
gccのバージョンの違いにより，同じLinuxでも<code>add5.s</code>の中身が以下と異なることがあります．</p>
</blockquote>
<p>以下では表示が長いので省略しています．
全てを表示するには右にある<i class="fa fa-eye"></i>ボタンを押して下さい．
（ここでは<code>add5.s</code>の中身は理解できなくてOKです）．</p>
<pre><code class="language-bash">$ cat add5.s
        .file   &quot;add5.c&quot;
        .text
        .globl  add5
        .type   add5, @function
add5:
.LFB0:
        .cfi_startproc
        endbr64
        pushq   %rbp
<span class="boring">        .cfi_def_cfa_offset 16
</span><span class="boring">        .cfi_offset 6, -16
</span><span class="boring">        movq    %rsp, %rbp
</span><span class="boring">        .cfi_def_cfa_register 6
</span><span class="boring">        movl    %edi, -4(%rbp)
</span><span class="boring">        movl    -4(%rbp), %eax
</span><span class="boring">        addl    $5, %eax
</span><span class="boring">        popq    %rbp
</span><span class="boring">        .cfi_def_cfa 7, 8
</span><span class="boring">        ret
</span><span class="boring">        .cfi_endproc
</span><span class="boring">.LFE0:
</span><span class="boring">        .size   add5, .-add5
</span><span class="boring">        .ident  &quot;GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0&quot;
</span><span class="boring">        .section        .note.GNU-stack,&quot;&quot;,@progbits
</span><span class="boring">        .section        .note.gnu.property,&quot;a&quot;
</span><span class="boring">        .align 8
</span><span class="boring">        .long   1f - 0f
</span><span class="boring">        .long   4f - 1f
</span><span class="boring">        .long   5
</span><span class="boring">0:
</span><span class="boring">        .string &quot;GNU&quot;
</span><span class="boring">1:
</span><span class="boring">        .align 8
</span><span class="boring">        .long   0xc0000002
</span><span class="boring">        .long   3f - 2f
</span><span class="boring">2:
</span><span class="boring">        .long   0x3
</span><span class="boring">3:
</span><span class="boring">        .align 8
</span><span class="boring">4:
</span></code></pre>
<p>このうち実行に関係する部分だけを残したアセンブリコードが以下になります．</p>
<p id="add5.s">
<pre><code class="language-x86asmatt"># add5.s
    .text
    .globl add5
    .type add5, @function
add5:
    pushq %rbp
    movq  %rsp, %rbp
    movl  %edi, -4(%rbp)
    movl  -4(%rbp), %eax
    addl  $5, %eax
    popq  %rbp
    ret
    .size  add5, .-add5
</code></pre>
</p>
<p>各行の意味は<a href="2-asm-intro.html#add5.s-content">次の次の節</a>で説明しますが，
ちょっとだけ説明します．</p>
<ul>
<li><code>.text</code>などドット<code>.</code>で始まる命令は<strong>アセンブラ命令</strong>です</li>
<li><code>add5:</code>など名前の後ろにコロン<code>:</code>があるものは<strong>ラベルの定義</strong>です</li>
<li><code>%rbp</code>など，パーセント<code>%</code>で始まるものは<strong>レジスタ</strong>です</li>
<li><code>$5</code>など，ドル<code>$</code>で始まるものは定数(<strong>即値</strong>)です．</li>
<li><code>addl $5, %eax</code>は「レジスタ<code>%eax</code>の値と定数の5を足し算した結果を
<code>%eax</code>レジスタに格納する」という動作を行う<strong>機械語命令</strong>です</li>
<li><code>#</code>から行末までは<strong>コメント</strong>です</li>
</ul>
<details>
<summary>
AT&T形式とIntel形式とは
</summary>
<p>x86-64用のアセンブラには本書で扱うGNUアセンブラ以外にも，
<a href="https://github.com/netwide-assembler/nasm">NASM</a> (netwide assembler)などいくつかあり，
困ったことにアセンブリ言語の表記が異なります．
この表記方法には大きく2種類：<strong>AT&amp;T</strong>形式と<strong>Intel形式</strong>があります．
本書で扱うGNUアセンブラはAT&amp;T形式，NASMや<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>はIntel形式を使っています．</p>
<p>一番大きな違いは機械語命令の引数(<strong>オペランド</strong>といいます)の順番です．</p>
<ul>
<li>AT&amp;T形式は「左から右へ」，つまり代入先のオペランドを右に書きます</li>
<li>Intel形式は「右から左へ」，つまり代入先のオペランドを左に書きます</li>
</ul>
<img src="figs/att-intel.svg" height="100px" id="fig:att-intel">
<p>他にもAT&amp;T形式には<code>%</code>や<code>$</code>がつくなど，細かい違いがあります．
<a href="xxx">ここ(未執筆)</a>で詳しく説明します．</p>
<p>なお，<code>gcc</code>に<code>-S -masm=intel</code>とオプションを設定すると，
出力されるアセンブリコードをIntel形式に変更できます．</p>
<pre><code class="language-bash">$ gcc -S -masm=intel add5.c
</code></pre>
<pre><code class="language-x86asm">        .intel_syntax noprefix
        .text
        .globl  add5
        .type   add5, @function
add5:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR -4[rbp], edi
        mov     eax, DWORD PTR -4[rbp]
        add     eax, 5
        pop     rbp
        ret
        .size   add5, .-add5
</code></pre>
<p>(<code>DWORD</code>は4バイト (double word)を意味しています)</p>
</details>
<p>なお，消した行の説明を以下に書きますが，読み飛ばしてOKです．</p>
<details>
<summary>
.cfi_とは
</summary>
<p><code>.cfi</code>で始まるもの（アセンブラ命令）は call frame information を扱う命令です．
本書の範囲では不要です．詳細は<a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a>を参照下さい．</p>
</details>
<details>
<summary>
.fileと.identとは
</summary>
<p><code>.file</code>と<code>.ident</code>はコメントとほぼ同じでアセンブラは単に無視します．</p>
</details>
<details>
<summary>
.section .note.とは
</summary>
<p>以下の2つはセキュリティ上，実際には重要です（本書では消してしまいますが）．
<code>.section .note.GNU-stack,&quot;&quot;,@progbits</code>はスタック上の機械語命令を実行不可と指定しています．
<code>.section .note.gnu.property,&quot;a&quot;</code>はIntel CETというセキュリティ技術の一部である IBT (indirect branch tracking)と SHSTK (shadow stack) のための指示です．</p>
</details>
<details>
<summary>
endbr64とは
</summary>
<p><code>endbr64</code>もセキュリティ上，重要です．
間接ジャンプは脆弱性の大きな原因です．
<code>endbr64</code>はセキュリティ技術であるIntel CET技術の命令であり，
間接ジャンプ先の命令が<code>endbr64</code>以外の時は実行エラーとする，というものです．
本書の学習者としては「<code>endbr64</code>はセキュリティ上，重要だけど，アセンブリ言語を学習する立場では「<code>endbr64</code>は<code>nop</code>命令(何も実行しない命令)」と思えば十分です．</p>
</details>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>の各行の意味の<a href="2-asm-intro.html#add5.s-content">説明</a>の前に，説明の都合上，
<strong>アセンブル</strong>と<strong>アセンブラ</strong>を説明します．</p>
<h2 id="アセンブル"><a class="header" href="#アセンブル">アセンブリコードをオブジェクトファイルにアセンブルする</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>に対して，以下のコマンドを実行すると，
<code>add5.o</code>が生成されます．この処理を<strong>アセンブル</strong>(assemble)といいます．
そして，アセンブルを行うプログラム（コマンド）を
<strong>アセンブラ</strong>(assembler)と呼びます．
<code>gcc -c</code>は内部的にアセンブラ<code>as</code>を呼び出します．
<code>as</code>は本書で使用する<a href="https://sourceware.org/binutils/docs-2.40/as/index.html">GNUアセンブラ</a>のコマンド名です．</p>
<pre><code class="language-bash">$ gcc -c add5.s
$ ls
add5.c add5.o add5.s
</code></pre>
<img src="figs/assemble.svg" height="50px" id="fig:assemble">
<p>アセンブル処理は<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>とちょうど逆の関係です．</p>
<img src="figs/assemble2.svg" height="70px" id="fig:assemble2">
<p><code>add5.o</code>はバイナリファイルです．
また，<code>add5.o</code>から作成する実行可能ファイル<code>a.out</code>もバイナリファイルです．
バイナリ(の中身)については次の章，<a href="./3-binary.html">3節.バイナリ</a>で説明します．</p>
<h2 id="add5.s-content"><a class="header" href="#add5.s-content">アセンブリ言語の構成要素</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>はアセンブリ言語のプログラムであり，
<strong>アセンブリコード</strong> (assembly code)と呼びます．
アセンブリコードは以下の4つを組み合わせて書きます．</p>
<ul>
<li>機械語命令 (例：<code>pushq %rbp</code>)</li>
<li>アセンブラ命令 (例：<code>.text</code>)</li>
<li>ラベル定義 (例：<code>add5:</code>)</li>
<li>コメント (例：<code># add5.s</code>)</li>
</ul>
<p>特に<strong>機械語命令</strong>(machine instruction)と<strong>アセンブラ命令</strong>(assembler directive)
の違いに注意して下さい．</p>
<ul>
<li>
<p>機械語命令はCPUが実行する命令です．
例えば，<code>pushq %rbp</code>は機械語命令(のニモニック)です．
この<code>pushq %rbp</code>は<code>a.out</code>が実行された時に<strong>CPUが</strong>実行します．</p>
<p>アセンブラがすることは例えば
<code>add5.s</code>中の<code>pushq %rbp</code>という機械語命令のニモニックを
<code>0x55</code>という2進数(ここでは16進数表記)に変換して，<code>add5.o</code>に出力するだけです．
アセンブラは<code>pushq %rbp</code>という機械語命令を実行しません．
アセンブラにとって，<code>pushq %rbp</code>も<code>0x55</code>も両方とも単なるデータに過ぎないので
す．</p>
</li>
<li>
<p>アセンブラ命令はアセンブラが実行する命令です．
例えば，<code>.text</code>はアセンブラ命令です．
本書が使用するGNUアセンブラではドット記号<code>.</code>で始まる命令は全てアセンブラ命令です．</p>
<p><a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブラ</a>は<code>add5.s</code>から<code>add5.o</code>を出力（アセンブル）します．
そのアセンブラに対して行う指示がアセンブラ命令です．
例えば，<code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」を
アセンブラに指示しています．
アセンブラはアセンブル時に<code>.text</code>というアセンブラ命令を実行します
(CPUが<code>a.out</code>を実行するときではありません）．</p>
</li>
</ul>
<h2 id="アセンブリ言語は1行に1つが基本"><a class="header" href="#アセンブリ言語は1行に1つが基本">アセンブリ言語は1行に1つが基本</a></h2>
<p>アセンブリ言語は基本的に1行に1つだけ，
「機械語命令」「アセンブラ命令」「ラベル定義」「コメント」
のいずれかを書くのが基本です．
ただし，複数を組み合わせて1行にできる場合もあります．
以下に可能な例を示します．</p>
<ul>
<li>OK <code>add5: pushq %rbp</code>   (ラベル定義と機械語命令)</li>
<li>OK <code>pushq %rbp; movq %rsp, %rbp</code>   (機械語命令と機械語命令，セミコロン<code>;</code>で区切る)</li>
<li>OK <code>pushq %rbp  # コメント</code> (機械語命令とコメント)</li>
<li>OK <code>.text  # コメント</code> (アセンブラ命令とコメント)</li>
</ul>
<h2 id="add5s中の-add5s"><a class="header" href="#add5s中の-add5s"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code># add5.s</code></a></h2>
<p><code># add5.s</code>は<code>gcc -S</code>の出力ではなく，私が付け加えた行です．
この行は<strong>コメント</strong>です．<code>#</code>から行末までがコメントとなり，
アセンブラは単にコメントを無視します．
つまりコメントは(C言語のコメントと同じで)人間が読むためだけのものです．</p>
<h2 id="add5s中のtext"><a class="header" href="#add5s中のtext"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>.text</code></a></h2>
<p><code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」と
アセンブラに指示しています．
<a href="./3-binary.html#.text">セクション</a>でも説明しますが，
<code>add5.o</code>や<code>a.out</code>などのバイナリファイルの中身は<strong>セクション</strong>という単位で
区切られています．
アセンブラが(機械語を含む)データを2進数に変換して出力する時，
「どのセクションに出力するのか」の指定が必要となるのです．</p>
<p><code>.text</code>セクション以外には，代表的なセクションとして，
<code>.data</code>セクション，<code>.rodata</code>セクションがあります．
それぞれの役割は以下の通りです．</p>
<ul>
<li><code>.text</code>    機械語命令(例：<code>pushq %rbp</code>)を置くセクション</li>
<li><code>.data</code>    初期化済みの静的変数の値(例：<code>0x1234</code>)を置くセクション</li>
<li><code>.rodata</code>  読み込みのみ(read only)の値(例：<code>&quot;hello\n\0&quot;</code>)を置くセクション</li>
</ul>
<p>例えば，以下のアセンブリコード<code>foo.s</code>があるとします
(<code>.rodata</code>セクションを指定する際は，<code>.section</code>が必要です)．</p>
<pre><code class="language-x86asmatt"># foo.s
.text            # .textセクションに出力せよ
pushq %rbp
movq %rsp, %rbp
.data            # .dataセクションに出力せよ
.long 0x11223344
.section .rodata # .rodataセクションに出力せよ
.string &quot;hello\n\0&quot;
</code></pre>
<p>この<code>foo.s</code>をアセンブラが処理すると以下になります(以下の図を見ながら読んで下さい)．</p>
<ul>
<li><code>pushq %rbp</code>を2進数にすると <code>0x55</code>，
<code>movq %rsp, %rbp</code>を2進数にすると <code>0x48 0x89 0xe5</code> なので，
これら合計4バイトを<code>.text</code>セクションに出力します．</li>
<li><code>.data</code>は「<code>.data</code>セクションに出力せよ」
「<code>.long</code>は指定したデータを4バイトの2進数として出力せよ」という意味です．
<code>0x11223344</code>を2進数にすると <code>0x44 0x33 0x22 0x11</code>なので
これら4バイトを<code>.data</code>セクションに出力します．
(出力が逆順になっているように見えるのは
x86-64が<a href="./3-binary.html#%E3%83%AA%E3%83%88%E3%83%AB%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>だからです．)</li>
<li><code>.section .rodata</code>は「<code>.rodata</code>セクションに出力せよ」
「<code>.ascii</code>は指定した文字列をASCIIコードの2進数として出力せよ」という意味です．
<code>&quot;hello\n\0&quot;</code>を2進数にすると <code>0x68 0x65 0x6c 0x6c 0x64 0x0a 0x00</code>なので，
これら7バイトを<code>.rodata</code>セクションに出力します．
(最後の'\0'はヌル文字です．C言語では文字列定数の最後に自動的に
ヌル文字が追加されますが，アセンブリ言語では必ずしもそうではありません．
<code>.ascii</code>はヌル文字を追加しません．)
ASCIIコードは<code>man ascii</code>で確認できます．</li>
</ul>
<img src="figs/section2.svg" height="200px" id="fig:section2">
<details>
<summary>
.bssセクションは?
</summary>
<p><code>.text</code>，<code>.data</code>，<code>rodata</code>に加えて，<code>.bss</code>セクションも代表的なセクションですが，
ここでは説明を省略しました．
<a href="./3-binary.html#.bss"><code>.bss</code>セクション</a>は未初期化の静的変数の実体を格納するセクションなのですが，
ちょっと特殊だからです．
未初期化の静的変数はゼロで初期化されることになっているので，
バイナリファイル中では(サイズの情報等をのぞいて)実体は存在しません．
プログラム実行時に初めてメモリ上で<code>.bss</code>セクションの実体が確保され，
その領域はゼロで初期化されます．</p>
</details>
<h2 id="add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a class="header" href="#add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>add5:</code>，<code>.globl add5</code>，<code>.type add5, @function</code>，<code>.size add5, .-add5</code></a></h2>
<h3 id="add5はラベルの定義"><a class="header" href="#add5はラベルの定義"><code>add5:</code>はラベルの定義</a></h3>
<p><code>add5:</code>は<code>add5</code>というラベルを定義しています．
ラベルはアドレスを表しています．
もっと具体的には「ラベルは，そのラベル直後の機械語命令や値が，
メモリ上に配置された時のアドレス」になります．</p>
<p>例えば，次のアセンブリコードがあり，</p>
<pre><code class="language-x86asmatt">add5:
    pushq %rbp 
</code></pre>
<p>この<code>pushq %rbp</code>命令の2進数表現<code>0x55</code>が<code>0x1234</code>番地に置かれたとします．</p>
<img src="figs/label.svg" height="150px" id="fig:label">
<p>この時，ラベル<code>add5</code>の値は<code>0x1234</code>になります．
（ここでは話を単純化しています．ラベルの値が最終的に決まるまで，
再配置(relocation)などの処理が入ります）</p>
<h3 id="ラベルの参照"><a class="header" href="#ラベルの参照">ラベルの参照</a></h3>
<p>で，大事なラベルの使い方（参照）です．
機械語命令のニモニック中で，<strong>アドレスを書ける場所にはラベルも書ける</strong>のです．
例えば，関数をコールする命令<code>call</code>命令で<code>add5</code>関数を呼び出す時，
以下の2行はどちらも同じ意味になります．
ラベル<code>add5</code>の値は<code>0x1234</code>になるからです．
（ここでも話を単純化しています．関数や変数のアドレスは
絶対アドレスではなく，相対アドレスなどが使われることがあるからです）．</p>
<pre><code class="language-x86asmatt">    call 0x1234
    call add5    
</code></pre>
<p>どちらの書き方でも，アセンブラのアセンブル結果は同じになります．
（もちろん通常はラベルを使います．具体的なアドレスを使って
アセンブリコードを書くのは人間にとってはつらいからです）．</p>
<h3 id="記号表がラベルを管理する"><a class="header" href="#記号表がラベルを管理する">記号表がラベルを管理する</a></h3>
<p>アセンブラはラベルのアドレスが何番地になるかを管理するために，
アセンブル時に<strong>記号表</strong>(symbol table)を作ります．
記号表中の情報は割と単純で，主に以下の6つです．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレス</th><th>配置される<br/>セクション</th><th>グローバル<br/>か否か</th><th>型</th><th>サイズ</th><th>ラベル名<br/>(シンボル名)</th></tr></thead><tbody>
<tr><td><code>0x1234</code></td><td><code>.text</code></td><td>グローバル</td><td>関数</td><td>15</td><td><code>add5</code></td></tr>
</tbody></table>
</div>
<p>ここで，<a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>のラベル<code>add5</code>が</p>
<ul>
<li>配置されるセクションが<code>.text</code>なのは，ラベルの定義<code>add5:</code>の前に<code>.text</code>が指定されているから</li>
<li>グローバルなのは，<code>.globl add5</code>と指定されているから</li>
<li>関数という型なのは，<code>.type add5, @function</code>と指定されているから</li>
<li>サイズが15バイトなのは，<code>.size  add5, .-add5</code>と指定されているから
(サイズ15バイトは<code>.-add5</code>から自動計算されます)</li>
</ul>
<p>です．
ここでグローバルの意味は，C言語のグローバル関数やグローバル変数と(ほぼ)同じです．
グローバルなシンボルは他のファイルからも参照できます．</p>
<details>
<summary>
ラベル or シンボル？
</summary>
<p>アセンブラが扱うシンボルのうち，アドレスを表すシンボルのことをラベルと呼んでいます．
シンボルはアドレス以外の値も保持できます．
つまりシンボルの一部がラベルであり，<code>add5</code>は関数<code>add5</code>の先頭アドレスを表すシンボルなのでラベルです．</p>
</details>
<details>
<summary>
.-add5 とは
</summary>
<p><code>.-add5</code>はアドレスの引き算をしています．<code>.</code>は特別なラベルで「この行のアドレス」を意味します．<code>add5</code>は<code>add5:</code>のアドレスを意味します．
ですので，<code>.-add5</code>は「最後の<code>ret</code>命令の次のアドレスから，
最初の<code>pushq %rbp</code>命令のアドレスを引いた値」になります．
つまり引き算の結果は「関数<code>add5</code>中の機械語命令の合計サイズ（単位はバイト）」です．</p>
</details>
<p><a href="./3-binary.html#nm"><code>nm</code>コマンド</a>を使うと記号表の中身を表示できます．</p>
<pre><code class="language-bash">$ nm ./a.out |egrep add5
0000000000001234 T add5
</code></pre>
<p>大文字<code>T</code>は「<code>.text</code>中のグローバルシンボル」であることを意味しています．
（小文字<code>t</code>だと「<code>.text</code>中のグローバルではないシンボル」という意味になります）．
この<code>nm</code>の出力では「<code>add5</code>が関数」という情報とサイズが表示できていません．
<code>readelf</code>コマンドを使うと，関数であることとサイズが❶15バイトであることを表示できます．</p>
<pre><code class="language-bash">$ readelf -s ./a.out | egrep add5
     1: 0000000000001234    ❶15 FUNC    GLOBAL DEFAULT    1 add5
</code></pre>
<details>
<summary>
readelfコマンドとは
</summary>
<p><code>objdump</code>は汎用のコマンド（ELFバイナリ以外のバイナリにも使える）ため，
<a href="./3-binary.html#ELF">ELF</a>特有の情報を表示できないことがあります．
ELF専用のコマンドである<code>readelf</code>を使えば，ELF特有の情報も表示できます．
例えば，以下では<code>readelf</code>を使って記号表(❶<code>.symtab</code>)のセクションがあることを確認できました．</p>
<pre><code class="language-bash">$ readelf -S add5.o セクションヘッダを表示
There are 12 section headers, starting at offset 0x258:
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000013  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
（中略）↓これが記号表 (symbol table)
  [ 9]❶.symtab           SYMTAB           0000000000000000  000000d8
       00000000000000f0  0000000000000018          10     9     8
</code></pre>
</details>
<h2 id="stack-frame"><a class="header" href="#stack-frame"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>pushq %rbp</code>，<code>movq  %rsp, %rbp</code>，<code>popq  %rbp</code></a></h2>
<h3 id="movq-rsp-rbp"><a class="header" href="#movq-rsp-rbp"><code>movq %rsp, %rbp</code></a></h3>
<p><code>%rsp</code>と<code>%rbp</code>はどちらも<strong>レジスタ</strong>です．
(GNUアセンブラではレジスタの名前の先頭に必ず<code>%</code>が付きます)．
レジスタはCPU内の高速なメモリです．CPUはメモリにアクセスするよりも，
はるかに高速にレジスタにアクセスできます．
<code>%rsp</code>と<code>%rbp</code>はどちらも8バイト長のデータを格納できます．</p>
<p><code>movq %rsp, %rbp</code>という機械語命令は
「<code>%rsp</code>レジスタの値を<code>%rsp</code>にコピーする」という命令です．
<code>movq</code>のmovは「move (移動)」，qは「処理するサイズが8バイト」であることを意味しています．</p>
<details>
<summary>
なぜqが8バイト?
</summary>
<p>qはクアッドワード(quad word)の略だからです．
以下の通り，クワッドワードは「ワード2バイトの4個分」なので8バイトになります．</p>
<ul>
<li><strong>ワード</strong>(word)は<strong>バイト</strong>(byte)と同様に情報量の単位ですが，
ワードが何バイトかはCPUごとに異なります．
x86-64ではワードは2バイトです．
x86の元祖であるIntel 8086が16ビットCPUだったことに由来します．</li>
<li><strong>クアッド</strong>(quad)は4を意味します．
例えば，quadrupleは「4倍の」，quad bikeは「4輪バイク」を意味します．</li>
</ul>
</details>
<p>仮に<code>movq %rsp, %rbp</code>を実行する前に，
<code>%rsp</code>の値が<code>0x11223344</code>，<code>%rbp</code>の値が<code>0x55667788</code>とします．
<code>movq %rsp, %rbp</code>を実行すると，
<code>%rsp</code>の値が<code>%rbp</code>にコピーされるので，
<code>%rsp</code>の値も<code>%rbp</code>の値も<code>0x11223344</code>になります．
要するに，<code>movq</code>命令はC言語の代入文と同じです．</p>
<img src="figs/rsp-rbp.svg" height="150px" id="fig:rsp-rbp">
<h3 id="push-rbp-pop-rbp"><a class="header" href="#push-rbp-pop-rbp"><code>pushq %rbp</code>と<code>popq  %rbp</code></a></h3>
<p><code>pushq %rbp</code>は「スタックに<code>%rbp</code>の値を<strong>プッシュ</strong>する」機械語命令です．
以下の図のように，<code>%rbp</code>中の値をスタックの一番上にコピーします．
スタックはコピー先の部分を含めて上に成長します（赤枠の部分がスタック全体）．</p>
<img src="figs/push-rbp.svg" height="200px" id="fig:push-rbp">
<p><code>popq %rbp</code>は「スタックから<strong>ポップ</strong>した値を<code>%rbp</code>に格納する」という機械語命令です．
以下の図のように，スタックの一番上の値を<code>%rbp</code>にコピーします．
スタックはコピー元の部分だけ下に縮みます（赤枠の部分がスタック全体）．</p>
<img src="figs/pop-rbp.svg" height="200px" id="fig:pop-rbp">
<p>これだけだと，<code>pushq %rbp</code>や<code>popq %rbp</code>の役割がよく分かりませんね．
実はこの2つの命令は以下で説明する<strong>スタックフレーム</strong>の処理に関係しています．</p>
<h3 id="データ構造としてのスタック"><a class="header" href="#データ構造としてのスタック">データ構造としてのスタック</a></h3>
<p><strong>スタック</strong>(stack)は超基本的なデータ構造であり，
以下の図の通り，<strong>プッシュ操作</strong>と<strong>ポップ操作</strong>でデータの格納と取り出しを行います．</p>
<ul>
<li>プッシュはスタックの一番上にデータを格納します</li>
<li>ポップはスタックの一番上からデータを取り出します</li>
</ul>
<img src="figs/stack.svg" height="200px" id="fig:stack">
<p>最後に格納したデータが，取り出す時は先に取り出されるので，
<strong>後入れ先出し方式</strong>(LIFO: last in first out)とも呼ばれます．</p>
<p>スタックは関数呼び出しの実装に便利なデータ構造です．
関数呼び出しからリターンするときは，呼び出された順番とは逆順にリターンするからです．</p>
<details>
<summary>
キューqueueは?
</summary>
<p>ちなみに超基本的なデータ構造として<strong>キュー</strong>(queue)も重要です．
こちらは先に格納したデータが，先に取り出されるので
<strong>先入れ先出し方式</strong>(FIFO: first in first out)になります．</p>
</details>
<h3 id="スタックとスタックフレーム"><a class="header" href="#スタックとスタックフレーム">スタックとスタックフレーム</a></h3>
<p><strong>スタック</strong>とはプロセス（実行中のプログラム）が使用するメモリの領域の1つです．
ここでのスタックは関数呼び出しのためのスタックなので，
<strong>コールスタック</strong>(call stack)と呼ぶのが正式名称なのですが，
慣習に習って本書でも単にスタックと呼びます．</p>
<img src="figs/memory-layout.svg" height="300px" id="fig:memory-layout">
<p>関数を呼び出すと，<strong>スタックフレーム</strong>というデータがスタックに追加(プッシュ)されて，
スタックは上に成長します．その関数からリターンすると，
そのスタックフレームはスタックから削除(ポップ)されて縮みます．
スタックフレームは<strong>関数呼び出し1回分のデータ</strong>で，
局所変数，引数，返り値，戻り番地(リターンアドレス)，退避したレジスタの値などを含みます．</p>
<p>例えば，<code>main</code>関数が<code>add5</code>関数を呼び出して，<code>add5</code>からリターンすると以下の図になります．</p>
<img src="figs/stack-frame.svg" height="200px" id="fig:stack-frame">
<h3 id="stack-rsp-rbp"><a class="header" href="#stack-rsp-rbp"><code>%rsp</code>と<code>%rbp</code>は一番上のスタックフレームの上下を指す</a></h3>
<p>さて，ここでようやく<code>%rsp</code>レジスタと<code>%rbp</code>レジスタの出番です．
実は<code>%rsp</code>と<code>%rbp</code>は以下の図のように，
<strong>スタック上の一番上のスタックフレームの上下</strong>を指す役割を担っています．</p>
<img src="figs/stack-frame2.svg" height="200px" id="fig:stack-frame2">
<p>「レジスタがスタックを指す」というのは具体的に以下の図の状態です．
つまり，
スタックフレームの一番上のアドレス(例えば<code>0x11223344</code>)が
<code>%rsp</code>に入っていて，<code>%rsp</code>の値をそのアドレスとして使う意図がある場合，
「<code>%rsp</code>はスタックフレームの一番上を指す」と言い，
<a href="2-asm-intro.html#fig:stack-frame2">上の図</a>のように矢印で図表現します．
(<code>%rbp</code>も同様です)</p>
<img src="figs/stack-frame3.svg" height="170px" id="fig:stack-frame3">
<h3 id="stack-frame4"><a class="header" href="#stack-frame4"><code>%rsp</code>は常にスタックの一番上を指す</a></h3>
<p><code>pushq</code>命令で
プッシュすると<code>%rsp</code>はプッシュしたデータの一番上を指すようにずれるので，
<code>%rsp</code>は常にスタックの一番上(スタックトップ)を指します．
また，<code>%rbp</code>をプッシュしたので下図のように
プッシュした値もスタックフレームの一番下を指しています．</p>
<img src="figs/push-rbp-2.svg" height="120px" id="fig:push-rbp-2">
<p>同様に<code>popq</code>命令でポップした時はポップで取り出したデータ分だけ
<code>%rsp</code>が指す先は下にずれて，やはり<code>%rsp</code>はスタックトップを指します．
下図では保存した<code>%rbp</code>の値をポップして<code>%rbp</code>に格納したので，
この時だけ「ひとつ下のスタックフレームの一番下」を<code>%rbp</code>は指しています
(が，通常，この直後にリターンして一番上のスタックフレームは破棄されます．
ですので，すぐに「<code>%rsp</code>と<code>%rbp</code>は常に一番上のスタックフレームの上下を指す」
という状態に戻ります．)</p>
<img src="figs/pop-rbp-2.svg" height="150px" id="fig:pop-rbp-2">
<h3 id="create-new-stack-frame"><a class="header" href="#create-new-stack-frame"><code>pushq %rbp</code> と <code>movq %rsp, %rbp</code> は新しいスタックフレームを作る</a></h3>
<p>関数を呼び出すと，その関数のための新しくスタックフレームを作る必要があります．
誰が作るのかというと「呼び出された関数自身」が作ります(これはABI(xxx)が定める事項です)．</p>
<p>ここでは関数<code>main</code>が関数<code>add5</code>を<code>call</code>命令で呼び出すとして説明します．</p>
<pre><code class="language-x86asmatt">main:
   ...
   call add5
</code></pre>
<pre><code class="language-x86asmatt">add5:
   pushq %rbp
   movq %rsp, %rbp
</code></pre>
<p>これらの命令を実行した時のスタックの様子は以下の図のとおりです．
(「<code>call</code>前」等のボタンを押して，図を切り替えて下さい)</p>
<form class="tab-wrap">
    <input id="stack-frame4-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame4-1"><code>call</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-1.svg" height="150px" id="fig:stack-frame4-1">
    </div>
    <input id="stack-frame4-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-2"><code>call</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-2.svg" height="150px" id="fig:stack-frame4-2">
    </div>
    <input id="stack-frame4-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-3"><code>push %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-3.svg" height="150px" id="fig:stack-frame4-3">
    </div>
    <input id="stack-frame4-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-4"><code>movq %rsp, %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
    </div>
</form>
<p>一つずつ説明していきます．</p>
<ul>
<li><code>call</code>命令実行前は<code>main</code>関数が一番上のスタックフレームです．
その上下を<code>%rsp</code>と<code>%rbp</code>が指しています．</li>
<li><code>call</code>命令を実行して<code>add5</code>関数に実行を移す際に，
<code>call</code>命令はスタック上に<strong>戻り番地</strong>(リターンアドレス)をプッシュします．
戻り番地とは「関数からリターンした時にどのアドレスに実行を戻せばよいか」
　を表す番地です．この場合では<code>call add5</code>命令の次のアドレスが戻り番地になります．</li>
<li><code>push %rbp</code>命令を実行すると，今の<code>%rbp</code>レジスタの値をスタック上にプッシュします．
<a href="2-asm-intro.html#push-rbp-2">上</a>の説明と見比べて下さい．
新しいスタックフレームを作る際に，<code>%rbp</code>に新しい値を設定する必要があるために，
今の<code>%rbp</code>の値をスタック上に退避（保存）するため，<code>pushq %rbp</code>が必要となります．</li>
<li>次に <code>movq %rsp, %rbp</code> を実行します．
実は<code>add5</code>のスタックフレームはとても小さくて「古い<code>%rbp</code>」しか入っていません．
ですので，<code>%rsp</code>の値を<code>%rbp</code>にコピーすれば，
「<code>add5</code>のスタックフレームの上下を<code>%rsp</code>と<code>%rsp</code>が指している」という状態にできます．
この動作も<a href="2-asm-intro.html#movq-rsp-rbp">上</a>で説明したので見比べて下さい．</li>
</ul>
<p>以上で，<code>add5</code>のための新しいスタックフレームを作れました．</p>
<h3 id="popq-rbpは今のスタックフレームを捨てる"><a class="header" href="#popq-rbpは今のスタックフレームを捨てる"><code>popq %rbp</code>は今のスタックフレームを捨てる</a></h3>
<p>これは<a href="2-asm-intro.html#create-new-stack-frame">前節</a>での説明のちょうど逆になります．</p>
<pre><code class="language-x86asmatt">popq %rbp
ret
</code></pre>
<p>を実行すると，スタックフレームは以下の図になります．</p>
<form class="tab-wrap">
    <input id="stack-frame5-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="stack-frame5-1"><code>popq %rbp</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-1.svg" height="150px" id="fig:stack-frame5-1">
    </div>
    <input id="stack-frame5-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-2"><code>popq %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-2.svg" height="150px" id="fig:stack-frame5-2">
    </div>
    <input id="stack-frame5-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-3"><code>ret</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-3.svg" height="150px" id="fig:stack-frame5-3">
    </div>
</form>
<ul>
<li>
<p><code>popq %rbp</code>の実行前は，スタックトップ付近はこの図の状態になっています．
(コンパイラがこの図の状態になるようにアセンブリコードを出力します．
自分でアセンブリコードを書く場合は，この図の状態になるように正しくプログラムする必要があります)
「この図の状態」をもう少し説明すると以下になります．</p>
<ul>
<li>スタックトップには <strong>古い<code>%rbp</code></strong> が格納されていて，
その <strong>古い<code>%rbp</code></strong> は1つ前のスタックフレームの一番下を指している．</li>
<li>スタックトップのひとつ下には<strong>戻り番地</strong>が格納されている．</li>
<li>さらにその下には<code>add5</code>を呼び出した関数(ここでは<code>main</code>)のスタックフレームがある．</li>
</ul>
</li>
<li>
<p><code>popq %rbp</code>を実行すると，<code>%rbp</code>は<code>main</code>関数のスタックフレームの一番下を
指すようになります．(<a href="2-asm-intro.html#push-rbp-pop-rbp">上の説明</a>と合わせて読んで下さい．)
また，ポップの結果，<code>%rsp</code>が指す先が下にずれて，戻り番地を指すように変わりました．</p>
</li>
<li>
<p><code>ret</code>命令はスタックトップから戻り番地をポップして，次に実行する命令を戻り番地に設定します．スタックの状態は<code>add5</code>を呼び出す前の状態に戻りました．</p>
</li>
</ul>
<details>
<summary>
「この図の状態」の例外
</summary>
<div  id="-fomit-frame-pointer">
<p><a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にならないことがあります．
<code>-fomit-frame-pointer</code>というオプション付きでコンパイルすると，
<code>%rbp</code>は「スタックフレームの一番下を指すポインタ(ベースポインタ)」として
使うのではなく，汎用レジスタ(好きな目的のために使えるレジスタ)として使われます．
このため，関数からリターンする直前に<a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にはなりません．
<code>-O2</code>などの最適化オプションを指定すると，
<code>-fomit-frame-pointer</code>も有効になることが多いです．</p>
</div>
</details>
<details>
<summary>
全てのスタックフレームは「古い`%rbp`」で数珠つなぎ
</summary>
<p>実は下の図のように全てのスタックフレームは「古い<code>%rbp</code>」で数珠つなぎ，
つまり<strong>線形リスト</strong>(linked list)になっています</p>
<img src="figs/stack-frame-list.svg" height="300px" id="fig:stack-frame-list">
</details>
<details>
<summary>
戻り番地とプログラムカウンタ
</summary>
<p>一般的にCPUは<strong>プログラムカウンタ</strong>と呼ばれる特別な役割を持つレジスタを備えています．
x86-64では<code>%rip</code>レジスタがプログラムカウンタです．
<code>ret</code>命令はスタックをポップして取り出した戻り番地を
プログラムカウンタ<code>%rip</code>に格納することで，「関数からリターンする」という
動作を実現しています．</p>
</details>
<h2 id="add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a class="header" href="#add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の <code>movl  %edi, -4(%rbp)</code>， <code>movl  -4(%rbp), %eax</code>， <code>addl  $5, %eax</code></a></h2>
<p>ここでは以下の3命令を説明します．
直感的にはこの3命令で「<code>n + 5</code>」を計算しています．</p>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
  addl  $5, %eax
</code></pre>
<ul>
<li>
<p>まず<code>-4(%rbp)</code>を説明します．
これは「<code>%rbp</code>中のアドレスから4を引いた数」をアドレスとしてメモリを
読み書きすることを意味しています．以下の図はスタックをより正確に描いています．</p>
<ul>
<li>メモリは1バイトごとにアドレスが付いています．
古い<code>%rbp</code>や戻り番地のデータはそれぞれ8バイトなので，
アドレス8つ分(つまり8バイト)の場所を占めています．</li>
<li>多バイト長のデータはそのデータが占めている<strong>先頭のアドレス</strong>を使って
メモリを読み書きします．(本書の図ではメモリの0番地が常に上にあることを思い出してください)．
ですので，1バイトごとのアドレスで考えると，<code>%rbp</code>はスタックフレームの
一番下を指していません．</li>
<li>そして，<code>-4(%rbp)</code>は「<code>%rbp</code>から4を引いたアドレス」ですので，
以下の図で<code>-4(%rbp)</code>が指している場所を指しています．</li>
</ul>
</li>
</ul>
<img src="figs/stack-layout.svg" height="400px" id="fig:stack-layout">
<ul>
<li>
<p>次に<code>%edi</code>と<code>%eax</code>について説明します．</p>
<ul>
<li>以下の図のようにx86-64には8バイト長の<code>%rdi</code>と<code>%rax</code>という
汎用レジスタがあります(他にも汎用レジスタはありますがここでは割愛)．
その右半分にそれぞれ<code>%edi</code>と<code>%eax</code>という名前が付いています．
<code>%edi</code>と<code>%eax</code>は4バイト長です．</li>
<li><code>%rdi</code>レジスタは関数呼び出しでは<strong>第1引数</strong>を渡すために使われます．
<code>add5</code>の第1引数<code>n</code>は<code>int</code>型で，この場合は4バイト長だったため，
<code>%edi</code>に<code>n</code>の値が入っています．</li>
<li><code>%rax</code>レジスタは関数呼び出しでは<strong>返り値</strong>を返すために使われます．
<code>add5</code>の返り値の方が<code>int</code>型なので，<code>%eax</code>に値を入れてから
関数をリターンすれば，返り値が返せることになります．</li>
</ul>
</li>
</ul>
<img src="figs/edi-eax.svg" height="300px" id="fig:edi-eax">
<ul>
<li>次に以下の2つの命令を説明します．</li>
</ul>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
</code></pre>
<ul>
<li><code>movl</code>の<code>l</code>は4バイトのデータをコピーすることを表しています．ですので，
例えば，<code>movl  %edi, -4(%rbp)</code>は<code>%edi</code>中の4バイトデータを
先頭アドレスが<code>-4(%rbp)</code>から4バイト分の領域
(<a href="2-asm-intro.html#fig:stack-layout">この図</a>で一番上の赤い部分)
にコピーする命令になります．</li>
</ul>
<details>
<summary>
なぜl(エル)が4バイト
</summary>
<p>l(エル)はlongの略で，GNUアセンブラでは以下の通り，longが4バイトを意味するからです．
Intelマニュアルなどでは4バイトのことをdouble wordと呼びます．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>short</td><td>long</td><td>quad</td></tr>
<tr><td>Intelマニュアル</td><td>word</td><td>double word</td><td>quad word</td></tr>
</tbody></table>
</div></details>
<ul>
<li>
<p>この2つの命令で「<code>%edi</code>中の4バイトを<code>-4(%rbp)</code>にコピー」して，次に
「<code>-4(%rbp)</code>中の4バイトを<code>%eax</code>にコピー」しています．
「<code>%edi</code>から<code>%eax</code>に直接コピーすればいいんじゃね?」と思った方，正解です．
実はこの場合は(<code>-4(%rbp)</code>に格納しても使われないので)不要なのですが，
コンパイラは
「引数<code>n</code>の実体の場所を<code>-4(%rbp)</code>としたので，
<code>-4(%rbp)</code>にも<code>n</code>の値を格納する」という判断をしたようです．</p>
</li>
<li>
<p><code>addl  $5, %eax</code>命令を説明します．</p>
<ul>
<li>この命令は<code>%eax</code>の値と定数<code>5</code>の値を足し算した結果を<code>%eax</code>に格納します．</li>
<li>つまり，<code>n + 5</code>の結果がこの命令の実行後に<code>%eax</code>に入ります．</li>
<li>GNUアセンブラでは定数の先頭にはドルマーク<code>$</code>が付きます．
ただし，<code>-4(%rbp)</code>の<code>-4</code>など，ドルマークが付かないこともあります．</li>
</ul>
</li>
</ul>
<p>以上で<code>add5.s</code>の説明が終わりました(お疲れ様でした)．</p>
</details>
<details>
<summary>
即値とは
</summary>
<p>上で<code>$5</code>は定数と説明しましたが，アセンブラ用語では
<strong>即値</strong>(immediate value)と呼びます．
それは機械語命令の2進数の中に
即値の値が埋め込まれており，即座に(つまりメモリやレジスタにアクセスすることなく)
値を取り出せることに由来しています．
x86-64のマニュアルなどで <em>imm32</em> などが出てきます．<em>imm32</em>は「32ビット長の即値」を意味しています．</p>
</details>
</details>
<details>
<summary>
%rspより上のメモリ領域に勝手に書き込んで良いのか(レッドゾーン)
</summary>
<div id="redzone">
LinuxのABI [System V ABI](https://wiki.osdev.org/System_V_ABI)ではOKです．
LinuxのABIでは`%rsp`レジスタの上，128バイトの領域を**レッドゾーン**と呼び，
この領域には好きに読み書きして良いことになっています．
(ABIが「割り込みハンドラやシグナルハンドラが実行されても，
レッドゾーンの値は破壊されない」ことを保証しています．）
もちろん，自分自身で関数を呼び出すとレッドゾーン中の値は壊れるので，
レッドゾーンは**葉関数**(leaf function)，つまり関数を呼び出さない関数
が使うのが一般的です．
レッドゾーンのおかげで，`%rsp`をずらさずにメモリの読み書きができるので，
その分だけ実行が高速になります．
<img src="figs/redzone.svg" height="300px" id="fig:redzone">
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 3; }
</style>
<h1 id="バイナリファイル"><a class="header" href="#バイナリファイル">バイナリファイル</a></h1>
<h2 id="バイナリファイルの中身を見る"><a class="header" href="#バイナリファイルの中身を見る">バイナリファイルの中身を見る</a></h2>
<h3 id="hexdump"><a class="header" href="#hexdump">16進ダンプ</a></h3>
<p><code>add5.c</code>や<code>add5.s</code>はテキストファイルですが，
<a href="./2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">2節のアセンブリ言語</a>で作成した
<code>add5.o</code>はバイナリファイルです．
バイナリファイルなので，<code>less</code>コマンドでは中身を読めません．</p>
<pre><code class="language-bash">$ less add5.o
^?❶ELF^B^A^A^@^@^@^@^@^@^@^@^@^A^@&gt;^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@X^B
^@^@^@^@^@^@^@^@^@^@@^@^@^@^@^@@^@^L^@^K^@&lt;F3&gt;^O^^&lt;FA&gt;UH&lt;89&gt;&lt;E5&gt;&lt;89&gt;}&lt;FC&gt;&lt;8B&gt;E
（長いので省略）
</code></pre>
<details id="ELF">
<summary>
❶ELFとは
</summary>
<p>上の<code>less</code>コマンドの結果にELFという文字が見える理由を説明します．
ELFはLinuxが採用している<strong>バイナリ形式</strong>(binary format)です．
このELFのバイナリファイルの先頭4バイトには<strong>マジックナンバー</strong>という
バイナリファイルを識別する特別な数値が入っています．
ELFバイナリのマジックナンバーは <code>7F 45 4C 46</code>です．
<code>45 4C 46</code>はASCII文字で <code>E L F</code> なので，lessコマンドが<code>ELF</code>と表示したわけです． </p>
</details>
<p>バイナリファイルの中身を読むには例えば<code>od</code>コマンドを使います．</p>
<pre><code class="language-bash">$ od -t x1 add5.o
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00
（長いので省略）
</code></pre>
<p>一番左の数字が「先頭からのバイト数(16進表記)」，
その右側に並んでいるのが「1バイトごとに16進表記したファイルの中身」です．
（1バイトのデータは2桁の16進数で表せることを思い出しましょう．
例えば，<code>add5.o</code>の中身の先頭4バイトの値は<code>7F 45 4C 46</code>です）．</p>
<p><code>-t x1</code>というオプションは「1バイトごとに16進数で表示せよ」という意味です．
このような出力を<strong>16進ダンプ</strong>(hex dump)と言います．
他に16進ダンプするコマンドとして，<code>xxd</code>や<code>hexdump</code>などがあります．</p>
<p>ちなみに，<code>add5.c</code>はテキストファイルですが，内容は2進数で保存されて
いますので，<code>od</code>コマンドで中身を表示できます．</p>
<pre><code class="language-bash">$ od -t x1 add5.c
0000000 69 6e 74 20 61 64 64 35 20 28 69 6e 74 20 6e 29
0000020 0a 7b 0a 20 20 20 20 72 65 74 75 72 6e 20 6e 20
0000040 2b 20 35 3b 0a 7d 0a
0000047
</code></pre>
<p>先頭の<code>69</code>はASCII文字<code>i</code>の文字コード，
同様に，次の<code>6e</code>は文字<code>n</code>，その次の<code>74</code>は文字<code>t</code>なので，
<code>add5.c</code>の先頭3文字が<code>int</code>であることを確認できます．
ASCIIコード表は<code>man ascii</code>コマンドで閲覧できます．</p>
<details>
<summary>
manコマンドとは
</summary>
<p><code>man</code>コマンドはLinux上でマニュアルを表示するコマンドです．</p>
<p>例えば<code>man ascii</code>を実行すると以下のように表示されます．</p>
<pre><code class="language-bash">$ man ascii

ASCII(7)                   Linux Programmer's Manual                  ASCII(7)

NAME
       ascii - ASCII character set encoded in octal， decimal， and hexadecimal

DESCRIPTION
       ASCII is the American Standard Code for Information Interchange.  It is
       a 7-bit code.  Many 8-bit codes (e.g.， ISO  8859-1)  contain  ASCII  as
       their  lower  half.  The international counterpart of ASCII is known as
       ISO 646-IRV.

       The following table contains the 128 ASCII characters.

       C program '\X' escapes are noted.

       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
       ────────────────────────────────────────────────────────────────────────
       000   0     00    NUL '\0' (null character)   100   64    40    @
       001   1     01    SOH (start of heading)      101   65    41    A
       002   2     02    STX (start of text)         102   66    42    B
（以下略）
</code></pre>
<p>デフォルトでは<code>less</code>コマンドで1ページずつ表示されるので，
スペースキーで次のページが，<code>b</code>を押せば前のページが表示されます．
終了するには<code>q</code>を押します．<code>h</code>を押せばヘルプを表示し，<code>/</code>で検索もできます．
例えば，<code>/backspace</code>と入力してリターンを押すと，<code>backspace</code>を検索してくれます．</p>
<p><code>man</code>コマンドは章ごとに分かれています．例えば</p>
<ul>
<li>1章はコマンド (例：<code>ls</code>)</li>
<li>2章はシステムコール (例：<code>open</code>)</li>
<li>3章はライブラリ関数 (例：<code>printf</code>)</li>
</ul>
<p>となっています．
<code>printf</code>というコマンドがあるので，
<code>man printf</code>とすると（ライブラリ関数ではなく）コマンドの<code>printf</code>の
マニュアルが表示されてしまいます．
ライブラリ関数の<code>printf</code>を見たい場合は
<code>man 3 printf</code>と章番号も指定します．</p>
</details>
<p>なお，<code>od</code>コマンドに<code>-c</code>オプションをつけると，
(文字として表示可能なバイトは)文字が表示されます．</p>
<pre><code class="language-bash">$ od -t x1 -c add5.c
0000000  69  6e  74  20  61  64  64  35  20  28  69  6e  74  20  6e  29
          i   n   t       a   d   d   5       (   i   n   t       n   )
0000020  0a  7b  0a  20  20  20  20  72  65  74  75  72  6e  20  6e  20
         \n   {  \n                   r   e   t   u   r   n       n    
0000040  2b  20  35  3b  0a  7d  0a
          +       5   ;  \n   }  \n
0000047
</code></pre>
<h3 id="everything-binary"><a class="header" href="#everything-binary">コンピュータの中のデータはすべて<code>0</code>と<code>1</code>から成る</a></h3>
<p>ここで大事なことを復習しましょう．
それは
<strong>「コンピュータの中のデータは，どんな種類のデータであっても，
機械語命令であっても，すべて<code>0</code>と<code>1</code>だけで表現されている」</strong>
ということです．
ですので，テキストはバイナリでもあるのです．</p>
<ul>
<li>テキスト=文字として表示可能な2進数だけを含むデータ</li>
<li>バイナリ=文字以外の2進数も含んだデータ</li>
</ul>
<img src="figs/text-binary.svg" height="100px" id="fig:text-binary">
<blockquote>
<p>注意：
本書で，テキスト(text)という言葉には2種類の意味があることに注意して下さい．</p>
<ul>
<li>1つは「文字」を意味します．例：「テキストファイル」（文字が入ったファイル）</li>
<li>もう1つは「機械語命令列」を意味します．例：「<a href="3-binary.html#.text">テキストセクション</a>」（機械語命令列が格納されるセクション）</li>
</ul>
</blockquote>
<h3 id="2進数と符号化"><a class="header" href="#2進数と符号化">2進数と符号化</a></h3>
<p><a href="3-binary.html#everything-binary">前節</a>で説明した通り，
コンピュータ中では全てのものを0と1の2進数で表現する必要があります．
そのため，データの種類ごとに2進数での表現方法，つまり<strong>符号化</strong>
(encoding)の方法が定められています．
例えば，</p>
<ul>
<li>文字<code>U</code>をASCII文字として符号化すると，<code>01010101</code>になります．</li>
<li><code>pushq %rbp</code>をx86-64の機械語命令として符号化すると，<code>01010101</code>になります．</li>
</ul>
<p>おや，どちらも同じ<code>01010101</code>になってしまいました．
この2進数が<code>P</code>なのか<code>pushq %rbp</code>なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．</p>
<img src="figs/encode.svg" height="130px" id="fig:encode">
<p>別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する<a href="3-binary.html#.text"><code>.text</code>セクション</a>にある
2進数のデータ列は「<code>.text</code>セクションに存在するから」という理由で
機械語命令として解釈されます．</p>
<h3 id="fileコマンド"><a class="header" href="#fileコマンド"><code>file</code>コマンド</a></h3>
<p><a href="3-binary.html#hexdump">16進ダンプ</a>以外の方法で，<code>add5.o</code>の中身を見てみます．
まずは<code>file</code>コマンドです．</p>
<pre><code class="language-bash">$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable， x86-64， ❹version 1 (SYSV)， ❺not stripped
</code></pre>
<p>これで，<code>add5.o</code>が64ビットの❶ELFバイナリであることが分かりました．</p>
<details id="LSB">
<summary>
❷LSBとは
</summary>
<p>多バイト長のデータをバイト単位で格納する順序を<strong>バイトオーダ</strong>(byte order)といいます．
LSBは最下位バイトから順に格納するバイトオーダ (Least Significant Byte first)，
つまりリトルエンディアンを意味しています．
多バイト長データで最下位のバイトをLeast Significant Byte (<strong>LSB</strong>)，
最上位のバイトをMost Significant Byte (<strong>MSB</strong>)と呼びます．
例えば，<code>0x11223344</code>という4バイトのデータのLSBは<code>0x44</code>，MSBは<code>0x11</code>です．
多バイト長データをメモリに格納する時，</p>
<ul>
<li>LSBから先にメモリに格納する方法を<div style="display:inline-block" id="リトルエンディアン"><strong>リトルエンディアン</div></strong> (little endian)</li>
<li>MSBから先にメモリに格納する方法を<strong>ビッグエンディアン</strong> (big endian)
と呼びます．</li>
</ul>
<img src="figs/endian.svg" height="150px" id="fig:endian">
<p>x86-64のバイトオーダがリトルエンディアンのため，ELFバイナリもリトルエンディアンになっています．
リトルエンディアンでの注意は16進ダンプする時に，多バイト長データが逆順に表示されることです．
以下で多バイト長データ❶<code>0x11223344</code>を<code>.text</code>セクションに配置してアセンブルした
<code>little.o</code>を逆アセンブルすると，❸<code>44 33 22 11</code>と逆順に表示されています．
(<code>objdump -h</code>の出力から，<code>.text</code>セクションのオフセット(ファイルの先頭からのバイト数)が❷0x40バイトであることを使って，<code>od</code>コマンドに<code>-j0x40</code>オプションを使い，<code>.text</code>セクションの先頭付近の情報を表示しています)</p>
<pre><code class="language-bash">$ cat little.s
.text
❶.long 0x11223344
$ gcc -c little.s
$ objdump -h little.o
foo.o:     file format elf64-x86-64
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000004  0000000000000000  0000000000000000 ❷00000040  2**0
                  CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000044  2**0
                  CONTENTS， ALLOC， LOAD， DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0
                  ALLOC
$ od -t x1 -j0x40 little.o | head -n1
0000100 ❸44 33 22 11 00 00 00 00 00 00 00 00 00 00 00 00
</code></pre>
<details>
 <summary>
 エンディアンの由来とは
 </summary>
<p><strong>エンディアン</strong>(endian)という言葉はガリバー旅行記から来ています．
お話の中で，卵の殻は尖った方からむくべき派 (little endian)と
丸い方からむくべき派 (big endian)が争うのです．なのでインディアンとは何の関係もありません．</p>
</details>
</details>
<!--
これは嘘でしたｗ
LSBはLinuxの標準である[Linux Standard Base](https://refspecs.linuxfoundation.org/lsb.shtml)の略です．LSBはELFバイナリの規格であるSystem V ABIを含んでいます．
ABIはapplication binary interfaceの略です．
-->
<details>
<summary>
❸relocatableとは
</summary>
<p>バイナリ中のアドレスを再配置 (relocate)できるバイナリのことをrelocatableであるといいます．オブジェクトファイルはリンク時や実行時にアドレスを変更できるよう，
relocatableであることが多いです．</p>
</details>
<details>
<summary>
❹version 1 (SYSV)とは
</summary>
<p>LinuxのABI（バイナリ互換規約）である<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>
に準拠していることを表しています．</p>
</details>
<details>
<summary>
❺not strippedとは
</summary>
<p>バイナリには実行に直接関係ない<strong>記号表</strong>や<strong>デバッグ情報</strong>などが
含まれていることがよくあります．
この「実行に直接関係ない情報」が削除されたバイナリのことを
stripped binaryと呼びます．
<code>strip</code>コマンドで「実行に直接関係ない情報」を削除できます．
削除された分，サイズが少し減っています．</p>
<pre><code class="language-bash">$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 1368 Jul 19 10:09 add5.o
$ strip add5.o
$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 880 Jul 19 14:58 add5.o
</code></pre>
</details>
<p>なお，<code>file</code>コマンドはバイナリ以外のファイルにも使えます．</p>
<pre><code class="language-bash">$ file add5.c
add5.c: ASCII text
$ file add5.s
add5.s: assembler source， ASCII text
$ file .
.:  directory
$ file /dev/null
/dev/null: character special (1/3)
</code></pre>
<h3 id=".text"><a class="header" href="#.text">セクションと<code>objdump -h</code>コマンド</a></h3>
<p>バイナリファイルの構造はざっくり以下の図のようになっています．</p>
<img src="figs/section.svg" height="250px" id="fig:text-binary">
<ul>
<li>最初のヘッダ以外の四角を<strong>セクション</strong>(section)と呼びます．</li>
<li>バイナリはセクションという単位で区切られていて，それぞれ別の目的でデータが格納されます．</li>
<li>ヘッダは目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．</li>
</ul>
<p>ヘッダの情報は<code>objdump -h</code>で表示できます．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
(以下略)
</code></pre>
<p>ここでは「<code>.text</code>，<code>.data</code>，<code>.bss</code>という3つのセクションがある」ことを
見ればOKです．</p>
<details>
<summary>
VMAとLMAとは
</summary>
<p>VMAはvirtual memory addressの略で「このセクションがメモリ上で実行される時のメモリアドレス」です．一方，LMAはload memory addressの略で「このセクションをメモリ上に配置する時のメモリアドレス」です．
通常，セクションをメモリに配置した後で，移動せずにそのまま実行するため，VMAとLMAは同じアドレスになります．
<code>add5.o</code>ではアドレスが決まってないので，VMAもLMAもゼロになっています．</p>
</details>
<details>
<summary>
File offとは
</summary>
<p>File offはファイルオフセットを表しています．このセクションがバイナリファイルの先頭から何バイト目から始まっているかを16進表記で表しています．</p>
</details>
<details>
<summary>
Algnとは
</summary>
<p>Algnは<strong>アラインメント</strong>(alignment)を表しています．
例えば「このセクションをメモリ上に配置する時，その先頭アドレスが8の倍数になるようにしてほしい」という状況の時，この部分が<code>2**3</code>となります（2の3乗=8）．</p>
</details>
<details>
<summary>
CONTENTS， ALLOC， LOAD， READONLY， CODEとは
</summary>
<p>これらはセクションフラグと呼ばれるセクションの属性値です．</p>
<ul>
<li>CONTENTS  このセクションには中身がある（つまり中身が空のセクションもある）</li>
<li>ALLOC     ロード時にこのセクションのためにメモリを割り当てる必要がある</li>
<li>LOAD      このセクションは実行するためにメモリ上にロードする必要がある</li>
<li>READONLY  メモリ上では「読み込みのみ許可（書き込み禁止）」と設定する必要がある</li>
<li>CODE      このセクションは実行可能な機械語命令を含んでいる</li>
</ul>
</details>
<br/>
<div id=".bss">
3つのセクション `.text`，`.data`，`.bss` の役割は以下の通りです：
<ul>
<li><code>.text</code>セクションは機械語命令を格納します．例えば，<code>pushq %rbp</code>を表す<code>0x55</code>は<code>.text</code>セクションに格納されます．</li>
<li><code>.data</code>セクションは初期化済みの静的変数の値を格納します．例えば，大域変数<code>int x=999;</code>があったとき，999の2進数表現が<code>.data</code>セクションに格納されます．</li>
<li><code>.bss</code>セクションは未初期化の静的変数の値を格納します．例えば，大域変数<code>int y;</code>があったとき，（概念的には）初期値0の2進数表現が<code>.bss</code>セクションに格納されます．</li>
</ul>
</div>
<details>
<summary>
なぜ概念的
</summary>
<p>実はファイル中では<code>.bss</code>セクションにはサイズ情報などごくわずかの情報しか持っていません．実行時にメモリ上に<code>.bss</code>セクションを作る際に，実際に必要なメモリを確保して，そのメモリ領域をすべてゼロで初期化すれば十分だからです（ファイル中に大量のゼロの並びを保持する必要はありません）．</p>
</details>
<p>さらに代表的なセクションである<code>.rodata</code>も説明します．</p>
<ul>
<li><code>.rodata</code>セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数<code>&quot;hello&quot;</code>は書き込み禁止なので，<code>&quot;hello&quot;</code>の2進数表現が<code>.rodata</code>セクションに格納されます．</li>
</ul>
<p>バイナリファイルには上記以外のセクションも数多く使われますが，
まずはこの基本の4種類 (<code>.text</code>， <code>.data</code>， <code>.bss</code>， <code>.rodata</code>) を覚えましょう．</p>
<h3 id="nm"><a class="header" href="#nm">記号表の中身を表示させる(<code>nm</code>コマンド)</a></h3>
<p>バイナリファイル中には<strong>記号表</strong>(symbol table)があることが多いです．
記号表とは「変数名や関数名がバイナリ中では何番地のアドレスになっているか」という情報です．
<code>nm</code>コマンドでバイナリファイル中の記号表を表示できます．
まず，以下の<code>foo.c</code>を準備して下さい．</p>
<pre><code>// foo.c
int g1 = 999;
int g2;
int s1 = 888;
int s2;
int main ()
{
    static int s3 = 777;
    static int s4;
    int ❼i1 = 666;
    int ❼i2;
}
</code></pre>
<p>そしてコンパイルして，<code>nm</code>コマンドで記号表の中身を表示させます．</p>
<pre><code class="language-bash">$ gcc -c foo.c
$ nm foo.o
0000000000000000 ❶D g1
0000000000000000 ❸B g2
0000000000000000 ❺T main
0000000000000004 ❶D s1
0000000000000004 ❸B s2
0000000000000008 ❷d ❻s3.0
0000000000000008 ❹b ❻s4.1
</code></pre>
<p>この出力の読み方は以下の通りです．</p>
<ul>
<li>❶<code>D</code>と❷<code>d</code>は<code>.data</code>セクションのシンボル，❸<code>B</code>と❹<code>b</code>は<code>.bss</code>セクションのシンボル，❺<code>T</code>と<code>t</code>は<code>.text</code>セクションのシンボルであることを表す</li>
<li>大文字はグローバル（ファイルをまたがって有効なシンボル），小文字はファイルローカルなシンボルであることを表す</li>
<li><code>static</code>付きの局所変数を表すシンボルは同名のシンボルと区別するために，
❻<code>.0</code>や<code>.1</code>などが付加されることがある．</li>
<li>左側の<code>00</code>，<code>04</code>，<code>08</code>がシンボルに対応するアドレスですが，再配置前(relocation前)なので仮のアドレス(各セクションの先頭からのオフセット)</li>
<li>(<code>static</code>のついてない)局所変数❼は記号表には含まれていない．</li>
</ul>
<h3 id="ASLR-PIE"><a class="header" href="#ASLR-PIE">ASLRとPIE（ちょっと脱線）</a></h3>
<p>オブジェクトファイルのセクションごとの仮のアドレスは，
リンク後の<code>a.out</code>では具体的なアドレスになります</p>
<pre><code class="language-bash">$ gcc foo.c
$ nm ./a.out | egrep g1
0000000000004010 D g1
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000001129 T main
</code></pre>
<details>
<summary>
U __libc_start_main@@GLIBC_2.34とは
</summary>
<p>バイナリ中で参照されているけど定義がないシンボルがあると，
<code>nm</code>コマンドはundefinedを意味する<code>U</code>を表示します．
実は<code>a.out</code>は<code>main</code>関数を呼び出す前に<code>__libc_start_main</code>という
GLIBC中の関数を(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>した上で)呼び出します．
<code>__libc_start_main</code>は
様々な初期化を行った後，<code>main</code>関数を呼び出すのが主な役割です．</p>
</details>
<p>出力が長くなるので，<code>g1</code>と<code>main</code>のアドレスだけ載せています．
<code>g1</code>のアドレスは<code>4010</code>番地，<code>main</code>のアドレスは<code>1129</code>番地となりました．
ただし，このまま実行すると，<code>g1</code>や<code>main</code>のアドレスはこれらのアドレスにはならず，
実行するたびに変わります．
これは<strong>ASLR</strong>や<strong>PIE</strong>というセキュリティ対策機能のためです．</p>
<p>確かめてみましょう．
以下の<code>foo2.c</code>を普通にコンパイルして実行してみます．</p>
<pre><code class="language-C">// foo2.c
#include &lt;stdio.h&gt;
int g1 = 999;
int main ()
{
    printf (&quot;%p， %p\n&quot;， &amp;g1， main);
}
</code></pre>
<p>以下の通り，<code>g1</code>や<code>main</code>のアドレスは実行するたびに変わりますし，
<code>nm</code>が出力したアドレスとも異なります．</p>
<pre><code class="language-bash">$ gcc foo.c
$ ./a.out
0x557f2361e010， 0x557f2361b149
$ ./a.out
0x55a40e6f5010， 0x55a40e6f2149
$ ./a.out
0x562750663010， 0x562750660149
$ 
</code></pre>
<p>ここではASLRとPIEの機能を無効にして，アドレスが変わらなくなることを確認します．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
$ gcc -no-pie foo2.c
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000401136 T main
$ nm ./a.out | egrep g1
0000000000404030 D g1
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
</code></pre>
<p>ASLRとPIEの機能をオフにすることで，アドレスが変わらなくなり，
かつ<code>nm</code>が出力するアドレスと同じになることが確認できました．</p>
<blockquote>
<p>注意：
不用意なASLRとPIEの無効化はセキュリティ機能を下げるので避けるべきです．
しかしデバッグ作業ではアドレスが変わらなくなるので
ASLRとPIEの無効化が有用な場合もあります．
なお，デバッガ中ではASLRは無効化されていることが多いです．</p>
</blockquote>
<details>
<summary>
ASLRとは
</summary>
<p>ASLR (address space layout randomizationの略)は，
アドレス空間の配置をランダム化する機能です．
テキスト（実行コード），ライブラリ，スタック，ヒープなどをメモリ上に
配置するアドレスを実行するたびにランダムに変化させます．
以下を実行するとASLRは無効化され，</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
</code></pre>
<p>以下を実行するとASLRは有効化されます．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=1
</code></pre>
</details>
<details id="PIE">
<summary>
PIEとは
</summary>
<p>PIE (position independent executableの略)は位置独立実行可能ファイルを意味します．
通常，動的ライブラリは位置独立コードPIC (position independent code)としてコンパイルされます．
動的ライブラリはメモリ上で共有されるため，どのアドレスに配置してもそのまま再配置せずに，実行したいからです．
PIEは動的ライブラリだけでなく，<code>a.out</code>も位置独立にした実行可能ファイルを指します．
<code>-no-pie</code>オプションでコンパイルすると，PIEを無効化できます．</p>
<pre><code class="language-bash">$ gcc -no-pie foo2.c
</code></pre>
</details>
<h2 id="逆アセンブル再び"><a class="header" href="#逆アセンブル再び">逆アセンブル再び</a></h2>
<p><a href="./2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>で説明した通り，
<code>objdump -d ./a.out</code>で逆アセンブル結果が表示されます（再掲）．</p>
<pre><code class="language-bash">$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
</code></pre>
<p><code>objdump</code>コマンドは<code>add5.o</code>の<code>.text</code>セクションを抽出し，
そのデータを機械語命令として解釈して，対応するニモニックを出力しています．</p>
<p>この出力によれば，<code>.text</code>セクションの先頭4バイトは<code>F3 0F 1E FA</code>で，
この4バイトが<code>endbr64</code>命令になります
（x86-64の命令長は可変長で，1バイト〜15バイトです）．</p>
<p>以下では<code>.text</code>セクションの先頭4バイトが<code>F3 0F 1E FA</code>であることを確認します．</p>
<p>セクションのヘッダを出力するコマンド<a href="3-binary.html#.text"><code>objdump -h</code></a>の出力を再掲します．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
</code></pre>
<p><code>.text</code>セクションの<code>File off</code>の欄を見ると<code>00000040</code>とあります．
これは<code>.text</code>セクションが<code>add5.o</code>の先頭から16進数で40バイト
目（以後，0x40と表記します）にあることを意味しています．</p>
<p><code>od</code>コマンドの<code>-j</code>オプションを使うと，指定したバイト数だけ，
先頭をスキップしてくれます．
この<code>-j</code>オプションを使って，0x40バイトスキップして，
<code>.text</code>セクションの最初だけを16進ダンプします
（<code>head -n3</code>は先頭の3行だけ表示します）．</p>
<pre><code class="language-bash">$ od -t x1 -j0x40 add5.o | head -n3
0000100 ❶f3 0f 1e fa 55 48 89 e5 89 7d fc 8b 45 fc 83 c0
0000120   05 5d c3 00 47 43 43 3a 20 28 55 62 75 6e 74 75
0000140   20 39 2e 34 2e 30 2d 31 75 62 75 6e 74 75 31 7e
</code></pre>
<p>この結果❶を見ると，<code>.text</code>セクションの最初の4バイトは
<code>F3 0F 1E FA</code>であることが分かります．
これは上の<a href="3-binary.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB%E5%86%8D%E3%81%B3">逆アセンブルの結果</a>の先頭4バイトと一致しており，
<code>endbr64</code>命令が，<code>add5.o</code>の先頭から0x40バイト目に存在することが分かりました．</p>
<h2 id="広義のコンパイル"><a class="header" href="#広義のコンパイル">広義のコンパイルとリンク</a></h2>
<p>ここでは広義のコンパイル，つまりCのプログラム<code>foo.c</code>から
実行可能ファイル<code>a.out</code>を生成する処理の中身を見ていきます．
いちばん大事なのは最後の<strong>リンク</strong>(link)です．</p>
<img src="figs/compile-all.svg" height="300px" id="fig:compile-all">
<ul>
<li>❶ Cの前処理，すなわち<code>#include</code>や<code>#define</code>などの前処理命令の処理と，マクロ（例えば<code>&lt;stdio.h&gt;</code>が定義する<code>NULL</code>や<code>EOF</code>）の展開を行います．<code>gcc -E</code>コマンドで実行できますが，内部的にはカッコ内の<code>cpp</code>や<code>cc1</code>コマンドが実行されています（現在は<code>cc1</code>）．</li>
<li>❷ 狭義のコンパイル処理で，Cのプログラムをアセンブリコードに変換します．</li>
<li>❸ アセンブラ(<code>as</code>コマンド)によるアセンブル処理で，オブジェクトファイル<code>foo.o</code>を生成します．<code>foo.o</code>中にはバイナリの機械語命令が入っています．</li>
<li>❹ <code>foo.o</code>だけでは実行可能ファイルは作れません．例えば，<code>printf</code>などのライブラリ関数の実体は，
<code>libc.a</code>(<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">静的ライブラリ</a>)や<code>libc.so</code>(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">動的ライブラリ</a>)の中にあるからです．
また，<code>main</code>関数を呼び出すためのCスタートアップルーチン(多くの場合，<code>crt*.o</code>というファイル名)も必要です．
また，分割コンパイルの機能を使った結果，<code>foo.o</code>は他のC言語のプログラムをアセンブルしたオブジェクトファイル<code>*.o</code>が必要なことがよくあります．
「このような他のバイナリと<code>foo.o</code>を合体させて<code>a.out</code>を生成する処理」のことを<strong>リンク</strong>(link)と呼びます．</li>
</ul>
<p>広義のコンパイルで具体的にどのような処理が行われてるのかを見るには，
<code>-v</code>をつけて<code>gcc -v</code>とコンパイルすれば表示されます．
（以下では表示を省略しています．全てを表示するには<i class="fa fa-eye"></i>ボタンを押して下さい）．</p>
<pre><code class="language-bash">$ gcc -v main.c add5.s |&amp; tee out
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
<span class="boring"> Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.3.0-1ubuntu1~22.04.1' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c，ada，c++，go，brig，d，fortran，objc，obj-c++，m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32，m64，mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-nvptx/usr，amdgcn-amdhsa=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
</span><span class="boring"> Thread model: posix
</span><span class="boring"> Supported LTO compression algorithms: zlib zstd
</span><span class="boring"> gcc version 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04.1) 
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpdir a- -dumpbase main.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include-fixed&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/../../../../x86_64-linux-gnu/include&quot;
</span><span class="boring"> #include &quot;...&quot; search starts here:
</span><span class="boring"> #include &lt;...&gt; search starts here:
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/include
</span><span class="boring">  /usr/local/include
</span><span class="boring">  /usr/include/x86_64-linux-gnu
</span><span class="boring">  /usr/include
</span><span class="boring"> End of search list.
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> Compiler executable checksum: e13e2dc98bfa673227c4000e476a9388
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/cc5o7Jgg.o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/ccUs2R16.o add5.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/
</span><span class="boring"> LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../:/lib/:/usr/lib/
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgnuv0i.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/cc5o7Jgg.o /tmp/ccUs2R16.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/11/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span></code></pre>
<h2 id="バイナリファイルの種類"><a class="header" href="#バイナリファイルの種類">バイナリファイルの種類</a></h2>
<p>実行可能ファイル<code>a.out</code>に関連するバイナリファイルには
以下の4種類があります：</p>
<ul>
<li>オブジェクトファイル(<code>*.o</code>)</li>
<li>実行可能ファイル(<code>a.out</code>)</li>
<li>静的ライブラリファイル(<code>lib*.a</code>)</li>
<li>動的ライブラリファイル(<code>lib*so</code>)</li>
</ul>
<h3 id="オブジェクトファイル"><a class="header" href="#オブジェクトファイル">オブジェクトファイル(<code>*.o</code>)</a></h3>
<p><strong>オブジェクトファイル</strong>とはLinuxでファイル名の拡張子が<code>.o</code>なファイルです．
オブジェクトファイルは機械語命令を含んでいますが，
このオブジェクトファイル単体では実行することができません．
実行を可能にするには<a href="3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB"><strong>リンク</strong></a>(link)処理を経て，
<a href="3-binary.html#%E5%AE%9F%E8%A1%8C%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB"><strong>実行可能ファイル</strong></a>
を作成する必要があります．</p>
<p>オブジェクトファイルは<strong>再配置可能オブジェクトファイル</strong>
(relocatable object file)と呼ばれることもあります．
オブジェクトファイルはリンク時に再配置（アドレス調整）が可能だからです．</p>
<h3 id="実行可能ファイル"><a class="header" href="#実行可能ファイル">実行可能ファイル(<code>a.out</code>)</a></h3>
<p><strong>実行可能ファイル</strong>(executable file)はその名前の通り，OSに実行を依頼すればそのままで実行できるバイナリファイルのことです．
例えば，hello wordの実行可能ファイル<code>a.out</code>はシェル上で以下のように実行できます．</p>
<pre><code class="language-bash">$ ./a.out
hello， world
</code></pre>
<p><code>ls</code>などのシェル上で実行可能なコマンドも実行可能ファイルです．</p>
<pre><code class="language-bash">$ which ls
/usr/bin/ls
$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， ❶interpreter /lib64/ld-linux-x86-64.so.2， ❷BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd， for GNU/Linux 3.2.0， stripped
$ ls
a.out add5.c add5.o add5.s
</code></pre>
<p id="interpreter">
<details>
<summary>
❶interpreterとは
</summary>
<p>ELFバイナリの動的リンカのことを（なぜか）interpreterと呼びます．
プログラミング言語処理系のインタプリタとは何の関係もありません．
ELFバイナリでは動的リンカのフルパスを指定することができ，バイナリに埋め込みます．
この場合は <code>/lib64/ld-linux-x86-64.so.2</code> が埋め込まれています．
OSが<code>a.out</code>を実行する際に，
OSはまず動的リンカ(interpreter)をメモリにロードして，
ロードした動的リンカに制御を渡します．
動的リンカは<code>a.out</code>中の他の部分や，動的ライブラリをメモリにロードし，
動的リンクを行ってから，<code>a.out</code>の<strong>エントリポイント</strong>
(最初に実行を開始するアドレス)にジャンプします．
その後，いくつかの初期化を行ってから，<code>main</code>関数が呼び出されます．</p>
<p><code>a.out</code>のエントリポイントは<code>readelf -h</code>コマンドで確認できます．
エントリポイントは<code>0x401050</code>番地でした❶．</p>
<pre><code class="language-bash">$ readelf -h ./a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement， little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
❶Entry point address:               0x401050
  Start of program headers:          64 (bytes into file)
  Start of section headers:          16832 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         36
  Section header string table index: 35
</code></pre>
<p>逆アセンブルすると<code>0x401050</code>番地は<code>_start</code>という関数がありました❷．
<code>a.out</code>は<code>_start</code>関数から実行が始まることが分かりました．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep 401050 -A 5
0000000000401050 ❷ &lt;_start&gt;:
  401050:	f3 0f 1e fa          	endbr64 
  401054:	31 ed                	xor    %ebp，%ebp
  401056:	49 89 d1             	mov    %rdx，%r9
  401059:	5e                   	pop    %rsi
  40105a:	48 89 e2             	mov    %rsp，%rdx
  40105d:	48 83 e4 f0          	and    $0xfffffffffffffff0，%rsp
</code></pre>
</details>
</p>
<details>
<summary>
❷BuildID[sha1]とは
</summary>
<p>BuildIDはバイナリファイルが同じかどうかを識別するユニークな番号（背番号）です．
ここでは<code>2f15</code>で始まる40桁の16進数が <code>/usr/bin/ls</code>のBuildIDです．
BuildIDはLinux ELF特有の機能です．
<code>strip</code>してもBuildIDは変化しないので，<code>strip</code>前後のファイルが同じかの確認に使えます．</p>
<pre><code class="language-bash">$ gcc hello.c
$ cp a.out a.out.stripped
$ strip a.out.stripped
$ file a.out a.out.stripped
a.out:          ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
a.out.stripped: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， stripped
</code></pre>
<p>ここでは説明しませんが<strong>コアファイル</strong>(core file)にもBuildIDが入っており，
そのコアファイルを出力した<code>a.out</code>を探すことができます．</p>
<p>ちなみにsha1はSHA-1を意味しており，SHA-1は160ビットのハッシュを生成するハッシュ関数です．
<code>git</code>のハッシュにはSHA-1が使われています．
<code>sha1sum</code>コマンドでSHA-1のハッシュを計算できます．</p>
<pre><code class="language-bash">$ sha1sum ./a.out
ff99525ad6a48d78d35d3108401af935a6ca9bbe  ./a.out
</code></pre>
<p>この結果から分かる通り，BuildIDのハッシュは，単純に<code>a.out</code>から作ったハッシュ値ではありません．
ELFバイナリのヘッダとセクションの一部からハッシュを計算しているようですが，正確な情報は見つかりませんでした．</p>
</details>
<p>実行可能なコマンドには実行可能ファイルではなく，
スクリプトなことがあります．</p>
<pre><code class="language-bash">$ which shasum
/usr/bin/shasum
$ file /usr/bin/shasum
/usr/bin/shasum: Perl script text executable
$ head -3 /usr/bin/shasum
#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+&quot;$@&quot;}'
	if 0; # ^ Run only under a shell
</code></pre>
<p><code>shasum</code>コマンドは(実行可能ファイルではなく)Perlスクリプトでした．</p>
<h3 id="静的ライブラリ"><a class="header" href="#静的ライブラリ">静的ライブラリ(<code>lib*.a</code>)</a></h3>
<p><strong>静的ライブラリ</strong>(static library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
するときに使われるライブラリです．
<strong>ライブラリ</strong>とは複数のオブジェクトファイルを１つのファイルにまとめたもの（<strong>アーカイブ</strong>）です．</p>
<p>LinuxなどのUNIX系のOSでは静的ライブラリのファイル拡張子は<code>.a</code>が多いです．
またWindowsでは<code>.lib</code>です．
<code>printf</code>の実体が入っているC標準ライブラリの
静的ライブラリのファイル名は<code>libc.a</code>です．</p>
<h3 id="動的ライブラリ"><a class="header" href="#動的ライブラリ">動的ライブラリ(<code>lib*.so</code>)</a></h3>
<p><strong>動的ライブラリ</strong>(dynamic library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>動的リンク</strong></a>
するときに使われるライブラリです．
動的ライブラリは<strong>共有ライブラリ</strong>(shared library)とも呼ばれます．
動的ライブラリは複数のプロセスからメモリ上で共有されるからです．</p>
<p>Linuxでは動的ライブラリのファイル拡張子は<code>.so</code>です(shared objectの略)．
処理系の都合でファイル拡張子に数字がつくことがあります（例：<code>.so.6</code>）．
動的ライブラリのファイル拡張子はUnix系のOSでも様々です．
Windowsでは<code>.dll</code>です．</p>
<h2 id="静的リンクと動的リンク"><a class="header" href="#静的リンクと動的リンク">静的リンクと動的リンク</a></h2>
<p>静的ライブラリは静的リンクに使われるライブラリで，
動的ライブラリは動的リンクに使われるライブラリです．</p>
<h3 id="静的リンク"><a class="header" href="#静的リンク">静的リンク</a></h3>
<p><strong>静的リンク</strong>とは<strong>コンパイル時</strong>にリンクを行う手法です．
仕組みは単純ですが，ファイルやメモリの使用量が増える欠点があります．
<a href="3-binary.html#fig:compile-all">この図</a>で説明したリンクは実は静的リンクでした．</p>
<p>静的リンクしたファイル<code>a.out</code>はリンク済みなので，
ライブラリ関数(例えば<code>printf</code>)の実体も<code>a.out</code>の中に入っています．</p>
<img src="figs/static-link-printf.svg" height="200px" id="fig:static-link-printf">
<p><code>a.out</code>ごとに<code>printf</code>のコピーが作られるので，
ファイルの使用量が無駄に増えてしまいます．
また<code>a.out</code>中の<code>printf</code>は実行時にもメモリ上で<strong>共有されない</strong>ので，
メモリの使用量も無駄に増えてしまいます．</p>
<h3 id="静的リンクでコンパイルしてみる"><a class="header" href="#静的リンクでコンパイルしてみる">静的リンクでコンパイルしてみる</a></h3>
<pre><code class="language-C">// hello.c
#include &lt;stdio.h&gt;
int main (int ac， char **ag)
{
    printf (&quot;hello (%d)\n&quot;， ac);
}
</code></pre>
<p>静的リンクするには<code>-static</code>オプションをつけます（<code>-static</code>無しだと動的リンクになります）．
<code>printf</code>に第2引数を与えているのは，こうしないと，コンパイラが勝手に
<code>printf</code>の呼び出しを<code>puts</code>に変更してしまうからです．</p>
<p><code>a.out</code>を<code>file</code>コマンドで確認すると<code>statically linked</code>とあり❶，
静的リンクできたことが分かります．</p>
<pre><code class="language-bash">$ gcc -static hello.c
$ file ./a.out
./a.out: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， ❶statically linked， BuildID[sha1]=40fe6c0daaf2d49fabad4d37bc34fcdd12cb8da9， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<details>
<summary>
練習問題：静的にリンクした`a.out`中に`printf`の実体があることを確認せよ
</summary>
<p><code>a.out</code>を逆アセンブルし，❶<code>&lt;main&gt;:</code>を含む行から15行を表示させます．
(❷<code>-A 14</code>は「マッチした行の後ろ14行も表示する」というオプションです)．
<code>main</code>関数は(<code>printf</code>ではなく)❸<code>_IO_printf</code>を呼び出していることを確認できます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep ❷-A 14 ❶&quot;&lt;main&gt;:&quot;
0000000000401cb5 &lt;main&gt;:
  401cb5:	f3 0f 1e fa          	endbr64 
  401cb9:	55                   	push   %rbp
  401cba:	48 89 e5             	mov    %rsp，%rbp
  401cbd:	48 83 ec 10          	sub    $0x10，%rsp
  401cc1:	89 7d fc             	mov    %edi，-0x4(%rbp)
  401cc4:	48 89 75 f0          	mov    %rsi，-0x10(%rbp)
  401cc8:	8b 45 fc             	mov    -0x4(%rbp)，%eax
  401ccb:	89 c6                	mov    %eax，%esi
  401ccd:	48 8d 3d 30 33 09 00 	lea    0x93330(%rip)，%rdi        # 495004 &lt;_IO_stdin_used+0x4&gt;
  401cd4:	b8 00 00 00 00       	mov    $0x0，%eax
  401cd9:	e8 72 ec 00 00       	callq  410950 ❸&lt;_IO_printf&gt;
  401cde:	b8 00 00 00 00       	mov    $0x0，%eax
  401ce3:	c9                   	leaveq 
  401ce4:	c3                   	retq   
</code></pre>
<blockquote>
<p>注：ここでは<code>egrep -A 14</code>としてますが，皆さんが試す時は，</p>
<pre><code class="language-bash">$ objdump -d ./a.out | less
</code></pre>
<p>としてから，<code>/&lt;main&gt;:</code>とリターンを入力して検索する方が便利でしょう．</p>
</blockquote>
<p>次に同じく<code>a.out</code>を逆アセンブルし，`&lt;_IO_printf&gt;:'を含む行から数行を表示させます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;_IO_printf&gt;:&quot;
0000000000410950 &lt;_IO_printf&gt;:
  410950:	f3 0f 1e fa          	endbr64 
  410954:	48 81 ec d8 00 00 00 	sub    $0xd8，%rsp
  41095b:	49 89 fa             	mov    %rdi，%r10
  41095e:	48 89 74 24 28       	mov    %rsi，0x28(%rsp)
  410963:	48 89 54 24 30       	mov    %rdx，0x30(%rsp)
</code></pre>
<p>これは<code>_IO_printf</code>の定義なので，<code>a.out</code>に<code>printf</code>の実体があることを確認できました．
なお，以下の<code>nm</code>コマンドでも，<code>a.out</code>に<code>printf</code>の実体があることを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep _IO_printf
0000000000410950 T _IO_printf
</code></pre>
<p>実は<code>_IO_printf</code>も<code>printf</code>も実体は同じです．処理系の都合で，
「実体は同じだけど別の名前をつける」ことがあり，それをエイリアス（別名）といいます．
0x410950番地で調べると，これを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 410950
0000000000410950 T _IO_printf
0000000000410950 T __printf
0000000000410950 T printf
</code></pre>
</details>
<h3 id="動的リンク"><a class="header" href="#動的リンク">動的リンク</a></h3>
<p><strong>動的リンク</strong>とは実行を始める際の<strong>ロード時</strong>（<code>a.out</code>をメモリにコピーする時）
あるいは<strong>実行途中</strong>にメモリ上でリンクを行う手法です．
現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．</p>
<p>動的リンクしたファイル<code>a.out</code>には
「ライブラリ関数(例えば<code>printf</code>)とのリンクが必要だよ」という
小さな参照情報だけが入っており，<code>printf</code>の実体は入っていません．
実際のリンクは実行時にメモリ上で行います．</p>
<img src="figs/dynamic-link-printf.svg" height="200px" id="fig:dynamic-link-printf">
<p><code>a.out</code>には<code>printf</code>を含まないので，ファイルの使用量を抑えられます．
また<code>a.out</code>中の<code>printf</code>は実行時にはメモリ上で<strong>共有される</strong>ので，
メモリの使用量も抑えられます．</p>
<p>ファイルサイズを比較してみると，静的リンクした<code>a.out-static</code>は約870KB，
動的リンクした<code>a.out-dynamic</code>は約17KBで，50倍ものサイズ差がありました．</p>
<pre><code class="language-bash">$ gcc -static -o a.out-static hello.c
$ gcc -o a.out-dynamic hello.c
$ ls -l a.out*
-rwxrwxr-x 1 gondow gondow  16696 Jul 20 17:52 a.out-dynamic
-rwxrwxr-x 1 gondow gondow 871832 Jul 20 17:51 a.out-static
</code></pre>
<h3 id="動的リンクでコンパイルしてみる"><a class="header" href="#動的リンクでコンパイルしてみる">動的リンクでコンパイルしてみる</a></h3>
<p>Linuxでは<code>-static</code>オプションをつけなければ動的リンクになります．</p>
<pre><code class="language-bash">$ gcc hello.c
$ file a.out
a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<p>実行時にリンクが必要な動的ライブラリの情報は<code>ldd</code>コマンドで表示できます．</p>
<pre><code class="language-bash">$ ldd ./a.out
	❶linux-vdso.so.1 (0x00007ffd21638000)
	❷libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcfef5c1000)
	❸/lib64/ld-linux-x86-64.so.2 (0x00007fcfef7d8000)

</code></pre>
<p>この<code>a.out</code>は<code>linux-vsdo.so.1</code>，<code>libc.so.6</code>，<code>ld-linux-x86-64.so.2</code>という
3つの動的ライブラリと実行時にリンクする必要があることを表示しています．
<code>libc.so.6</code>は（<code>LD_LIBRARY_PATH</code>などの設定がなければ）
絶対パス<code>/lib/x86_64-linux-gnu/libc.so.6</code>とリンクされます．</p>
<details>
<summary>
❶linux-vdso.so.1とは
</summary>
<p>vDSO (virtual dynamic shared objectの略)で，カーネル空間で実行する必要が無い
システムコール(例えば<code>gettimeofday</code>)を高速に実行するための仕組みです．</p>
<ul>
<li><a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></li>
</ul>
</details>
<details>
<summary>
❷libc.so.6とは
</summary>
<p>C標準ライブラリが入った動的ライブラリです．
<code>nm -D</code>コマンドで調べると，<code>printf</code>の実体が入っていることが分かります．
(<code>-D</code>は共有ライブラリで使われる動的シンボルを表示させるオプションです）</p>
<pre><code class="language-bash">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | egrep ' T printf'
0000000000061c90 T printf
0000000000061100 T printf_size
0000000000061bb0 T printf_size_info
</code></pre>
<p><code>-D</code>オプションをつけないと「❶シンボルが無いよ」と言われてしまいます．
(動的シンボル以外は<code>strip</code>されているからです)</p>
<pre><code class="language-bash">$ nm /lib/x86_64-linux-gnu/libc.so.6
nm: /lib/x86_64-linux-gnu/libc.so.6: ❶no symbols
</code></pre>
</details>
<details>
<summary>
❸ld-linux-x86-64.so.2とは
</summary>
<p>動的リンクを行うプログラム（共有ライブラリ），つまり動的リンカです．
<a href="3-binary.html#interpreter">interpreterとは</a>も参照下さい．</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man ld-linux.so</a></li>
</ul>
</details>
<details>
<summary>
練習問題：動的にリンクした`a.out`中に`printf`の実体が無いことを確認せよ
</summary>
<p><code>nm</code>コマンドで<code>a.out</code>には<code>main</code>を始めごく少数の
関数しか定義しておらず，その中に<code>printf</code>は入っていないことが以下で確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep ' T '
00000000000011f8 T _fini
00000000000011f0 T __libc_csu_fini
0000000000001180 T __libc_csu_init
0000000000001149 T main
0000000000001060 T _start
</code></pre>
<p>また<code>nm</code>の出力を<code>printf</code>で検索すると，GLIBC中の<code>printf</code>への参照はあるが
<code>a.out</code>中では未定義(<code>U</code>)となっていることが分かります．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 'printf'
                 U printf@@GLIBC_2.34
</code></pre>
<div  id="GOT-PLT">
なお逆アセンブルすると`<printf@plt>`という小さな関数が見つかりますが，
これは`printf`の実体ではありません．
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;printf&quot;
0000000000001050 &lt;printf@plt&gt;:
    1050:	f3 0f 1e fa          	endbr64 
    1054:	f2 ff 25 75 2f 00 00 	bnd jmpq ❶*0x2f75(%rip)        # 3fd0 &lt;printf@GLIBC_2.34&gt;
    105b:	0f 1f 44 00 00       	nopl   0x0(%rax，%rax，1)
</code></pre>
<p><code>&lt;printf@plt&gt;</code>は<code>printf</code>を呼び出す単なる踏み台で，
PLT (procedure linkage table)という仕組みです．
PLTは<code>printf</code>の最初の呼び出しまで<code>printf</code>の<strong>アドレス解決</strong>
(address resolution)を遅延します．具体的には次の2ステップになります．</p>
<ul>
<li><code>printf@plt</code>の間接ジャンプ先❶の初期値は「動的リンクする関数（動的リンカ）」になっているため，最初に<code>printf@plt</code>が呼ばれると，動的リンクを行い，その結果，間接ジャンプ先が「<code>printf</code>の実体」に変更されます❷．
そして動的リンカは何もなかったかのように<code>printf</code>を呼び出します．
（ちなみに<code>printf@plt</code>の間接ジャンプで参照するメモリ領域は GOT (global offset table)と呼ばれます）</li>
<li>その結果，2回目以降の以下の間接ジャンプ❶では<code>printf</code>が呼ばれます．</li>
</ul>
<p>つまり，GOTに<code>printf</code>のアドレスを格納することが，ここではアドレス解決になっています．</p>
<img src="figs/plt-printf.svg" height="400px" id="fig:plt-printf">
</div>
</details>
<h3 id="静的ライブラリを作成してみる"><a class="header" href="#静的ライブラリを作成してみる">静的ライブラリを作成してみる</a></h3>
<p id="main.c-static">
<pre><code class="language-C">// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main (void)
{
    printf (&quot;%d\n&quot;， add5 (10));
}
</code></pre>
</p>
<p id="add5.c-static">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ ar rcs libadd5.a add5.o  ❶
$ ar t libadd5.a
add5.o  ❷
$ file libadd5.a
libadd5.a: current ar archive
$ gcc ❸-static -o a.out-static main.c ❹-L. ❺-ladd5
$ file a.out-static
file ./a.out-static
./a.out-static: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， statically linked， BuildID[sha1]=1bf84a77504302513d6219e4b27316309d08ed2d， for GNU/Linux 3.2.0， not stripped
$ ./a.out-static 
15 ❻
</code></pre>
<ul>
<li>❶ <code>ar rcs</code>コマンドで<code>add5.o</code>から<code>libadd5.a</code>を作成します．</li>
<li>❷  <code>ar t</code>コマンドで<code>libadd5.a</code>の中身を調べます．中身は<code>add5.o</code>だけでした．</li>
<li>❸❹❺ <code>gcc</code>で<code>main.c</code>と<code>libadd5.a</code>を静的リンクします．
静的リンクするために❸<code>-static</code>オプションが必要です．
<code>libadd5.a</code>がカレントディレクトリにあることを伝えるために❹<code>-L.</code>が必要です．
静的リンクする静的ライブラリが<code>libadd5.a</code>であることを伝えるために
❺<code>-ladd5</code>が必要です．（前の<code>add</code>と後の<code>.a</code>は自動的に付加されます）</li>
<li>❻ 実行してみると，静的ライブラリ<code>libadd5.a</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<h3 id="動的ライブラリを作成してみる"><a class="header" href="#動的ライブラリを作成してみる">動的ライブラリを作成してみる</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ gcc ❶-fPIC ❷-shared -o libadd5.so add5.c
$ file libadd5.so
libadd5.so: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， BuildID[sha1]=415ef51f32145b59c51e836a25959f0f66039768， not stripped
$ gcc -o a.out-dynamic main.c -ladd5 -L. ❸-Wl，-rpath .
$ file ./a.out-dynamic
./a.out-dynamic: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=a5d4f8ef61cef4e0b063376333f07170d312c546， for GNU/Linux 3.2.0， not stripped
$ ldd ./a.out
	linux-vdso.so.1 (0x00007ffff7fcd000)
	libadd5.so =&gt; ❹./libadd5.so (0x00007ffff7fbd000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dad000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
$ ./a.out-dynamic
15 ❺ 
</code></pre>
<ul>
<li>❶❷ <code>add5.c</code>から動的ライブラリ<code>libadd5.so</code>を作ります．
<code>libadd5.so</code>を<strong>位置独立コード</strong>(PIC)にするために，❶<code>-fPIC</code>が必要です．
<code>libadd5.so</code>を<strong>共有オブジェクト</strong>(shared object)にするために，❷<code>-shared</code>が必要です．</li>
<li>❸ <code>gcc</code>で<code>main.c</code>と<code>libadd5.so</code>を動的リンクします．
実行時に動的ライブラリを探索するパスを❸<code>-Wl，-rpath .</code>で指定しています．
ここでは<code>libadd5.so</code>をカレントディレクトリに置いているためです．
（セキュリティ上，実際に使う際は絶対パスを指定する方が安全でしょう）．
ちなみに<code>-Wl，-rpath .</code>を<code>gcc</code>に指定すると，
<a href="https://man7.org/linux/man-pages/man1/ld.1.html"><code>ld</code>コマンド</a>
に<code>-rpath .</code>というオプションが渡されます	．</li>
<li>❹ <code>ldd</code>コマンドで調べると，<code>a.out-dynamic</code>中の<code>libadd5.so</code>は
<code>./libadd5.so</code>を参照していることを確認できました．</li>
<li>❺ 実行してみると，動的ライブラリ<code>libadd5.so</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<details id="PIC">
<summary>
位置独立コードとは
</summary>
<p><strong>位置独立コード</strong>(position independent code， PIC)とはメモリ上の
どこにロードしても，そのまま実行できるコードです．
位置独立コードでは絶対アドレスは使わず（再配置が必要になってしまうから），
相対アドレスか間接アドレス参照だけを使います．
位置独立コードにすることで，メモリ上で動的ライブラリを共有できるため，
メモリ使用量を抑えることができます．</p>
</details>
<h2 id="デバッグ情報"><a class="header" href="#デバッグ情報">デバッグ情報</a></h2>
<h3 id="デバッグ情報とは"><a class="header" href="#デバッグ情報とは">デバッグ情報とは</a></h3>
<p><strong>デバッグ情報</strong>とは<code>gcc</code>に<code>-g</code>オプションをつけると
バイナリに付加される情報で，
デバッグ時に有用なソースコード中の情報を含んでいます．
例えば，変数の型情報や，ソースコード中の行番号が挙げられます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ file ./a.out
./a.out: ELF 64-bit LSB pie executable， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=68a01f5977ae542600062913c447a7ba7f2fad62， for GNU/Linux 3.2.0， ❷ with debug_info， not stripped
</code></pre>
<p>❶<code>-g</code>オプションをつけてコンパイルしてから，<code>file</code>コマンドで調べると，
❷デバッグ情報が含まれていることを確認できます．</p>
<p>コンパイラは様々なデバッグ情報の形式を扱えます．
LinuxのELFバイナリでは<a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARFデバッグ情報</a>
が使われることが多いです．(以下，DWARFを前提として説明します)</p>
<h3 id="no-debug-info"><a class="header" href="#no-debug-info">デバッグ情報が無いと，デバッガでファイル名や行番号が表示されない</a></h3>
<p>デバッグ情報無しでデバッガ<code>gdb</code>を使うとどうなるか試してみましょう．
<a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc ❶ main.c add5.c
$ gdb ./a.out
(gdb) ❷ b add5
Breakpoint 1 at 0x1175
(gdb) ❸ r
Starting program: /tmp/a.out 
Breakpoint 1， 0x0000555555555175 in ❹ add5 ()
(gdb) bt
#0  ❻0x0000555555555175 in ❺ add5 ()
#1  0x000055555555515b in main ()
(gdb) quit
</code></pre>
<p><code>-g</code>オプション無しで❶コンパイルしています．
<code>add5</code>関数にブレークポイントを設定❷します．
<strong>ブレークポイント</strong>とはプログラムの実行を一時的に停止する場所です．
関数名<code>add5</code>でブレークポイントを指定したので，
実行すると<code>add5</code>関数の先頭で実行が一時停止します．</p>
<p>❸ runコマンド (<code>r</code>はrunコマンドの省略形)で実行した所，
<code>add5</code>関数でブレーク(実行を一時停止)できたのですが，
関数名<code>add5</code>だけが表示され，<strong>ファイル名や行番号が表示されません</strong>❹．
バックトレースを出力しても同様です❺．</p>
<p>バックトレースとは「<code>main</code>関数から現在実行中の関数までの
呼び出し系列」のことです．
ここでは<code>main</code>関数が<code>add5</code>関数を呼び出しただけなので，
バックトレースは2行しかありません．
❻<code>0x0000555555555175</code>は<code>add5</code>関数が
<code>0x0000555555555175</code>番地の機械語命令を実行する直前で実行を停止していることを
示しています．</p>
<h3 id="デバッグ情報があるとデバッガでファイル名や行番号が表示される"><a class="header" href="#デバッグ情報があるとデバッガでファイル名や行番号が表示される">デバッグ情報があると，デバッガでファイル名や行番号が表示される</a></h3>
<p>今回はデバッグ情報ありでデバッガを使ってみます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1175: ❷ file add5.c， line 2.
(gdb) r
Starting program: /tmp/a.out 
Breakpoint 1， add5 (n=10) at ❸ add5.c:2
2	{
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:2
#1  0x000055555555515b in main () at main.c:5

$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: ❷ file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at ❸ add5.c:3
3	    return n + 5;
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:3
#1  0x000055555555515b in main () at main.c:5
</code></pre>
<ul>
<li>❶ <code>-g</code>をつけたので，<code>a.out</code>にはデバッグ情報が付加されています．</li>
<li><a href="3-binary.html#no-debug-info">先程</a>とは異なり，❷❸❹ファイル名<code>add5.c</code>や行番号<code>3</code>が付加されています．</li>
</ul>
<h3 id="デバッグ情報があると行番号とアドレスを相互変換できる"><a class="header" href="#デバッグ情報があると行番号とアドレスを相互変換できる">デバッグ情報があると，行番号とアドレスを相互変換できる．</a></h3>
<h4 id="addr2line"><a class="header" href="#addr2line">アドレス→行番号の変換</a></h4>
<p>デバッグ情報があるバイナリに対しては，
<code>addr2line</code>コマンドでアドレスを対応する行番号に変換できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ objdump -d ./a.out | egrep -A 4 &quot;&lt;main&gt;:&quot;
0000000000001149 &lt;main&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp，%rbp
    1151:	bf 0a 00 00 00       	mov    $0xa，%edi
$  addr2line -e ./a.out ❶ 0x1149
❷/tmp/main.c:4
</code></pre>
<p>上の実行例では<code>addr2line</code>コマンドで，
<code>0x1149</code>番地の機械語命令はソースコードでは❷<code>/tmp/main.c</code>の4行目に
対応していることが分かりました．</p>
<p>デバッガ上でも確かめてみましょう．</p>
<pre><code>(gdb) b main
Breakpoint 1 at 0x1151: file main.c， line 5.
(gdb) r
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
(gdb) ❶ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
(以下略)
(gdb) ❷ info line *0x0000555555555149 
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
(gdb) ❸ info line main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<ul>
<li>(objdumpコマンドでも可能ですが)
<code>gdb</code>上でも逆アセンブルできます．
逆アセンブルのコマンドは<code>disassemble</code>ですが長いので，
短縮名<code>disas</code>をここでは使っています．
(<code>gdb</code>は他のコマンドと区別できる範囲で，コマンド名を省略できます)．
<a href="3-binary.html#ASLR-PIE">ASLRとPIE</a>が有効な場合，
デバッガ上で逆アセンブルすると，実際のメモリのアドレスが表示されて便利です．
この場合，<a href="3-binary.html#addr2line">上</a>では<code>0x1149</code>番地だったのに，
<code>0x0000555555555149</code>番地に変わっています．</li>
<li><code>gdb</code>の❷<code>info line</code>コマンドを使うと，アドレスから行番号に変換できます．
<code>0x555555555149</code>番地は<code>main.c</code>の4行目に対応しており，
また，この行は機械語命令では<code>0x555555555149</code>番地から<code>0x555555555151</code>に
対応していると表示されています．</li>
<li><code>gdb</code>上では❸<code>info line</code>コマンドを使って，
行番号からアドレスへの変換もできます．</li>
</ul>
<p>なお，<code>gdb</code>で<code>layout asm</code>とすると逆アセンブル結果を常に表示できます．
ブレークポイント(左端の<code>b</code>や<code>B</code>)や次に実行する機械語命令の位置(<code>&gt;</code>)が
表示されて分かりやすいです．</p>
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<details>
<summary>
B+ってどういう意味
</summary>
<ul>
<li><code>B</code>は少なくても一度はブレークしたブレークポイント</li>
<li><code>b</code>は一度もブレークしていないブレークポイント</li>
<li><code>+</code>は有効化されているブレークポイント</li>
<li><code>-</code>は無効化されているブレークポイント</li>
</ul>
</details>
<h4 id="行番号アドレスの変換"><a class="header" href="#行番号アドレスの変換">行番号→アドレスの変換</a></h4>
<p>コマンドライン上で，行番号をアドレスに変換するには
(コマンドがちょっと長くなりますが)以下のように<code>gdb</code>を使います．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;info line main.c:4&quot; --batch
Line 4 of &quot;main.c&quot; starts at address ❶0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<p>上ではプログラムを実行せずにアドレスを取得したので，
<code>a.out</code>ファイル中のアドレス❶<code>0x1149</code>が表示されています．
実行時のアドレスを表示したいなら，以下のようにします
(バッチモードで，<code>b main</code>，<code>run</code>，<code>info line main.c:4</code>という3つのコマンドを実行しています)．
実行時のアドレス❷<code>0x555555555149</code>を表示できました．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;b main&quot; -ex &quot;r&quot; -ex &quot;info line main.c:4&quot; --batch
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
Line 4 of &quot;main.c&quot; starts at address ❷0x555555555149 &lt;main&gt; and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<p>以下のように<code>line2addr</code>などの名前でシェル関数を定義すれば，
短く書けます(が，そんなに頻繁には使わないかも)．</p>
<pre><code class="language-bash">$ function line2addr () {
&gt; command gdb $1 -ex &quot;info line $2&quot; --batch
&gt; }
$ line2addr ./a.out main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<h3 id="デバッグ情報があると逆アセンブル時にソースコードも表示できる"><a class="header" href="#デバッグ情報があると逆アセンブル時にソースコードも表示できる">デバッグ情報があると，逆アセンブル時にソースコードも表示できる</a></h3>
<p>デバッグ情報がある場合，
(<code>objdump -d</code>ではなく)<code>objdump -S</code>で逆アセンブルすると
ソースコードも表示できます．
❶関数<code>add5</code>の定義部分であること，
❷<code>return n + 5;</code>の行のコンパイル結果であること，
などが見やすくなります．</p>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ objdump -S ./add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
❶ int add5 (int n)
{
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
 ❷ return n + 5;
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
}
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<h3 id="デバッガでレジスタの値を確認する"><a class="header" href="#デバッガでレジスタの値を確認する">デバッガでレジスタの値を確認する</a></h3>
<p>デバッガでレジスタの値を確認できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./aout
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) p ❶ $rdi
$1 = 10
(gdb) ❷ info reg
Undefined info command: &quot;regs&quot;.  Try &quot;help info&quot;.
(gdb) info reg
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe048      140737488347208
rsi            0x7fffffffe038      140737488347192
rdi            0xa                 10
(以下略，qを押して表示を停止)
</code></pre>
<ul>
<li>❶ <code>gdb</code>では<code>%</code>ではなく<code>$</code>をつけてレジスタ名を指定します．
<code>p</code>は<code>print</code>コマンドの省略名です．<code>%rdi</code>の値が<code>10</code>であることが分かりました．
16進数で表示したい場合は，<code>p/x $rdi</code>と<code>/x</code>をつけます</li>
<li>❷ レジスタの値一覧は<code>info reg</code>で表示できます．ページャが起動されるので，<code>q</code>を押して表示を停止します．</li>
</ul>
<p><code>gdb</code>で<code>layout regs</code>とすると，レジスタの値を常に表示できます．</p>
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
<ul>
<li><code>layout regs</code>するとレジスタの値一覧が表示されます．
上から「レジスタ表示」「ソースコード表示」「コマンド入力」のためのウィンドウです．</li>
<li><code>focus regs</code>や，<code>ctrl-x o</code>などを入力すると，レジスタ表示ウィンドウが選択されます．
この状態で↓キーを押すと(あるいはマウスでスクロールされると）
レジスタ表示ウィンドウの表示をスクロールできます．</li>
<li><code>ctrl-x a</code>を入力すると，元の表示方法に戻ります．</li>
</ul>
<h3 id="デバッガでメモリの値を確認する"><a class="header" href="#デバッガでメモリの値を確認する">デバッガでメモリの値を確認する</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>を
を実行し，<code>add5</code>関数のスタックフレームが作成された直後は
以下の図(<a href="./2-asm-intro#stack-frame4">この図</a>の再掲)になっています．</p>
<img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
<p>これをデバッガで確認しましょう．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) disas
Dump of assembler code for function add5:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    %edi，-0x4(%rbp)
=&gt; 0x0000555555555183 &lt;+11&gt;:	mov    -0x4(%rbp)，%eax
   0x0000555555555186 &lt;+14&gt;:	add    $0x5，%eax
   0x0000555555555189 &lt;+17&gt;:	pop    %rbp
   0x000055555555518a &lt;+18&gt;:	ret    
(gdb) ❶ p/x $rsp
$1 = 0x7fffffffdf10
(gdb) ❷ p/x $rbp
$2 = 0x7fffffffdf10
(gdb) ❸ x/1gx 0x7fffffffdf10
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❹ x/1gx $rsp
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❺ x/8bx $rsp
0x7fffffffdf10:	0x20 0xdf 0xff 0xff 0xff 0x7f 0x00 0x00
</code></pre>
<ul>
<li>
<p>❶❷ <code>%rsp</code>と<code>%rbp</code>レジスタの値を調べると，どちらも
<code>0x7fffffffdf10</code>番地でした．</p>
</li>
<li>
<p>❸ <code>x/1gx 0x7fffffffdf10</code> はメモリの中身を表示するコマンドです．</p>
<ul>
<li><code>x</code>のコマンド名は examine memory から来ています．</li>
<li><code>/1gx</code>は出力形式を指定しています．
この場合は「8バイトのデータを16進表記で1つ表示」という意味です．</li>
</ul>
</li>
</ul>
<details>
<summary>
xコマンドの表示オプション
</summary>
<p><code>x</code>コマンドの表示オプションには以下があります(他にもあります)．</p>
<ul>
<li><code>x</code>  16進数</li>
<li><code>d</code>  符号あり10進数</li>
<li><code>u</code>  符号なし10進数</li>
<li><code>t</code>   2進数</li>
<li><code>c</code>  文字</li>
<li><code>s</code>  文字列</li>
</ul>
<p>データのサイズ指定には以下があります．</p>
<ul>
<li><code>b</code>  1バイト (byte)</li>
<li><code>h</code>  2バイト (halfword)</li>
<li><code>w</code>  4バイト (word)</li>
<li><code>g</code>  8バイト (giant)</li>
</ul>
</details>
<details>
<summary>
サイズの用語がバラバラ過ぎる！
</summary>
<p>以下の通り，GNUアセンブラ(AT&amp;T形式)，Intel形式，<code>gdb</code>で各サイズに対する
用語がバラバラです．混乱しやすいので要注意です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1バイト</th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>byte (b)</td><td>short (s)</td><td>long (l)</td><td>quad (q)</td></tr>
<tr><td>Intel形式</td><td>byte</td><td>word</td><td>double word (dword)</td><td>quad word (qword)</td></tr>
<tr><td><code>gdb</code></td><td>byte (b)</td><td>halfword (h)</td><td>word (w)</td><td>giant (g)</td></tr>
</tbody></table>
</div></details>
<ul>
<li>❹ 具体的なアドレス(ここでは<code>0x7fffffffdf10</code>)ではなく，
レジスタ名 (ここでは<code>$rsp</code>)を指定して，
　そのレジスタが指しているメモリの中身を表示できます．</li>
<li>❺ <code>/1gx</code>ではなく<code>/8bx</code>と表示形式を指定すると，
「1バイトのデータを16進表記で8個表示」という意味になります．
<code>0x7FFFFFFFDF10</code>から<code>0x7FFFFFFFDF17</code>までの各番地には，それぞれ，
以下の図の通り，
<code>0x20</code>，<code>0xDF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0x7F</code>，<code>0x00</code>，<code>0x00</code>という値が
メモリ中に入っていることが分かります．
この格納されている8バイトのデータ<code>0x00007fffffffdf20</code>はアドレスであり，
以下の図の一番下のアドレス(赤字の部分)を指しています．</li>
</ul>
<img src="figs/stack-add5-layout.svg" height="350px" id="fig:stack-add5-layout">
<pre><code>(上のデバッグの続き)
(gdb) ❻ x/1gx $rsp+8
0x7fffffffdf18:	0x000055555555515b
(gdb) ❼ x/8bx $rsp+8
0x7fffffffdf18:	0x5b	0x51	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) ❽ disas 0x000055555555515b
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
❾ 0x000055555555515b &lt;+18&gt;:	mov    %eax，%esi
   0x000055555555515d &lt;+20&gt;:	lea    0xea0(%rip)，%rax        # 0x555555556004
   0x0000555555555164 &lt;+27&gt;:	mov    %rax，%rdi
   0x0000555555555167 &lt;+30&gt;:	mov    $0x0，%eax
   0x000055555555516c &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x0000555555555171 &lt;+40&gt;:	mov    $0x0，%eax
   0x0000555555555176 &lt;+45&gt;:	pop    %rbp
   0x0000555555555177 &lt;+46&gt;:	ret    
End of assembler dump.
</code></pre>
<ul>
<li>❻ <code>x/1gx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスの中身を表示させています．
<code>8(%rsp)</code>の意味は「<code>%rsp</code>の値に8を足したアドレス」です．
<code>gdb</code>中では「<code>$rsp + 8</code>」と入力します．</li>
<li>❼ <code>x/8bx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスを1バイトごとに表示しました．
上記の図の通り， 
<code>0x7FFFFFFFDF18</code>から<code>0x7FFFFFFFDF1F</code>までの各番地には，それぞれ，
<code>0x5B</code>，<code>0x51</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x00</code>，<code>0x00</code>が
格納されていることが分かりました．</li>
<li>❻の結果で得た<code>0x000055555555515b</code>番地を使って❽逆アセンブルしてみると，
❾この番地は「<code>call add5</code>」の次の命令 (この場合は <code>mov %eax， %esi</code>)であることが
分かりました．
このように，<strong>戻り番地</strong> (return address)は通常，
「その関数を呼び出した<code>call</code>命令の次の命令のアドレス」になります．</li>
</ul>
<details>
<summary>
戻り番地が通常ではない場合って?
</summary>
<p><strong>末尾コール最適化</strong> (tail-call optimization; TCO)が起こった時が該当します．</p>
<form class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="150px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="140px" id="fig:tail-call-opt2">
    </div>
</form>
<ul>
<li>上の「末尾コール最適化の前」の図では<code>main</code>関数が<code>A</code>を呼び，
関数<code>A</code>が<code>B</code>を呼んでいます．また逆の順番でリターンします．
しかし，<code>call B</code>の次の命令が<code>ret</code> (次の命令❷)になっているため，
関数<code>B</code>からリターンした後，関数<code>A</code>では何もせず，<code>main</code>にリターンしています．</li>
<li>そこで「末尾コール最適化の後」の図のように，関数<code>A</code>中の<code>call</code>命令を
無条件ジャンプ命令 <code>jmp</code>に書き換えて，関数<code>B</code>からは(<code>A</code>を経由せず)
直接，<code>main</code>関数のリターンするように書き換えて無駄なリターンを省くことができます．
これが末尾コール最適化です．</li>
<li>その結果，関数<code>B</code>のリターンアドレスは，関数<code>A</code>中の<code>call</code>命令の次のアドレス
(次の命令❷)ではなく，関数<code>main</code>中の「次の命令❶」となってしまいました．
これが戻り番地が通常ではない場合の一例です．</li>
</ul>
</details>
<h3 id="デバッグ情報を直接見る"><a class="header" href="#デバッグ情報を直接見る">デバッグ情報を直接見る</a></h3>
<p><code>objdump</code>，<code>readelf</code>，<code>llvm_dwarfdump</code>コマンドを使うと，
デバッグ情報の中身を直接見ることができます．</p>
<h4 id="objdump--w"><a class="header" href="#objdump--w"><code>objdump -W</code></a></h4>
<p>デバッグ情報には例えば，以下のものがあります</p>
<ul>
<li>デバッグ情報 (<code>.debug_info</code>)</li>
<li>行情報 (<code>.debug_line</code>)</li>
<li>アドレス情報 (<code>.debug_aranges</code>)</li>
<li>フレーム情報 (<code>.eh_frame</code>)</li>
<li>省略情報 (<code>.debug_abbrev</code>)</li>
</ul>
<p><code>objdump -W add5.o</code> とすると，<code>add5.o</code>中のデバッグ情報を全て表示します
<code>-Wi</code>， <code>-Wl</code>， <code>-Wr</code>， <code>-Wf</code>，<code>-Wa</code>とすると，
それぞれ，デバッグ情報，行情報，アドレス情報，フレーム情報，
省略情報だけを表示できます．</p>
<pre><code class="language-bash">$ objdump -W add5.o | less
add5.o:     file format elf64-x86-64

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string， offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string， offset: 0x5): add5.c
(以下略)
</code></pre>
<p>例えば，以下の部分は
仮引数の情報として「変数名は❻<code>n</code>，
❷<code>add5.c</code>の❸1行目❹15カラム目で宣言されていて，
型は❺<code>&lt;0x5e&gt;</code>を見てね．変数の場所は❻<code>(DW_OP_fbreg: -20)</code>」となってます．</p>
<pre><code>&lt;2&gt;&lt;50&gt;: Abbrev Number: 3 (DW_TAG_formal_parameter)
    &lt;51&gt;   DW_AT_name        : ❶ n
    &lt;53&gt;   DW_AT_decl_file   : ❷ 1
    &lt;54&gt;   DW_AT_decl_line   : ❸ 1
    &lt;55&gt;   DW_AT_decl_column : ❹ 15
    &lt;56&gt;   DW_AT_type        : ❺ &lt;0x5e&gt;
    &lt;5a&gt;   DW_AT_location    : 2 byte block: 91 6c ❻ (DW_OP_fbreg: -20)
</code></pre>
<details>
<summary>
❻DW_OP_fbreg: -20とは
</summary>
<p>「CFA (canonical frame address)から -20バイトのオフセットの位置」を意味しています．
CFAはDWARFデバッグ情報が定める仮想的なレジスタでCPUごとに異なります．
x86-64の場合は「<code>call</code>命令を実行する直前の<code>%rsp</code>の値」なので，以下になります．
(<code>call</code>命令が戻り番地をスタックにプッシュすることを思い出しましょう)．
引数<code>n</code>(下図で赤い部分)の先頭アドレスは，
CFAからちょうど-20バイトの場所にあることが確認できました．</p>
<img src="figs/stack-layout-CFA.svg" height="400px" id="fig:stack-layout">
<p><a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>でコンパイルされていなければ，
(通常は関数の先頭で<code>push %rbp</code>するので)以下の式が成り立ちます．</p>
<pre><code class="language-math">CFA == %rbp + 16
</code></pre>
<p>なお，<code>fbreg</code> は frame base registerの略だと思います．</p>
</details>
<details>
<summary>
Abbrev Number (省略番号)とは
</summary>
<p>例えば，以下のDIEで Abbrev Number は ❶4となっています．</p>
<pre><code class="language-bash">$ objdump -Wi add5.o
(一部略)
&lt;1&gt;&lt;5e&gt;: Abbrev Number: ❶4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : 4
    &lt;60&gt;   DW_AT_encoding    : 5         (signed)
    &lt;61&gt;   DW_AT_name        : int
</code></pre>
<p><code>objdump -Wa</code>で<code>.debug_abbrev</code>を表示すると4番目のエントリは
以下となっています．つまり，</p>
<ul>
<li>❷4番のAbbrev Number (省略番号)を持つDIEは ❸DW_TAG_base_type である</li>
<li>DW_TAG_base_typeには例えば，❹変数名の情報があり，その型は❺DW_FORM_stringである</li>
</ul>
<p>と分かります．</p>
<pre><code class="language-bash">$ objdump -Wa add5.o
(一部略)
❷4 ❸DW_TAG_base_type    [no children]
    DW_AT_byte_size    DW_FORM_data1
    DW_AT_encoding     DW_FORM_data1
  ❹DW_AT_name       ❺DW_FORM_string
    DW_AT value: 0     DW_FORM value: 0
</code></pre>
<p>要するに<code>.debug_abbrev</code>の情報は<code>.debug_info</code>のメタ情報(型情報)であり，
この場合，4という数字を保持するだけで，
「このDIEはDW_TAG_base_typeである．その内容は…(以下略)」
という情報を持てるのです．</p>
<p>これによりサイズの圧縮が可能になっています．
<code>objdump -W</code>はある程度は散っている情報をまとめて表示していて親切です．</p>
</details>
<details>
<summary>
LEB128とは
</summary>
<p>LEB128 (little endian base 128)は任意の大きさの整数を扱える
可変長の符号化方式です．直感的にはLEB128はUTF-8の整数版です．</p>
<p>LEB128はDWARFやWebAssemblyなどで使われています．
(ですので，DWARFデバッグ情報にはLEB128の符号化が使われている箇所があります．
デバッグ情報の16進ダンプを解析する際は注意しましょう)．</p>
<p>LEB128には符号ありと符号なしの2種類がありますが，以下では符号なしで説明します．</p>
<p>ここでは123456を符号なしLEB128形式に変換します．
結果は最下位バイトから，<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>の3バイトになります．
まず<code>bc</code>コマンドで2進数にします❶．</p>
<pre><code class="language-bash">$ bc
obase=2
123456
❶ 11110001001000000
</code></pre>
<p>次に以下のステップを踏みます．</p>
<form class="tab-wrap">
    <input id="LEB128-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="LEB128-1">ステップ1</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-1.svg" height="70px" id="fig:LEB128-1">
    </div>
    <input id="LEB128-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-2">ステップ2</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-2.svg" height="70px" id="fig:LEB128-2">
    </div>
    <input id="LEB128-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-3">ステップ3</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-3.svg" height="70px" id="fig:LEB128-3">
    </div>
    <input id="LEB128-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-4">ステップ4</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-4.svg" height="85px" id="fig:LEB128-4">
    </div>
</form>
<p>ステップ4の結果を<code>bc</code>コマンドで16進数にします❷．</p>
<pre><code class="language-bash">$ bc
obase=16
ibase=2
000001111100010011000000
❷ 7C4C0
</code></pre>
<p>結果の16進数❷<code>0x7C4C0</code> を1バイトごとに最下位バイトから出力すると，
最終的な結果は<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>となります．
LEB128の最上位バイトの最上位ビットは必ず0で，
それ以外のバイトはの最上位ビットは1なので，
サイズ情報がなくても，
元の整数に戻す際，どのバイトまで処理すればよいかが分かります．</p>
</details>
<p>型の情報<code>&lt;0x5e&gt;</code>は以下にありました．
「サイズは❼ 4バイト，❽符号あり，型名は❾<code>int</code>」です．</p>
<pre><code>&lt;1&gt;&lt;5e&gt;: Abbrev Number: 4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : ❼ 4
    &lt;60&gt;   DW_AT_encoding    : 5        ❽ (signed)
    &lt;61&gt;   DW_AT_name        : ❾ int
</code></pre>
<p>上記の<code>.debug_info</code>中の情報である，
DW_TAG_formal_parameterやDW_TAG_base_typeなどは
DIE (debug information entry)というデバッグ情報の単位の1つです．
DIEは全体で木構造になっています．</p>
<img src="figs/DIE-tree.svg" height="150px" id="fig:DIE-tree">
<p>またデバッグ情報情報があちこちに散っています．
例えば，❷「ファイル1」の情報はどこにあるかというと</p>
<pre><code>    &lt;53&gt; ❷ DW_AT_decl_file   : 1
</code></pre>
<p>行情報にありました．
以下でエントリ1の情報を見ると，<code>add5.c</code>と分かりました．</p>
<pre><code class="language-bash">$ objdump -Wl add5.o | less
(中略)
The File Name Table (offset 0x2c, lines 2, columns 2):
  Entry Dir     Name
  0     0       (indirect line string, offset: 0x11): add5.c
  1     0       (indirect line string, offset: 0x18): add5.c
</code></pre>
<h4 id="readelf"><a class="header" href="#readelf"><code>readelf</code></a></h4>
<p><code>readelf</code>コマンドでも<code>objdump</code>と同様にDWARFデバッグ情報を表示できます．
以下は実行例です．</p>
<pre><code class="language-bash">$ readelf -wi ./add5.o
Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string, offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string, offset: 0x5): add5.c
    &lt;16&gt;   DW_AT_comp_dir    : (indirect line string, offset: 0x0): /tmp
    &lt;1a&gt;   DW_AT_low_pc      : 0x0
    &lt;22&gt;   DW_AT_high_pc     : 0x13
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
(以下略)
</code></pre>
<h2 id="メモリマップを見る"><a class="header" href="#メモリマップを見る">メモリマップを見る</a></h2>
<h3 id="pmapコマンドでメモリマップを見る"><a class="header" href="#pmapコマンドでメモリマップを見る"><code>pmap</code>コマンドでメモリマップを見る</a></h3>
<p><code>pmap</code>コマンドを使うと，
実行中のプログラム(プロセス)がどのメモリ領域を使用しているか
(メモリマップ)を調べられます．
(この出力は<code>/proc</code>ファイルシステムの <code>/proc/プロセス番号/maps</code>の内容から作られています)．</p>
<pre><code class="language-bash">$ cat 
❶ ^Z   
[1]+  Stopped                 cat
$ ps | egrep cat
❷  7687 pts/0    00:00:00 cat
$ ❸ pmap 7687
7687:   cat
❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
000055f74dafc000    132K rw---   [ anon ]
00007f63a7e00000   6628K r---- locale-archive
00007f63a8600000    160K r---- libc.so.6
00007f63a8628000   1620K r-x-- libc.so.6
00007f63a87bd000    352K r---- libc.so.6
00007f63a8815000     16K r---- libc.so.6
00007f63a8819000      8K rw--- libc.so.6
00007f63a881b000     52K rw---   [ anon ]
00007f63a8829000    148K rw---   [ anon ]
00007f63a885d000      8K rw---   [ anon ]
00007f63a885f000      8K r---- ld-linux-x86-64.so.2
00007f63a8861000    168K r-x-- ld-linux-x86-64.so.2
00007f63a888b000     44K r---- ld-linux-x86-64.so.2
00007f63a8897000      8K r---- ld-linux-x86-64.so.2
00007f63a8899000      8K rw--- ld-linux-x86-64.so.2
❹ 00007fff86f9f000 132K ❺rw---   ❻[ stack ]
00007fff86ff8000     16K r----   [ anon ]
00007fff86ffc000      8K r-x--   [ anon ]
ffffffffff600000      4K --x--   [ anon ]
 total             9560K
$ fg
❽ ^D
</code></pre>
<ul>
<li>まず <code>cat</code>コマンドを起動します．ファイル名を指定していないので，
標準入力からの入力待ちになります．
ここで❶ ctrl-Z を入力して，<code>cat</code>コマンドの実行を中断 (suspend)します．
<code>pmap</code>コマンドは実行中のプロセスにしか実行できないため，
<code>cat</code>コマンドが実行中のまま終了しないように，こうしています．</li>
<li>次に<code>ps</code>コマンドで<code>cat</code>コマンドのプロセス番号を調べます．
❷7687がプロセス番号と分かりました．</li>
<li>❸プロセス番号7687を引数として<code>pmap</code>コマンドを実行します．</li>
<li>出力の各行が使用中のメモリ領域の情報を示しています．例えば，❹の行は次を意味しています．</li>
</ul>
<p><code>❹ 00007fff86f9f000    132K ❺rw---   ❻[ stack ]</code></p>
<ul>
<li>
<p>❹アドレス`00007fff86f9f000'からサイズ132KBの領域を使用している．</p>
</li>
<li>
<p>このメモリ領域の❻アクセス権限は読み書きが可能で，実行は不可．</p>
<ul>
<li><code>r</code> 読み込み可能</li>
<li><code>w</code> 書き込み可能</li>
<li><code>x</code> 実行可能</li>
</ul>
</li>
<li>
<p>このメモリ領域は❻スタックとして使用している</p>
</li>
<li>
<p><code>cat</code>コマンド自身は以下の5つのメモリ領域を使用しています．</p>
</li>
</ul>
<pre><code class="language-bash">❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
</code></pre>
<ul>
<li>
<p>アクセス権限が <code>r-x--</code>のものは，<code>.text</code>セクションでしょう．
(<code>.text</code>セクションは通常，実行可能かつ書き込み禁止にするからです)</p>
</li>
<li>
<p>アクセス権限が <code>rw----</code>のものは，<code>.data</code>セクションでしょう．
(<code>.data</code>セクションは通常，実行禁止かつ書き込み可能にするからです)</p>
</li>
<li>
<p>残りの3つのアクセス権限が <code>r----</code> のものは，<code>.rodata</code>セクションなどでしょう．
(詳細は調べていません)</p>
</li>
<li>
<p>使用しているサイズが4KBの倍数なのは，x86-64でよくある
<strong>ページ</strong>(page)サイズが4KBだからです．
(ページとは仮想記憶方式の1つであるページングで使われる，
固定長(例えば4KB)に区切ったメモリ領域のことです)．
プロセスは<code>mmap</code>システムコールを使って，OSからページ単位でメモリを割り当ててもらい，その際にページごとにアクセス権限を設定できます．</p>
</li>
<li>
<p>最後に❼で，中断していた<code>cat</code>コマンドを<code>fg</code>コマンドで実行を再開し，
<code>ctrl-D</code>を入力して<code>cat</code>コマンドの実行を終了しています．</p>
</li>
</ul>
<h3 id="gdbでメモリマップを見る"><a class="header" href="#gdbでメモリマップを見る"><code>gdb</code>でメモリマップを見る</a></h3>
<p><code>gdb</code>でもメモリマップを見ることができます</p>
<pre><code class="language-bash">$ gdb /usr/bin/cat
(gdb) r
ctrl-Z
Program received signal SIGTSTP, Stopped (user).
(gdb) info proc map
process 7821
Mapped address spaces:

          Start Addr           End Addr       Size     Offset  Perms  objfile
      0x555555554000     0x555555556000     0x2000        0x0  r--p   /usr/bin/cat
      0x555555556000     0x55555555a000     0x4000     0x2000 ❶r-xp   /usr/bin/cat
<span class="boring">      0x55555555a000     0x55555555c000     0x2000     0x6000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555c000     0x55555555d000     0x1000     0x7000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555d000     0x55555555e000     0x1000     0x8000  rw-p   /usr/bin/cat
</span><span class="boring">      0x55555555e000     0x55555557f000    0x21000        0x0  rw-p   [heap]
</span><span class="boring">      0x7ffff7400000     0x7ffff7a79000   0x679000        0x0  r--p   /usr/lib/locale/locale-archive
</span><span class="boring">      0x7ffff7c00000     0x7ffff7c28000    0x28000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7c28000     0x7ffff7dbd000   0x195000    0x28000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7dbd000     0x7ffff7e15000    0x58000   0x1bd000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e15000     0x7ffff7e19000     0x4000   0x214000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e19000     0x7ffff7e1b000     0x2000   0x218000  rw-p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e1b000     0x7ffff7e28000     0xd000        0x0  rw-p   
</span><span class="boring">      0x7ffff7f87000     0x7ffff7fac000    0x25000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbb000     0x7ffff7fbd000     0x2000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbd000     0x7ffff7fc1000     0x4000        0x0  r--p   [vvar]
</span><span class="boring">      0x7ffff7fc1000     0x7ffff7fc3000     0x2000        0x0  r-xp   [vdso]
</span><span class="boring">      0x7ffff7fc3000     0x7ffff7fc5000     0x2000        0x0  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fc5000     0x7ffff7fef000    0x2a000     0x2000  r-xp   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fef000     0x7ffff7ffa000     0xb000    0x2c000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffb000     0x7ffff7ffd000     0x2000    0x37000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x39000  rw-p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
</span><span class="boring">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0  --xp   [vsyscall]
</span></code></pre>
<details>
<summary>
アクセス権限rwxpのpとは
</summary>
<p><code>mmap</code>でメモリ領域をマップする際に，
フラグとして<code>MAP_PRIVATE</code>を指定すると<code>p</code>，
<code>MAP_SHARED</code>を指定すると<code>s</code>と表示されます．</p>
<ul>
<li>
<p><code>MAP_PRIVATE</code> マップした領域への変更はプロセス間で共有されません．
マップは<strong>copy-on-write</strong>なので，書き込まれるまで自分専用のコピーは発生せず，
共有されます．</p>
</li>
<li>
<p><code>MAP_SHARED</code> マップした領域への変更はプロセス間で共有されます．
すなわちマップした領域に書き込みを行うと，
その変更は他のプロセスにも見えます．
ただし，<code>msync</code>を使う必要があります．</p>
</li>
</ul>
<p>❶<code>.text</code>セクションの共有設定も<code>p</code>となっています．
これは<code>.text</code>セクションも<code>mmap</code>の<code>MAP_PRIVATE</code>でマップしているからです．
動的リンクした実行可能ファイルの<code>.text</code>セクションは
物理メモリ上で共有されていますが，
その共有と<code>MAP_SHARED</code>は関係ないのです．</p>
<!--
ちなみに，そのプロセスが`mmap`で`MAP_SHARED`なマップをすれば，
表示が`s`になります(自分でやってみて確かめました)．

strace して .text を MAP_PRIVATE　してるのを確かめようとしたけど
よくわからんかった．
$ strace /lib64/ld-linux-x86-64.so.2 /usr/bin/cat
もやったんだけどね．
-->
</details>
<h2 id="再配置情報"><a class="header" href="#再配置情報">再配置情報</a></h2>
<h3 id="再配置情報の概要"><a class="header" href="#再配置情報の概要">再配置情報の概要</a></h3>
<p><strong>再配置情報</strong>(relocation information)とは「後でアドレス調整する時のために，
機械語命令中のどの場所をどんな方法で書き換えればよいか」を表す情報です．
オブジェクトファイル<code>*.o</code>は一般的に再配置情報を含んでいます．</p>
<pre><code class="language-C">// asm/reloc-main.c
#include &lt;stdio.h&gt;
extern int x;
int main ()
{
    printf (&quot;%d\n&quot;, x);
}
</code></pre>
<pre><code class="language-C">// asm/reloc-sub.c
int x = 999;
</code></pre>
<p>例えば，上の<a href="./asm/reloc-main.c"><code>reloc-main.c</code></a>と
<a href="./asm/reloc-sub.c"><code>reloc-sub.c</code></a>を見て下さい．
<code>reloc-main.c</code>中で参照している変数<code>x</code>の実体は<code>reloc-main.c</code>中には無く，
実体は<code>reloc-sub.c</code>中にあります．</p>
<img src="figs/reloc-overview.svg" height="170px" id="fig:reloc-overview">
<p>ですので，<a href="./asm/reloc-main.s"><code>reloc-main.s</code></a>中の
<code>movq x(%rip), %eax</code>をアセンブルして<code>reloc-main.o</code>を作っても，
この時点では<code>x</code>のアドレスが不明なので，<strong>仮のアドレス</strong>(上図では<code>00 00 00 00</code>)
にするしかありません．
そこで，この<code>movq x(%rip), %eax</code>命令に対する<strong>再配置情報</strong>として
「この命令の2バイト目から4バイトを4バイト長の<code>%rip</code>相対アドレスで埋める」
という情報(<code>R_X86_64_PC32</code>，<a href="3-binary.html#R_X86_64_PC32">後述</a>)を
<code>reloc-main.o</code>中に保持しておき，リンク時に正しいアドレスを埋め込むのです．</p>
<img src="figs/reloc-overview2.svg" height="300px" id="fig:reloc-overview2">
<pre><code>$ gcc -c reloc-main.c
$ gcc -c reloc-sub.c
$ gcc reloc-main.o reloc-sub.o
</code></pre>
<details>
<summary>
なんでgccを3回?
</summary>
<p>通常は<code>gcc reloc-main.c reloc-sub.c</code>と，<code>gcc</code>を一回実行して
<code>a.out</code>を作ります．が，ここでは<code>reloc-main.o</code>の中の再配置情報を
見たいので，わざわざ別々に<code>reloc-main.o</code>と<code>reloc-sub.o</code>を作り，
最後にリンクして<code>a.out</code>を作っています．</p>
</details>
<p><code>reloc-main.o</code>と<code>reloc-sub.o</code>をリンクして<code>a.out</code>を作ると，
(様々な<code>*.o</code>中のセクションを一列に並べることで)
変数<code>x</code>のアドレスが<code>0x4010</code>に決まり，
上図の「次の命令」のアドレスも<code>0x1157</code>に決まりました．
仮のアドレスに埋めたかったのは，<code>%rip</code>相対番地でしたので，
<code>0x4010-0x1157=0x2EB9</code>と計算した<code>0x2EB9</code>番地を仮のアドレスの部分に埋めました．
これが再配置です．</p>
<details>
<summary>
様々な*.o中のセクションを一列に並べることで，とは
</summary>
<br/>
<img src="figs/reloc-overview4.svg" height="200px" id="fig:reloc-overview4">
<p>例えば上図で<code>foo2.o</code>中の変数<code>x</code>のアドレスは仮アドレス<code>0x1000</code>ですが，
<code>foo1.o</code>と<code>foo2.o</code>中のセクションを1列に並べると，
リンク後は「<code>a.out</code>の先頭アドレスが(例えば)<code>0x4000</code>なので，先頭から数えると，
(<code>0x4000 + 0x0500 + 0x1000 = 0x5500</code>という計算をして)
変数<code>x</code>のアドレスは<code>0x5500</code>に決まりますよね」という話です．</p>
</details>
<h3 id="objdump-dr"><a class="header" href="#objdump-dr"><code>objdump -dr</code> で再配置情報を見てみる</a></h3>
<pre><code>$ gcc -g -c reloc-main.c
$ objdump -dr reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	8b 05 ❶ 00 00 00 00    mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
		❷ a: R_X86_64_PC32	x-0x4
   e:	89 c6                	mov    %eax,%esi
  10:	48 8d 05 ❸ 00 00 00 00 	lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
		❹ 13: R_X86_64_PC32	.rodata-0x4
  17:	48 89 c7             	mov    %rax,%rdi
  1a:	b8 00 00 00 00       	mov    $0x0,%eax
  1f:	e8 00 00 00 00       	call   24 &lt;main+0x24&gt;
			20: R_X86_64_PLT32	printf-0x4
  24:	b8 00 00 00 00       	mov    $0x0,%eax
  29:	5d                   	pop    %rbp
  2a:	c3                   	ret    
</code></pre>
<p><a href="3-binary.html#%E5%86%8D%E9%85%8D%E7%BD%AE%E6%83%85%E5%A0%B1%E3%81%AE%E6%A6%82%E8%A6%81">前節</a>の説明を，実際に再配置情報を見ることで確かめます．
上の実行例は<code>objdump -dr</code>で<code>reloc-main.o</code>の逆アセンブルの結果と
再配置情報の両方を表示させたものです．</p>
<ul>
<li>❶を見ると<a href="3-binary.html#fig:reloc-overview">図</a>の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li><span id="R_X86_64_PC32">❷の<code>a: R_X86_64_PC32 x-0x4</code>が再配置情報です．</span>
<ul>
<li><code>a</code>は仮のアドレスを書き換える場所(<code>.text</code>セクションの先頭からのオフセット)です．
命令<code>mov 0x0(%rip), %eax</code>の先頭のオフセットが<code>0x8</code>なので，
<code>0x8</code>に<code>2</code>を足した値が<code>0xa</code>となっています
(この<code>mov</code>命令の最初の2バイトはオペコード)．</li>
<li><code>R_X86_64_PC32</code>は再配置の方法を表しています．
「<code>%rip</code>相対アドレスで4バイト(32ビット)としてアドレスを埋める」ことを意味しています．
(PCはプログラムカウンタ，つまり<code>%rip</code>を使うことを意味しています)．</li>
<li><code>x-0x4</code>は「変数<code>x</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PC32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>S + A - P</code>と定めています．</p>
<ul>
<li><code>S</code> はそのシンボルのアドレス (上の例では<code>0x4010</code>)</li>
<li><code>A</code> は調整用の値 (addend と呼びます．上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では '0x1157 - 4`番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x4010 + (-4) - (0x1157 - 4) = 0x2EB9
</code></pre>
<p>となります．</p>
</details>
<ul>
<li>❸は&quot;%d\n&quot;という文字列の仮アドレス，❹はその仮アドレスの再配置情報です．
❶❷と同様です．</li>
</ul>
<h3 id="readelf--rで再配置情報を見てみる"><a class="header" href="#readelf--rで再配置情報を見てみる"><code>readelf -r</code>で再配置情報を見てみる</a></h3>
<pre><code>$ readelf -r reloc-main.o | less
Relocation section '.rela.text' at offset 0x5b0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000a00000002 R_X86_64_PC32     0000000000000000 x - 4
000000000013  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000020  000b00000004 R_X86_64_PLT32    0000000000000000 printf - 4
(略)
</code></pre>
<p><code>readelf -r</code>でも<code>objdump -dr</code>と同様の結果が得られます．</p>
<h3 id="pltの再配置情報"><a class="header" href="#pltの再配置情報">PLTの再配置情報</a></h3>
<p><code>printf</code>の再配置情報も見てみましょう．</p>
<img src="figs/reloc-overview3.svg" height="300px" id="fig:reloc-overview3">
<pre><code>$ objdump -dr ./reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;main&gt;:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
                        a: R_X86_64_PC32        x-0x4
   e:   89 c6                   mov    %eax,%esi
  10:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
                        13: R_X86_64_PC32       .rodata-0x4
  17:   48 89 c7                mov    %rax,%rdi
  1a:   b8 00 00 00 00          mov    $0x0,%eax
  1f:   e8 ❶ 00 00 00 00       call   24 &lt;main+0x24&gt;
             ❷ 20: R_X86_64_PLT32      printf-0x4
  24:   b8 00 00 00 00          mov    $0x0,%eax
  29:   5d                      pop    %rbp
  2a:   c3                      ret    
</code></pre>
<pre><code>$ objdump -d ./a.out
0000000000001149 &lt;main&gt;:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       8b 05 b9 2e 00 00       mov    0x2eb9(%rip),%eax        # 4010 &lt;x&gt;
    1157:       89 c6                   mov    %eax,%esi
    1159:       48 8d 05 a4 0e 00 00    lea    0xea4(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1160:       48 89 c7                mov    %rax,%rdi
    1163:       b8 00 00 00 00          mov    $0x0,%eax
    1168:     ❸e8 e3 fe ff ff          call   1050 &lt;printf@plt&gt;
    116d:       b8 00 00 00 00          mov    $0x0,%eax
    1172:       5d                      pop    %rbp
    1173:       c3                      ret    
</code></pre>
<p><a href="3-binary.html#objdump-dr">先程の<code>x</code></a>の場合とほぼ同じです．</p>
<ul>
<li>❶を見ると<a href="3-binary.html#fig:reloc-overview3">図</a>の左側の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li>❷の<code>20: R_X86_64_PLT32 printf-0x4</code>が再配置情報です．
<ul>
<li><code>20</code>は仮のアドレスを書き換える場所(オフセット)です．</li>
<li><code>R_X86_64_PLT32</code>は再配置の方法を表しており
「<code>printf@plt</code>への<code>%rip</code>相対アドレス (4バイト(32ビット))を埋める」ことを意味しています．</li>
<li><code>printf-0x4</code>は「変数<code>printf@plt</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PLT32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>L + A - P</code>と定めています．</p>
<ul>
<li><code>L</code> はそのシンボルのPLTエントリのアドレス (上の例では<code>printf@plt</code>のアドレス<code>0x1050</code>)</li>
<li><code>A</code> は調整用のaddend (上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では '0x116D - 4`番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x1050 + (-4) - (0x116D - 4) = -0x11D = 0xFFFFFEE3
</code></pre>
<p>となります．</p>
</details>
<ul>
<li><code>a.out</code>中では「次の命令」が<code>0x116D</code>番地，<code>printf@plt</code>が<code>0x1050</code>番地と決まったので，<code>0x1050 - 0x116D = -0x11D = 0xFFFFFEE3</code>番地が
❸の部分に埋め込まれました．</li>
</ul>
<p><a href="3-binary.html#GOT-PLT">ここ</a>でも説明した通り，
<code>printf</code>の実体はCライブラリの中にあり，
(<code>gcc</code>のデフォルト動作である)<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>の場合，
PLTとGOTの仕組みを使って，<code>printf</code>を呼び出します．
これは<a href="3-binary.html#objdump-dr">先程の<code>x</code></a>の場合は
「(<code>main</code>関数中の)次の命令と変数<code>x</code>の相対アドレスは固定で決まる」のに対して，
<code>printf</code>の場合は固定で決まらないからです
(Cライブラリが実行時に何番地にロードされるか不明だから)．</p>
<img src="figs/plt-printf2.svg" height="300px" id="fig:plt-printf2">
<p>そこで，</p>
<ul>
<li><code>main</code>関数中では(<code>printf</code>を直接呼ぶのではなく)，
(<code>printf</code>のための踏み台である)<code>printf@plt</code>を呼び出す．</li>
<li><code>printf@plt</code>はGOT領域に実行時に書き込まれる<code>printf</code>のアドレスを使い，
間接ジャンプ (上図では<code>bnd jmp *0x2f75(%rip)</code>)して，
本物の<code>printf</code>を呼び出す．</li>
</ul>
<p>という仕組みになっています．</p>
<p>(<code>main</code>関数が<code>printf@plt</code>を呼ぶのではなく，
直接<code>call *0x2f75(%rip)</code>すればいいんじゃね？と言われると，
私もそれでいいじゃん，と思ってしまいます．
<code>ltrace</code>コマンドがPLTエントリをフックして実装している，などの利点があるのは
分かりますが，それ以外に理由はあるのでしょうか．
ご存知の方はぜひ教えてください．)</p>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 4; }
</style>
<h1 id="バイナリ2進数でのデータ表現"><a class="header" href="#バイナリ2進数でのデータ表現">バイナリ(2進数)でのデータ表現</a></h1>
<h2 id="2進数と16進数"><a class="header" href="#2進数と16進数">2進数と16進数</a></h2>
<h2 id="符号なし整数"><a class="header" href="#符号なし整数">符号なし整数</a></h2>
<h3 id="符号なし整数のオーバーフロー"><a class="header" href="#符号なし整数のオーバーフロー">符号なし整数のオーバーフロー</a></h3>
<h2 id="符号あり整数2の補数"><a class="header" href="#符号あり整数2の補数">符号あり整数，2の補数</a></h2>
<h3 id="符号あり整数のオーバーフロー"><a class="header" href="#符号あり整数のオーバーフロー">符号あり整数のオーバーフロー</a></h3>
<h2 id="ASCII"><a class="header" href="#ASCII">文字コード (ASCIIコード)</a></h2>
<h2 id="符号拡張とゼロ拡張"><a class="header" href="#符号拡張とゼロ拡張">符号拡張とゼロ拡張</a></h2>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 5; }
</style>
<h1 id="アーキテクチャ"><a class="header" href="#アーキテクチャ">アーキテクチャ</a></h1>
<h2 id="一般的なコンピュータの構成要素"><a class="header" href="#一般的なコンピュータの構成要素">一般的なコンピュータの構成要素</a></h2>
<h3 id="フェッチ実行サイクル"><a class="header" href="#フェッチ実行サイクル">フェッチ実行サイクル</a></h3>
<h2 id="レジスタ"><a class="header" href="#レジスタ">レジスタ</a></h2>
<h3 id="汎用レジスタ"><a class="header" href="#汎用レジスタ">汎用レジスタ</a></h3>
<img src="figs/gp-regs.svg" height="350px" id="fig:gp-regs">
<ul>
<li>上記16個のレジスタが<strong>汎用レジスタ</strong>(general-purpose register)です．
原則として，プログラマが自由に使えます．</li>
<li>ただし，<code>%rsp</code>は<strong>スタックポインタ</strong>，<code>%rbp</code>は<strong>ベースポインタ</strong>と呼び，
<a href="./2-asm-intro.html#stack-rsp-rbp">一番上のスタックフレームの上下を指す</a>
という役割があります．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>
オプションでコンパイルされた<code>a.out</code>中では，<code>%rbp</code>はベースポインタとしてではなく，
汎用レジスタとして使われています)．</li>
</ul>
<h4 id="caller-savecallee-saveレジスタ"><a class="header" href="#caller-savecallee-saveレジスタ"><a href="./6-inst.html#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<h4 id="引数"><a class="header" href="#引数"><a href="./6-inst.html#arg-reg">引数</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<h3 id="プログラムカウンタ命令ポインタ"><a class="header" href="#プログラムカウンタ命令ポインタ">プログラムカウンタ（命令ポインタ）</a></h3>
<img src="figs/rip.svg" height="100px" id="fig:rip">
<h3 id="ステータスレジスタフラグレジスタ"><a class="header" href="#ステータスレジスタフラグレジスタ"><a href="./6-inst.html#status-reg">ステータスレジスタ（フラグレジスタ）</a></a></h3>
<img src="figs/rflags.svg" height="100px" id="fig:rflags">
<h4 id="本書で扱うフラグ"><a class="header" href="#本書で扱うフラグ">本書で扱うフラグ</a></h4>
<p>ステータスレジスタのうち，本書は以下の6つのフラグを扱います．
フラグの値が1になることを「フラグがセットされる」「フラグが立つ」と表現します．
またフラグの値が0になることを「フラグがクリアされる」「フラグが消える」と表現します．</p>
<div class="table-wrapper"><table><thead><tr><th>フラグ</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td><code>CF</code></td><td>キャリーフラグ</td><td>算術演算で結果の最上位ビットにキャリーかボローが生じるとセット．それ以外はクリア．符号<strong>なし</strong>整数演算でのオーバーフロー状態を表す．</td></tr>
<tr><td><code>OF</code></td><td>オーバーフローフラグ</td><td>符号ビット(MSB)を除いて，整数の演算結果が大きすぎるか小さすぎるかするとセット．それ以外はクリア．2の補数表現での符号<strong>あり</strong>整数演算のオーバーフロー状態を表す．</td></tr>
<tr><td><code>ZF</code></td><td>ゼロフラグ</td><td>結果がゼロの時にセット．それ以外はクリア．</td></tr>
<tr><td><code>SF</code></td><td>符号フラグ</td><td>符号あり整数の符号ビット(MSB)と同じ値をセット．(0は正の数，1は負の数であることを表す)</td></tr>
<tr><td><code>PF</code></td><td>パリティフラグ</td><td>結果の最下位バイトの値1のビットが偶数個あればセット，奇数個であればクリア．</td></tr>
<tr><td><code>AF</code></td><td>調整フラグ</td><td>算術演算で，結果のビット3にキャリーかボローが生じるとセット．それ以外はクリア．BCD演算で使用する(本書ではほとんど使いません)．</td></tr>
</tbody></table>
</div>
<h4 id="cfフラグが立つ例"><a class="header" href="#cfフラグが立つ例">CFフラグが立つ例</a></h4>
<pre><code class="language-x86asmatt"># asm/cf.s
    .text
    .globl main
    .type main, @function
main:
    movb $0xFF, %al
    addb $1, %al  # オーバーフローでCFが立つ
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g cf.s
$ gdb ./a.out
(gdb) b 8
Breakpoint 1 at 0x112d: file cf.s, line 8.
(gdb) r
Breakpoint 1, main () at cf.s:8
8	    ret
(gdb) p $al
$1 = ❶ 0
(gdb) p $eflags
$2 = [ ❷ CF PF AF ZF IF ]
(gdb) quit
</code></pre>
<img src="figs/cf.svg" height="150px" id="fig:cf">
<ul>
<li><code>movb $0xFF, %al</code>と<code>addb $1, %al</code>で，1バイト符号<strong>なし</strong>整数の加算<code>0xFF+1</code>をすると，オーバーフローが起きて<code>%al</code>の値は❶ 0になります．
(1バイト符号<strong>なし</strong>整数の範囲は0〜255です．<code>0xFF+1</code>は255+1=256となり
(1バイト符号<strong>なし</strong>整数として)オーバーフローが起きています)．</li>
<li><code>p $eflags</code>でステータスフラグを調べると，❷ CF フラグが立っています．</li>
</ul>
<h4 id="ofフラグが立つ例"><a class="header" href="#ofフラグが立つ例">OFフラグが立つ例</a></h4>
<pre><code class="language-x86asmatt"># asm/of.s
    .text
    .globl main
    .type main, @function
main:
    movb $0x7F, %al
    addb $1, %al  # オーバーフローでOFが立つ
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g of.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file of.s, line 6.
(gdb) r
Breakpoint 1, main () at of.s:6
6	    movb $0x7F, %al
(gdb) si
7	    addb $1, %al  # オーバーフローでOFが立つ
(gdb) si
main () at of.s:8
8	    ret
(gdb) p $al
$1 = ❶ -128
(gdb) p $eflags
$1 = [ AF SF IF ❷ OF ]
(gdb) ❸ p/u $al
$2 = ❹ 128
(gdb) quit
</code></pre>
<img src="figs/of.svg" height="150px" id="fig:of">
<ul>
<li><code>movb $0x7F, %al</code>と<code>addb $1, %al</code>で，1バイト符号<strong>あり</strong>整数の加算<code>0x7F+1</code>をすると，オーバーフローが起きて<code>%al</code>の値は❶ -128になります．
(1バイト符号<strong>あり</strong>整数の範囲は-128〜127です．<code>0x7F+1</code>は127+1=128となり
(1バイト符号<strong>あり</strong>整数として)オーバーフローが起きています)．</li>
<li><code>p $eflags</code>でステータスフラグを調べると，❷ OF フラグが立っています．</li>
<li>なお，符号なし(❸<code>u</code>)オプションをつけて<code>%al</code>レジスタの値を表示させると，
符号なしの結果として正しい❹ 128という結果になりました．
(x86-64は符号なし・符号ありを区別せず，どちらに対しても正しい結果を
計算します)．</li>
</ul>
<h3 id="レジスタの別名"><a class="header" href="#レジスタの別名">レジスタの別名</a></h3>
<h4 id="raxレジスタの別名-rbx-rcx-rdxも同様"><a class="header" href="#raxレジスタの別名-rbx-rcx-rdxも同様"><code>%rax</code>レジスタの別名 (<code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>も同様)</a></h4>
<img src="figs/reg-alias1.svg" height="150px" id="fig:reg-alias1">
<ul>
<li><code>%rax</code>の下位32ビットは<code>%eax</code>としてアクセス可能</li>
<li><code>%eax</code>の下位16ビットは<code>%ax</code>としてアクセス可能</li>
<li><code>%ax</code>の上位8ビットは<code>%ah</code>としてアクセス可能</li>
<li><code>%ax</code>の下位8ビットは<code>%al</code>としてアクセス可能</li>
</ul>
<p>xxx 具体例</p>
<h4 id="rbpレジスタの別名-rsp-rdi-rsiも同様"><a class="header" href="#rbpレジスタの別名-rsp-rdi-rsiも同様"><code>%rbp</code>レジスタの別名 (<code>%rsp</code>, <code>%rdi</code>, <code>%rsi</code>も同様)</a></h4>
<img src="figs/reg-alias2.svg" height="150px" id="fig:reg-alias2">
<ul>
<li><code>%rbp</code>の下位32ビットは<code>%ebp</code>としてアクセス可能</li>
<li><code>%ebp</code>の下位16ビットは<code>%bp</code>としてアクセス可能</li>
<li><code>%bp</code>の下位8ビットは<code>%bpl</code>としてアクセス可能</li>
</ul>
<h4 id="r8レジスタの別名-r9r15も同様"><a class="header" href="#r8レジスタの別名-r9r15も同様"><code>%r8</code>レジスタの別名 (<code>%r9</code>〜<code>%r15</code>も同様)</a></h4>
<img src="figs/reg-alias3.svg" height="150px" id="fig:reg-alias3">
<ul>
<li><code>%r8</code>の下位32ビットは<code>%r8d</code>としてアクセス可能</li>
<li><code>%r8d</code>の下位16ビットは<code>%r8w</code>としてアクセス可能</li>
<li><code>%r8w</code>の下位8ビットは<code>%r8b</code>としてアクセス可能</li>
</ul>
<h4 id="同時に使えない制限"><a class="header" href="#同時に使えない制限">同時に使えない制限</a></h4>
<ul>
<li>一部のレジスタは<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>と一緒には使えない．</li>
<li>例：<code>movb %ah, (%r8)</code> や <code>movb %ah, %bpl</code>はエラーになる．</li>
<li>正確には<code>REX</code>プレフィックス付きの命令では，<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>を使えない．</li>
</ul>
<h3 id="32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする"><a class="header" href="#32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする">32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする</a></h3>
<ul>
<li>例:<code>movl $0xAABBCCDD, %eax</code>を実行すると<code>%rax</code>の上位32ビットが全てゼロになる</li>
<li>例: <code>movw $0x1122, %ax</code>や<code>movb $0x11, %al</code>では上位をゼロにすることはない</li>
</ul>
<details>
<summary>
上位32ビットをゼロにする実行例
</summary>
<img src="figs/zero-upper32.svg" height="250px" id="fig:zero-upper32">
<pre><code class="language-x86asmatt"># asm/zero-upper32.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movl $0xAABBCCDD, %eax
    movq $0x1122334455667788, %rax
    movw $0x1122, %ax
    movq $0x1122334455667788, %rax
    movb $0x11, %al
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g zero-upper32.s
$ gdb ./a.out -x zero-upper32.txt
Breakpoint 1, main () at zero-upper32.s:7
7	    movl $0xAABBCCDD, %eax
6	    movq $0x1122334455667788, %rax
7	    movl $0xAABBCCDD, %eax
$1 = 0x1122334455667788
8	    movq $0x1122334455667788, %rax
$2 = 0xaabbccdd
# 以下が出力されれば成功
# $1 = 0x1122334455667788
# $2 = 0xaabbccdd
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 6; }
</style>
<h1 id="x86-64機械語命令"><a class="header" href="#x86-64機械語命令">x86-64機械語命令</a></h1>
<h2 id="how-to-execute-x86-inst"><a class="header" href="#how-to-execute-x86-inst">x86-64機械語命令の実行方法</a></h2>
<h3 id="概要デバッガ上で実行します"><a class="header" href="#概要デバッガ上で実行します">概要：デバッガ上で実行します</a></h3>
<p>機械語命令を実行しても，単に<code>a.out</code>を実行するだけでは
意図通りに実行できたかの確認が難しいです．
(アセンブリコード内から<code>printf</code>を呼び出せばいいのですが，
そのコードもうざいので)．
そこで本書では<strong>デバッガを使って</strong>機械語命令の実行と確認を行います．</p>
<p>以下では例として<code>movq $999, %rax</code>という機械語命令を実行してみます．
(これらのファイルは<a href="https://github.com/gondow/linux-x86-64-programming/tree/main/src/asm">サンプルコード</a>から入手できます)．
<code>movq $999, %rax</code>は「定数<code>999</code>を<code>%rax</code>レジスタに格納する」という命令ですので，
実行後，<code>%rax</code>レジスタに<code>999</code>という値が入っていれば，
うまく実行できたことを確認できます．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p>実行確認のための<code>gdb</code>のコマンド列を書いたファイルも用意しています．</p>
<div id="asm/movq-4.txt">
<pre><code># asm/movq-4.txt
b 7
r
list 6,6
p $rax
echo # %raxの値が999なら成功\n
quit
</code></pre>
</div>
<h3 id="デバッガ上で実行gdbコマンドを手入力"><a class="header" href="#デバッガ上で実行gdbコマンドを手入力">デバッガ上で実行：<code>gdb</code>コマンドを手入力</a></h3>
<p><code>asm/movq-4.txt</code>中の<code>gdb</code>コマンドを
以下のように1行ずつ入力してみて下さい．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶
(gdb) b 7 ❷
Breakpoint 1 at 0x1130: file movq-4.s, line 6.
(gdb) r ❸
Breakpoint 1, main () at movq-4.s:6
6	    ret
(gdb) list 6,6 ❹
5	    movq $999, %rax
(gdb) p $rax ❺
$1 = 999
(gdb) quit
</code></pre>
<ul>
<li>❶ コンパイルした<code>a.out</code>を<code>gdb</code>上で実行</li>
<li>❷ ブレークポイントを7行目(<code>movq $999, %rax</code>の次の行)に設定 (<code>b</code>はbreakの略)</li>
<li>❸ 実行開始 (<code>r</code> は run の略)</li>
<li>❹ ソースコードの6行目だけを表示</li>
<li>❺ レジスタ<code>%rax</code>の値を(10進表記で)表示 (<code>p</code>はprintの略)</li>
<li><a href="6-inst.html#asm/movq-4.txt"><code>movq-4.txt</code></a>
の最後の行 <code>echo # %raxの値が999なら成功\n</code>は，
「どうなると正しく実行できたか」を確認するメッセージを出力するコマンドですので，
ここでは入力不要です．
❺の結果と一致したので「正しい実行」と確認できました．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力--xオプションを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力--xオプションを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>-x</code>オプションを使う)</a></h3>
<p><code>gdb</code>コマンドを手入力して，よく使う<code>gdb</code>コマンドを覚えることは良いことです．
とはいえ，手入力は面倒なので，自動入力も使いましょう．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶ -x movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	 ❷ movq $999, %rax
❸ $1 = 999 
❹ # %raxの値が999なら成功
(gdb) 

</code></pre>
<ul>
<li>❶ <code>-x movq-4.txt</code> というオプションをつけると，指定したファイル(ここでは<code>movq-4.txt</code>)の中に書かれている<code>gdb</code>コマンドを1行ずつ順番に実行してくれます</li>
<li><code>list 6,6</code>を実行した結果，❷6行目の<code>movq $999, %rax</code> が表示されています</li>
<li><code>p $rax</code>を実行した結果，<code>%rax</code>レジスタの値が❸999であると表示されています．
(<code>$1</code>は<code>gdb</code>が扱う変数です．ここでは無視して下さい)</li>
<li><code>echo # %raxの値が999なら成功\n</code> を<code>gdb</code>が実行した結果，
❹ <code># %raxの値が999なら成功</code>というメッセージが表示されています．
このメッセージと❸の実行結果を見比べれば「実行結果が正しい」ことを確認できます．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>source</code>コマンドを使う)</a></h3>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) ❶ source movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	    movq $999, %rax
$1 = 999
# %raxの値が999なら成功
</code></pre>
<p><code>gdb</code>は通常通りに実行開始して，
❶ <code>source</code>コマンドを使えば，<code>movq-4.txt</code>中の<code>gdb</code>コマンドを実行できます．
<code>-x</code>オプションと<code>source</code>コマンドは好きな方を使って下さい．</p>
<h2 id="アドレッシングモード-オペランドの表記方法"><a class="header" href="#アドレッシングモード-オペランドの表記方法">アドレッシングモード (オペランドの表記方法)</a></h2>
<h3 id="アドレッシングモードの概要"><a class="header" href="#アドレッシングモードの概要">アドレッシングモードの概要</a></h3>
<p>機械語命令は命令(<strong>オペコード</strong>(opcode))と
その引数の<strong>オペランド</strong>(operand)から構成されています．
例えば，<code>movq $999, %rax</code>という命令では，
<code>movq</code>がオペコードで，<code>$999</code>と<code>%rax</code>がオペランドです．</p>
<img src="figs/opcode-operand.svg" height="100px" id="fig:opcode-operand">
<p><strong>アドレッシングモード</strong>とはオペランドの書き方のことです．
(元々は「メモリのアドレスを指定する記法」という意味で「アドレッシングモード」という用語が使われています).
x86-64では大きく，以下の4種類の書き方ができます．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="6-inst.html#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="6-inst.html#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="6-inst.html#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td></tr>
<tr><td><code>movq foo, %rax</code></td></tr>
<tr><td rowspan="3">
<p><a href="6-inst.html#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベル（その値はアドレス）であり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="addr-mode-imm"><a class="header" href="#addr-mode-imm">アドレッシングモード：即値（定数）</a></h3>
<h4 id="定数-999"><a class="header" href="#定数-999">定数 <code>$999</code></a></h4>
<p><strong>即値</strong>(immediate value，定数)には<code>$</code>をつけます．
例えば<code>$999</code>は定数<code>999</code>を意味します．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-4.s"><code>movq-4.s</code></a>の6行目の
<code>movq $999, %rax</code>は「定数<code>999</code>をレジスタ<code>%rax</code>に格納する」という意味です．
デバッガで動作を確認します
(デバッガの操作手順は<a href="./asm/movq-4.txt"><code>movq-4.txt</code></a>にもあります)．</p>
<pre><code>$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-4.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-4.s:6
6	    movq $999, %rax
(gdb) si
main () at movq-4.s:7
7	    ret
(gdb) p $rax
$1 = 999
</code></pre>
<p>確かに<code>%rax</code>レジスタ中に<code>999</code>が格納されていました．</p>
<p>なお，多くの場合，即値は32ビットまでで，オペランドのサイズが64ビットの場合，
32ビットの即値は，64ビットの演算前に
<strong>64ビットに<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">符号拡張</a></strong> されます
(<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a>だと
負の値が大きな正の値になって困るからです)．
64ビットに符号拡張される例は<a href="x86-list.html#imm-64bit-signed-extended">こちら</a>
を見て下さい．
例外は<code>movq</code>命令で，64ビットの即値を扱えます．
実行例は<a href="x86-list.html#mov-64bit-imm">こちら</a>を見て下さい．</p>
<h4 id="ラベル-main"><a class="header" href="#ラベル-main">ラベル <code>$main</code></a></h4>
<p>定数が書ける場所にはラベル(その値はアドレス)も書けます．
ラベルは関数名やグローバル変数の実体があるメモリの先頭番地を
示すために使われます(それ以外にはジャンプのジャンプ先としても使われます)．
ですので，<code>main</code>関数の先頭番地を示す<code>main</code>というラベルが
<code>main</code>関数をコンパイルしたアセンブリコード中に存在します．</p>
<pre><code class="language-x86asmatt"># asm/movq-6.s
    .text
    .globl main
    .type main, @function
main:
    movq $main, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-6.s">movq-6.s</a>の6行目の<code>movq $main, %rax</code>は
「ラベル<code>main</code>が表すアドレスを<code>%rax</code>レジスタに格納する」という意味です．
<code>gdb</code>で確かめます．</p>
<pre><code>$ gcc ❶ -no-pie -g movq-6.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at ❷ 0x40110a: file movq-6.s, line 7.
(gdb) r
Breakpoint 1, main () at movq-6.s:7
7   ❸  movq $main, %rax
(gdb) ❹ si
main () at movq-6.s:8
8	ret
(gdb) p/x $rax
$1 = ❺ 0x40110a 
</code></pre>
<ul>
<li>まず❶ <code>-no-pie</code>オプションをつけてコンパイルして下さい．
(<code>-static</code>オプションを使ってもうまくいくと思います)</li>
</ul>
<details>
<summary>
なぜ -no-pieオプション
</summary>
<p><code>-no-pie</code>オプションをつけないと以下のエラーが出てしまうからです．</p>
<pre><code>$ gcc -g movq-6.s
/usr/bin/ld: /tmp/ccqHsPbg.o: relocation R_X86_64_32S against symbol `main' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld: failed to set dynamic section sizes: bad value
collect2: error: ld returned 1 exit status
</code></pre>
<p><code>-no-pie</code>は「位置独立実行可能ファイル
(<a href="./3-binary.html#ASLR-PIE">PIE</a>，<a href="./3-binary.html#PIE">PIE</a>)を生成しない」
というオプションです．
最近のLinuxの<code>gcc</code>では，PIEがデフォルトで有効になっている事が多いです．
<a href="./3-binary.html#PIC">PIC</a>(位置独立コード)やPIEは「再配置(アドレス調整)無しに
どのメモリ番地に配置しても，そのまま実行可能」という機械語命令列です．
そのため，PIEやPICのメモリ参照では<strong>絶対アドレス</strong>(absolute address)が使えません．</p>
<p><code>-no-pie</code>オプションが無いと，
アセンブラは<code>movq $main, %rax</code>という命令中の<code>main</code>というラベルを
「絶対アドレスだ」と解釈してエラーにするようです．</p>
<details>
<summary>
絶対アドレス，相対アドレスとは
</summary>
<div id="絶対アドレス・相対アドレス">
<img src="figs/absolute-addr.svg" height="250px" id="fig:absolute-addr">
<p><strong>絶対アドレス</strong>とは「メモリの先頭0番地から何バイト目か」で示すアドレスです．
上図で青色のメモリ位置の絶対アドレスは<code>0x1000</code>番地となります．
一方，<strong>相対アドレス</strong>(relative address)は(0番地ではなく)別の何かを起点とした差分のアドレスです．
x86-64では<code>%rip</code>レジスタ(プログラムカウンタ)を起点とすることが多いです．
上図では青色のメモリ位置の相対アドレスは
<code>%rip</code>を起点とすると，<code>-0x500</code>番地となります(<code>0x1000 - 0x1500 = -0x500</code>)．</p>
<p>また，相対アドレスに起点のアドレスを足すと絶対アドレスになります
(<code>-0x500 + 0x1500 = 0x1000</code>)．</p>
</div>
</details>
<p>なぜ PICやPIEで絶対アドレスが使えないかと言うと，
機械語命令列を何番地に置くかで，絶対アドレスが変化してしまうからです．</p>
<details>
<summary>
もうちょっと具体的に
</summary>
<p>例えば，<code>movq $main, %rax</code>という命令は
<code>main</code>関数のアドレスを<code>%rax</code>レジスタに格納するわけですが，
このアドレスが絶対アドレスの場合，出力される機械語命令に
絶対アドレスが埋め込まれてしまいます．</p>
<pre><code>$ gcc -no-pie -g movq-6.s
$ objdump -d ./a.out
(一部略)
000000000040110a &lt;main&gt;:
  40110a:  48 c7 c0 ❷ 0a 11 40 00    mov ❶$0x40110a,%rax
  401111:  c3                        ret    
</code></pre>
<p>上の逆アセンブル結果を見ると，確かに<code>main</code>関数のアドレス❶ <code>0x40110a</code>が
機械語命令列に❷埋め込まれています．
(x86-64は<a href="./3-binary.html#LSB">リトルエンディアン</a>なので，バイトの並びが逆順に見えることに注意)．</p>
<p>相対アドレスだと大丈夫なことも見てみます．
<a href="./asm/leaq-1.s"><code>leaq-1.s</code></a>中の
<code>leaq main(%rip), %rax</code>は，
「<code>%rip</code>を起点とした<code>main</code>の相対アドレスと，
<code>%rip</code>の値との和を<code>%rax</code>レジスタに格納する」という命令です．
(<code>lea</code> は load effective address の略です．effective addressは日本語では<strong>実効アドレス</strong>です)．</p>
<pre><code class="language-x86asmatt"># asm/leaq-1.s
    .text
    .globl main
    .type main, @function
main:
    leaq main(%rip), %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g leaq-1.s
$ objdump -d ./a.out
(一部略)
0000000000001129 &lt;main&gt;:
 ❶ 1129:  48 8d 05 ❸ f9 ff ff ff    lea    ❷ -0x7(%rip),%rax  # 1129 &lt;main&gt;
 ❹ 1130:  c3                      ret    
</code></pre>
<p>上のように逆アセンブルすると以下が分かります．</p>
<ul>
<li><code>main</code>関数の(ファイル<code>a.out</code>中での)アドレスは❶ <code>0x1129</code>番地</li>
<li><code>leaq main(%rip), %rax</code>の <code>%rip</code>の値は❸ <code>0x1130</code>番地
(プログラムカウンタ <code>%rip</code>は「次に実行する機械語命令のアドレス」を保持しています)．</li>
<li>機械語命令に埋め込まれているアドレスは相対アドレスで，
❶ <code>0x1129</code> - ❸ <code>0x1130</code> = ❷ <code>-0x7</code> = ❸ <code>0xFFFFFFF9</code> です．</li>
</ul>
<p>❶ <code>0x1129</code> や ❹ <code>0x1130</code> のアドレスは，
<code>main</code>関数がどのアドレスに配置されるかで変化します．
しかし，この相対アドレス❷ <code>-0x7</code> は
<code>main</code>関数がどのアドレスに配置されても変化しないので，
この機械語命令はPICやPIEとして使えるわけです．</p>
<p>❷ <code>-0x7</code> が ❸ <code>0xFFFFFFF9</code> として埋め込まれているのは，
<a href="xxx">2の補数表現</a>だからですね</p>
<p>なお，相対アドレスが固定にならない場合(例えば，<code>printf</code>関数のアドレス)もあります．
その場合は<a href="./3-binary.html#GOT-PLT">GOTやPLT</a>を使います．
<code>printf</code>関数のアドレスを機械語命令列(<code>.text</code>セクション)に埋め込むのではなく，
別の書込み可能なセクション(例：<code>got</code>セクション)に格納し，
そのアドレスを使って<strong>間接コール</strong>(indirect call)するのです．</p>
</details>
</details>
<details>
<summary>
-staticオプションとは
</summary>
<p><code>-static</code>オプションは(動的リンクではなく)
<a href="./3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
せよという，<code>gcc</code>への指示になります．</p>
</details>
<ul>
<li>
<p><code>main</code>関数の先頭にブレークポイントを設定します．
<code>main</code>関数の先頭アドレスが❷ <code>0x40110a</code>と分かります．</p>
</li>
<li>
<p>❸ <code>movq $main, %rax</code>の実行直前で止まっているので，
❹ <code>si</code>で1命令実行を進めます．</p>
</li>
<li>
<p>❺ <code>%rax</code>レジスタ中に<code>main</code>関数のアドレス❷ <code>0x40110a</code>が入っていました．</p>
</li>
</ul>
<h3 id="addr-mode-reg"><a class="header" href="#addr-mode-reg">アドレッシングモード：レジスタ参照</a></h3>
<pre><code class="language-x86asmatt"># asm/movq-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    movq %rax, %rbx
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-1.s"><code>movq-1.s</code></a>中の<code>movq %rax, %rbx</code>は
「<code>%rax</code>レジスタ中の値を<code>%rbx</code>に格納する」という意味です．</p>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-1.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-1.s:6
6	    ❶ movq $999, %rax
(gdb) si
7	    ❷ movq %rax, %rbx
(gdb) si
main () at movq-1.s:8
8	    ret
(gdb) p $rax
$1 = ❸ 999
(gdb) p $rbx
$2 = ❹ 999
</code></pre>
<p><code>gdb</code>上での実行で，❶ 定数<code>999</code>が<code>%rax</code>に格納され，
❷ <code>%rax</code>中の<code>999</code>がさらに<code>%rbx</code>に格納されたことを
❸❹確認できました．</p>
<h3 id="addr-mode-direct"><a class="header" href="#addr-mode-direct">アドレッシングモード：直接メモリ参照</a></h3>
<p><strong>直接メモリ参照</strong>はアクセスするメモリ番地が定数となるメモリ参照です．
以下の例ではラベル<code>x</code>を使ってメモリ参照していますが，
これは直接メモリ参照になります．
アセンブル時に(つまり実行する前に)アドレスが具体的に(以下では<code>0x404028</code>番地)と決まるからです．</p>
<pre><code class="language-x86asmatt"># asm/movq-7.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-7.s
$ gdb ./a.out -x movq-7.txt
Breakpoint 1, main () at movq-7.s:10
10	    ret
9	    movq x, %rax
$1 = ❶ 999
# %raxの値が999なら成功
</code></pre>
<p>以下の図で<code>0x401106&lt;main&gt;</code>は「ラベル<code>main</code>が示すアドレスは<code>0x401106</code>番地」
「ラベル<code>x</code>が示すアドレスは<code>0x404028</code>番地」であることを示してます．</p>
<img src="figs/label2.svg" height="250px" id="fig:label2">
<p>そして<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の以下の3行で，以下は</p>
<pre><code class="language-x86asmatt">    .data
x:
    .quad 999 
</code></pre>
<p>「<code>.data</code>セクションにサイズが8バイトのデータとして値<code>999</code>を配置せよ」
「そのデータの先頭アドレスをラベル<code>x</code>として定義せよ」を意味しています
(<code>quad</code>が8バイトを意味しています)．
ですので，実行時には上図のように
「<code>.data</code>セクションのある場所(上図では<code>0x404028</code>番地)に値<code>999</code>が入っていて，
ラベル<code>x</code>の値は<code>0x404028</code>」となっています．</p>
<p>ですので，<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の<code>movq x, %rax</code>は
「ラベル<code>x</code>が表すアドレス(上図では<code>0x404028</code>番地)のメモリの中身(上図では<code>999</code>)
を<code>%rax</code>レジスタにコピーせよ」を意味します．</p>
<p>実行すると<code>movq x, %rax</code>の実行で，<code>x</code>中の<code>999</code>が<code>%rax</code>レジスタに
コピーされたことを確認できました❶．</p>
<p>ここで$マークの有無，つまり<code>x</code>と<code>$x</code>の違いに注意しましょう
(<a href="6-inst.html#label2">上図</a>も参照)．</p>
<pre><code class="language-x86asmatt">movq x, %rax    # x はメモリの中身を表す
movq $x, %rax   # $x はアドレスを表す
</code></pre>
<p>以下のように<code>movq $x, %rax</code>を実行すると，
<code>%rax</code>レジスタにはアドレス(ここでは<code>0x404028</code>番地)が
入っていることを確認できました❷．</p>
<details>
<summary>
-8(%rbp)の-8には(定数なのに)$マークが付かない
</summary>
<p><a href="6-inst.html#addr-mode-indirect">以下</a>でも説明しますが，
例えば<code>-8(%rbp)</code>とオペランドに書いた時，<code>-8</code>は($マークが無いのに)
定数として扱われます．
そして，<code>-8(%rbp)</code>は，<code>%rbp - 8</code>の計算結果をアドレスとするメモリの中身を意味します．　
ちなみにこの<code>-8</code>のことは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>では<strong>変位</strong> (displacement)と呼ばれています．
つまり「変位は定数だけど$マークはつきません」．</p>
</details>
<pre><code class="language-x86asmatt"># asm/movq-8.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq $x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-8.s
$ gdb ./a.out -x movq-8.txt
Breakpoint 1, main () at movq-8.s:10
10	    ret
9	    movq $x, %rax
$1 = 0x404028 ❷
nm ./a.out | egrep 'd x'
0000000000404028 d x
# %raxの値と nmコマンドによるxのアドレスが一致すれば成功
</code></pre>
<p>ちなみに，<code>x</code>のアドレスが<code>0x404028</code>になると分かっていれば，</p>
<pre><code class="language-x86asmatt">movq x, %rax          # これと
movq 0x404028, %rax   # これは同じ意味
</code></pre>
<p>上の2行は全く同じ意味(<code>0x404028</code>番地のメモリの中身)になります．
しかし，何番地になるか事前に分からないのが普通なので，
通常はラベル(ここでは<code>x</code>)を使います．</p>
<h3 id="addr-mode-indirect"><a class="header" href="#addr-mode-indirect">アドレッシングモード：間接メモリ参照</a></h3>
<p><strong>間接メモリ参照</strong>はアクセスするメモリ番地が変数となるメモリ参照です．
アセンブリ言語では変数という概念は無いので，
正確には「実行時に決まるレジスタの値を使って，
参照先のメモリアドレスを計算して決める」という参照方式です．
以下では3つの例が出てきます(<a href="6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>でより複雑な間接メモリ参照を説明します)．</p>
<div class="table-wrapper"><table><thead><tr><th>間接メモリ参照</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>(%rsp)</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>8(%rsp)</code></td><td><code>%rsp + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>%rip + foo</code></td></tr>
</tbody></table>
</div><br/>
<img src="figs/addr-mode-indirect.svg" height="250px" id="fig:addr-mode-indirect">
<p>以下の<a href="./asm/movq-9.s">movq-9.s</a>を<code>pushq $777</code>まで実行すると，
メモリの状態は上図のようになっています．
(<code>%rsp</code>が指す<code>777</code>のひとつ下のアドレスが<code>%rsp+8</code>なのは，
<code>pushq $777</code>命令が「サイズが8バイトの値<code>777</code>をスタックにプッシュしたから」です)．</p>
<pre><code class="language-x86asmatt"># asm/movq-9.s
    .data
foo:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    pushq $888
    pushq $777
    movq (%rsp), %rax
    movq 8(%rsp), %rbx
    movq foo(%rip), %rcx
    ret
    .size main, .-main
</code></pre>
<ul>
<li><code>(%rsp)</code> は「アドレスが <code>%rsp</code>の値のメモリ」なので値<code>777</code>が入っている部分を参照します</li>
<li><code>8(%rsp)</code> は「アドレスが <code>%rsp + 8</code>の値のメモリ」なので値<code>888</code>が入っている部分を参照します</li>
<li><code>foo(%rip)</code> はちょっと特殊です．この形式は <strong><code>%rip</code>相対アドレッシング</strong> といいます．
この形式の時，ラベル<code>foo</code>の値はプログラムカウンタ<code>%rip</code>中のアドレスを起点とした
<a href="6-inst.html#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">相対アドレス</a>
になります．ですので，<code>%rip + foo</code>は<code>foo</code>の
<a href="6-inst.html#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">絶対アドレス</a>
になるので，
<code>foo(%rip)</code>はラベル<code>foo</code>のメモリ部分，つまり<code>999</code>が入っている部分になります．</li>
</ul>
<details>
<summary>
gdbでの実行結果
</summary>
<pre><code>$ gcc -g movq-9.s
$ gdb ./a.out -x movq-9.txt
Breakpoint 1, main () at movq-9.s:14
14	    ret
11	    movq (%rsp), %rax
12	    movq 8(%rsp), %rbx
13	    movq foo(%rip), %rcx
$1 = 777
$2 = 888
$3 = 999
# 777, 888, 999なら成功
</code></pre>
</details>
<h3 id="メモリ参照"><a class="header" href="#メモリ参照">メモリ参照</a></h3>
<p><a href="6-inst.html#addr-mode-indirect">前節</a>では，
<code>(%rsp)</code>，<code>8(%rsp)</code>，<code>foo(%rip)</code>という間接メモリ参照の例を説明しました．
ここではメモリ参照の一般形を説明します．
以下がx86-64のメモリ参照の形式です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div><details>
<summary>
「segment: メモリ参照」という形式
</summary>
<p>実は「segment: メモリ参照」という形式もあるのですが，
あまり使わないので，ここでは省いて説明します．
興味のある人は<a href="x86-list.html#segment-override">こちら</a>を参照下さい．</p>
</details>
<p>disp (base, index, scale)
でアクセスするメモリのアドレスは
base + index * scale + disp で計算します．
disp(<code>%rip</code>)でアクセスするメモリのアドレスは
disp + <code>%rip</code>で計算します．
disp，base，index，scaleとして指定可能なものは次の節で説明します．</p>
<h3 id="メモリ参照で可能な組み合わせ64ビットモードの場合"><a class="header" href="#メモリ参照で可能な組み合わせ64ビットモードの場合">メモリ参照で可能な組み合わせ(64ビットモードの場合)</a></h3>
<h4 id="通常のメモリ参照"><a class="header" href="#通常のメモリ参照">通常のメモリ参照</a></h4>
<p>通常のメモリ参照では，disp，base，index，scaleに以下を指定できます．</p>
<img src="figs/memory-ref.svg" height="250px" id="fig:memory-ref">
<ul>
<li>disp には符号あり定数を指定する．ただし「64ビット定数」は無いことに注意．
アドレス計算時に64ビット長に符号拡張される．
dispは変位(displacement)を意味する．</li>
<li>base には上記のいずれかのレジスタを指定可能．省略も可．</li>
<li>index には上記のいずれかのレジスタを指定可能．省略も可．
<code>%rsp</code>を指定できないことに注意．</li>
<li>scale を省略すると <code>1</code> と同じ</li>
</ul>
<blockquote>
<p>注: dispの例外．
<code>mov␣</code>命令のみ，64ビットのdispを指定可能．
この場合，<code>movabs␣</code>というニモニックを使用可能．
(<code>abs</code>はおそらく絶対アドレス absolute address から)．
メモリ参照はdispのみで，base，index，scaleは指定不可．
他方のオペランドは<code>%rax</code>のみ指定可能．</p>
<pre><code>movq     0x1122334455667788, %rax
movabsq  0x1122334455667788, %rax
movq     %rax, 0x1122334455667788
movabsq  %rax, 0x1122334455667788
</code></pre>
</blockquote>
<h4 id="rip相対参照"><a class="header" href="#rip相対参照"><code>%rip</code>相対参照</a></h4>
<img src="figs/rip-relative.svg" height="120px" id="fig:rip-relative">
<p><code>%rip</code>相対参照では32ビットのdispと<code>%rip</code>レジスタのみが指定可能です．</p>
<h3 id="メモリ参照の例"><a class="header" href="#メモリ参照の例">メモリ参照の例</a></h3>
<p>以下がメモリ参照の例です．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>指定したもの</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>8</code></td><td><code>[8]</code></td><td>disp</td><td><code>8</code></td></tr>
<tr><td><code>foo</code></td><td><code>[foo]</code></td><td>disp</td><td><code>foo</code></td></tr>
<tr><td><code>(%rbp)</code></td><td><code>[rbp]</code></td><td>base</td><td><code>%rbp</code></td></tr>
<tr><td><code>8(%rbp)</code></td><td><code>[rbp+8]</code></td><td>dispとbase</td><td><code>%rbp + 8</code></td></tr>
<tr><td><code>foo(%rbp)</code></td><td><code>[rbp+foo]</code></td><td>dispとbase</td><td><code>%rbp + foo</code></td></tr>
<tr><td><code>8(%rbp,%rax)</code></td><td><code>[rbp+rax+8]</code></td><td>dispとbaseとindex</td><td><code>%rbp + %rax + 8</code></td></tr>
<tr><td><code>8(%rbp,%rax, 2)</code></td><td><code>[rbp+rax*2+8]</code></td><td>dispとbaseとindexとscale</td><td><code>%rbp + %rax*2 + 8</code></td></tr>
<tr><td><code>(%rip)</code></td><td><code>[rip]</code></td><td>base</td><td><code>%rip</code></td></tr>
<tr><td><code>8(%rip)</code></td><td><code>[rip+8]</code></td><td>dispとbase</td><td><code>%rip + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>[rip+foo]</code></td><td>dispとbase</td><td><code>%rip + foo</code></td></tr>
<tr><td><code>%fs:-4</code></td><td><code>fs:[-4]</code></td><td><a href="./x86-list.html#segment-override">segment</a>とdisp</td><td><code>%fsのベースレジスタ - 4</code></td></tr>
</tbody></table>
</div><details>
<summary>
なんでこんな複雑なアドレッシングモード?
</summary>
<p>x86-64はRISCではなくCISCなので「よく使う1つの命令で複雑な処理が
できれば，それは善」という思想だからです(知らんけど)．
例えば，以下のCコードの配列<code>array[i]</code>へのアクセスはアセンブリコードで
<code>movl (%rdi,%rsi,4), %eax</code>の1命令で済みます．
(ここでは<code>sizeof(int)</code>が<code>4</code>なので，scaleが<code>4</code>になっています．
配列の先頭アドレスが<code>array</code>の，<code>i</code>番目の要素のアドレスは，
<code>array + i * sizeof(int)</code>で計算できることを思い出しましょう．
なお，<code>array.s</code>の出力を得るには，<code>gcc -S -O2 array.c</code>として下さい．
私の環境では<code>-O2</code>が無いと<code>gcc</code>は冗長なコードを吐きましたので)．</p>
<pre><code>// array.c
int foo (int array [], int i)
{
    return array [i];
}
</code></pre>
<pre><code>	.text
	.p2align 4
	.globl	foo
	.type	foo, @function
foo:
	endbr64
	movslq	%esi, %rsi
	movl	(%rdi,%rsi,4), %eax
	ret
	.size	foo, .-foo
</code></pre>
</details>
<h2 id="オペランドの表記方法"><a class="header" href="#オペランドの表記方法">オペランドの表記方法</a></h2>
<p>以下の機械語命令の説明で使う記法を説明します．
この記法はその命令に許されるオペランドの形式を表します．</p>
<h3 id="オペランド即値定数"><a class="header" href="#オペランド即値定数">オペランド，即値(定数)</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*op1*|  | 第1オペランド |
|*op2*|  | 第2オペランド |
|*imm*| `$100` |  *imm8*, *imm16*, *imm32*のどれか |
|*imm8*| `$100` | 8ビットの即値(定数) |
|*imm16*| `$100` | 16ビットの即値(定数) |
|*imm32*| `$100` | 32ビットの即値(定数) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>op1</em></td><td></td><td>第1オペランド</td></tr>
<tr><td><em>op2</em></td><td></td><td>第2オペランド</td></tr>
<tr><td rowspan="2"><em>imm</em></td><td><code>$100</code></td><td rowspan="2"><em>imm8</em>, <em>imm16</em>, <em>imm32</em>のどれか</td></tr>
<tr><td><code>$foo</code></td></tr>
<tr><td><em>imm8</em></td><td><code>$100</code></td><td>8ビットの即値(定数)</td></tr> 
<tr><td><em>imm16</em></td><td><code>$100</code></td><td>16ビットの即値(定数)</td></tr>
<tr><td><em>imm32</em></td><td><code>$100</code></td><td>32ビットの即値(定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>多くの場合，サイズを省略して単に<em>imm</em>と書きます．
特にサイズに注意が必要な時だけ，<em>imm32</em>などとサイズを明記します．</li>
<li><a href="./x86-list.html#mov-64bit-imm">一部例外を除き</a>，
x86-64では64ビットの即値を書けません(32ビットまでです)．</li>
</ul>
<h3 id="汎用レジスタ-1"><a class="header" href="#汎用レジスタ-1">汎用レジスタ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>r</em></td><td><code>%rax</code></td><td><em>r8</em>, <em>r16</em>, <em>r32</em>, <em>r64</em>のどれか</td></tr>
<tr><td><em>r8</em></td><td><code>%al</code></td><td>8ビットの汎用レジスタ</td></tr>
<tr><td><em>r16</em></td><td><code>%ax</code></td><td>16ビットの汎用レジスタ</td></tr>
<tr><td><em>r32</em></td><td><code>%eax</code></td><td>32ビットの汎用レジスタ</td></tr>
<tr><td><em>r64</em></td><td><code>%rax</code></td><td>64ビットの汎用レジスタ</td></tr>
</tbody></table>
</div>
<h3 id="メモリ参照-1"><a class="header" href="#メモリ参照-1">メモリ参照</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*r/m*  | `-8(%rbp)` |  *r/m8*, *r/m16*, *r/m32*, *r/m64*のどれか |
|*r/m8* | `-8(%rbp)` | *r8*  または 8ビットのメモリ参照 |
|*r/m16*| `-8(%rbp)` | *r16* または16ビットのメモリ参照 |
|*r/m32*| `-8(%rbp)` | *r32* または32ビットのメモリ参照 |
|*r/m64*| `-8(%rbp)` | *r64* または64ビットのメモリ参照 |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="4"><em>r/m</em></td><td><code>%rbp</code></td><td rowspan="4"><em>r/m8</em>, <em>r/m16</em>, <em>r/m32</em>, <em>r/m32</em>, <em>r/m64</em>のどれか</td></tr>
<tr><td><code>100</code></td></tr>
<tr><td><code>-8(%rbp)</code></td></tr>
<tr><td><code>foo(%rbp)</code></td></tr>
<tr><td><em>r/m8</em></td><td><code>-8(%rbp)</code></td><td><em>r8</em>  または 8ビットのメモリ参照</td></tr>
<tr><td><em>r/m16</em></td><td><code>-8(%rbp)</code></td><td><em>r16</em> また
は16ビットのメモリ参照</td></tr>
<tr><td><em>r/m32</em></td><td><code>-8(%rbp)</code></td><td><em>r32</em> また
は32ビットのメモリ参照</td></tr>
<tr><td><em>r/m64</em></td><td><code>-8(%rbp)</code></td><td><em>r64</em> また
は64ビットのメモリ参照</td></tr>
<tr><td><em>m</em></td><td><code>-8(%rbp)</code></td><td> メモリ参照</td></tr>
</tbody></table>
</div>
<h2 id="x86-64機械語命令転送など"><a class="header" href="#x86-64機械語命令転送など">x86-64機械語命令：転送など</a></h2>
<h3 id="nop命令-何もしない"><a class="header" href="#nop命令-何もしない"><code>nop</code>命令: 何もしない</a></h3>
<p><code>nop</code>は転送命令ではありませんが，最も簡単な命令ですので最初に説明します．</p>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
<tr><td><strong><code>nop</code></strong> <em>op1</em></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td><code>nop</code></td><td>何もしない</td><td><a href="./asm/nop.s">nop.s</a> <a href="./asm/nop.txt">nop.txt</a></td></tr>
<tr><td><strong><code>nop</code></strong> <em>r/m</em></td><td><code>nopl (%rax)</code></td><td>何もしない</td><td><a href="./asm/nop2.s">nop2.s</a> <a href="./asm/nop2.txt">nop2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./5-arch.html#status-reg">CF</a></th><th><a href="./5-arch.html#status-reg">OF</a></th><th><a href="./5-arch.html#status-reg">SF</a></th><th><a href="./5-arch.html#status-reg">ZF</a></th><th><a href="./5-arch.html#status-reg">PF</a></th><th><a href="./5-arch.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
<ul>
<li><code>nop</code>は何もしない命令です(ただしプログラムカウンタ<code>%rip</code>は増加します)．
フラグも変化しません．</li>
<li>機械語命令列の間を(何もせずに)埋めるために使います．</li>
<li><code>nop</code>の機械語命令は1バイト長です．
(なのでどんな長さの隙間にも埋められます)．</li>
<li><code>nop</code> <em>r/m</em> という形式の命令は2〜9バイト長の<code>nop</code>命令になります．
1バイト長の<code>nop</code>を9個並べるより，
9バイト長の<code>nop</code>を1個並べた方が，実行が早くなります．</li>
<li>「複数バイトの<code>nop</code>命令がある」という知識は，
逆アセンブル時に<code>nopl (%rax)</code>などを見て「なんじゃこりゃ」とビックリしないために必要です．</li>
</ul>
<h3 id="mov命令-データの転送コピー"><a class="header" href="#mov命令-データの転送コピー"><code>mov</code>命令: データの転送（コピー）</a></h3>
<div id="mov-plain">
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E6%96%87%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td><a href="./asm/movq-1.s">movq-1.s</a> <a href="./asm/movq-1.txt">movq-1.txt</a></td></tr>
<tr><td><code>movq %rax, -8(%rsp)</code></td><td><code>*(%rsp - 8) = %rax</code></td><td><a href="./asm/movq-2.s">movq-2.s</a> <a href="./asm/movq-2.txt">movq-2.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq -8(%rsp), %rax</code></td><td><code>%rax = *(%rsp - 8)</code></td><td><a href="./asm/movq-3.s">movq-3.s</a> <a href="./asm/movq-3.txt">movq-3.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, -8(%rsp)</code></td><td><code>*(%rsp - 8) = 999</code></td><td><a href="./asm/movq-5.s">movq-5.s</a> <a href="./asm/movq-5.txt">movq-5.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
</div>
<ul>
<li><code>mov</code>命令は第1オペランドの値を第2オペランドに転送(コピー)します．
例えば，<code>movq %rax, %rbx</code>は「<code>%rax</code>の値を<code>%rbx</code>にコピー」することを意味します．</li>
</ul>
<details>
<summary>
movq-1.sの実行例
</summary>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out -x movq-1.txt
Breakpoint 1, main () at movq-1.s:8
8	    ret
7	    movq %rax, %rbx
# p $rbx
$1 = 999
# %rbxの値が999なら成功
</code></pre>
</details>
<details>
<summary>
movq-2.sの実行例
</summary>
<pre><code>$ gcc -g movq-2.s
$ gdb ./a.out -x movq-2.txt
Breakpoint 1, main () at movq-2.s:8
8	    ret
7	    movq %rax, -8(%rsp)
# x/1gd $rsp-8
0x7fffffffde90:	999
# -8(%rsp)の値が999なら成功
</code></pre>
</details>
<ul>
<li>
<p>オペランドには，即値，レジスタ，メモリ参照を組み合わせて指定できますが，
メモリからメモリへの直接データ転送はできません．</p>
</li>
<li>
<p><code>␣</code>には<a href="./x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a>
(<code>q</code>, <code>l</code>, <code>w</code>, <code>b</code>)を指定します．
命令サフィックスは転送するデータのサイズを明示します
(順番に，8バイト，4バイト，2バイト，1バイトを示します)．</p>
<ul>
<li><code>movb $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>1バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movw $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>2バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movl $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>4バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movq $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>8バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
</ul>
</li>
</ul>
<form class="tab-wrap">
    <input id="mov1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="mov1"><code>movb $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov1.svg" height="300px" id="fig:mov1">
    </div>
    <input id="mov2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov2"><code>movw $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov2.svg" height="300px" id="fig:mov2">
    </div>
    <input id="mov3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov3"><code>movl $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov3.svg" height="300px" id="fig:mov3">
    </div>
    <input id="mov4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov4"><code>movq $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov4.svg" height="300px" id="fig:mov4">
    </div>
</form>
<h4 id="機械語命令のバイト列をアセンブリコードに直書きできる"><a class="header" href="#機械語命令のバイト列をアセンブリコードに直書きできる">機械語命令のバイト列をアセンブリコードに直書きできる</a></h4>
<p><code>movq %rax, %rbx</code>をコンパイルして逆アセンブルすると，
機械語命令のバイト列は<code>48 89 C3</code>となります．
<code>.byte</code>というアセンブラ命令を使うと，
アセンブラに指定したバイト列を出力できます．
例えば，次のように<code>.byte 0x48, 0x89, 0xC3</code>と書くと，
<code>.text</code>セクションに<code>0x48, 0x89, 0xC3</code>というバイト列を出力できます．</p>
<pre><code class="language-x86asmatt"># asm/byte.s
    .text
    .globl main
    .type main, @function
main:
    movq %rax, %rbx          # これと
    .byte 0x48, 0x89, 0xC3   # これは同じ意味
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:   ❶48 89 c3     ❸mov    %rax,%rbx
    112c:   ❷48 89 c3     ❹mov    %rax,%rbx
    112f:   c3               ret    
</code></pre>
<p>コンパイルして逆アセンブルしてみると，
❷<code>0x48, 0x89, 0xC3</code>を出力できています．
一方，❶<code>0x48, 0x89, 0xC3</code>にも同じバイト列が並んでいます．
これは❸<code>movq %rax, %rbx</code>命令の機械語命令バイト列ですね．
さらに❷<code>0x48, 0x89, 0xC3</code>の逆アセンブル結果として，
❹<code>movq %rax, %rbx</code>とも表示されています．</p>
<p>つまり，アセンブラにとっては，</p>
<ul>
<li><code>movq %rax, %rbx</code> というニモニック</li>
<li><code>.byte 0x48, 0x89, 0xC3</code> というバイト列</li>
</ul>
<p>は全く同じ意味になるのでした．
ですので，<code>.text</code>セクションにニモニックで機械語命令を書く代わりに，
<code>.byte</code>を使って直接，機械語命令のバイト列を書くことができます．</p>
<h4 id="異なる機械語のバイト列で同じ動作のmov命令がある"><a class="header" href="#異なる機械語のバイト列で同じ動作のmov命令がある">異なる機械語のバイト列で，同じ動作の<code>mov</code>命令がある</a></h4>
<ul>
<li>質問： <code>%rax</code>の値を<code>%rbx</code>にコピーしたい時，
<code>movq</code> <em>r</em>, <em>r/m</em> と <code>movq</code> <em>r/m</em>, <em>r</em> のどちらを使えばいいのでしょう?</li>
<li>答え： どちらを使ってもいいです．ただし，異なる機械語命令のバイト列に
なることがあります．</li>
</ul>
<p>実は<code>0x48, 0x89, 0xC3</code>というバイト列は，
<code>movq</code> <em>r</em>, <em>r/m</em> を使った時のものです．
一方，<code>movq</code> <em>r/m</em>, <em>r</em> という形式を使った場合は，
バイト列は <code>0x48, 0x8B, 0xD8</code>になります．確かめてみましょう．</p>
<pre><code class="language-x86asmatt"># asm/byte2.s
    .text
    .globl main
    .type main, @function
main:
    .byte 0x48, 0x89, 0xC3
    .byte 0x48, 0x8B, 0xD8
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte2.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:    ❶48 89 c3      ❸mov    %rax,%rbx
    112c:    ❷48 8b d8      ❹mov    %rax,%rbx
    112f:      c3             ret    
</code></pre>
<p>❶<code>48 89 c3</code>と❷<code>48 8b d8</code>は異なるバイト列ですが
逆アセンブル結果としては
❸<code>mov %rax,%rbx</code>と❹<code>mov %rax,%rbx</code>と，どちらも同じ結果になりました．</p>
<p>このように同じニモニック命令に対して，複数の機械語のバイト列が存在する時，
アセンブラは「実行が速い方」あるいは「バイト列が短い方」を適当に選んでくれます．
(そして，アセンブラが選ばない方をどうしても使いたい場合は，
<code>.byte</code>等を使って機械語のバイト列を直書きするしかありません)．</p>
<h3 id="xchg命令-オペランドの値を交換"><a class="header" href="#xchg命令-オペランドの値を交換"><code>xchg</code>命令: オペランドの値を交換</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>op1</em>, <em>op2</em></td><td>exchange</td><td><em>op1</em> と <em>op2</em> の値を交換する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xchg %rax, (%rsp)</code></td><td><code>%rax</code>と<code>(%rsp)</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
<tr><td><strong><code>xchg</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xchg (%rsp), %rax</code></td><td><code>(%rsp)</code>と<code>%rax</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>xchg</code>命令は<strong>アトミックに</strong>2つのオペランドの値を交換します．(LOCKプレフィクスをつけなくてもアトミックになります)</li>
<li>この<strong>アトミック</strong>な動作はロックなどの<strong>同期機構</strong>を作るために使えます．</li>
</ul>
<details>
<summary>
xchg.sの実行例
</summary>
<pre><code>$ gcc -g xchg.s
$ gdb ./a.out -x xchg.txt
Breakpoint 1, main () at xchg.s:9
9	    xchg %rax, (%rsp)
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
10	    xchg (%rsp), %rax
1: /x $rax = 0x1122334455667788
2: /x *(void **)($rsp) = 0x99aabbccddeeff00
11	    popq %rax
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
# 値が入れ替わっていれば成功
</code></pre>
</details>
<details>
<summary>
機械語1命令の実行はアトミックとは限らない
</summary>
<p>機械語1命令の実行はアトミックとは限りません．
例えば，<code>inc</code>命令(オペランドを1増やす命令)は
マニュアルによると「<code>LOCK</code>プリフィックスをつければアトミックに実行される」とあります．
<code>inc</code>命令に<code>LOCK</code>プリフィックスがない場合には(たまたまアトミックに実行されるかも知れませんが)
「常にアトミックである」と期待してはいけないのです(マニュアルで「アトミックだ」と明記されていない限り)．</p>
<p>なお，<code>inc</code>は「メモリから読んだ値に1を足して書き戻す」ため
アトミックにならない可能性がありますが，<strong>読むだけ</strong>または<strong>書くだけ</strong>でかつ，
<strong>適切にアラインメント</strong>されていれば，
そのメモリ操作は<a href="https://stackoverflow.com/questions/36624881/why-is-integer-assignment-on-a-naturally-aligned-variable-atomic-on-x86/36685056#36685056">アトミックになります</a>．</p>
</details>
<h3 id="lea命令-実効アドレスを計算"><a class="header" href="#lea命令-実効アドレスを計算"><code>lea</code>命令: 実効アドレスを計算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>op1</em>, <em>op2</em></td><td>load effective address</td><td><em>op1</em> の実効アドレスを <em>op2</em> に代入する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>m</em>, <em>r</em></td><td><code>leaq -8(%rsp, %rsi, 4), %rax</code></td><td><code>%rax=%rsp+%rsi*4-8</code></td><td><a href="./asm/leaq-2.s">leaq-2.s</a> <a href="./asm/leaq-2.txt">leaq-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>lea</code>命令は第1オペランド(常にメモリ参照)の実効アドレスを計算して，
第2オペランドに格納します．</li>
<li><code>lea</code>命令はアドレスを計算するだけで，メモリにはアクセスしません．</li>
</ul>
<details>
<summary>
leaq-2.sの実行例
</summary>
<pre><code>$ gcc -g lea.s
$ gdb ./a.out -x lea.txt
Breakpoint 1, main () at leaq-2.s:8
8	    ret
# p/x $rsp
$1 = 0x7fffffffde98
# p/x $rsi
$2 = 0x8
# p/x $rax
$3 = 0x7fffffffdeb0
# %rax == %rsp + %rsi * 4 なら成功
</code></pre>
</details>
<ul>
<li><strong>実効アドレス</strong>とは<a href="6-inst.html#addr-mode-direct">直接メモリ参照</a>や
<a href="6-inst.html#addr-mode-indirect">間接メモリ参照</a>で計算したアドレスことです．</li>
</ul>
<details>
<summary>
実効アドレスとリニアアドレスの違いは?→(ほぼ)同じ
</summary>
<br/>
<img src="figs/effective-addr.svg" height="300px" id="fig:effective-addr">
<ul>
<li><strong>実効アドレス</strong>(effective address)は
<a href="./6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">メモリ参照</a>で
disp (base, index, scale) や disp (<code>%rip</code>)から計算したアドレスのことです．</li>
<li>x86-64のアセンブリコード中のアドレスは<strong>論理アドレス</strong> (logical address)といい，
<strong>セグメント</strong>と<strong>実効アドレス</strong>のペアとなっています．
このペアをx86-64用語で<strong>farポインタ</strong>とも呼びます．
(本書ではfarポインタは扱いません)．</li>
<li>セグメントが示すベースアドレスと実効アドレスを加えたものが
<strong>リニアアドレス</strong>(linear address)です．
例えば64ビットアドレス空間だと，リニアアドレスは0番地から2<sup>64</sup>-1番地
まで一直線に並ぶのでリニアアドレスと呼ばれています．
リニアアドレスは<strong>仮想アドレス</strong>(virtual address)と等しくなります．</li>
<li>また，x86-64では<a href="./x86-list.html#segment-override">例外</a>を除き，
セグメントが示すベースアドレスが0番地なので，
<strong>実効アドレスとリニアアドレスは等しくなります</strong>．</li>
<li>リニアアドレス(仮想アドレス)はCPUのページング機構により，
物理アドレスに変換されて，最終的なメモリアクセスが行われます．</li>
</ul>
</details>
<ul>
<li>コンパイラは加算・乗算を高速に実行するため<code>lea</code>命令を使うことがあります．</li>
</ul>
<p>例えば，</p>
<pre><code class="language-x86asmatt">movq $4, %rax
addq %rbx, %rax
shlq $2, %rsi   # 左論理シフト．2ビット左シフトすることで%rsiを4倍にしている
addq %rsi, %rax
</code></pre>
<p>は，<code>%rax = %rbx + %rsi * 4 + 4</code>という計算を4命令でしていますが，
<code>lea</code>命令なら以下の1命令で済みます</p>
<pre><code class="language-x86asmatt">leaq 4(%rbx, %rsi, 4), %rax
</code></pre>
<blockquote>
<p>注: 実行時間は命令ごとに異なりますので，命令数だけで
実行時間を比較することはできません．</p>
</blockquote>
<h3 id="pushとpop命令-スタックとデータ転送"><a class="header" href="#pushとpop命令-スタックとデータ転送"><code>push</code>と<code>pop</code>命令: スタックとデータ転送</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>op1</em></td><td>push</td><td><em>op1</em> をスタックにプッシュ</td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>op1</em></td><td>pop</td><td>スタックから <em>op1</em> にポップ</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>imm</em></td><td><code>pushq $999</code></td><td><code>%rsp-=8; *(%rsp)=999</code></td><td><a href="./asm/push1.s">push1.s</a> <a href="./asm/push1.txt">push1.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m16</em></td><td><code>pushw %ax</code></td><td><code>%rsp-=2; *(%rsp)=%ax</code></td><td><a href="./asm/push2.s">push2.s</a> <a href="./asm/push2.txt">push2.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m64</em></td><td><code>pushq %rax</code></td><td><code>%rsp-=8; *(%rsp)=%rax</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m16</em></td><td><code>popw %ax</code></td><td><code>*(%rsp)=%ax; %rsp += 2</code></td><td><a href="./asm/pop2.s">pop2.s</a> <a href="./asm/pop2.txt">pop2.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m64</em></td><td><code>popq %rbx</code></td><td><code>%rbx=*(%rsp); %rsp += 8</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<br/>
<form class="tab-wrap">
    <input id="push-pop1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="push-pop1"><code>pushq %rax前</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop1.svg" height="350px" id="fig:push-pop1">
    </div>
    <input id="push-pop2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop2"><code>pushq %rax後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop2.svg" height="350px" id="fig:push-pop2">
    </div>
    <input id="push-pop3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop3"><code>popq %rbx後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop3.svg" height="350px" id="fig:push-pop3">
    </div>
</form>
<ul>
<li><code>push</code>命令はスタックポインタ<code>%rsp</code>を<strong>減らしてから</strong>，
スタックトップ(スタックの一番上)にオペランドの値を格納します．</li>
<li><code>pop</code>命令はスタックトップの値をオペランドに<strong>格納してから</strong>，
スタックポインタを増やします．</li>
<li>64ビットモードでは，32ビットの<code>push</code>と<code>pop</code>はできません．</li>
<li>抽象データ型のスタックは(スタックトップに対する)プッシュ操作とポップ操作しか
できませんが，x86-64のスタック操作はスタックトップ以外の部分にも自由にアクセス可能です(例えば，<code>-8(%rsp)</code>や<code>-8(%rbp)</code>などへのメモリ参照で)．</li>
</ul>
<details>
<summary>
push1.sの実行例
</summary>
<pre><code>$ gcc -g push1.s
$ gdb ./a.out -x push1.txt
Breakpoint 1, main () at push1.s:6
6	    pushq $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push1.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde90
# x/1gd $rsp
0x7fffffffde90:	999
# %rsp が8減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
push2.sの実行例
</summary>
<pre><code>$ gcc -g push2.s
$ gdb ./a.out -x push2.txt
Breakpoint 1, main () at push2.s:6
6	    pushw $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push2.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde96
# x/1hd $rsp
0x7fffffffde96:	999
# %rsp が2減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
pop2.sの実行例
</summary>
<pre><code>$ gcc -g pop2.s
$ gdb ./a.out -x pop2.txt
Breakpoint 1, main () at pop2.s:7
7	    popw %ax
# p/x $rsp
$1 = 0x7fffffffde96
main () at pop2.s:8
8	    ret
# p/x $rsp
$2 = 0x7fffffffde98
# p/d $ax
$3 = 999
# %rsp が2増えて，%axの値が999なら成功
</code></pre>
</details>
<details>
<summary>
push-pop.sの実行例
</summary>
<pre><code>$ gcc -g push-pop.s
$ gdb ./a.out -x push-pop.txt
Breakpoint 1, main () at push-pop.s:8
8	    pushq %rax
# p/x $rsp
$1 = 0x7fffffffde98
main () at push-pop.s:9
9	    popq  %rbx
# p/x $rsp
$2 = 0x7fffffffde90
# x/8bx $rsp
0x7fffffffde90:	0x88	0x77	0x66	0x55	0x44	0x33	0x22	0x11
# %rsp の値が8減って，スタックトップ8バイトが 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11なら成功
</code></pre>
</details>
<h2 id="x86-64機械語命令-算術論理演算"><a class="header" href="#x86-64機械語命令-算術論理演算">x86-64機械語命令: 算術・論理演算</a></h2>
<h3 id="概要とステータスフラグ"><a class="header" href="#概要とステータスフラグ">概要とステータスフラグ</a></h3>
<p>ここでは以下の算術・論理演算を説明します．</p>
<div class="table-wrapper"><table><thead><tr><th>演算の種類</th><th>主な命令</th></tr></thead><tbody>
<tr><td>算術</td><td><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>inc</code>, <code>dec</code>, <code>not</code></td></tr>
<tr><td>論理</td><td><code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code></td></tr>
<tr><td>シフト</td><td><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>, <code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code></td></tr>
<tr><td>比較</td><td><code>cmp</code>, <code>test</code></td></tr>
<tr><td>変換(拡張)</td><td><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code></td></tr>
</tbody></table>
</div>
<p>これらの命令のほとんどが演算の結果として，
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0">ステータスフラグ</a>
の値を変化させます．
本書ではステータスフラグの変化を以下の記法で表します．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="6-inst.html#status-reg">CF</a></th><th><a href="6-inst.html#status-reg">OF</a></th><th><a href="6-inst.html#status-reg">SF</a></th><th><a href="6-inst.html#status-reg">ZF</a></th><th><a href="6-inst.html#status-reg">PF</a></th><th><a href="6-inst.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td>!</td><td>?</td><td>0</td><td>1</td><td></td></tr>
</tbody></table>
</div>
<p>記法の意味は以下の通りです．</p>
<div id="status-reg">
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>意味</th></tr></thead><tbody>
<tr><td>空白</td><td>フラグ値に変化なし</td></tr>
<tr><td>!</td><td>フラグ値に変化あり</td></tr>
<tr><td>?</td><td>フラグ値は未定義(参照禁止)</td></tr>
<tr><td>0</td><td>フラグ値はクリア(0になる)</td></tr>
<tr><td>1</td><td>フラグ値はセット(1になる)</td></tr>
</tbody></table>
</div></div>
<h3 id="add命令-足し算"><a class="header" href="#add命令-足し算"><code>add</code>命令: 足し算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add</td><td><em>op1</em> を <em>op2</em> に加える</td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add with carry</td><td><em>op1</em> と CF を <em>op2</em> に加える</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>addq $999, %rax</code></td><td><code>%rax += 999</code></td><td><a href="./asm/add-1.s">add-1.s</a> <a href="./asm/add-1.txt">add-1.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>addq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>addq (%rsp), %rax</code></td><td><code>%rax += *(%rsp)</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>adcq $999, %rax</code></td><td><code>%rax += 999 + CF</code></td><td><a href="./asm/adc-1.s">adc-1.s</a> <a href="./asm/adc-1.txt">adc-1.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>adcq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax + CF</code></td><td><a href="./asm/adc-2.s">adc-2.s</a> <a href="./asm/adc-2.txt">adc-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>adcq (%rsp), %rax</code></td><td><code>%rax += *(%rsp) + CF</code></td><td><a href="./asm/adc-3.s">adc-3.s</a> <a href="./asm/adc-3.txt">adc-3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と<code>adc</code>はオペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算します．</li>
<li><code>adc</code>は例えば，多倍長整数(任意の桁数の整数)を実装する時の
「繰り上がり」の計算に便利です．</li>
</ul>
<details>
<summary>
add-1.sの実行例
</summary>
<pre><code>$ gcc -g add-1.s
$ gdb ./a.out -x add-1.txt
Breakpoint 1, main () at add-1.s:8
8	    ret
# p $rax
$1 = 1000
# %raxが1000なら成功
</code></pre>
</details>
<details>
<summary>
add-2.sの実行例
</summary>
<pre><code>$ gcc -g add-2.s
$ gdb ./a.out -x add-2.txt
Breakpoint 1, main () at add-2.s:10
10	    popq %rbx
# p $rax
$1 = 1001
# x/1gd $rsp
0x7fffffffde90:	1000
# %raxが1001，(%rsp)が1000なら成功
</code></pre>
</details>
<details>
<summary>
adc-1.sの実行例
</summary>
<pre><code>$ gcc -g adc-1.s
$ gdb ./a.out -x adc-1.txt
reakpoint 1, main () at adc-1.s:8
8	    adcq $2, %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-1.s:9
9	    ret
# p $rax
$3 = 3
# %rflagsでCFが立っていて，%raxが3なら成功
</code></pre>
</details>
<details>
<summary>
adc-2.sの実行例
</summary>
<pre><code>$ gcc -g adc-2.s
$ gdb ./a.out -x adc-2.txt
Breakpoint 1, main () at adc-2.s:9
9	    adcq $2, (%rsp)
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-2.s:10
10	    ret
x/1gd $rsp
0x7fffffffde90:	1002
# %rflagsでCFが立っていて，(%rsp)が1002なら成功
</code></pre>
</details>
<details>
<summary>
adc-3.sの実行例
</summary>
<pre><code>$ gcc -g adc-3.s
$ gdb ./a.out -x adc-3.txt
Breakpoint 1, main () at adc-3.s:9
9	    adcq (%rsp), %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-3.s:10
10	    ret
# p $rax
$3 = 1000
# %rflagsでCFが立っていて，%raxが1000なら成功
</code></pre>
</details>
<h3 id="sub-sbb命令-引き算"><a class="header" href="#sub-sbb命令-引き算"><code>sub</code>, <code>sbb</code>命令: 引き算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract</td><td><em>op1</em> を <em>op2</em> から引く</td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract with borrow</td><td><em>op1</em> と CF を <em>op2</em> から引く</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>subq $999, %rax</code></td><td><code>%rax -= 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>subq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>subq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp)</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>sbbq $999, %rax</code></td><td><code>%rax -= 999 + CF</code></td><td><a href="./asm/sbb-1.s">sbb-1.s</a> <a href="./asm/sbb-1.txt">sbb-1.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>sbbq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>sbbq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp) + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と同様に，<code>sub</code>と<code>sbb</code>は
オペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算します．</li>
</ul>
<details>
<summary>
sub-1.sの実行例
</summary>
<pre><code>$ gcc -g sub-1.s
$ gdb ./a.out -x sub-1.txt
Breakpoint 1, main () at sub-1.s:8
8	    ret
# p $rax
$1 = 1
# %raxが1なら成功
</code></pre>
</details>
<details>
<summary>
sub-2.sの実行例
</summary>
<pre><code>$ gcc -g sub-2.s
$ gdb ./a.out -x sub-2.txt
Breakpoint 1, main () at sub-2.s:10
10	    popq %rbx
# p $rax
$1 = -997
# x/1gd $rsp
0x7fffffffde90:	998
# %raxが-997，(%rsp)が998なら成功
</code></pre>
</details>
<details>
<summary>
sbb-1.sの実行例
</summary>
<pre><code>$ gcc -g sbb-1.s
$ gdb ./a.out -x sbb-1.txt
Breakpoint 1, main () at sbb-1.s:8
8	    sbbq $2, %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at sbb-1.s:9
9	    ret
# p $rax
$3 = -3
# %rflagsでCFが立っていて，%raxが-3なら成功
</code></pre>
</details>
<details>
<summary>
sbb-2.sの実行例
</summary>
<pre><code>$ gcc -g sbb-2.s
$ gdb ./a.out -x sbb-2.txt
Breakpoint 1, main () at sbb-2.s:9
9	    sbbq $2, (%rsp)
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
10	    sbbq (%rsp), %rax
main () at sbb-2.s:11
11	    ret
x/1gd $rsp
0x7fffffffde90:	996
# p $rax
$3 = -996
# %rflagsでCFが立っていて，(%rsp)が996，%raxが-996なら成功
</code></pre>
</details>
<h3 id="mul-imul命令-かけ算"><a class="header" href="#mul-imul命令-かけ算"><code>mul</code>, <code>imul</code>命令: かけ算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>op1</em></td><td>unsigned multiply</td><td>符号なし乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em></td><td>signed multiply</td><td>符号あり乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em></td><td>signed multiply</td><td>符号あり乗算．<em>op2</em> *= <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em>, <em>op3</em></td><td>signed multiply</td><td>符号あり乗算．<em>op3</em> = <em>op1</em> * <em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>r/m</em></td><td><code>mulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/mul-1.s">mul-1.s</a> <a href="./asm/mul-1.txt">mul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em></td><td><code>imulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/imul-1.s">imul-1.s</a> <a href="./asm/imul-1.txt">imul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>imulq $4, %rax</code></td><td><code>%rax *= 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>imulq %rbx, %rax</code></td><td><code>%rax *= %rbx</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r/m</em>, <em>r</em></td><td><code>imulq $4, %rbx, %rax</code></td><td><code>%rax = %rbx * 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<br/>
<img src="figs/imul.svg" height="250px" id="fig:imul">
<ul>
<li>オペランドが1つの形式では，<code>%rax</code>が隠しオペランドになります．
このため，乗算の前に<code>%rax</code>に値をセットしておく必要があります．
また，8バイト同士の乗算結果は最大で16バイトになるので，
乗算結果を<code>%rdx</code>と<code>%rax</code>に分割して格納します
(16バイトの乗算結果の上位8バイトを<code>%rdx</code>に，下位8バイトを<code>%rax</code>に格納します)．
これをここでは<code>(%rdx:%rax)</code>という記法で表現しています．</li>
<li><code>imul</code>だけ例外的に，オペランドが2つの形式と3つの形式があります．
2つか3つの形式では乗算結果が8バイトを超えた場合，
越えた分は破棄されます(乗算結果は8バイトのみ)．</li>
</ul>
<details>
<summary>
mul-1.sの実行例
</summary>
<pre><code>$ gcc -g mul-1.s
$ gdb ./a.out -x mul-1.txt
Breakpoint 1, main () at mul-1.s:9
9	    ret
# p $rdx
$1 = 0
# p $rax
$2 = 6
# %rdxが0, %raxが6なら成功
</code></pre>
</details>
<details>
<summary>
imul-1.sの実行例
</summary>
<pre><code>$ gcc -g imul-1.s
$ gdb ./a.out -x imul-1.txt
Breakpoint 1, main () at imul-1.s:9
9	    ret
# p $rdx
$1 = 0xffffffffffffffff
# p $rax
$2 = -6
# %rdxが0xFFFFFFFFFFFFFFFF, %raxが-6なら成功
</code></pre>
</details>
<details>
<summary>
imul-2.sの実行例
</summary>
<pre><code>$ gcc -g imul-2.s
$ gdb ./a.out -x imul-2.txt
Breakpoint 1, main () at imul-2.s:8
8	    imulq $4, %rax
9	    imulq %rbx, %rax
1: $rax = -8
10	    imulq $5, %rbx, %rax
1: $rax = 24
main () at imul-2.s:11
11	    ret
1: $rax = -15
# %raxが-8, 24, -15なら成功
</code></pre>
</details>
<h3 id="div-idiv命令-割り算余り"><a class="header" href="#div-idiv命令-割り算余り"><code>div</code>, <code>idiv</code>命令: 割り算，余り</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>op1</em></td><td>unsigned divide</td><td>符号なし除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>op1</em></td><td>signed divide</td><td>符号あり除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>r/m</em></td><td><code>divq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/div-1.s">div-1.s</a> <a href="./asm/div-1.txt">div-1.txt</a></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>r/m</em></td><td><code>idivq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/idiv-1.s">idiv-1.s</a> <a href="./asm/idiv-1.txt">idiv-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>16バイトの値 <code>%rdx:%rax</code> を第1オペランドで割った商が<code>%rax</code>に入り，
余りが<code>%rdx</code>に入ります．</li>
<li>隠しオペランドとして<code>%rdx</code>と<code>%rax</code>が使われるので，
事前に値を設定しておく必要があります．
<code>idiv</code>を使う場合，もし<code>%rdx</code>を使わないのであれば，
<code>cqto</code>命令で<code>%rax</code>を<code>%rdx:%rax</code>に符号拡張しておくと良いです．</li>
</ul>
<details>
<summary>
div-1.sの実行例
</summary>
<pre><code>$ gcc -g div-1.s
$ gdb ./a.out -x div-1.txt
Breakpoint 1, main () at div-1.s:10
10	    ret
# p $rax
$1 = 33
# p $rdx
$2 = 9
# %raxが33, %rdxが9なら成功
</code></pre>
</details>
<details>
<summary>
idiv-1.sの実行例
</summary>
<pre><code>$ gcc -g idiv-1.s
$ gdb ./a.out -x idiv-1.txt
Breakpoint 1, main () at idiv-1.s:9
9	    idivq %rbx
# p/x $rdx
$1 = 0xffffffffffffffff
main () at idiv-1.s:10
10	    ret
# p $rax
$2 = -33
# p $rdx
$3 = -9
# 最初の%rdxが0xFFFFFFFFFFFFFFFF, %raxが-33, 2番目の%rdxが-9なら成功
</code></pre>
</details>
<h3 id="inc-dec命令-インクリメントデクリメント"><a class="header" href="#inc-dec命令-インクリメントデクリメント"><code>inc</code>, <code>dec</code>命令: インクリメント，デクリメント</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>op1</em></td><td>increment</td><td><em>op1</em>の値を1つ増加</td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>op1</em></td><td>decrement</td><td><em>op1</em>の値を1つ減少</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>r/m</em></td><td><code>inc %rax</code></td><td><code>%rax</code>++</td><td><a href="./asm/inc-1.s">inc-1.s</a> <a href="./asm/inc-1.txt">inc-1.txt</a></td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>r/m</em></td><td><code>dec %rax</code></td><td><code>%rax</code>--</td><td><a href="./asm/dec-1.s">dec-1.s</a> <a href="./asm/dec-1.txt">dec-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>inc</code>や<code>dec</code>はオーバーフローしてもCFが変化しないところがポイントです．</li>
</ul>
<details>
<summary>
inc-1.sの実行例
</summary>
<pre><code>$ gcc -g inc-1.s
$ gdb ./a.out -x inc-1.txt
Breakpoint 1, main () at inc-1.s:8
8	    ret
# p $rax
$1 = 1
# %raxが1なら成功
</code></pre>
</details>
<details>
<summary>
dec-1.sの実行例
</summary>
<pre><code>$ gcc -g dec-1.s
$ gdb ./a.out -x dec-1.txt
reakpoint 1, main () at dec-1.s:8
8	    ret
# p $rax
$1 = -1
# %raxが-1なら成功
</code></pre>
</details>
<h3 id="neg命令-符号反転"><a class="header" href="#neg命令-符号反転"><code>neg</code>命令: 符号反転</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>op1</em></td><td>negation</td><td>2の補数による<em>op1</em>の符号反転</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>r/m</em></td><td><code>neg %rax</code></td><td><code>%rax = -%rax</code></td><td><a href="./asm/neg-1.s">neg-1.s</a> <a href="./asm/neg-1.txt">neg-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<details>
<summary>
neg-1.sの実行例
</summary>
<pre><code>$ gcc -g neg-1.s
$ gdb ./a.out -x neg-1.txt
Breakpoint 1, main () at neg-1.s:7
7	    neg %rax
1: $rax = 999
8	    neg %rax
1: $rax = -999
main () at neg-1.s:9
9	    ret
1: $rax = 999
# %raxが 999 → -999 → 999 と変化すれば成功
</code></pre>
</details>
<h3 id="not命令-ビット論理演算-1"><a class="header" href="#not命令-ビット論理演算-1"><code>not</code>命令: ビット論理演算 (1)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>op1</em></td><td>bitwise not</td><td><em>op1</em>の各ビットの反転 (NOT)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>r/m</em></td><td><code>notq %rax</code></td><td><code>%rax = ~%rax</code></td><td><a href="./asm/not-1.s">not-1.s</a> <a href="./asm/not-1.txt">not-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<details>
<summary>
not-1.sの実行例
</summary>
<pre><code>$ gcc -g not-1.s
$ gdb ./a.out -x not-1.txt
Breakpoint 1, main () at not-1.s:7
7	    not %al
1: /t $al = 11001010
8	    not %al
1: /t $al = 110101
main () at not-1.s:9
9	    ret
1: /t $al = 11001010
# %alが 11001010 → 110101 → 11001010 と変化すれば成功
</code></pre>
</details>
<h3 id="and-or-xor命令-ビット論理演算-2"><a class="header" href="#and-or-xor命令-ビット論理演算-2"><code>and</code>, <code>or</code>, <code>xor</code>命令: ビット論理演算 (2)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise and</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理積(AND)</td></tr>
<tr><td><strong><code>or␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise or</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理和(OR)</td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise xor</td><td><em>op1</em>と<em>op2</em>の各ビットごとの排他的論理和(XOR)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>andq $0x0FFF, %rax</code></td><td><code>%rax &amp;= 0x0FFF</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>andq %rax, (%rsp)</code></td><td><code>*(%rsp) &amp;= %rax</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>andq (%rsp), %rax</code></td><td><code>%rax &amp;= *(%rsp)</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>orq $0x0FFF, %rax</code></td><td><code>%rax |= 0x0FFF </code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>orq %rax, (%rsp)</code></td><td><code>*(%rsp) |= %rax</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>orq (%rsp), %rax</code></td><td><code>%rax |= *(%rsp)</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>xorq $0x0FFF, %rax</code></td><td><code>%rax ^= 0x0FFF</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xorq %rax, (%rsp)</code></td><td><code>*(%rsp) ^= %rax</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xorq (%rsp), %rax</code></td><td><code>%rax ^= *(%rsp)</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><em>x</em></th><th style="text-align: center"><em>y</em></th><th style="text-align: center"><em>x</em> &amp; <em>y</em></th><th style="text-align: center"><em>x</em> | <em>y</em></th><th style="text-align: center"><em>x</em> ^ <em>y</em></th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>&amp;</code>, <code>|</code>, <code>^</code>はC言語で，それぞれ，ビットごとの論理積，論理和，排他的論理積です
(忘れた人はC言語を復習しましょう)．</li>
</ul>
<details>
<summary>
and-1.sの実行例
</summary>
<pre><code>$ gcc -g and-1.s
$ gdb ./a.out -x and-1.txt
Breakpoint 1, main () at and-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 10001000

Breakpoint 2, main () at and-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	00001000
# p/t $al
$2 = 0
# 表示される値が 10001000, 00001000, 0 なら成功
</code></pre>
</details>
<details>
<summary>
or-1.sの実行例
</summary>
<pre><code>$ gcc -g or-1.s
$ gdb ./a.out -x or-1.txt
Breakpoint 1, main () at or-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 11101110

Breakpoint 2, main () at or-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	11101111
# p/t $al
$2 = 11111111
# 表示される値が 11101110, 11101111, 11111111 なら成功
</code></pre>
</details>
<details>
<summary>
xor-1.sの実行例
</summary>
<pre><code>$ gcc -g xor-1.s
$ gdb ./a.out -x xor-1.txt
Breakpoint 1, main () at xor-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 1100110

Breakpoint 2, main () at xor-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	01101001
# p/t $al
$2 = 10011110
# 表示される値が 1100110, 01101001, 10011110 なら成功
</code></pre>
</details>
<h3 id="sal-sar-shl-shr-シフト"><a class="header" href="#sal-sar-shl-shr-シフト"><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>: シフト</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic left</td><td>算術左シフト</td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical left</td><td>論理左シフト</td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic right</td><td>算術右シフト</td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical right</td><td>論理右シフト</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>r/m</em></td><td><code>salq %rax</code></td><td><code>%rax</code>を1ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>salq $2, %rax</code></td><td><code>%rax</code>を2ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>salq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>r/m</em></td><td><code>shlq %rax</code></td><td><code>%rax</code>を1ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shlq $2, %rax</code></td><td><code>%rax</code>を2ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shlq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>r/m</em></td><td><code>sarq %rax</code></td><td><code>%rax</code>を1ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>sarq $2, %rax</code></td><td><code>%rax</code>を2ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>sarq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>r/m</em></td><td><code>shrq %rax</code></td><td><code>%rax</code>を1ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shrq $2, %rax</code></td><td><code>%rax</code>を2ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<img src="figs/shift.svg" height="300px" id="fig:shift">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li><strong>シフト</strong>とは(指定したビット数だけ)右か左にビット列をずらすことを意味します．
<em>op2</em>がなければ「1ビットシフト」を意味します．</li>
<li><strong>論理シフト</strong>とは「空いた場所に<strong>0を入れる</strong>」，
<strong>算術シフト</strong>とは「空いた場所に<strong>符号ビットを入れる</strong>」ことを意味します．</li>
<li>左シフトの場合は(符号ビットを入れても意味がないので)，論理シフトでも算術シフトでも，0を入れます．その結果，算術左シフト<code>sal</code>と論理左シフト<code>shl</code>は全く同じ動作になります．</li>
<li>C言語の符号あり整数に対する右シフト(&gt;&gt;)は算術シフトか論理シフトかは
決まっていません(実装依存です)．
C言語で，ビット演算は符号なし整数に対してのみ行うようにしましょう．</li>
</ul>
<details>
<summary>
sal-1.sの実行例
</summary>
<pre><code>$ gcc -g sal-1.s
$ gdb ./a.out -x sal-1.txt
Breakpoint 1, main () at sal-1.s:8
8	    salq %rax
1: /t $rax = 11111111
9	    salq $2, %rax
1: /t $rax = 111111110
10	    salq %cl, %rax
1: /t $rax = 11111111000
main () at sal-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
shl-1.sの実行例
</summary>
<pre><code>$ gcc -g shl-1.s
$ gdb ./a.out -x shl-1.txt
reakpoint 1, main () at shl-1.s:8
8	    shlq %rax
1: /t $rax = 11111111
9	    shlq $2, %rax
1: /t $rax = 111111110
10	    shlq %cl, %rax
1: /t $rax = 11111111000
main () at shl-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
sar-1.sの実行例
</summary>
<pre><code>$ gcc -g sar-1.s
$ gdb ./a.out -x sar-1.txt
Breakpoint 1, main () at sar-1.s:8
8	    sarq %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000000
9	    sarq $2, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111110000000
10	    sarq %cl, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111111100000
main () at sar-1.s:11
11	    ret
1: /t $rax = 1111111111111111111111111111111111111111111111111111111111111100
# 表示される値が 1111111111111111111111111111111111111111111111111111111100000000, 1111111111111111111111111111111111111111111111111111111110000000, 1111111111111111111111111111111111111111111111111111111111100000, 1111111111111111111111111111111111111111111111111111111111111100 なら成功
</code></pre>
</details>
<details>
<summary>
shr-1.sの実行例
</summary>
<pre><code>$ gcc -g shr-1.s
$ gdb ./a.out -x shr-1.txt
reakpoint 1, main () at shr-1.s:8
8	    shrq %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000000
9	    shrq $2, %rax
1: /t $rax = 111111111111111111111111111111111111111111111111111111110000000
10	    shrq %cl, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000
main () at shr-1.s:11
11	    ret
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100
# 表示される値が 1111111111111111111111111111111111111111111111111111111100000000, 111111111111111111111111111111111111111111111111111111110000000, 1111111111111111111111111111111111111111111111111111111100000, 1111111111111111111111111111111111111111111111111111111100 なら成功
</code></pre>
</details>
<h3 id="rol-ror-rcl-rcr-ローテート"><a class="header" href="#rol-ror-rcl-rcr-ローテート"><code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code>: ローテート</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left</td><td>左ローテート</td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left through carry</td><td>CFを含めて左ローテート</td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right</td><td>右ローテート</td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right through carry</td><td>CFを含めて右ローテート</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>r/m</em></td><td><code>rolq %rax</code></td><td><code>%rax</code>を1ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rolq $2, %rax</code></td><td><code>%rax</code>を2ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rolq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>r/m</em></td><td><code>rclq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rclq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rclq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>r/m</em></td><td><code>rorq %rax</code></td><td><code>%rax</code>を1ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rorq $2, %rax</code></td><td><code>%rax</code>を2ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rorq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>r/m</em></td><td><code>rcrq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rcrq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rcrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<img src="figs/rotate.svg" height="330px" id="fig:rotate">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li>ローテートは，シフトではみ出したビットを空いた場所に入れます．</li>
<li>ローテートする方向(右か左)，CFを含めるか否かで，4パターンの命令が存在します．</li>
</ul>
<details>
<summary>
rol-1.sの実行例
</summary>
<pre><code>$ gcc -g rol-1.s
$ gdb ./a.out -x rol-1.txt
Breakpoint 1, main () at rol-1.s:8
8	    rolq %rax
1: /t $rax = 11111111
9	    rolq $2, %rax
1: /t $rax = 111111110
10	    rolq %cl, %rax
1: /t $rax = 11111111000
main () at rol-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
rcl-1.sの実行例
</summary>
<pre><code>$ gcc -g rcl-1.s
$ gdb ./a.out -x rcl-1.txt
Breakpoint 1, main () at rcl-1.s:10
10	    rclq %rax
1: /t $rax = 11111111
11	    rclq $2, %rax
1: /t $rax = 111111111
12	    rclq %cl, %rax
1: /t $rax = 11111111100
main () at rcl-1.s:13
13	    ret
1: /t $rax = 11111111100000
# 表示される値が 11111111, 111111111, 11111111100, 11111111100000 なら成功
</code></pre>
</details>
<details>
<summary>
ror.sの実行例
</summary>
<pre><code>$ gcc -g ror.s
$ gdb ./a.out -x ror.txt
Breakpoint 1, main () at ror-1.s:8
8	    rorq %rax
1: /t $rax = 11111111
9	    rorq $2, %rax
1: /t $rax = 1000000000000000000000000000000000000000000000000000000001111111
10	    rorq %cl, %rax
1: /t $rax = 1110000000000000000000000000000000000000000000000000000000011111
main () at ror-1.s:11
11	    ret
1: /t $rax = 1111110000000000000000000000000000000000000000000000000000000011
# 表示される値が 11111111, 1000000000000000000000000000000000000000000000000000000001111111, 1110000000000000000000000000000000000000000000000000000000011111, 1111110000000000000000000000000000000000000000000000000000000011 なら成功
</code></pre>
</details>
<details>
<summary>
rcr-1.sの実行例
</summary>
<pre><code>$ gcc -g rcr-1.s
$ gdb ./a.out -x rcr-1.txt
Breakpoint 1, main () at rcr-1.s:10
10	    rcrq %rax
1: /t $rax = 11111010
11	    rcrq $2, %rax
1: /t $rax = 1000000000000000000000000000000000000000000000000000000001111101
12	    rcrq %cl, %rax
1: /t $rax = 1010000000000000000000000000000000000000000000000000000000011111
main () at rcr-1.s:13
13	    ret
1: /t $rax = 1101010000000000000000000000000000000000000000000000000000000011
# 表示される値が 11111010, 1000000000000000000000000000000000000000000000000000000001111101, 1010000000000000000000000000000000000000000000000000000000011111, 1101010000000000000000000000000000000000000000000000000000000011 なら成功
</code></pre>
</details>
<h3 id="cmp-test-比較"><a class="header" href="#cmp-test-比較"><code>cmp</code>, <code>test</code>: 比較</a></h3>
<h4 id="cmp命令"><a class="header" href="#cmp命令"><code>cmp</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>sub</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>cmpq $999, %rax</code></td><td><code>subq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpq %rax, (%rsp)</code></td><td><code>subq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>cmpq (%rsp), %rax</code></td><td><code>subq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<details>
<summary>
cmp-1.sの実行例
</summary>
<pre><code>$ gcc -g cmp-1.s
$ gdb ./a.out -x cmp-1.txt
reakpoint 1, main () at cmp-1.s:8
8	    cmpq $1, %rax       # %rax (=0) - 1
9	    cmpq %rax, (%rsp)   # (%rsp) (=1) - %rax (=0)
1: $eflags = [ CF PF AF SF IF ]
10	    cmpq (%rsp), %rax   # %rax (=0) - (%rsp) (=1)
1: $eflags = [ IF ]
main () at cmp-1.s:11
11	    ret
1: $eflags = [ CF PF AF SF IF ]
# 表示されるステータスフラグが以下なら成功
# 1: $eflags = [ CF PF AF SF IF ] (SF==1 → 結果は負)
# 1: $eflags = [ IF ]             (SF==0 → 結果は0か正)
# 1: $eflags = [ CF PF AF SF IF ] (SF==1 → 結果は負)
</code></pre>
</details>
<h4 id="test命令"><a class="header" href="#test命令"><code>test</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>logical compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>and</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>testq $999, %rax</code></td><td><code>andq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>testq %rax, (%rsp)</code></td><td><code>andq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>testq (%rsp), %rax</code></td><td><code>andq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令と同様に，<code>test</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令と同様に，<code>test</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が0ならジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">testq %rax, %rax
jz L2
</code></pre>
<ul>
<li>例えば<code>%rax</code>が0かどうかを知りたい場合，
<code>cmpq $0, %rax</code>と<code>testq %rax, %rax</code>のどちらでも調べることができます．
どちらの場合も，ZF==1なら，<code>%rax</code>が0と分かります
(<code>testq %rax, %rax</code>はビットごとのANDのフラグ変化を計算するので，
<code>%rax</code>がゼロの時だけ，ZF==1となります)．
コンパイラは<code>testq %rax, %rax</code>を使うことが多いです．
<code>testq %rax, %rax</code>の方が命令長が短くなるからです．</li>
</ul>
<details>
<summary>
test-1.sの実行例
</summary>
<pre><code>$ gcc -g test-1.s
$ gdb ./a.out -x test-1.txt
Breakpoint 1, main () at test-1.s:8
8	    testq $0, %rax       # %rax (=1) &amp; 0
9	    testq %rax, (%rsp)   # (%rsp) (=1) &amp; %rax (=1)
1: $eflags = [ PF ZF IF ]
10	    testq (%rsp), %rax   # %rax (=1) &amp; (%rsp) (=1)
1: $eflags = [ IF ]
main () at test-1.s:11
11	    ret
1: $eflags = [ IF ]
# 表示されるステータスフラグが以下なら成功
# 1: $eflags = [ PF ZF IF ] (ZF==1 → 結果は0)
# 1: $eflags = [ IF ]       (ZF==0 → 結果は非0)
# 1: $eflags = [ IF ]       (ZF==0 → 結果は非0)
</code></pre>
</details>
<h3 id="movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張"><a class="header" href="#movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張"><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code>命令: 符号拡張とゼロ拡張</a></h3>
<h4 id="movs-movz命令"><a class="header" href="#movs-movz命令"><code>movs</code>, <code>movz</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movsx</code> <em>op2</em>, <em>op1</em> </br> <code>movsxd</code> <em>op2</em>, <em>op1</em></td><td>move with sign-extention</td><td><em>op1</em>を符号拡張した値を<em>op2</em>に格納</td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movzx</code> <em>op2</em>, <em>op1</em></td><td>move with zero-extention</td><td><em>op1</em>をゼロ拡張した値を<em>op2</em>に格納</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movslq %eax, %rbx</code></td><td><code>%rbx</code> = <code>%eax</code>を8バイトに符号拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movzwq %ax, %rbx</code></td><td><code>%rbx</code> = <code>%ax</code>を8バイトにゼロ拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><code>␣␣</code>に入るもの</th><th>何の略か</th><th>意味</th></tr></thead><tbody>
<tr><td><code>bw</code></td><td>byte to word</td><td>1バイト→2バイトの拡張</td></tr>
<tr><td><code>bl</code></td><td>byte to long</td><td>1バイト→4バイトの拡張</td></tr>
<tr><td><code>bq</code></td><td>byte to quad</td><td>1バイト→8バイトの拡張</td></tr>
<tr><td><code>wl</code></td><td>word to long</td><td>2バイト→4バイトの拡張</td></tr>
<tr><td><code>wq</code></td><td>word to quad</td><td>2バイト→8バイトの拡張</td></tr>
<tr><td><code>lq</code></td><td>long to quad</td><td>4バイト→8バイトの拡張</td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>movs</code>, <code>movz</code>命令はAT&amp;T形式とIntel形式でニモニックが異なるので注意です．</li>
<li>GNUアセンブラではAT&amp;T形式でも実は<code>movsx</code>, <code>movzx</code>のニモニックが使用できます．
ただし逆アセンブルすると，<code>movslq</code>, <code>movzwq</code>などのニモニックが表示されるので，
<code>movslq</code>, <code>movzwq</code>などを使う方が良いでしょう．</li>
<li><code>movzlq</code> (Intel形式では<code>movzxd</code>)はありません．例えば，<code>%eax</code>に値を入れると，
<code>%rax</code>の上位32ビットは<a href="./x86-list.html#zero-upper32">クリア</a>されるので，
<code>movzlq</code>は不要だからです．</li>
<li>Intel形式では，4バイト→8バイトの拡張の時だけ，
(<code>movsx</code>ではなく)<code>movsxd</code>を使います．</li>
</ul>
<details>
<summary>
movs-movz.sの実行例
</summary>
<pre><code>$ gcc -g movs-movz.s
$ gdb ./a.out -x movs-movz.txt
Breakpoint 1, main () at movs-movz.s:7
7	    movslq %eax, %rbx
8	    movzwq %ax, %rbx
1: /x $rbx = 0xffffffffffffffff
main () at movs-movz.s:9
9	    ret
1: /x $rbx = 0xffff
# 以下が表示されれば成功
# 1: /x $rbx = 0xffffffffffffffff
# 1: /x $rbx = 0xffff
</code></pre>
</details>
<h4 id="cbtw-cqto命令"><a class="header" href="#cbtw-cqto命令"><code>cbtw</code>, <code>cqto</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td>**<code>c␣t␣</code></td><td><code>c␣␣␣</code></td><td>convert ␣ to ␣</td><td><code>%rax</code> (または<code>%eax</code>, <code>%ax</code>, <code>%al</code>)を符号拡張</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a><br/>(AT&amp;T形式)</th><th>詳しい記法<br/>(Intel形式)</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cbtw</code></strong></td><td><code>cbw</code></td><td><code>cbtw</code></td><td><code>%al</code>(byte)を<code>%ax</code>(word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtl</code></strong></td><td><code>cwde</code></td><td><code>cwtl</code></td><td><code>%ax</code>(word)を<code>%eax</code>(long)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtd</code></strong></td><td><code>cwd</code></td><td><code>cwtd</code></td><td><code>%ax</code>(word)を<code>%dx:%ax</code>(double word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltd</code></strong></td><td><code>cdq</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%edx:%eax</code>(doube long, quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltq</code></strong></td><td><code>cdqe</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%rax</code>(quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cqto</code></strong></td><td><code>cqo</code></td><td><code>cqto</code></td><td><code>%rax</code>(quad)を<code>%rdx:%rax</code>(octuple)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cqto</code>などは<code>idiv</code>で割り算する前に使うと便利(<code>%rdx:%rax</code>が<code>idiv</code>の隠しオペランドなので)．</li>
<li>GNUアセンブラはIntel形式のニモニックも受け付ける．</li>
</ul>
<details>
<summary>
cbtw.sの実行例
</summary>
<pre><code>$ gcc -g cbtw.s
$ gdb ./a.out -x cbtw.txt
Breakpoint 1, main () at cbtw.s:7
7	    cbtw   # %al -&gt; %ax
9	    cwtl   # %ax -&gt; %eax
$1 = -1
$2 = 0xffff
11	    cwtd   # %ax -&gt; %dx:%ax
$3 = -1
$4 = 0xffffffff
13	    cltd   # %eax -&gt; %edx:%eax
$5 = {-1, -1}
$6 = {0xffff, 0xffff}
15	    cltq   # %eax -&gt; %rax
$7 = {-1, -1}
$8 = {0xffffffff, 0xffffffff}
17	    cqto   # %rax -&gt; %rdx:%rax
$9 = -1
$10 = 0xffffffffffffffff
main () at cbtw.s:19
19	    ret
$11 = {-1, -1}
$12 = {0xffffffffffffffff, 0xffffffffffffffff}
# 以下が表示されれば成功
# $1 = -1
# $2 = 0xffff
# $3 = -1
# $4 = 0xffffffff
# $5 = {-1, -1}
# $6 = {0xffff, 0xffff}
# $7 = {-1, -1}
# $8 = {0xffffffff, 0xffffffff}
# $9 = -1
# $10 = 0xffffffffffffffff
# $11 = {-1, -1}
# $12 = {0xffffffffffffffff, 0xffffffffffffffff}
</code></pre>
</details>
<h2 id="ジャンプ命令"><a class="header" href="#ジャンプ命令">ジャンプ命令</a></h2>
<ul>
<li><strong>ジャンプ</strong>とは「次に実行する命令を(『次の番地の命令』ではなく)
『別の番地の命令』にすることです．
ジャンプの仕組みは簡単で「ジャンプ先のアドレスをプログラムカウンタ
<code>%rip</code>に代入する」だけです．
C言語風に書くと<code>%rip = ジャンプ先のアドレス</code>となります
(ジャンプ先が相対アドレスで与えられた場合は，
<code>%rip += 相対アドレス</code>になります)．</li>
<li><strong>無条件ジャンプ</strong>はC言語の<code>goto</code>文と同じで常にジャンプします．
<strong>条件付きジャンプ</strong>は条件が成り立った時だけジャンプします．
条件付きジャンプをC言語風に書くと<code>if (条件) goto ジャンプ先;</code>になります．</li>
</ul>
<h3 id="abs-rel-jump"><a class="header" href="#abs-rel-jump">絶対ジャンプと相対ジャンプ</a></h3>
<img src="figs/abs-rel-jump.svg" height="250px" id="fig:abs-rel-jump">
<ul>
<li><strong>絶対ジャンプ</strong> (absolute jump)は<strong>絶対アドレス</strong>，
つまりメモリの先頭からのオフセットでジャンプ先のアドレスを指定するジャンプです．
上の例で，AからBにジャンプする時，<code>jmp 0x1000</code>は絶対ジャンプになります．
(プログラムカウンタは「次に実行する命令を指すレジスタ」なので，
正確には「Aの一つ前の命令からBにジャンプする時」になります)．</li>
<li><strong>相対ジャンプ</strong> (relative jump)は
プログラムカウンタ<code>%rip</code>を起点とする<strong>相対アドレス</strong>で
ジャンプ先のアドレスを指定するジャンプです．
上の例で，AからBにジャンプする時，<code>jmp -0x500</code>は相対ジャンプになります．</li>
</ul>
<h3 id="dir-indir-jump"><a class="header" href="#dir-indir-jump">直接ジャンプと間接ジャンプ</a></h3>
<img src="figs/direct-indirect-jump.svg" height="350px" id="fig:direct-indirect-jump">
<ul>
<li>
<p><strong>直接ジャンプ</strong> (direct jump)はジャンプ先のアドレスを
<strong>即値</strong> (<strong>定数</strong>)で指定するジャンプです．
上の例で一番左の<code>jmp 0x1000</code>は直接ジャンプです．</p>
</li>
<li>
<p><strong>間接ジャンプ</strong> (indirect jump)はジャンプ先のアドレスを
<strong>レジスタ</strong>や<strong>メモリ</strong>で指定して，その中に格納されている値を
ジャンプ先のアドレスとするジャンプです．</p>
<ul>
<li>上の例で真ん中の<code>jmp *%rax</code>は<strong>レジスタ</strong>を使った間接ジャンプです．
レジスタ中のアドレス (ここでは<code>0x1000</code>番地)にジャンプします．
(なぜアスタリスク<code>*</code>が必要なのかは謎です．GNUアセンブラの記法です．)</li>
<li>上の例で一番右の<code>jmp *(%rax)</code>は<strong>メモリ参照</strong>を使った間接ジャンプです．
メモリ中のアドレス (ここでは<code>0x1000</code>番地)にジャンプします．</li>
</ul>
</li>
</ul>
<h3 id="jmp-無条件ジャンプ"><a class="header" href="#jmp-無条件ジャンプ"><code>jmp</code>: 無条件ジャンプ</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>jmp</code></strong> <em>op1</em></td><td>jump</td><td><em>op1</em>にジャンプ</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`jmp`** *rel8*| `jmp 0x1000` | `0x1000`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *rel32*| `jmp foo` | `foo`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *%rax` | `*%rax`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *(%rax)` | `*(%rax)`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>jmp</code></strong> <em>rel</em></td><td><code>jmp 0x1000</code></td><td><code>0x1000</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += 0x1000</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><code>jmp foo</code></td><td><code>foo</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += foo</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *%rax</code></td><td><code>*%rax</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *(%rax)</code></td><td><code>*(%rax)</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *(%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
</tbody></table>
</div>
---
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64では，相対・直接と絶対・間接の組み合わせしかありません．
(つまり，相対・間接ジャンプや絶対・直接ジャンプはありません．
なお，ここで紹介していないfarジャンプでは絶対・直接もあります)．</li>
<li>相対・直接ジャンプでは符号ありの8ビット(<em>rel8</em>)か
32ビット(<em>rel32</em>)の整数定数で相対アドレスを指定します．
(64ビットの相対アドレスは指定できません．64ビットのジャンプをしたい時は
絶対・間接ジャンプ命令を使います)．</li>
<li><em>rel8</em>か<em>rel32</em>かはアセンブラが勝手に選んでくれます．
逆に<code>jmpb</code>や<code>jmpl</code>などとサフィックスをつけて指定することはできません．</li>
<li>なぜか，定数なのに<em>rel8</em>や<em>rel32</em>にはドルマーク<code>$</code>をつけません．
逆に<em>r/m</em>の前にはアスタリスク<code>*</code>が必要です．
GNUアセンブラのこの部分は一貫性がないので要注意です．</li>
</ul>
<h3 id="条件付きジャンプの概要"><a class="header" href="#条件付きジャンプの概要">条件付きジャンプの概要</a></h3>
<ul>
<li>条件付きジャンプ命令 <code>j␣</code>は
　ステータスフラグ (CF, OF, PF, SF, ZF)をチェックして，
条件が成り立てばジャンプします．
条件が成り立たない場合はジャンプせず，次の命令に実行を進めます．</li>
<li>条件付きジャンプは比較命令と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<ul>
<li>条件付きジャンプ命令のニモニックでは次の用語を使い分けます
<ul>
<li>符号あり整数の大小には less/greater を使う</li>
<li>符号なし整数の大小には above/below を使う</li>
</ul>
</li>
</ul>
<h3 id="条件付きジャンプ-符号あり整数用"><a class="header" href="#条件付きジャンプ-符号あり整数用">条件付きジャンプ: 符号あり整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em><br/> <strong><code>jnle</code></strong> <em>rel</em></td><td>jump if greater <br/> jump if not less nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==0&amp;&amp;SF==OF</code></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em><br/> <strong><code>jnl</code></strong> <em>rel</em></td><td>jump if greater or equal <br/> jump if not less</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF==OF</code></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em><br/> <strong><code>jng</code></strong> <em>rel</em></td><td>jump if less or equal <br/> jump if not greater</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==1||SF!=OF</code></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em><br/> <strong><code>jnge</code></strong> <em>rel</em></td><td>jump if less <br/> jump if not greater nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF!=OF</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jg foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jnle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnle foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jge foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jnl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnl foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jle foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jng</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jng foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jl foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
<tr><td><strong><code>jnge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnge foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jg</code>と<code>jnle</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==0&amp;&amp;SF==OF</code>と共通です．
他の3つのペア，<code>jge</code>と<code>jnl</code>，<code>jle</code>と<code>jng</code>，<code>jl</code>と<code>jnge</code>も同様です．</li>
</ul>
<details>
<summary>
なぜ ZF==0&&SF=OF が(符号ありの場合の)op2>op1になるのか
</summary>
<ul>
<li>復習: <code>cmp␣</code> <em>op1</em>, <em>op2</em>は (<em>op2</em> - <em>op1</em>)という引き算を計算した時の
フラグ変化を計算します．</li>
<li>①: OF==0(オーバーフロー無し)の場合:
<ul>
<li>SF==0 だと引き算の結果は0以上→ <em>op2</em> - <em>op1</em> &gt;= 0 → <em>op2</em> &gt;= <em>op1</em></li>
</ul>
</li>
<li>②: OF==1(オーバーフローあり)の場合:
<ul>
<li>結果の正負が逆になる．つまり SF==1 だと引き算の結果は負(OF==1で逆になるので正)→ <em>op2</em> - <em>op1</em> &gt;= 0 → <em>op2</em> &gt;= <em>op1</em></li>
</ul>
</li>
<li>③:  ①と②から，(OF==0&amp;&amp;SF==0)||(OF==1&amp;&amp;SF==1)なら，<em>op2</em> &gt;= <em>op1</em> になる．
(OF==0&amp;&amp;SF==0)||(OF==1&amp;&amp;SF==1)を簡単にすると OF==SF になる．</li>
<li>④: ③に ZF==0 (結果はゼロではない)という条件を加えると，
ZF==0&amp;&amp;SF=OF が *op2 &gt; <em>op1</em> と等価になる．</li>
</ul>
<img src="figs/of-sf.svg" height="250px" id="fig:of-sf">
<ul>
<li>上の例で，OF==1の時，引き算結果の大小関係(SF)が逆になることを見てみます．
<ul>
<li>(+64)-(-64)はオーバーフローが起きて，結果は-128になります(SF==1)．
引き算の結果は負ですが，大小関係は (+64) &gt; (-64) です(逆になってます)．</li>
<li>(-64)-(+65)はオーバーフローが起きて，結果は127になります(SF==0)．
引き算の結果は正ですが，大小関係は (-64) &lt; (+65) です(逆になってます)．</li>
</ul>
</li>
</ul>
</details>
<h3 id="条件付きジャンプ-符号なし整数用"><a class="header" href="#条件付きジャンプ-符号なし整数用">条件付きジャンプ: 符号なし整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em><br/> <strong><code>jnbe</code></strong> <em>rel</em></td><td>jump if above <br/> jump if not below nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0&amp;ZF==0</code></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em><br/> <strong><code>jnb</code></strong> <em>rel</em></td><td>jump if above or equal <br/> jump if not below</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em><br/> <strong><code>jna</code></strong> <em>rel</em></td><td>jump if below or equal <br/> jump if not above</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1&amp;&amp;ZF==1</code></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em><br/> <strong><code>jnae</code></strong> <em>rel</em></td><td>jump if below <br/> jump if not above nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>ja foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jnbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnbe foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jae foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jnb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnb foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jbe foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jna</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jna foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jb foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
<tr><td><strong><code>jnae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnae foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>ja</code>と<code>jnbe</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>CF==0&amp;&amp;ZF==0</code>と共通です．
他の3つのペア，<code>jae</code>と<code>jnb</code>，<code>jbe</code>と<code>jna</code>，<code>jb</code>と<code>jnae</code>も同様です．</li>
</ul>
<!--
### 条件付きジャンプ: カウンタ用
ほぼ使わないので割愛
-->
<h3 id="条件付きジャンプ-フラグ用"><a class="header" href="#条件付きジャンプ-フラグ用">条件付きジャンプ: フラグ用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td>jump if carry</td><td><code>CF==1</code>なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td>jump if not carry</td><td><code>CF==0</code>なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td>jump if overflow</td><td><code>OF==1</code>なら<em>rel</em>にジャンプ</td><td><code>OF==1</code></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td>jump if not overflow</td><td><code>OF==0</code>なら<em>rel</em>にジャンプ</td><td><code>OF==0</code></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td>jump if sign</td><td><code>SF==1</code>なら<em>rel</em>にジャンプ</td><td><code>SF==1</code></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td>jump if not sign</td><td><code>SF==0</code>なら<em>rel</em>にジャンプ</td><td><code>SF==0</code></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em> <br/> <strong><code>je</code></strong> <em>rel</em></td><td>jump if zero <br/> jump if equal</td><td><code>ZF==1</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>==<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==1</code></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em> <br/> <strong><code>jne</code></strong> <em>rel</em></td><td>jump if not zero <br/> jump if not equal</td><td><code>ZF==0</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>!=<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==0</code></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em> <br/> <strong><code>jpe</code></strong> <em>rel</em></td><td>jump if parity <br/> jump if parity even</td><td><code>PF==1</code>なら<em>rel</em>にジャンプ</td><td><code>PF==1</code></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em> <br/> <strong><code>jpo</code></strong> <em>rel</em></td><td>jump if not parity <br/> jump if parity odd</td><td><code>PF==0</code>なら<em>rel</em>にジャンプ</td><td><code>PF==0</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td><code>jc foo</code></td><td>if (<code>CF==1</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td><code>jnc foo</code></td><td>if (<code>CF==0</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td><code>jo foo</code></td><td>if (<code>OF==1</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td><code>jno foo</code></td><td>if (<code>OF==0</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td><code>js foo</code></td><td>if (<code>SF==1</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td><code>jns foo</code></td><td>if (<code>SF==0</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em></td><td><code>jz foo</code></td><td>if (<code>ZF==1</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>je</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>je foo</code></td><td>if (<code>%rax==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em></td><td><code>jnz foo</code></td><td>if (<code>ZF==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jne</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jne foo</code></td><td>if (<code>%rax!=0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em></td><td><code>jp foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpe</code></strong> <em>rel</em></td><td><code>jpe foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em></td><td><code>jnp foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpo</code></strong> <em>rel</em></td><td><code>jpo foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jz</code>と<code>je</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==1</code>と共通です．
他の3つのペア，<code>jnz</code>と<code>jne</code>，<code>jp</code>と<code>jpe</code>，<code>jnp</code>と<code>jpo</code>も同様です．</li>
<li>AFフラグのための条件付きジャンプ命令は存在しません．</li>
</ul>
<h3 id="call-return"><a class="header" href="#call-return"><code>call</code>, <code>ret</code>命令: 関数を呼び出す，リターンする</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>op1</em></td><td>call procedure</td><td><code>%rip</code>をスタックにプッシュしてから <em>op1</em>にジャンプする<br/> (<code>pushq %rip; %rip</code> = <em>op1</em>)</td></tr>
<tr><td><strong><code>ret</code></strong></td><td>return from procedure</td><td>スタックからポップしたアドレスにジャンプする <br/> (<code>popq %rip</code>)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>rel</em></td><td><code>call foo</code></td><td>相対・直接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>call</code></strong> <em>r/m</em></td><td><code>call *%rax</code></td><td>絶対・間接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>ret</code></strong></td><td><code>ret</code></td><td>関数からリターン</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<details>
<summary>
call.sの実行例
</summary>
<pre><code>$ gcc -g call.s
$ gdb ./a.out -x call.txt
reakpoint 1, main () at call.s:12
12	    call foo
1: /x $rip = 0x401107
# info address foo
Symbol &quot;foo&quot; is at ❶0x401106 in a file compiled without debugging.
Breakpoint 2 at 0x401106: file call.s, line 6.
❷Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106

❸Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106

❹Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106
# 3回，関数fooを呼び出して，リターンできていれば成功
</code></pre>
<ul>
<li><code>info address foo</code>コマンドで，<code>foo</code>のアドレスは
<code>❶0x401106</code>番地と分かりました．</li>
<li>❷❸❹より3回，<code>foo</code>を呼び出せていることが分かります．</li>
</ul>
</details>
<blockquote>
<p>注: <strong>関数呼び出し規約</strong>(calling convention)，スタックレイアウトなどは
<a href="./9-abi.html#ABI">ABI</a>が定めるお約束です．
以下では<a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>に基づいて説明します．</p>
</blockquote>
<h4 id="return-address-stack"><a class="header" href="#return-address-stack">関数の呼び出しとリターンでは，<strong>戻り番地をスタックに積む</strong></a></h4>
<p>関数呼び出しとリターンには<strong>スタック</strong>を使います(スタック超重要)．
スタックは以下の図の通り，プロセスが使うメモリの一部の領域です．</p>
<img src="figs/memory-layout.svg" height="300px" id="fig:memory-layout">
<p>関数呼び出しにジャンプ命令(<code>jmp</code>)を使うと，
(一般的に呼び出す側は複数箇所なので)
リターン時に<strong>どこに戻ればよいかが分かりません</strong>．
そこで，戻る場所(<strong>戻り番地</strong> (return address))をスタックに保存しておきます．
<code>call</code>命令はこの「戻り番地をスタックに保存する」ことを自動的にやってくれます．
以下で具体例<code>call2.s</code>を見てみましょう．
<code>call2.s</code>では関数<code>main</code>から関数<code>foo</code>を<code>call</code>命令で呼び出して，
関数<code>foo</code>から関数<code>main</code>に<code>ret</code>命令でリターンしています．</p>
<pre><code class="language-x86asmatt"># asm/call2.s
    .text

    .type foo, @function
foo:
    ret
    .size foo, .-foo

    .globl main
    .type main, @function
main:
    call foo
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie call2.s
$ objdump -d ./a.out
(中略)
0000000000401106 &lt;foo&gt;:
❷401106:	c3                   	ret    

0000000000401107 &lt;main&gt;:
  401107:	e8 fa ff ff ff       	call   401106 &lt;foo&gt;
❶40110c:	c3                   	ret    
</code></pre>
<p><code>-no-pie</code>オプションは
<a href="./3-binary.html#ASLR-PIE">実行するたびにアドレスが変わらない</a>ためにつけています．
<code>-no-pie</code>オプション無しでも仕組みは変わりません．</p>
<form class="tab-wrap">
    <input id="call1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="call1"><code>call foo</code>実行直前</label>
    <div class="tab-content">
    	 <img src="figs/call1.svg" height="300px" id="fig:call1">
    </div>
    <input id="call2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="call2"><code>call foo</code>実行直後</label>
    <div class="tab-content">
    	 <img src="figs/call2.svg" height="300px" id="fig:call2">
    </div>
    <input id="call3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="call3">関数<code>foo</code>の<code>ret</code>実行直後</label>
    <div class="tab-content">
    	 <img src="figs/call3.svg" height="300px" id="fig:call3">
    </div>
</form>
<ul>
<li>
<p><code>call foo</code>実行直前: 図(左)が示す通り<code>%rip</code>は<code>call foo</code>命令を指しています．
ここで，<code>call foo</code>命令を実行すると，</p>
<ul>
<li><code>%rip</code>は<code>call foo</code>命令の次の命令(ここでは<code>main</code>関数中の<code>ret</code>命令)を指します．
(<code>%rip</code>は「実行中の命令の<strong>次の命令</strong>」を指すことを思い出しましょう)．</li>
<li><code>call foo</code>はまず<code>%rip</code>の値(上図では❶<code>0x40110C</code>)をスタックにプッシュします．
その結果，スタック上に<code>0x40110C</code>が書き込まれます．
この<code>0x40110C</code>が(関数<code>foo</code>からリターンする際の)戻り番地となります．</li>
<li>次に，<code>call foo</code>は関数<code>foo</code>の先頭番地(上図では❷<code>0x401106</code>)にジャンプします．</li>
</ul>
</li>
<li>
<p><code>call foo</code>実行直後: 図(中)が示す通り<code>%rip</code>は<code>foo</code>関数の<code>ret</code>命令を指しています．
一方，スタックトップ(<code>%rsp</code>が指している場所)には
戻り番地<code>0x40110C</code>が格納されています．
ここで，<code>ret</code>命令を実行すると，</p>
<ul>
<li>スタックから戻り番地 <code>0x40110C</code>をポップして取り出して，
<code>%rip</code>に格納します(つまり<code>0x40110C</code>番地にジャンプします)．</li>
</ul>
</li>
<li>
<p>関数<code>foo</code>の<code>ret</code>実行直後:
無事に関数<code>main</code>の<code>call foo</code>命令の次の命令(ここでは<code>ret</code>命令ｌ)に戻ってこれました．</p>
</li>
</ul>
<p>このように戻り番地をスタックに格納すれば，(メモリ不足にならない限り)
どれだけ数多くの関数呼び出しが続いても，正しい順番でリターンすることができます．
戻り番地の格納にスタックを使えば，
「コールした順番とは逆の順序で戻りアドレスを取り出せる」からです．</p>
<img src="figs/call-stack.svg" height="200px" id="fig:call-stack">
<p>例えば，上図のようにA→B→C→Dという順番で関数コールをした場合，
上図の順番で「Aへの戻り番地」「Bへの戻り番地」「Cへの戻り番地」が
スタックに積まれます．
リターンするときはD→C→B→Aという逆の順番になるわけですが，
スタックを使っているので，
ポップするたびに「Cへの戻り番地」「Bへの戻り番地」「Aへの戻り番地」
という逆の順番で戻り番地を正しく取り出せます．</p>
<h4 id="c言語の関数ポインタと間接call命令"><a class="header" href="#c言語の関数ポインタと間接call命令">C言語の<strong>関数ポインタ</strong>と，間接<code>call</code>命令</a></h4>
<pre><code>// asm/fp.c
int add5 (int n)
{
    return n + 5;
}

int main ()
{
    int (*fp)(int n);
    fp = add5;
    return fp (10);
}
</code></pre>
<pre><code>$ gcc -g fp.c
$ objdump -d ./a.out
(中略)
000000000000113c &lt;main&gt;:
    113c:	f3 0f 1e fa          	endbr64 
    1140:	55                   	push   %rbp
    1141:	48 89 e5             	mov    %rsp,%rbp
    1144:	48 83 ec 10          	sub    $0x10,%rsp
    1148:	48 8d 05 da ff ff ff ❷ lea    -0x26(%rip),%rax        # 1129 &lt;add5&gt;
    114f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    1153:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1157:	bf 0a 00 00 00       	mov    $0xa,%edi
    115c:	ff d0                ❶ call   *%rax
    115e:	c9                   	leave  
    115f:	c3                   	ret    
</code></pre>
<ul>
<li>C言語で関数ポインタを使うと，間接<code>call</code>命令にコンパイルされます．
<code>asm/fp.c</code>中の</li>
</ul>
<pre><code>    int (*fp)(int n);
</code></pre>
<p>の部分は「『<code>int</code>型の引数をもらい，<code>int</code>型を返す関数』へのポインタを
格納する変数<code>fp</code>を定義しています．
そして，<code>fp = add5</code>と代入を行い，<code>fp (10)</code>することで，
関数ポインタを使って間接的に<code>add5</code>関数を呼び出しています．</p>
<ul>
<li>このCコードをコンパイルして逆アセンブルすると，
関数ポインタを使った関数呼び出しは，
間接<code>call</code>命令 (ここでは❶ call *%rax)になっていることが分かります．
<code>%rax</code>には関数<code>add5</code>の先頭アドレスが入っています
(ここでは ❷ <code>lea -0x26(%rip),%rax</code>を実行することで)．</li>
</ul>
<details>
<summary>
fp = add5 であってる?
</summary>
<p><code>fp = add5</code>ではなく<code>fp = &amp;add5</code>が正しいのでは?と思った人はいますか?
<code>fp = add5</code>で正しいです．
(<code>sizeof</code>や単項演算子<code>&amp;</code>のオペランドであるときを除いて)
式中では「<strong>関数</strong>は<strong>関数へのポインタ</strong>」に暗黙的に型変換されます．
ですので，式中で<code>add5</code>の型は「関数へのポインタ」になり，
<code>fp</code>と<code>add5</code>は同じ型になります
(<code>fp = &amp;add5</code>としても動くんですけどね)．</p>
<p><code>fp (10)</code>も同様です．「<code>fp</code>は関数へのポインタなのだから，
<code>(*fp) (10)</code>が正しいのでは?」と思うかも知れません．
でも，<code>fp (10)</code>で正しいです．
そもそも関数呼び出しの文法は「関数 ( 引数の列 )」ではなく，
「関数へのポインタ ( 引数の列 )」です．
<code>add5 (10)</code>の<code>add5</code>の型は<strong>関数へのポインタ</strong>なんです．
ちなみに<code>(*fp)(10)</code>としても動きます．
<code>(*fp)</code>は「関数へのポインタを関数」に戻しますが，その戻った関数型は
すぐに「関数型へのポインタ」に変換されるからです．
ですので，<code>(******fp)(10)</code>でも動きます．</p>
</details>
<h3 id="enter-leave命令-スタックフレームを作成する解放する"><a class="header" href="#enter-leave命令-スタックフレームを作成する解放する"><code>enter</code>, <code>leave</code>命令: スタックフレームを作成する，解放する</a></h3>
<h4 id="スタックフレーム"><a class="header" href="#スタックフレーム">スタックフレーム</a></h4>
<ul>
<li><a href="6-inst.html#return-address-stack">戻り番地はスタックに格納</a>しますが，
それ以外のデータ(例えば，局所変数，引数，返り値，退避したレジスタの値など)も
スタックを使います．</li>
<li>スタック上で管理する，<strong>関数呼び出し1回分のデータ</strong>のことを
<strong>スタックフレーム</strong> (stack frame)といいます．</li>
</ul>
<p>例えば，<code>main</code>関数が<code>add5</code>関数を呼び出して，<code>add5</code>からリターンすると以下の図になります．
スタックフレームにはいろいろなデータが入っていますが，
スタックフレームまるごとでプッシュしたりポップしたりします．
ですので，関数を呼び出したりリターンする時はこの
「スタックフレームをプッシュしたり，ポップしたり」，
つまり「スタックフレームを作成したり，破棄したり」する機械語命令列を
使う必要があります(以下で説明します)．</p>
<img src="figs/stack-frame.svg" height="200px" id="fig:stack-frame">
<p>そして<code>%rsp</code>と<code>%rbp</code>は以下の図のように，
<strong>スタック上の一番上のスタックフレームの上下</strong>を指す役割を担っています．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>
オプションでコンパイルされている場合を除く)．</p>
<img src="figs/stack-frame2.svg" height="200px" id="fig:stack-frame2">
<h4 id="enter-leave命令"><a class="header" href="#enter-leave命令"><code>enter</code>, <code>leave</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>op1</em>, <em>op2</em></td><td>make stack frame</td><td>サイズ<em>op1</em>のスタックフレームを作成する</td></tr>
<tr><td><strong><code>leave</code></strong></td><td>discard stack frame</td><td>今のスタックフレームを破棄する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>imm16</em>, <em>imm8</em></td><td><code>enter $0x20, $0</code></td><td><code>pushq %rbp</code><br/><code>movq %rsp, %rbp</code><br/><code>subq $0x20, %rsp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
<tr><td><strong><code>leave</code></strong></td><td><code>leave</code></td><td><code>movq %rbp, %rsp</code><br/><code>popq %rbp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>enter</code>命令の<em>op2</em>には関数のネストレベルを指定するのですが，
C言語では入れ子の関数がない(つまりネストレベルは常にゼロ)なので
常にゼロを指定します．</li>
<li>ただし，<code>enter</code>は遅いので通常は使いません．
代わりに同等の動作をする<code>pushq %rbp; movq %rsp, %rbp; subq $</code><em>size</em><code>, %rsp</code>を使います．(<em>size</em>は新しいスタックフレームで確保するバイトサイズです)．
スタックは0番地に向かって成長するので，足し算ではなく引き算を使います．</li>
</ul>
<details>
<summary>
enter命令はどのぐらい遅いのか(3〜4倍?)
</summary>
<pre><code>$ gcc -g rdtscp-enter.c
$ ./a.out
processor ID = 0
processor ID = 0
processor ID = 0
240966
60796
$ ./a.out
processor ID = 0
processor ID = 0
processor ID = 0
165718
46368
$ ./a.out
processor ID = 1
processor ID = 1
processor ID = 1
204346
49530
</code></pre>
<p>インラインアセンブラを使ったCプログラム<a href="./asm/rdtscp-enter.c"><code>rdtscp-enter.c</code></a>で，以下のコードを10000万回繰り返して，
タイムスタンプカウンタの差分を調べた所，
(単純な調べ方ですが)概ね3〜4倍という結果になりました．</p>
<pre><code># 遅い
asm volatile (&quot;enter $32, $0; leave&quot;);
</code></pre>
<pre><code># 速い
asm volatile ( &quot;pushq %rbp; movq %rsp, %rbp;&quot;
               &quot;subq $32, %rsp; leave&quot;);
</code></pre>
<p><code>leave</code>を入れないとスタックを使い切ってしまうので<code>leave</code>を入れています．
<code>leave</code>を除いて計測すればもうちょっと差が開くかも知れません．</p>
</details>
<p>というわけで，<code>enter</code>は遅いので，コンパイラが<code>enter</code>の代わりに出力する
機械語命令列で説明します．</p>
<pre><code class="language-x86asmatt"># asm/stack-frame.s
    .text
    .type foo, @function
foo:
    pushq %rbp
    movq %rsp, %rbp	
    subq $32, %rsp
    # 本来はここにfoo関数本体の機械語列が来る
    leave # movq %rbp, %rsp; pop %rbp と同じ
    ret

    .globl main
    .type main, @function
main:
    call foo
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g enter2.s
$ gdb ./a.out -x stack-frame.txt
</code></pre>
<form class="tab-wrap">
    <input id="stack-frame6-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame6-1"><code>call</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-1.svg" height="150px" id="fig:stack-frame6-1">
    </div>
    <input id="stack-frame6-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-2"><code>call</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-2.svg" height="150px" id="fig:stack-frame6-2">
    </div>
    <input id="stack-frame6-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-3"><code>pushq %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-3.svg" height="150px" id="fig:stack-frame6-3">
    </div>
    <input id="stack-frame6-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-4"><code>movq %rsp, %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-4.svg" height="143px" id="fig:stack-frame6-4">
    </div>
    <input id="stack-frame6-5" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-5"><code>subq $32, %rsp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-5.svg" height="220px" id="fig:stack-frame6-5">
    </div>
</form>
<ul>
<li>関数<code>foo</code>の最初の3行が「関数<code>foo</code>のスタックフレーム」を作ります．</li>
</ul>
<pre><code class="language-x86asmatt">    pushq %rbp
    movq %rsp, %rbp	
    subq $32, %rsp
</code></pre>
<ul>
<li><code>call</code>前: <code>%rsp</code>と<code>%rbp</code>は関数<code>main</code>のスタックフレームの上下を指しています．</li>
<li><code>call</code>後: <code>call</code>命令が戻り番地をプッシュしてから，
(図にはありませんが)関数<code>foo</code>にジャンプします．</li>
<li><code>pushq %rbp</code>後: スタックに<code>%rbpの値</code>(図中では古い<code>%rbp</code>の値)をプッシュします．
この値は<code>main</code>のスタックフレームの一番下を指しています．</li>
<li><code>movq %rsp, %rbp</code>後: <code>%rbp</code>の値をスタック上に退避した(保存した)ので，
<code>movq %rsp, %rbp</code>により，
<code>%rbp</code>が「関数<code>foo</code>のスタックフレームの一番下」を指すようにします．</li>
<li><code>subq $32, %rsp</code>により，<code>foo</code>のスタックフレームを確保しました．
これで<code>foo</code>のスタックフレームは完成です．
ここでは32バイト確保していますが，関数<code>foo</code>の中身によって適宜，増減します．</li>
</ul>
<form class="tab-wrap">
    <input id="stack-frame7-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame7-1"><code>leave</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-1.svg" height="220px" id="fig:stack-frame7-1">
    </div>
    <input id="stack-frame7-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-2"><code>leave</code>前半(<code>movq %rbp, %rsp</code>)後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-2.svg" height="150px" id="fig:stack-frame7-2">
    </div>
    <input id="stack-frame7-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-3"><code>leave</code>後半(<code>popq %rbp</code>)後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-3.svg" height="150px" id="fig:stack-frame7-3">
    </div>
    <input id="stack-frame7-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-4"><code>ret</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-4.svg" height="143px" id="fig:stack-frame7-4">
    </div>
</form>
<ul>
<li>関数<code>foo</code>の最後の2行(<code>leave</code>と<code>ret</code>)が
「関数<code>foo</code>のスタックフレーム」を破棄します．
<code>leave</code>命令は<code>movq %rbp, %rsp; popq %rbp</code>と同じ動作をします．</li>
</ul>
<pre><code class="language-x86asmatt">    leave
    ret
</code></pre>
<ul>
<li><code>leave</code>前: <code>%rsp</code>と<code>%rbp</code>が関数<code>foo</code>のスタックフレームの上下を指しています．</li>
<li><code>leave</code>前半(<code>movq %rbp, %rsp</code>)後:
<code>%rsp</code>が関数<code>foo</code>のスタックフレームの一番下を指します．</li>
<li><code>leave</code>後半(<code>popq %rbp</code>)後:
退避しておいた「古い<code>%rbp</code>」をポップして<code>%rbp</code>に格納することで，
<code>%rbp</code>は関数<code>main</code>のスタックフレームの一番下を指します．</li>
<li><code>ret</code>後:
スタックトップに戻り番地がある状態に戻ったので，
<code>ret</code>命令で関数<code>foo</code>から<code>main</code>にリターンします．
<code>ret</code>命令はスタックからポップして戻り番地を取り出すので，
スタック上から戻り番地が無くなります．
これでスタックは関数<code>foo</code>を呼び出す前と同じ状態に戻りました．
<code>%rsp</code>と<code>%rbp</code>は関数<code>main</code>のスタックフレームの上下を指しています．</li>
</ul>
<h3 id="caller-saveレジスタとcallee-saveレジスタ"><a class="header" href="#caller-saveレジスタとcallee-saveレジスタ">caller-saveレジスタとcallee-saveレジスタ</a></h3>
<ul>
<li>レジスタの数は限られているので，必要に応じて，
レジスタの値はスタック上に退避(保存)する必要があります．</li>
<li>その保存の仕方で，レジスタは <strong>caller-saveレジスタ</strong>と<strong>callee-saveレジスタ</strong>に分類されます．これを以下で説明します．</li>
</ul>
<h4 id="calleeとcaller"><a class="header" href="#calleeとcaller">calleeとcaller</a></h4>
<img src="figs/caller-callee.svg" height="100px" id="fig:caller-callee">
<p>関数Aが関数Bを呼び出す時，</p>
<ul>
<li>関数Aを<strong>caller</strong>(呼び出す側)，</li>
<li>関数Bを<strong>callee</strong>(呼び出される側)，といいます．</li>
</ul>
<p>雇用者を employer，被雇用者(雇われてる人)を employee って呼ぶのと同じ言い方ですね．
デバッグする側(debugger)，デバッグされる側(debuggee)，
テストする側(tester)，テストされる側(testee)という言い方もあります．</p>
<h4 id="レジスタ退避と回復"><a class="header" href="#レジスタ退避と回復">レジスタ退避と回復</a></h4>
<ul>
<li>関数呼び出しで，レジスタの退避と回復が必要になることが良くあります．
レジスタの数が有限でごく少ないからです．</li>
<li>レジスタの退避・回復のやり方は大きく2種類あります：
<ul>
<li>caller側で退避・回復: caller側でレジスタのプッシュとポップを行う</li>
<li>callee側で退避・回復: callee側でレジスタのプッシュとポップを行う</li>
</ul>
</li>
</ul>
<img src="figs/caller-callee-reg.svg" height="150px" id="fig:caller-callee-reg">
<h4 id="caller-callee-save-regs"><a class="header" href="#caller-callee-save-regs"><a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>での caller-saveレジスタとcallee-saveレジスタ</a></h4>
<p>レジスタの退避と回復は，caller側でもcallee側でもできますが，
レジスタごとにどちらでやるかを決めておくと便利です．</p>
<ul>
<li>caller側で退避・回復を行うレジスタを<strong>caller-saveレジスタ</strong>と呼びます</li>
<li>callee側で退避・回復を行うレジスタを<strong>callee-saveレジスタ</strong>と呼びます</li>
</ul>
<p><a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>では
以下のように，caller-saveレジスタとcallee-saveレジスタが決まっています．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<p><code>%rsp</code>のcallee側での退避・回復には，
プッシュやポップを使いませんが，
「caller側にリターンする前に元に戻す，という約束をcallee側は守る(責任がある)」
という意味で，<code>%rsp</code>もcallee-saveレジスタになります．</p>
<h3 id="関数規約"><a class="header" href="#関数規約">関数呼び出し規約 (calling convention)</a></h3>
<p><strong>関数呼び出し規約</strong> (calling convention)は
ABIが定める「callerとcalle間のお約束」です．例えば，</p>
<ul>
<li>引数の渡し方 (スタック渡しかレジスタ渡しか)</li>
<li>スタックフレームのレイアウト (どこに何を置くか)</li>
<li>レジスタの役割</li>
<li><a href="./6-inst.html#caller-callee-save-regs">caller-saveレジスタとcallee-saveレジスタ</a></li>
<li>アラインメント</li>
</ul>
<h4 id="arg-reg"><a class="header" href="#arg-reg">引数の渡し方</a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<ul>
<li>第1引数〜第6引数は上記の通り，レジスタを介して渡します</li>
<li>第7引数以降はレジスタではなくスタックを介して渡します</li>
</ul>
<h4 id="スタックレイアウト"><a class="header" href="#スタックレイアウト">スタックレイアウト</a></h4>
<img src="figs/stack-layout2.svg" height="400px" id="fig:stack-layout2">
<ul>
<li>上図は典型的なスタックレイアウトです．</li>
<li>局所変数と第7以降の引数はスタック上に置きます．
スタック上の局所変数や引数は<code>%rbp</code>を使ってアクセスします．
例えば，上図ではメモリ参照<code>-16(%rbp)</code>は局所変数2，
メモリ参照<code>24(%rbp)</code>は第8引数への参照になります．
<code>%rbp</code>を使う理由は，
これらの絶対アドレスがコンパイル時に決まりませんが，
<code>%rbp</code>に対する相対アドレスはコンパイル時に決まるからです．
(<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>オプションが
指定された場合は，<code>%rbp</code>ではなく<code>%rsp</code>を使ってアクセスします)．</li>
<li>スタックに置く局所変数や引数が8バイト未満の場合は
<a href="9-abi.html#alignment">アラインメント制約</a>を満たすために，
隙間(パディング)を入れる必要があることがあります．</li>
</ul>
<h4 id="register-role"><a class="header" href="#register-role">レジスタの役割</a></h4>
<ul>
<li><code>%rsp</code>と<code>%rbp</code>は一番上のスタックフレームの上下を指します
(<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>オプションが
指定されていなければ)．</li>
<li>(8バイト以下の整数であれば)返り値は<code>%rax</code>に入れて返します．</li>
<li>可変長引数の関数(例えば <code>printf</code>)を呼び出す時は，
呼び出す前に
<code>%al</code>に「使用するベクタレジスタ(例えば<code>%xmm0</code>)の数」を入れます．</li>
</ul>
<h4 id="レッドゾーン-redzone"><a class="header" href="#レッドゾーン-redzone">レッドゾーン (redzone)</a></h4>
<img src="figs/redzone.svg" height="300px" id="fig:redzone">
<ul>
<li><a href="./2-asm-intro.html#redzone"><strong>レッドゾーン</strong></a>は
<code>%rsp</code>レジスタの上，128バイトの領域のことです．
この領域には好きに読み書きして良いことになっています．</li>
</ul>
<h4 id="alignment-rsp"><a class="header" href="#alignment-rsp">アラインメント制約</a></h4>
<ul>
<li><code>call</code>命令実行時に<code>%rsp</code>レジスタは16バイト境界を満たす，
つまり<code>%rsp</code>の値が16の倍数である必要があります．
これを守らないとプログラムが<strong>クラッシュすることがある</strong>ので要注意です</li>
</ul>
<h4 id="prologue"><a class="header" href="#prologue">関数プロローグとエピローグ</a></h4>
<img src="figs/func-prologue.svg" height="300px" id="fig:func-prologue">
<ul>
<li>関数本体実行前に準備を行うコードを<strong>関数プロローグ</strong>(function prologue)，
関数本体実行後に後片付けを行うコードを<strong>関数エピローグ</strong>(function epilogue)
といいます．</li>
<li>上図は典型的な関数プロローグとエピローグです．
<ul>
<li>関数プロローグでは，スタックフレームの作成，
callee-saveレジスタの退避(必要があれば)，
(局所変数や引数のために必要な)スタックフレーム上での領域の確保，
などを行います．</li>
<li>関数エピローグでは，概ね，関数プロローグの逆を行います．
callee-saveレジスタの回復の順番も，退避のときと逆になっている点に注意して下さい
(退避の時は<code>%rbx</code>→<code>%r12</code>，回復の時は逆順で<code>%r12</code>→<code>%rbx</code>)．</li>
</ul>
</li>
<li>コンパイラに<code>-O2</code>などの最適化オプションを指定すると，
不要な命令が削られたり移動するため，プロローグとエピローグの内容が
大きく変わることがあります．</li>
</ul>
<h3 id="cコードからアセンブリコードを呼び出す"><a class="header" href="#cコードからアセンブリコードを呼び出す">Cコードからアセンブリコードを呼び出す</a></h3>
<pre><code>// asm/mix1/main.c
#include &lt;stdio.h&gt;
int sub (int, int);
int main (void)
{
    printf (&quot;%d\n&quot;, sub (23, 7));
}

</code></pre>
<pre><code class="language-x86asmatt"># asm/mix1/sub.s
    .text
    .globl sub
    .type sub, @function
sub:
    pushq %rbp
    movq  %rsp, %rbp
    subq  %rsi, %rdi
    movq  %rdi, %rax
    leave
    ret
    .size sub, .-sub
</code></pre>
<pre><code>$ gcc -g main.c sub.s
$ ./a.out
16
</code></pre>
<ul>
<li><a href="./6-inst.html#%E9%96%A2%E6%95%B0%E8%A6%8F%E7%B4%84">関数規約</a>が守られていれば，
Cからアセンブリコードの関数を呼び出したり，
アセンブリコードからCの関数を呼び出すことができます．</li>
<li>上の例では関数<code>main</code>から，アセンブリコード中の関数<code>sub</code>を呼び出しています．</li>
</ul>
<h3 id="アセンブリコードからcコードを呼び出す"><a class="header" href="#アセンブリコードからcコードを呼び出す">アセンブリコードからCコードを呼び出す</a></h3>
<pre><code class="language-x86asmatt"># asm/mix2/main.s
    .text
    .globl main
    .type sub, @function
main:
    pushq %rbp
    movq %rsp, %rbp
    movq $23,  %rdi
    movq $7,   %rsi
    call sub
    leave
    ret
    .size main, .-main
</code></pre>
<pre><code>// asm/mix2/sub.c
int sub (int a, int b)
{
    return a - b;
}
</code></pre>
<pre><code>$ gcc -g main.s sub.c
$ ./a.out
$ echo $?
16
</code></pre>
<ul>
<li>上の例ではアセンブリコードからCの関数を呼び出しています．
関数<code>sub</code>の計算結果をここでは<strong>終了ステータス</strong>として表示しています．
関数<code>sub</code>が計算結果を<code>%rax</code>に入れて返した後，
関数<code>main</code>が<code>%rax</code>を壊さず終了したので，
引き算の結果がそのまま終了ステータスになっています．</li>
<li>終了ステータスの値は関数<code>main</code>が<code>return</code>した値，または<code>exit</code>の引数に渡した値です．
ただし，下位1バイトしか受け取れないので，終了ステータスの値は0から255までになります．</li>
</ul>
<h3 id="アセンブリコードからprintfを呼び出す"><a class="header" href="#アセンブリコードからprintfを呼び出す">アセンブリコードから<code>printf</code>を呼び出す</a></h3>
<pre><code class="language-x86asmatt"># asm/printf.s
    .section .rodata
L_fmt:
    .string &quot;%d\n&quot;

    .text
    .globl main
    .type sub, @function
main:
    pushq %rbp
    movq  %rsp, %rbp
    leaq  L_fmt(%rip), %rdi
    movq  $999,  %rsi
#    pushq $888   # ❶このコメントを外すと segmentation fault になることも
    movb  $0, %al # ❷
    call  printf
    leave
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g printf.s
$ ./a.out
999
</code></pre>
<ul>
<li>アセンブリコードから<code>printf</code>などのライブラリ関数を呼び出せます．</li>
<li><code>call</code>命令実行時には<code>%rsp</code>の値は16の倍数で無くてはいけません
(<a href="./6-inst.html#alignment-rsp"><code>%rsp</code>のアラインメント制約</a>)．
なので，❶の行のコメントを外して実行すると，segmentation fault
が起きることがあります(起きないこともありますが，それはたまたまです)．
❶の行のコメントを外さなければ，
「戻り番地の8バイトと古い<code>rbp</code>の値の8バイト」でちょうど16バイトが積まれて，
<code>%rsp</code>の値は16の倍数になります．</li>
<li><code>printf</code>は可変長引数を持つ関数なので，呼び出し前に
<code>%al</code>にベクトルレジスタ(例 <code>%xmm0</code>)の数を<a href="./6-inst.html#register-role">入れておく必要</a>があります
(ここではベクトルレジスタを使っていないのでゼロに設定)．</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnuアセンブラ命令"><a class="header" href="#gnuアセンブラ命令">GNUアセンブラ命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インラインアセンブラ"><a class="header" href="#インラインアセンブラ">インラインアセンブラ</a></h1>
<h2 id="att-intel"><a class="header" href="#att-intel">AT&amp;T形式とIntel形式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 9; }
</style>
<h1 id="ABI"><a class="header" href="#ABI">ABI: アプリケーション・バイナリ・インタフェース</a></h1>
<h2 id="alignment"><a class="header" href="#alignment">アラインメント制約</a></h2>
<div class="table-wrapper"><table><thead><tr><th>型</th><th>アラインメント制約</th></tr></thead><tbody>
<tr><td>1バイト整数</td><td>1の倍数のアドレス</td></tr>
<tr><td>2バイト整数</td><td>2の倍数のアドレス</td></tr>
<tr><td>4バイト整数</td><td>4の倍数のアドレス</td></tr>
<tr><td>8バイト整数</td><td>8の倍数のアドレス</td></tr>
<tr><td>ポインタ(8バイト長)</td><td>8の倍数のアドレス</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 10; }
</style>
<h1 id="デバッガgdbの使い方"><a class="header" href="#デバッガgdbの使い方">デバッガ<code>gdb</code>の使い方</a></h1>
<h2 id="デバッガの概要"><a class="header" href="#デバッガの概要">デバッガの概要</a></h2>
<h3 id="なぜデバッガ"><a class="header" href="#なぜデバッガ">なぜデバッガ?</a></h3>
<img src="figs/debugger-why.svg" height="200px" id="fig:debugger-why">
<ul>
<li><code>gdb</code>などのデバッガの使用をお薦めする理由は「プログラムのデバッグ」を<strong>とても楽にしてくれる</strong>からです！！</li>
<li>デバッグが難しいのは実行中のプログラムの中身（実行状態）が外からでは見えにくいからです．
<code>printf</code>を埋め込むことでも変数の値や実行パスを調べられますが，
デバッガを使うともっと効率的に調べることができます．</li>
<li>デバッガは「簡単に習得できて，効果も高いお得な開発ツール」です．
慣れることが大事です．</li>
<li>デバッガはつまみ食いOKです．
最初は「自分が使いたい機能，使える機能」だけを使えばいいのです．
デバッガを使うために「デバッガの全て」を学ぶ必要はありません．</li>
</ul>
<h3 id="デバッガとは"><a class="header" href="#デバッガとは">デバッガとは</a></h3>
<img src="figs/debugger-what.svg" height="200px" id="fig:debugger-what">
<p>デバッガは主に以下の機能を組み合わせて，プログラムの実行状態を調べることで，
バグの原因を探します．</p>
<ul>
<li>① プログラム実行の一時停止:
「実行を止めたい場所(<strong>ブレークポイント</strong>)」や止めたい条件を設定できます．
ブレークポイントには関数名や行番号やアドレスなどを指定できます．</li>
<li>② <strong>ステップ実行</strong>:
①でプログラムの実行を一時停止した後，
ステップ実行の機能を使って，ちょっとずつ実行を進めます．</li>
<li>③ 実行状態の表示:
変数の値，現在の行番号，スタックトレース(バックトレース)などを表示できます．</li>
<li>④ 実行状態の変更:
変数に別の値を代入したり，関数を呼び出したりして，
「ここでこう実行したら」を試せます．</li>
</ul>
<h3 id="gdbとは"><a class="header" href="#gdbとは"><code>gdb</code>とは</a></h3>
<ul>
<li><strong>Linux</strong>上で使える代表的で高性能なデバッガです．</li>
<li>C/C++/<strong>アセンブリ言語</strong>/Objective-C/Rustなど，多くの言語をサポートしています．</li>
<li><strong>Linux/x86-64</strong>を含む，多くのOSやプロセッサに対応しています．</li>
<li>オープンソースで無料で使えます (GNU GPLライセンス)．</li>
<li>一次情報: <a href="https://www.sourceware.org/gdb/">GDB: The GNU Project Debugger</a></li>
</ul>
<h2 id="gdbの実行例-c言語編"><a class="header" href="#gdbの実行例-c言語編"><code>gdb</code>の実行例 (C言語編)</a></h2>
<h3 id="起動-run-と終了-quit"><a class="header" href="#起動-run-と終了-quit">起動 <code>run</code> と終了 <code>quit</code></a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc ❶ -g hello.c
$ ./a.out
hello
$ ❷ gdb ./a.out
❸(gdb) ❹ run
hello
(gdb) ❺ quit
A debugging session is active.
	Inferior 1 [process 20186] will be killed.
Quit anyway? (y or n)  ❻ y
$
</code></pre>
<ul>
<li><code>gdb</code>でデバッグする前に，<code>gcc</code>のコンパイルに❶<code>-g</code>オプションを付けます．
<code>-g</code>は<code>a.out</code>に<a href="./3-binary.html#%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%83%85%E5%A0%B1">デバッグ情報</a>を付加します．
デバッグ情報がなくてもデバッグは可能ですが，
ファイル名や行番号などの情報が表示されなくなり不便です．</li>
</ul>
<details>
<summary>
gcc -g -Og オプションがベスト
</summary>
<p><code>gdb</code>のマニュアルに以下の記述があります．</p>
<ul>
<li><code>-O2</code>などの最適化オプションを付けてコンパイルしたプログラムでも<code>gdb</code>で
デバッグできるが，行番号がずれたりする．なので可能なら
最適化オプションを付けない方が良い．</li>
<li><code>gdb</code>でデバッグするベストな最適化オプションは<code>-Og</code>であり，
<code>-Og</code>は<code>-O0</code>よりも良い．</li>
</ul>
<p>ですので，デバッグ時には <code>gcc -g -Og</code>オプションがベストなようです．</p>
</details>
<details>
<summary>
Inferior はデバッグ対象のプログラムのこと
</summary>
<p>上の実行例中の<code>Inferior 1 [process 20186] will be killed.</code>は
「<code>gdb</code>の終了に伴って，デバッグ対象のプログラムも実行終了させます」という
ことを意味しています．
inferiorは「下位の」「劣った」という意味ですね
(劣等感は英語で inferiority complex)．
<code>gdb</code>のマニュアルでもデバッグ対象のプログラムを一貫してinferiorと呼んでいます．
なお他の文献ではデバッグ対象のプログラムのことをデバッギ (debuggee)と呼ぶことがあります．</p>
</details>
<ul>
<li>❷ <code>gdb ./a.out</code> と，引数にデバッグ対象のバイナリ(ここでは<code>./a.out</code>)を指定して<code>gdb</code>を起動します．</li>
</ul>
<details>
<summary>
gdb起動メッセージの抑制
</summary>
<p>デフォルトで<code>gdb</code>を起動すると以下のような長い起動メッセージが出ます．</p>
<pre><code class="language-bash">$ gdb ./a.out 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
<span class="boring">There is NO WARRANTY, to the extent permitted by law.
</span><span class="boring">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
</span><span class="boring">This GDB was configured as &quot;x86_64-linux-gnu&quot;.
</span><span class="boring">Type &quot;show configuration&quot; for configuration details.
</span><span class="boring">For bug reporting instructions, please see:
</span><span class="boring">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
</span><span class="boring">Find the GDB manual and other documentation resources online at:
</span><span class="boring">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
</span><span class="boring">
</span><span class="boring">For help, type &quot;help&quot;.
</span><span class="boring">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
</span><span class="boring">Reading symbols from ./a.out...
</span><span class="boring">(gdb) 
</span></code></pre>
<p>これを抑制するには，<code>gdb -q</code>オプションを付けるか，
<code>~/.gdbearlyinit</code>ファイルに以下を指定します．</p>
<pre><code>set startup-quietly on
</code></pre>
</details>
<ul>
<li>❸ <code>(gdb)</code> は｀gdb<code>のプロンプトです．</code>gdb`のコマンドが入力可能なことを示します．</li>
<li>❹ <code>run</code>は<code>gdb</code>上で<strong>プログラムの実行を開始</strong>します．
ここではブレークポイントを指定していないため，そのまま<code>hello</code>を出力して
プログラムは終了しました．</li>
<li>❺ <code>quit</code>は<code>gdb</code>を終了させます．
(ここではすでにデバッグ対象のプログラムの実行は終了していますが)
デバッグ対象のプログラムが終了しておらず，
「本当に終了して良いか?」と聞かれたら，❻ <code>y</code>と答えて終了させます．</li>
</ul>
<details>
<summary>
コマンドの省略名
</summary>
<p><code>gdb</code>のコマンドは(区別できる範囲で)短く省略できます．
例えば，<code>run</code>は<code>r</code>，<code>quit</code>は<code>q</code>，それぞれ1文字でコマンドを指定できます．
慣れてきたらコマンドの省略名を使いましょう．</p>
</details>
<h3 id="コマンドライン引数argvを指定して実行"><a class="header" href="#コマンドライン引数argvを指定して実行">コマンドライン引数<code>argv</code>を指定して実行</a></h3>
<pre><code>// argv.c
#include &lt;stdio.h&gt;
int main (int argc, char *argv[])
{
    for (int i = 0; i &lt; argc; i++) {
        printf (&quot;argv[%d]=%s\n&quot;, i, argv [i]);
    }
}
</code></pre>
<pre><code>$ gcc -g argv.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ run a b c d
argv[0]=/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
argv[1]=a
argv[2]=b
argv[3]=c
argv[4]=d
[Inferior 1 (process 20303) exited normally]
(gdb) 
</code></pre>
<ul>
<li>コマンドライン引数を与えてデバッグしたい場合は，
<code>run</code>コマンドに続けて引数を与えます(ここでは<code>a b c d</code>)．</li>
</ul>
<h3 id="標準入出力を切り替えて実行"><a class="header" href="#標準入出力を切り替えて実行">標準入出力を切り替えて実行</a></h3>
<pre><code>// cat.c
#include &lt;stdio.h&gt;
int main ()
{
    int c;
    while ((c = getchar ()) != EOF) {
        putchar (c);
    }
}
</code></pre>
<pre><code>$ gcc -g cat.c
$ cat foo.txt
hello
byebye
$ gdb ./a.out
(gdb) run ❶ &lt; foo.txt ❷ &gt; out.txt
(gdb) quit
$ cat out.txt
hello
byebye
</code></pre>
<ul>
<li>標準入出力をリダイレクトして(切り替えて)実行したい場合は，
通常のシェルのときと同様に<code>run</code>コマンドの後で，
❶ <code>&lt;</code> や❷ <code>&gt;</code>を使って行います．</li>
</ul>
<h3 id="segmentation-fault-あるいは-bus-errorの原因を探る"><a class="header" href="#segmentation-fault-あるいは-bus-errorの原因を探る">segmentation fault (あるいは bus error)の原因を探る</a></h3>
<pre><code>// segv.c
#include &lt;stdio.h&gt;
int main ()
{
    int *p = (int *)0xDEADBEEF; // アクセスNGそうなアドレスを代入
    printf (&quot;%d\n&quot;, *p); 
}
</code></pre>
<pre><code>$ gcc -g segv.c
$ ./a.out
❶ Segmentation fault (core dumped)
$ gdb ./a.out
(gdb) r
Program received signal SIGSEGV, ❷ Segmentation fault.
0x0000555555555162 in ❸ main () at ❹ segv.c:6
6	 ❺ printf (&quot;%d\n&quot;, *p); 
(gdb) ❻ print/x p
$1 = ❼ 0xdeadbeef
(gdb) ❽ print/x *p
❾ Cannot access memory at address 0xdeadbeef
(gdb) quit
</code></pre>
<ul>
<li><code>segv.c</code>をコンパイルして実行すると❶ segmentation fault が起きました．
segumentation fault や bus error は正しくないポインタを使用して
メモリにアクセスすると発生します．</li>
<li><code>gdb</code>上で<code>a.out</code>を実行すると，<code>gdb</code>上でも ❷ segmentation fault が起きました．
発生場所は ❹ ファイル<code>segv.c</code>の<code>6行目</code>，❸ <code>main</code>関数内と表示されています．
また，6行目のソースコード ❺ <code>printf (&quot;%d\n&quot;, *p);</code>も表示されています．</li>
<li>変数<code>p</code>が怪しいので，❻ <code>print/x p</code>コマンドで変数<code>p</code>の値を表示させます．
<code>/x</code>は「16進数で表示」を指示するオプションです．
怪しそうな<code>0xDEADBEEF</code>という値が表示されました．
(<code>print</code>コマンドは<code>p</code>と省略可能です)．</li>
</ul>
<details>
<summary>
怪しいアドレスとは
</summary>
<p>まず，8の倍数ではないアドレスは怪しいです(正しいアドレスのこともあります)．
特に奇数のアドレスは怪しいです(正しいこともありますが)．
<a href="./9-abi.html#alignment">アラインメント制約</a>を守るため，
多くのデータが4の倍数や8の倍数のアドレスに配置されるからです．</p>
<p>また慣れてくると，例えば「<code>0x7ffde9a98000</code>はスタックのアドレスっぽい」と
感じるようになります．
「これ，どこのメモリだろう」と思ったら
<a href="./3-binary.html#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%9E%E3%83%83%E3%83%97%E3%82%92%E8%A6%8B%E3%82%8B">メモリマップ</a>
や<code>gdb</code>上で<code>info proc map</code>の結果を見て調べるのが良いです．</p>
</details>
<ul>
<li>念のため，<code>print</code>コマンドで<code>*p</code>を表示させると
(❽ <code>print/x *p</code>)，
この番地にはアクセスできないことが確認できました
(❾ <code>Cannot access memory at address 0xdeadbeef</code>)．</li>
</ul>
<h3 id="変数の値を表示-print"><a class="header" href="#変数の値を表示-print">変数の値を表示 (<code>print</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) ❶ b main
Breakpoint 1 at 0x1131: file calcx.c, line 3.
(gdb) ❷ r
❸ Breakpoint 1, main () at calcx.c:3
3	 ❹ int x = 10;
(gdb) ❺ s
❻ 4	    x += 3;
(gdb) ❼ p x
❽ $1 = 10
(gdb) s
5	    x += 4;
(gdb) p x
$2 = 13
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>s</code>(<code>step</code>), <code>p</code>(<code>print</code>), <code>q</code>(<code>quit</code>)</li>
<li>❶ <code>b main</code>で，<code>main</code>関数にブレークポイントを設定し，
❷ <code>r</code>で実行を開始すると，❸<code>main関数で実行が一時停止しました． ❹ </code>int x = 10;`は次に実行する文です(まだ<strong>実行していません</strong>)．</li>
</ul>
<details>
<summary>
breakで設定できる場所
</summary>
<p>ここでは<code>b main</code>と関数名を指定しました．
他にも以下のように行番号やファイル名も使えます．</p>
<div class="table-wrapper"><table><thead><tr><th>場所の指定</th><th>説明</th></tr></thead><tbody>
<tr><td><code>b 10</code></td><td>(今実行中のファイルの)10行目</td></tr>
<tr><td><code>b +5</code></td><td>今の実行地点から5行後</td></tr>
<tr><td><code>b -5</code></td><td>今の実行地点から5行前</td></tr>
<tr><td><code>b main</code></td><td>(今実行中のファイルの)関数<code>main</code></td></tr>
<tr><td><code>b main.c:main</code></td><td>ファイル<code>main.c</code>中の<code>main</code>関数</td></tr>
<tr><td><code>b main.c:10</code></td><td>ファイル<code>main.c</code>の10行目</td></tr>
</tbody></table>
</div></details>
<ul>
<li>❺ <code>s</code>で，1行だけ実行を進めます．
4行目 (❻ <code>4  x += 3;</code>)を実行する手前で実行が止まります．</li>
<li>ここで <code>❼ p x</code>として <code>x</code>の値を表示させます．
<code>❽ $1 = 10</code>と表示され，<code>x</code>の値は<code>10</code>と分かりました．
(<code>$1</code>は<code>gdb</code>中で使える変数ですが，ここでは使っていません)．</li>
</ul>
<h3 id="変数の値を自動表示-display"><a class="header" href="#変数の値を自動表示-display">変数の値を自動表示 (<code>display</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) ❶ disp x
❷ 1: x = 21845
(gdb) s
5	    x += 3;
❸ 1: x = 10
(gdb) s
6	    x += 4;
❹ 1: x = 13
(gdb) s
7	    return x;
❺ 1: x = 17
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>s</code>(<code>step</code>), <code>disp</code>(<code>display</code>), <code>q</code>(<code>quit</code>)</li>
<li>「何度も<code>p x</code>と入力するのが面倒」という人は<code>display</code>を使って，
変数の値を自動表示させましょう．<code>display</code>は実行が停止するたびに，
指定した変数の値を表示します．</li>
<li>ここでは❶ <code>disp x</code>として，変数<code>x</code>の値を自動表示させます．
(❷ <code>1: x = 21845</code>と出てるのは，変数<code>x</code>が未初期化のため，ゴミの値が表示されたからです)．</li>
<li><code>s</code>で1行ずつ実行を進めるたびに，
変数<code>x</code>の値が，❸ <code>1: x = 10</code>→ ❹ <code>1: x = 13</code>→ ❺ <code>1: x = 17</code> と変化するのが分かります．</li>
</ul>
<h3 id="条件付きブレークポイントの設定とバックトレース表示-break-if-backtrace"><a class="header" href="#条件付きブレークポイントの設定とバックトレース表示-break-if-backtrace">条件付きブレークポイントの設定とバックトレース表示 (<code>break if</code>, <code>backtrace</code>)</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
(gdb) ❶ b fact if n==0
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❷ r
❸ Breakpoint 1, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❹ bt
#0  fact (n=0) at fact.c:5
#1  0x0000555555555172 in fact (n=1) at fact.c:8
#2  0x0000555555555172 in fact (n=2) at fact.c:8
#3  0x0000555555555172 in fact (n=3) at fact.c:8
#4  0x0000555555555172 in fact (n=4) at fact.c:8
#5  0x0000555555555172 in fact (n=5) at fact.c:8
❺#6  0x000055555555518a in main () at fact.c:13
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>bt</code>(<code>backtrace</code>), <code>q</code>(<code>quit</code>)</li>
<li>❶ <code>b fact if n==0</code>で，引数<code>n</code>が<code>0</code>の時だけ<code>fact</code>の実行を停止する設定をして，
❷ <code>r</code>で実行を開始すると，意図通り ❸ <code>fact (n=0)</code>で実行停止できました．</li>
<li>ここで，❹<code>bt</code>として<strong>バックトレース</strong>を表示させます．
バックトレースとは「今，実行中の関数から遡って<code>main</code>関数に至るまでの
関数呼び出し系列」のことです．
❺<code>main</code>関数から，<code>fact(n=5)</code>→<code>fact(n=4)</code>→(中略)
→<code>fact(n=0)</code>と呼び出されたことが分かります．</li>
<li>なお，<code>backtrace full</code>とすると，
バックトレースに加えて，局所変数の値も表示されます．</li>
</ul>
<blockquote>
<p>注: Ubuntu 20.04 LTSなど，少し古いLinuxを使っている人は
バックトレース中の引数の値が間違った表示
になることがあります(私はなりました)．
これは<a href="https://stackoverflow.com/questions/64697087/gdb-shows-incorrect-arguments-of-functions-for-stack-frames">古い<code>gdb</code>が<code>endbr64</code>命令に非対応だったから</a>です．
Ubuntu 22.04 LTSなど最新のLinuxにすることをお勧めします (2023年8月現在)．</p>
</blockquote>
<h3 id="変数や式の変更監視-watch"><a class="header" href="#変数や式の変更監視-watch">変数や式の変更監視 (<code>watch</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) ❶ wa x
Hardware watchpoint 2: x
(gdb) ❷ c
Continuing.

Hardware watchpoint 2: x
❸ Old value = 21845
❹ New value = 10
main () at calcx.c:5
5	    x += 3;
(gdb) c
Continuing.

Hardware watchpoint 2: x
Old value = 10
New value = 13
main () at calcx.c:6
6	    x += 4;
(gdb) c
Continuing.

Hardware watchpoint 2: x
Old value = 13
New value = 17
main () at calcx.c:7
7	    return x;
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>wa</code>(<code>watch</code>), <code>c</code>(<code>continue</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>watch</code>は指定した変数や式の変化(書き込み)を監視します．
「どこで値が変わるのかわからない」という場合に便利です．
ここでは ❶ <code>wa x</code>として変数<code>x</code>を監視する設定を行い，
実行を再開します (❷ <code>c</code>)．
変更箇所で自動的にブレークされて，
変更前後の値が表示されました(❸ <code>Old value = 21845</code>，❹ <code>New value = 10</code>)．</p>
</li>
<li>
<p><code>break</code>と同様に，<code>watch</code>にも<code>if</code>で条件を指定できます．
例えば，<code>wa x if x==13</code>とすると，変数の値が<code>13</code>になった時点でブレークできます．</p>
</li>
<li>
<p><code>watch</code>はハードウェア機能を使うため，
高速ですが指定できる個数に限りがあります．</p>
</li>
<li>
<p><code>watch</code>には<code>-l</code>というオプションを指定可能です．
このオプションを指定すると，指定した変数や式を評価して，
その結果のアドレスへの書き込みを(変数のスコープを無視して)監視します．
評価結果がアドレスでなかった場合(つまり左辺値を持たない式だった場合)は<code>gdb</code>はエラーを表示します．</p>
</li>
<li>
<p><code>watch</code>は「書き込み」を監視します．
「読み込み」を監視したい時は<code>rwatch</code>，
「読み書き」の両方を監視したい時は<code>awatch</code>を使って下さい．</p>
</li>
</ul>
<h3 id="set-var-x"><a class="header" href="#set-var-x">実行中断と，実行途中での変数の値の変更</a></h3>
<pre><code>// inf-loop.c
#include &lt;stdio.h&gt;
int main ()
{
    int x = 1, n = 0;
    while (x != 0) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g inf-loop.c
$ gdb ./a.out
(gdb) r

❶ ^C
❷ Program received signal SIGINT, Interrupt.
main () at inf-loop.c:7
7	    while (x != 0) {
(gdb) ❸ p x=0
$1 = 0
(gdb) ❹ c
Continuing.
❺ hello, world
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>r</code>(<code>run</code>), <code>p</code>(<code>print</code>), <code>c</code>(<code>continue</code>), <code>q</code>(<code>quit</code>)</li>
<li>このプログラムは無限ループがあるため，実行を開始すると
<code>gdb</code>に制御が戻ってきません．そこで，<code>ctrl-c</code> (❶ <code>^C</code>)を入力して
プログラムを一時停止します．</li>
<li>変数<code>x</code>の値をゼロにすれば無限ループを抜けるので，
<code>print</code>コマンドで ❸ <code>p x=0</code>とすることで，変数<code>x</code>にゼロを代入します．
このように<code>print</code>コマンドは変数を変更したり，
副作用のある関数を呼び出すことができます(例えば，<code>p printf(&quot;hello\n&quot;)</code>として)．</li>
<li>実行を再開すると (❹<code>c</code>)，❺ <code>hello, world</code>が表示され，
無事に無限ループを抜けることができました．</li>
</ul>
<h3 id="再開場所の変更-jump"><a class="header" href="#再開場所の変更-jump">再開場所の変更 (<code>jump</code>)</a></h3>
<pre><code>// inf-loop2.c
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main ()
{
    int n = 0;
    while (time (NULL)) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g inf-loop2.c
$ gdb ./a.out
(gdb) r

^C
Program received signal SIGINT, Interrupt.
main () at inf-loop2.c:8
8	        n++;
(gdb) ❶ l
3	#include &lt;time.h&gt;
4	int main ()
5	{
6	    int n = 0;
7	    while (time (NULL)) {
8	        n++;
9	    }
❷ 10	    printf (&quot;hello, world\n&quot;);
11	}
(gdb) ❸ j 10
Continuing at 0x555555555191.
❹ hello, world
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>r</code>(<code>run</code>), <code>l</code>(<code>list</code>), <code>j</code>(<code>jump</code>), <code>q</code>(<code>quit</code>)</li>
<li><a href="10-gdb.html#set-var-x">先程</a>と異なり，今回，無限ループを抜けるのに，
単純に変数の値を変える方法は使えません．
(システムコール<code>time</code>は1970/1/1からの経過秒数を返します)．
そこで，ここでは<code>jump</code>コマンドを使います．
<code>jump</code>は「指定した場所から実行を再開」します．
(一方，<code>continue</code>は「実行を一時停止した場所から実行を再開」します)．</li>
</ul>
<details>
<summary>
別の方法
</summary>
<p>別の方法として，<code>time</code>が返した戻り値は<code>%rax</code>レジスタに入っているので，
<code>time</code>からのリターン直後に<code>p $rax=0</code>とする方法もあります
(レジスタ<code>%rax</code>の値が<code>0</code>になります)．
また <code>p $rip=0x0000555555555191</code>として，直接 <code>%rip</code>レジスタの値を
変更する方法もあります(<code>jump</code>コマンドの中身はまさにこれでしょう)．</p>
</details>
<ul>
<li>何行目から実行を再開すればよいかを調べるために，
<code>list</code>コマンドを使ってソースコードの一部を表示します．
(<code>list</code>に表示する行番号や関数名を指定することもできます)．
10行目から再開すれば良さそうと分かります．</li>
<li>10行目から実行を再開すると(❷ <code>j 10</code>)，
無事に無限ループを抜けられました (❸ <code>hello, world</code>)．</li>
</ul>
<img src="figs/gdb-layout-src.png" height="300px" id="fig:gdb-layout-src">
<p>なお，<code>layout src</code>とすると，ソースコードを表示するウインドウが現れます．
ソースコードと現在の実行位置を見ながらデバッグできるので便利です．
(時々画面が乱れるので，その時は<code>ctrl-l</code>(コントロールL)を押して，
画面を再描画して下さい)．
このモードから抜けるには，<code>tui disable</code>あるいは<code>ctrl-x a</code>を入力します．</p>
<h3 id="型の表示-whatis-ptype"><a class="header" href="#型の表示-whatis-ptype">型の表示 (<code>whatis</code>, <code>ptype</code>)</a></h3>
<pre><code>// struct2.c
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt; // for size_t

struct foo {
   int a1;
   char a2;
   size_t a3;
};

int main ()
{
    struct foo f = {10, 'a', 20};
    printf (&quot;%d\n&quot;, f.a1);
}
</code></pre>
<pre><code>$ gcc -g struct2.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1155: file struct2.c, line 12.
(gdb) r
Breakpoint 1, main () at struct2.c:12
12	    struct foo f = {10, 'a', 20};
(gdb) ❶ whatis f
type = struct foo
(gdb) ❷ ptype f
type = struct foo {
    int a1;
    char a2;
    size_t a3;
}
(gdb) ❸ ptype/o f
/* offset      |    size */  type = struct foo {
/*      0      |       4 */    int a1;
/*      4      |       1 */    char a2;
/* XXX  3-byte hole      */
/*      8      |       8 */    size_t a3;

                               /* total size (bytes):   16 */
                             }
(gdb) ❹ ptype struct foo
type = struct foo {
    int a1;
    char a2;
    size_t a3;
}
(gdb) ❺ whatis f.a3
type = size_t
(gdb) ❻ ptype f.a3
type = unsigned long
(gdb) ptype size_t
type = unsigned long
(gdb) ❼ info types foo
All types matching regular expression &quot;foo&quot;:

File struct2.c:
4:	struct foo;
(gdb) q
</code></pre>
<ul>
<li>
<p><code>whatis</code>や<code>ptype</code>は式や型名の型情報を表示します．</p>
</li>
<li>
<p><code>whatis</code>は構造体の中身を表示しませんが (❶ <code>whatis f</code>)，
<code>ptype</code>は表示します (❷ <code>ptype f</code>)．
<code>/o</code>オプションを付けると，構造体のフィールドのオフセットとサイズ，
構造体中のパディング(ホール，穴)も表示してくれます
(❸ <code>ptype/o f</code>)．</p>
</li>
<li>
<p><code>whatis</code>や<code>ptype</code>には型名も指定できます (❹ <code>ptype struct foo</code>)．</p>
</li>
<li>
<p><code>whatis</code>は<code>typedef</code>を1レベルまでしか展開しませんが (❺ <code>whatis f.a3</code>)，
<code>ptype</code>は全て展開します (❻ <code>ptype f.a3</code>)．</p>
</li>
<li>
<p><code>info types</code>を使うと，正規表現にマッチする型名一覧を表示します
(❼ <code>info types foo</code>)．</p>
</li>
</ul>
<h2 id="gdbの実行例-アセンブリ言語編"><a class="header" href="#gdbの実行例-アセンブリ言語編"><code>gdb</code>の実行例 (アセンブリ言語編)</a></h2>
<h3 id="アドレス指定でブレイクレジスタの値を表示"><a class="header" href="#アドレス指定でブレイクレジスタの値を表示">アドレス指定でブレイク，レジスタの値を表示</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g hello.c
$ gdb ./a.out
(gdb) ❶ b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❷ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
❸ =&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❹ b *0x0000555555555149
Breakpoint 2 at 0x555555555149: file hello.c, line 4.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Breakpoint 2, main () at hello.c:4
4	{
(gdb) ❺ disp/i $rip
1: x/i $rip
❻ =&gt; 0x555555555149 &lt;main&gt;:	endbr64 
(gdb) ❼ si
0x000055555555514d	4	{
❽ 1: x/i $rip
❾ =&gt; 0x55555555514d &lt;main+4&gt;:	push   %rbp
(gdb) si
0x000055555555514e	4	{
1: x/i $rip
=&gt; 0x55555555514e &lt;main+5&gt;:	mov    %rsp,%rbp
(gdb) ❿ p/x $rbp
$1 = 0x1
(gdb) ⓫ i r
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffdfb8      140737488347064
rsi            0x7fffffffdfa8      140737488347048
rdi            0x1                 1
rbp            0x1                 0x1
rsp            0x7fffffffde90      0x7fffffffde90
(長いので中略)
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disas</code>(<code>disassemble</code>), <code>si</code>(<code>stepi</code>), <code>p</code>(<code>print</code>), <code>i r</code>(<code>info registers</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p>まず，<code>main</code>関数にブレークポイントを設定して(❶ <code>b main</code>)，
実行を開始すると実行が一時停止するのですが，
逆アセンブル (❷ <code>disas</code>)して確かめると，
機械語命令レベルでは<code>main</code>関数の先頭で実行を一時停止していません．</p>
<ul>
<li>❸ <code>=&gt; 0x0000555555555151 &lt;+8&gt;:</code>　の <code>&lt;+8&gt;</code>が
「<code>main</code>関数の先頭から8バイト目」であることを示しています．
<code>gdb</code>は関数名を指定してブレークした場合，
<a href="./6-inst.html#prologue">関数プロローグ</a>が終わった場所でブレークします．</li>
<li><code>disassemble</code>は逆アセンブル結果を表示します．
何も指定しないと実行中の場所付近の逆アセンブル結果を表示します．
関数名やアドレスを指定することも可能です．
また，<code>disassemble</code>には以下のオプションを指定可能です．</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">オプション</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>/s</code></td><td>ソースコードも表示 (表示順は機械語命令の順番)</td></tr>
<tr><td style="text-align: center"><code>/m</code></td><td>ソースコードも表示 (表示順はソースコードの順番)</td></tr>
<tr><td style="text-align: center"><code>/r</code></td><td>機械語命令の16進ダンプも表示</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>ここでは<code>main</code>関数の先頭番地を指定してブレークポイントを設定してみます
(❹ <code>b *0x0000555555555149</code>)．行番号と区別するため <code>*</code>が必要です．
実行を開始するとブレークしました．</p>
</li>
<li>
<p>ブレークした番地と，その番地の機械語命令を表示すると便利です．
そのため，❺ <code>disp/i $rip</code>としました．
これはプログラムカウンタ<code>%rip</code>の値を命令として(<code>i</code>, instruction)自動表示せよ，
という意味です．(<code>gdb</code>ではレジスタを指定するのに<code>%rip</code>ではなく，
<code>$rip</code>のようにドルマーク<code>$</code>を使います)．
これにより，❻ <code>=&gt; 0x555555555149 &lt;main&gt;: endbr64</code>が表示されました．</p>
<ul>
<li>次に実行する番地は <code>0x555555555149</code>番地</li>
<li>その番地の命令は <code>endbr64</code>命令</li>
</ul>
</li>
<li>
<p><code>stepi</code> (❼ <code>si</code>)を使うと，1行ではなく，機械語命令を1つ実行する
ステップ実行になります．
❺<code>disp/i $rip</code>の効果で，
次に実行される命令の番地とニモニックが表示されました
(❾ <code>=&gt; 0x55555555514d &lt;main+4&gt;: push   %rbp</code>)．
なお，❽ <code>1: x/i $rip</code>とあるのは，
❺<code>disp/i $rip</code>は<code>print</code>ではなく，
<code>x/i $rip</code>コマンドで機械語命令を出力するからです
(<code>x</code>はメモリ中の値を表示するコマンドです．
<code>/i</code>はフォーマット指定で「機械語命令」(instruction)を意味します)．</p>
</li>
<li>
<p>レジスタの値を表示するには<code>print</code>を使います (❿ <code>p/x $rbp</code>)
<code>/x</code>はフォーマット指定で「16進数」(hexadecimal)を意味します．
値は1でした (<code>$1 = 0x1</code>)．</p>
</li>
<li>
<p>なお，<code>info registers</code> (⓫ <code>i r</code>)で，全ての汎用レジスタの値を
一括表示できます．</p>
</li>
</ul>
<h3 id="メモリ中の値機械語命令を表示する-x"><a class="header" href="#メモリ中の値機械語命令を表示する-x">メモリ中の値(機械語命令)を表示する (<code>x</code>)</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) disp/x $rip
1: /x $rip = &lt;error: No registers.&gt;
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
1: /x $rip = 0x555555555151
(gdb) ❶ disas/r
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	f3 0f 1e fa	endbr64 
   0x000055555555514d &lt;+4&gt;:	55	push   %rbp
   0x000055555555514e &lt;+5&gt;:	48 89 e5	mov    %rsp,%rbp
❷ =&gt; 0x0000555555555151 &lt;+8&gt;:	48 8d 05 ac 0e 00 00	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	48 89 c7	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	e8 f0 fe ff ff	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	b8 00 00 00 00	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	5d	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	c3	ret    
End of assembler dump.
(gdb) ❸ x/7xb 0x0000555555555151
❹ 0x555555555151 &lt;main+8&gt;:	0x48	0x8d	0x05	0xac	0x0e	0x00	0x00
(gdb) ❺ x/7xb $rip
0x555555555151 &lt;main+8&gt;:	0x48	0x8d	0x05	0xac	0x0e	0x00	0x00
(gdb) ❻ x/7xb $rip+7
0x555555555158 &lt;main+15&gt;:	0x48	0x89	0xc7	0xe8	0xf0	0xfe	0xff
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disp</code> (<code>display)</code>, <code>disas</code>(<code>disassemble</code>), <code>x</code>(<code>x</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p>16進ダンプ付き(<code>/r</code>)で逆アセンブルすると (❶ <code>disas/r</code>)，</p>
</li>
</ul>
<pre><code>❷ =&gt; 0x0000555555555151 &lt;+8&gt;:	48 8d 05 ac 0e 00 00	lea    0xeac(%rip),%rax        # 0x555555556004
</code></pre>
<p>と表示されました．
<code>0x0000555555555151</code>番地には <code>lea 0xeac(%rip),%rax</code>という命令があり，
機械語バイト列としては <code>48 8d 05 ac 0e 00 00</code>だと分かりました．</p>
<ul>
<li>
<p><code>x</code>コマンドでメモリ中の値を表示できます．
例えば，❸ <code>x/7xb 0x0000555555555151</code>は，
「<code>0x0000555555555151</code>番地のメモリの値を表示せよ．
表示は1バイト単位(<code>b</code>)，16進表記(<code>x</code>)のものを7個，表示せよ」という意味です．
その結果，逆アセンブル結果と同じ値が表示されました
(❹ <code>0x555555555151 &lt;main+8&gt;: 0x48 0x8d 0x05 0xac 0x0e 0x00 0x00</code>)．</p>
</li>
<li>
<p>なお，<code>x</code>コマンドに与える指定は <em>NFT</em> という形式です．<br />
<em>N</em> は表示個数(デフォルト1)，<em>F</em>はフォーマット，<em>U</em>は単位サイズの指定です．
<em>F</em>と<em>U</em>の順番は逆でもOKです． 
(例: <code>4gx</code> は「8バイトデータを16進数表記で4個表示」を意味する)．
<em>F</em>と<em>U</em>で指定できるものは以下の通りです．</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォーマット <em>F</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td>16進数 (hexadecimal)</td></tr>
<tr><td style="text-align: center"><code>d</code></td><td>符号あり10進数 (decimal)</td></tr>
<tr><td style="text-align: center"><code>u</code></td><td>符号なし10進数 (unsigned)</td></tr>
<tr><td style="text-align: center"><code>t</code></td><td>2進数 (two)</td></tr>
<tr><td style="text-align: center"><code>c</code></td><td>文字 (char)</td></tr>
<tr><td style="text-align: center"><code>s</code></td><td>文字列 (string)</td></tr>
<tr><td style="text-align: center"><code>i</code></td><td>機械語命令 (instruction)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">単位サイズ <em>U</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td>1バイト (byte)</td></tr>
<tr><td style="text-align: center"><code>h</code></td><td>2バイト (half-word)</td></tr>
<tr><td style="text-align: center"><code>w</code></td><td>4バイト (word)</td></tr>
<tr><td style="text-align: center"><code>g</code></td><td>8バイト (giant)</td></tr>
</tbody></table>
</div>
<ul>
<li><code>x</code>へのアドレス指定にレジスタの値 (❺ <code>x/7xb $rip</code>)や
レジスタ値を使った足し算 (❻ <code>x/7xb $rip+7</code>)も指定できます．</li>
</ul>
<h3 id="メモリ中の値スタックを表示する-x"><a class="header" href="#メモリ中の値スタックを表示する-x">メモリ中の値(スタック)を表示する (<code>x</code>)</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1180: file fact.c, line 13.
(gdb) b fact
Breakpoint 2 at 0x1158: file fact.c, line 5.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❶ p/x $rbp
$1 = ❷ 0x7fffffffde90
(gdb) c
Continuing.

Breakpoint 2, fact (n=5) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❸ x/1xg $rbp + 8
0x7fffffffde88:	❹ 0x000055555555518a
(gdb) disas main
Dump of assembler code for function main:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp,%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    $0x5,%edi
   0x0000555555555185 &lt;+13&gt;:	call   0x555555555149 &lt;fact&gt;
❺ 0x000055555555518a &lt;+18&gt;:	mov    %eax,%esi
   0x000055555555518c &lt;+20&gt;:	lea    0xe71(%rip),%rax        # 0x555555556004
   0x0000555555555193 &lt;+27&gt;:	mov    %rax,%rdi
   0x0000555555555196 &lt;+30&gt;:	mov    $0x0,%eax
   0x000055555555519b &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x00005555555551a0 &lt;+40&gt;:	mov    $0x0,%eax
   0x00005555555551a5 &lt;+45&gt;:	pop    %rbp
   0x00005555555551a6 &lt;+46&gt;:	ret    
End of assembler dump.
(gdb) ❻ x/1gx $rbp
0x7fffffffde80:	❼ 0x00007fffffffde90
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>p</code> (<code>print)</code>, <code>c</code>(<code>continue</code>), <code>x</code>(<code>x</code>), <code>disas</code>(<code>disassemble</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>main</code>と<code>fact</code>にブレークポイントを設定し，
<code>main</code>関数でブレークした時点で，<code>%rbp</code>の値を調べると (❶ <code>p/x $rbp</code>)，
❷ <code>0x7fffffffde90</code>と分かりました．
これは<code>main</code>関数のスタックフレームの一番下のアドレスです．</p>
</li>
</ul>
<img src="figs/stack-fact.svg" height="200px" id="fig:stack-fact">
<ul>
<li>
<p><code>fact</code>でブレークした時点で，スタックフレームは上図になっているはずです．
まずメモリ参照<code>8(%rbp)</code>に正しく戻り番地が入っているか調べます．
<code>$rbp+8</code>番地のメモリの値を調べると (❸ <code>x/1xg $rbp+8</code>)，
❹ <code>0x000055555555518a</code>が入っていました．
(<code>1xg</code>は，8バイトデータを16進数で1個分出力する，を意味します)．</p>
<p><code>main</code>関数を逆アセンブルすると，</p>
</li>
</ul>
<pre><code>   0x0000555555555185 &lt;+13&gt;:	call   0x555555555149 &lt;fact&gt;
❺ 0x000055555555518a &lt;+18&gt;:	mov    %eax,%esi
</code></pre>
<p>この番地(❹ <code>0x000055555555518a</code>)は<code>call fact</code>の次の命令なので，
戻り番地として正しいことを確認できました．</p>
<ul>
<li>次に<code>fact(5)</code>のスタックフレーム中の「古い<code>%rbp</code>」の値が正しいかを調べます．
<code>%rbp</code>が指すメモリの値を調べると(❻ <code>x/1gx $rbp</code>)，
❼ <code>0x00007fffffffde90</code>が入っていました．
これは ❷ <code>0x7fffffffde90</code>と一致するので，
「古い<code>%rbp</code>」が正しいことを確認できました．</li>
</ul>
<h3 id="シンボルテーブル-info-address-info-symbol"><a class="header" href="#シンボルテーブル-info-address-info-symbol">シンボルテーブル (<code>info address</code>, <code>info symbol</code>)</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g hello.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ info address main
Symbol &quot;main&quot; is a function at address ❷ 0x1149.
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❸ info address main
Symbol &quot;main&quot; is a function at address ❹ 0x555555555149.
(gdb) info address printf
Symbol &quot;printf&quot; is at 0x7ffff7c60770 in a file ❺ compiled without debugging.
(gdb) disas main
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❻ info symbol 0x0000555555555149
main in section .text of /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
(gdb) ❼ info symbol 0x0000555555555166
main + 29 in section .text of /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disas</code>(<code>disassemble</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>info address</code>は指定したシンボルのアドレスを表示します．
プログラム実行前の場合(❶ <code>info address main</code>)，
ファイル<code>a.out</code>中のアドレスを表示します(❷ <code>0x1149</code>)．
これは<code>nm</code>コマンドや<code>objdump -d</code>で得られるアドレスと同じです．</p>
</li>
</ul>
<pre><code>$ nm ./a.out | egrep main
                 U __libc_start_main@GLIBC_2.34
0000000000001149 T main
</code></pre>
<ul>
<li>
<p>一方，実行後では (❸ <code>info address main</code>)，
<code>main</code>関数のメモリ上でのアドレスが得られます (❹ <code>0x555555555149</code>)．
なお，<code>printf</code>のアドレスを調べると，
デバッグ情報無しでコンパイルされた旨のメッセージも表示されました
(❺ <code>compiled without debugging</code>)．</p>
</li>
<li>
<p><code>info symbol</code>は指定したアドレスを持つシンボルを返します．
例えば，<code>main</code>関数の先頭アドレスを指定すると
( ❻ <code>info symbol 0x0000555555555149</code>)，<code>main</code>を表示しました．
アドレスは<code>main</code>関数の途中のアドレスでも大丈夫です
( ❼ <code>info symbol 0x0000555555555166</code>)．</p>
</li>
</ul>
<h2 id="お便利機能"><a class="header" href="#お便利機能">お便利機能</a></h2>
<h3 id="helpコマンド"><a class="header" href="#helpコマンド"><code>help</code>コマンド</a></h3>
<p><code>help</code> (<code>h</code>)はコマンドのヘルプ(説明)を表示します．</p>
<pre><code>(gdb) help step
step, s
Step program until it reaches a different source line.
Usage: step ❶ [N]
Argument N means step N times (or till program stops for another reason).
</code></pre>
<p>例えば，<code>help step</code>とすると，<code>step</code>に回数を指定できる❶ことが分かりました．
<code>[N]</code>のカギカッコは省略可能な引数を意味します．</p>
<h3 id="aproposコマンド"><a class="header" href="#aproposコマンド"><code>apropos</code>コマンド</a></h3>
<p><code>apropos</code>(<code>apr</code>)は指定した正規表現をヘルプに含むコマンドを表示します．</p>
<pre><code>(gdb) apropos break
advance -- Continue the program up to the given location (same form as args for break command).
break, brea, bre, br, b -- Set breakpoint at specified location.
break, brea, bre, br, b -- Set breakpoint at specified location.
break-range -- Set a breakpoint for an address range.
breakpoints -- Making program stop at certain points.
clear, cl -- Clear breakpoint at specified location.
commands -- Set commands to be executed when the given breakpoints are hit.
(以下略)
</code></pre>
<p>例えば，<code>apropos break</code>とすると，<code>break</code>をヘルプに含むコマンド一覧を表示します．
<code>break</code>に関係するコマンドを知りたい場合に便利です．</p>
<h3 id="補完とヒストリ機能"><a class="header" href="#補完とヒストリ機能">補完とヒストリ機能</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>ctrl-p</code></td><td></td><td>1つ前のコマンドを表示</td></tr>
<tr><td><code>ctrl-n</code></td><td></td><td>1つ後のコマンドを表示</td></tr>
<tr><td><code>show commands</code></td><td></td><td>自分が入力したコマンド履歴を表示</td></tr>
<tr><td><code>ctrl-i</code></td><td></td><td>コマンド等を補完 (TABキーでも同じ)<br/>2回押すと候補一覧を表示</td></tr>
<tr><td><code>ctrl-l</code></td><td></td><td>画面をクリア・リフレッシュ</td></tr>
</tbody></table>
</div>
<pre><code>(gdb) br TAB  (br とTABの間にはスペースを入れない)
(gdb) break  (breakまで補完)
(gdb) break TAB (ここで2回TABを押すと)
break        break-range     (breakで始まるコマンドの一覧を表示)
</code></pre>
<pre><code>(gdb) b main
(gdb) r
(gdb) step
(gdb) ctrl-p  (ctrl-p を押すと)
(gdb) step    (1つ前のコマンド step が表示された)
</code></pre>
<h3 id="tui-テキストユーザインタフェース"><a class="header" href="#tui-テキストユーザインタフェース">TUI (テキストユーザインタフェース)</a></h3>
<p><code>layout</code>コマンドで，TUIの表示モードを使えます．
<code>src</code> (ソースコード)，<code>asm</code> (アセンブリコード)，
<code>regs</code> (レジスタ表示)を選べます．</p>
<!--
<img src="figs/gdb-layout-src.png" height="300px" id="fig:gdb-layout-src">
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<img src="figs/gdb-layout-split.png" height="300px" id="fig:gdb-layout-split">
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
-->
<img src="figs/gdb-layout-asm-regs.png" height="350px" id="fig:gdb-layout-asm-regs">
<p>上図は<code>layout asm</code>後に<code>layout regs</code>とした時の画面です．
元の表示方法に戻るには<code>ctrl-x a</code>として下さい．</p>
<h2 id="ブレークポイントの設定"><a class="header" href="#ブレークポイントの設定">ブレークポイントの設定</a></h2>
<h3 id="場所の指定"><a class="header" href="#場所の指定">場所の指定</a></h3>
<div class="table-wrapper"><table><thead><tr><th>場所の指定</th><th>説明</th></tr></thead><tbody>
<tr><td><code>b 10</code></td><td>(今実行中のファイルの)10行目</td></tr>
<tr><td><code>b +5</code></td><td>今の実行地点から5行後</td></tr>
<tr><td><code>b -5</code></td><td>今の実行地点から5行前</td></tr>
<tr><td><code>b main</code></td><td>(今実行中のファイルの)関数<code>main</code></td></tr>
<tr><td><code>b main.c:main</code></td><td>ファイル<code>main.c</code>中の<code>main</code>関数</td></tr>
<tr><td><code>b main.c:10</code></td><td>ファイル<code>main.c</code>の10行目</td></tr>
</tbody></table>
</div>
<h3 id="条件付きブレークポイント"><a class="header" href="#条件付きブレークポイント">条件付きブレークポイント</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ b fact if n==0
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❷ i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
	stop only if ❸ n==0
(gdb) ❹ cond 1 n==1
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
	stop only if n==1
(gdb) ❺ cond 1
Breakpoint 1 now unconditional.
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>i b</code>(<code>info breakpoints</code>), <code>cond</code>(<code>condition</code>), <code>q</code>(<code>quit</code>)</li>
<li>条件付きブレークポイントは<code>if</code>を使って指定します
(❶ <code>b fact if n==0</code>)．</li>
<li><code>i b</code>で，現在のブレークポイントの状況を確認できます (❷ <code>i b</code>)．
番号1のブレークポイントとして，❸ <code>n==0</code>という条件が設定されています．</li>
<li><code>cond</code>で，指定した番号のブレークポイントの条件を変更できます．
ここでは ❹ <code>cond 1 n==1</code>として，条件を<code>n==1</code>に変更しました．</li>
<li><code>cond</code>で新しい条件を指定しないと，条件が外れます(❺ <code>cond 1</code>)．</li>
</ul>
<h3 id="break-with-commands"><a class="header" href="#break-with-commands">コマンド付きブレークポイント</a></h3>
<p><code>commands</code>で「ブレークした時に実行するコマンド列」を指定できます．</p>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
(gdb) b fact 
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❶ commands
Type commands for breakpoint(s) 1, one per line.
End with a line saying just &quot;end&quot;.
&gt;print n
&gt;c
❷&gt;end
(gdb) ❸ r

Breakpoint 1, fact (n=5) at fact.c:5
5	    if (n &lt;= 0)
$1 = 5

Breakpoint 1, fact (n=4) at fact.c:5
5	    if (n &lt;= 0)
$2 = 4

Breakpoint 1, fact (n=3) at fact.c:5
5	    if (n &lt;= 0)
$3 = 3

Breakpoint 1, fact (n=2) at fact.c:5
5	    if (n &lt;= 0)
$4 = 2

Breakpoint 1, fact (n=1) at fact.c:5
5	    if (n &lt;= 0)
$5 = 1

Breakpoint 1, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
$6 = 0
120
(gdb) 
</code></pre>
<ul>
<li>引数無しで❶<code>commands</code>とすると，最後に設定したブレークポイントに対して
コマンドを設定します．
<code>commands 2</code>や<code>commands 5-7</code>などブレークポイントの番号や範囲の指定もできます．</li>
<li><code>commands</code>に続けて，実行したいコマンドを入力します．
最後に❷<code>end</code>を指定します．</li>
<li>❸実行すると，全ての<code>fact</code>の呼び出しが一気に表示できました．
指定したコマンド中に<code>continue</code>を指定できるのがとても便利です．</li>
<li>ここでは不使用ですが，コマンド列の最初に<code>silent</code>を使用すると，
ブレーク時のメッセージを非表示にできます．</li>
</ul>
<h2 id="ステップ実行"><a class="header" href="#ステップ実行">ステップ実行</a></h2>
<h3 id="ステップ実行の種類"><a class="header" href="#ステップ実行の種類">ステップ実行の種類</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ステップ実行の種類</th><th><code>gdb</code>コマンド</th><th>短縮形</th><th>説明</th></tr></thead><tbody>
<tr><td>ステップイン</td><td><code>step</code></td><td><code>s</code></td><td>1行実行を進める(関数呼び出しは中に入って1行を数える)</td></tr>
<tr><td>ステップオーバー</td><td><code>next</code></td><td><code>n</code></td><td>1行実行を進める(関数呼び出しはまたいで1行を数える)</td></tr>
<tr><td>ステップアウト</td><td><code>finish</code></td><td><code>fin</code></td><td>今の関数がリターンするまで実行を進める</td></tr>
<tr><td>実行再開</td><td><code>continue</code></td><td><code>c</code></td><td>ブレークされるまで実行を進める</td></tr>
</tbody></table>
</div><br/>
<img src="figs/step.svg" height="200px" id="fig:step">
<ul>
<li>上図で，今，<code>B();</code>を実行する直前でブレークしているとします．</li>
<li><code>step</code>すると，関数<code>B</code>の<code>printf(&quot;B\n&quot;);</code>まで実行を進めます．</li>
<li><code>next</code>すると，関数<code>A</code>の<code>printf(&quot;A\n&quot;);</code>まで実行を進めます．</li>
<li><code>finish</code>すると，関数<code>main</code>の<code>printf(&quot;main\n&quot;);</code>まで実行を進めます．</li>
</ul>
<h3 id="ステップインの実行例-step"><a class="header" href="#ステップインの実行例-step">ステップインの実行例 (<code>step</code>)</a></h3>
<pre><code>#include &lt;stdio.h&gt;
void B ()
{
    printf (&quot;B\n&quot;);
}
void A ()
{
    B ();
    printf (&quot;A\n&quot;);
}
int main ()
{
    A ();
    printf (&quot;main\n&quot;);
}

</code></pre>
<pre><code>$ gcc -g step.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❶ s
B () at step.c:4
4	❷    printf (&quot;B\n&quot;);
</code></pre>
<p><code>step</code>(❶ <code>s</code>)すると，❷ <code>printf (&quot;B\n&quot;);</code>まで実行しました．</p>
<h3 id="ステップオーバーの実行例-next"><a class="header" href="#ステップオーバーの実行例-next">ステップオーバーの実行例 (<code>next</code>)</a></h3>
<pre><code>$ gcc -g step.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❸ n
B
9	❹    printf (&quot;A\n&quot;);
</code></pre>
<p><code>next</code>(❸ <code>n</code>)すると，❹ <code>printf (&quot;A\n&quot;);</code>まで実行しました．</p>
<h3 id="ステップオーバーの実行例-finish"><a class="header" href="#ステップオーバーの実行例-finish">ステップオーバーの実行例 (<code>finish</code>)</a></h3>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out 
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❺ fin
Run till exit from #0  A () at step.c:8
B
A
main () at step.c:14
14	❻    printf (&quot;main\n&quot;);
</code></pre>
<p><code>finish</code>(❺ <code>fin</code>)すると，❻ <code>printf (&quot;main\n&quot;);</code>まで実行しました．</p>
<h3 id="実行再開の実行例-continue"><a class="header" href="#実行再開の実行例-continue">実行再開の実行例 (<code>continue</code>)</a></h3>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❼ c
Continuing.
B
A
main
</code></pre>
<p><code>continue</code>(❼ <code>c</code>)すると，ブレークポイントがなかったので，
最後まで実行して実行終了しました．</p>
<h2 id="変数の値の表示"><a class="header" href="#変数の値の表示">変数の値の表示</a></h2>
<h3 id="配列-"><a class="header" href="#配列-">配列 (<code>@</code>)</a></h3>
<pre><code>// array2.c
#include &lt;stdlib.h&gt;
int main (int argc, char **argv)
{
   int arr [4] = {0, 10, 20, 30};
   int *p = malloc (sizeof (int) * 4);
   p [0] = 40;
   p [1] = 50;
   p [2] = 60;
   p [3] = 70;
}
</code></pre>
<pre><code>$ gcc -g array2.c
(gdb) b 11
Breakpoint 1 at 0x5555555551ee: file array2.c, line 11.
(gdb) r aa bb cc dd
Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out aa bb cc dd

Breakpoint 1, main (argc=5, argv=0x7fffffffdf78) at array2.c:11
11	}
(gdb) ❶ p arr
❷ $1 = {0, 10, 20, 30}
(gdb) ❸ p *p
❹ $2 = 40
(gdb) ❺ p *p@4
❻ $3 = {40, 50, 60, 70}
(gdb) ❼ p *argv@5
❽ $4 = {
  0x7fffffffe2f7 &quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out&quot;, 0x7fffffffe337 &quot;aa&quot;, 0x7fffffffe33a &quot;bb&quot;, 0x7fffffffe33d &quot;cc&quot;, 
  0x7fffffffe340 &quot;dd&quot;}
</code></pre>
<ul>
<li>普通の配列は<code>print</code>でそのまま表示できます．
例えば ❶ <code>p arr</code>とすると，❷ <code>$1 = {0, 10, 20, 30}</code>と表示されます．</li>
<li><code>malloc</code>で配列を確保した場合，
単純に ❸ <code>p *p</code>とすると，<code>p</code>の型は<code>int *</code>なので，
❹ <code>$2 = 40</code>しか表示されません．
この場合は<code>@</code>を使って ❺ <code>p *p@4</code>とすると，
4要素の配列としてうまく表示できます(❻ <code>$3 = {40, 50, 60, 70}</code>)．</li>
<li>同様に<code>argv</code>も ❼ <code>p *argv@5</code>とすると，うまく表示できます(❽)．</li>
</ul>
<h3 id="スコープの指定-"><a class="header" href="#スコープの指定-">スコープの指定 ('::')</a></h3>
<pre><code>#include &lt;stdio.h&gt;
int x = 111;
int main ()
{
    static int x = 222;
    {
        int x = 333;
        printf (&quot;hello\n&quot;);
    }
}
</code></pre>
<pre><code>$ gcc -g scope.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b 8
Breakpoint 1 at 0x115c: file scope.c, line 8.
(gdb) r
Breakpoint 1, main () at scope.c:8
8		printf (&quot;hello\n&quot;);
(gdb) p x
$1 = 333
(gdb) ❶ p 'scope.c'::x
$2 = 111
(gdb) ❷ p main::x
$3 =  222
</code></pre>
<p>'::'を使うと，特定のファイルや関数中の変数の値を表示できます．</p>
<ul>
<li>❶ <code>p 'scope.c'::x</code> は<code>scope.c</code>のグローバル変数<code>x</code>の値を表示します．
(ファイル名をクオート文字 <code>'</code> で囲む必要があります)．</li>
<li>❷ <code>p main::x</code> は関数<code>main</code>の静的変数<code>x</code>の値を表示します．</li>
</ul>
<h3 id="構造体-リスト構造"><a class="header" href="#構造体-リスト構造">構造体 (リスト構造)</a></h3>
<pre><code>// list.c
#include &lt;stdio.h&gt;
struct list {
    int data;
    struct list *next;
};

int main ()
{
    struct list n1 = {10, NULL};
    struct list n2 = {20, &amp;n1};
    struct list n3 = {30, &amp;n2};
    struct list *p = &amp;n3;
}
</code></pre>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b 14
Breakpoint 1 at 0x119e: file list.c, line 14.
(gdb) r
Breakpoint 1, main () at list.c:14
14	}
(gdb) p p
$1 = (struct list *) 0x7fffffffde70
(gdb) ❶ p *p
❷ $2 = {data = 30, next = 0x7fffffffde60}
(gdb) ❸ p *p-&gt;next
$3 = {data = 20, next = 0x7fffffffde50}
(gdb) ❹ p *p-&gt;next-&gt;next
$4 = {data = 10, next = 0x0}
</code></pre>
<img src="figs/list.svg" height="80px" id="fig:list">
<ul>
<li><code>p</code>が指すリスト構造は上図のようになっています．</li>
<li><code>print</code>を使って(❶ <code>p *p</code>)，
構造体の中身を普通に表示できます(❷ <code>{data = 30, next = 0x7fffffffde60}</code>)．</li>
<li><code>*p-&gt;next</code>などのC言語の式と(ほぼ)同じ記法で，
リスト構造をたどって中身を表示できます
(❸ <code>p *p-&gt;next</code>，❹ <code>p *p-&gt;next-&gt;next</code>)．</li>
</ul>
<h3 id="共用体"><a class="header" href="#共用体">共用体</a></h3>
<pre><code>// union.c
#include &lt;stdio.h&gt;

union foo {
    int  u1;
    float u2;
};

int main ()
{
    union foo f;
    f.u1 = 999;
    f.u2 = 123.456;
}
</code></pre>
<pre><code>(gdb) b 13
Breakpoint 3 at 0x555555555138: file union.c, line 13.
(gdb) r
Breakpoint 3, main () at union.c:13
13	    f.u2 = 123.456;
(gdb) ❶ p f
❷ $1 = {u1 = 999, u2 = 1.39989717e-42}
(gdb) ❸ p f.u1
❹ $2 = 999
(gdb) s
14	}
(gdb) p f
$3 = {u1 = 1123477881, u2 = 123.456001}
(gdb) p f.u2
$4 = 123.456001
</code></pre>
<ul>
<li>共用体を<code>print</code>すると (❶ <code>p f</code>)，
<code>u1</code>と<code>u2</code>のどちらのメンバが使われているか<code>gdb</code>は分からないので，
両方の可能性を表示します (❷ <code>{u1 = 999, u2 = 1.39989717e-42}</code>)．</li>
<li>メンバ名を<code>u1</code>と指定すると (❸ <code>p f.u1</code>)，
そのメンバに対する値を表示します (❹ <code>$2 = 999</code>)．</li>
</ul>
<h3 id="特定の値をメモリ中から探す-find"><a class="header" href="#特定の値をメモリ中から探す-find">特定の値をメモリ中から探す (<code>find</code>)</a></h3>
<pre><code>// find.c
#include &lt;stdio.h&gt;
int arr [1000];

int main ()
{
    arr [500] = 0xDEADBEEF;
    printf (&quot;%p\n&quot;, &amp;arr [500]);
}
</code></pre>
<pre><code>(gdb) b 8
Breakpoint 1 at 0x115b: file find.c, line 8.
(gdb) r
Breakpoint 1, main () at find.c:8
8	    printf (&quot;%p\n&quot;, &amp;arr [500]);
(gdb) ❶ p/x &amp;arr[500]
❷ $1 = 0x555555558810
(gdb) ❸ find /w arr, arr+4000, 0xDEADBEEF
❹ 0x555555558810 &lt;arr+2000&gt;
1 pattern found.
</code></pre>
<ul>
<li>上のプログラムでは<code>arr[500]</code>に<code>0xDEADBEEF</code>という値が入っています．
この値が格納されている場所のアドレスは<code>print</code>で(❶ <code>p/x &amp;arr[500]</code>)，
❷ <code>0x555555558810</code>番地と分かります．</li>
<li>ここで仮に，配列のどこに<code>0xDEADBEEF</code>が入っているか分からず，
この配列に入っているか調べたいとします．
<code>find</code>コマンドで調べられます．
❸ <code>find /w arr, arr+4000, 0xDEADBEEF</code>は，
指定したアドレス範囲 (<code>arr</code>番地から<code>arr+4000</code>番地まで)，
4バイト (<code>/w</code>)の値 <code>0xDEADBEEF</code>を探せ，という意味になります．
正しく結果が表示されました (❹ <code>0x555555558810 &lt;arr+2000&gt;</code>)．</li>
</ul>
<h2 id="変数レジスタメモリに値をセット-set"><a class="header" href="#変数レジスタメモリに値をセット-set">変数，レジスタ，メモリに値をセット (<code>set</code>)</a></h2>
<p><code>set</code>を使うと，変数，レジスタ，メモリに値をセットできます．</p>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) s
5	    x += 3;
(gdb) ❶ set x = 20
(gdb) p x
$1 = 20
(gdb) ❷ p x = 30
$2 = 30
(gdb) p x
$3 = 30
(gdb) ❸ p/x &amp;x
$4 = 0x7fffffffde8c
(gdb) ❹ set {int}0x7fffffffde8c = 40
(gdb) p x
❺ $5 = 40
(gdb) p/x $rax
$6 = 0x555555555129
(gdb) ❻ set $rax = 0xDEADBEEF
(gdb) p/x $rax
$7 = 0xdeadbeef
</code></pre>
<ul>
<li>❶ <code>set x = 20</code> で，変数<code>x</code>に20を代入しています．</li>
<li>❸ <code>p/x &amp;x</code>で変数<code>x</code>のアドレスを調べて，
そのアドレスに代入してみます(❹ <code>set {int}0x7fffffffde8c = 40</code>)．
変数<code>x</code>の値が<code>40</code>に変わりました (❺ <code>$5 = 40</code>)．</li>
<li>❺ <code>set $rax = 0xDEADBEEF</code>で，レジスタ<code>%rax</code>の値を変更しました．</li>
<li>なお，変数，メモリ，レジスタのどの場合でも，
<code>print</code>コマンドを使っても代入できます (❷ <code>p x = 30</code>)．</li>
</ul>
<h2 id="gdb-commands"><a class="header" href="#gdb-commands"><code>gdb</code> の主なコマンドの一覧</a></h2>
<h3 id="起動終了"><a class="header" href="#起動終了">起動・終了</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>gdb ./a.out</code></td><td></td><td><code>gdb</code>の起動</td></tr>
<tr><td><code>run</code></td><td><code>r</code></td><td>実行開始</td></tr>
<tr><td><code>quit</code></td><td><code>q</code></td><td><code>gdb</code>の終了</td></tr>
<tr><td><code>ctrl-c</code></td><td></td><td>実行中のプログラムを一時停止<br/> (シグナル<code>SIGINT</code>を使用)</td></tr>
<tr><td><code>ctrl-z</code></td><td></td><td>実行中のプログラムを一時停止<br/> (シグナル<code>SIGTSTP</code>を使用)</td></tr>
<tr><td>⏎ (改行)</td><td></td><td>前と同じコマンドを再実行</td></tr>
</tbody></table>
</div>
<ul>
<li><code>ctrl-c</code>で<code>SIGINT</code>を<code>gdb</code>ではなく実行中のプログラムに渡すには，
<code>handle SIGINT nostop pass</code>とします．
<code>gdb</code>のシグナル処理状態は<code>info signals</code>で見られます．</li>
<li><code>gdb</code>のプロンプト<code>(gdb)</code>が出ている状態で，<code>ctrl-z</code>を入力すると，
<code>gdb</code>自体の実行を一時停止します．再開するには<code>fg</code>コマンドなどを使います．</li>
</ul>
<h3 id="ヘルプ"><a class="header" href="#ヘルプ">ヘルプ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>help</code> コマンド</td><td><code>h</code></td><td>コマンドのヘルプ(説明)を表示</td></tr>
<tr><td><code>apropos</code> [<code>-v</code>] 正規表現</td><td><code>apr</code></td><td>正規表現をヘルプに含むコマンドを表示(<code>-v</code>は詳細表示)</td></tr>
</tbody></table>
</div>
<h3 id="ヒストリコマンド履歴と補完コンプリーションなど"><a class="header" href="#ヒストリコマンド履歴と補完コンプリーションなど">ヒストリ(コマンド履歴)と補完(コンプリーション)など</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>ctrl-p</code></td><td></td><td>1つ前のコマンドを表示</td></tr>
<tr><td><code>ctrl-n</code></td><td></td><td>1つ後のコマンドを表示</td></tr>
<tr><td><code>show commands</code></td><td></td><td>自分が入力したコマンド履歴を表示</td></tr>
<tr><td><code>ctrl-i</code></td><td></td><td>コマンド等を補完 (TABキーでも同じ)<br/>2回押すと候補一覧を表示</td></tr>
<tr><td><code>ctrl-l</code></td><td></td><td>画面をクリア・リフレッシュ</td></tr>
</tbody></table>
</div>
<h3 id="ブレークポイントウォッチポイント"><a class="header" href="#ブレークポイントウォッチポイント">ブレークポイント・ウォッチポイント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>break</code> 場所</td><td><code>b</code></td><td>ブレークポイントの設定</td></tr>
<tr><td><code>rbreak</code> 正規表現</td><td><code>b</code></td><td>正規表現にマッチする全関数にブレークポイントの設定</td></tr>
<tr><td><code>watch</code> 場所</td><td><code>wa</code></td><td>ウォッチポイント(書き込み)の設定</td></tr>
<tr><td><code>rwatch</code> 場所</td><td><code>rw</code></td><td>ウォッチポイント(読み込み)の設定</td></tr>
<tr><td><code>awatch</code> 場所</td><td><code>aw</code></td><td>ウォッチポイント(読み書き)の設定</td></tr>
<tr><td><code>info break</code></td><td><code>i b</code></td><td>ブレークポイント・ウォッチポイント一覧表示</td></tr>
<tr><td><code>break</code> 場所 <code>if</code> 条件</td><td><code>b</code></td><td>条件付きブレークポイントの設定</td></tr>
<tr><td><code>condition</code> 番号 条件</td><td><code>cond</code></td><td>ブレークポイントに条件を設定</td></tr>
<tr><td><code>commands</code> [番号]</td><td><code>comm</code></td><td>ブレークした時に実行するコマンド列を設定(<code>end</code>で終了)</td></tr>
<tr><td><code>delete</code> 番号</td><td><code>d</code></td><td>ブレークポイントの削除</td></tr>
<tr><td><code>delete</code></td><td><code>d</code></td><td>全ブレークポイントの解除 (<code>clear</code>でも同じ)</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th>場所の指定方法</th><th>例</th></tr></thead><tbody>
<tr><td>関数名</td><td><code>main</code></td></tr>
<tr><td>行番号</td><td><code>6</code></td></tr>
<tr><td>ファイル名:行番号</td><td><code>main.c:6</code></td></tr>
<tr><td>ファイル名:関数名</td><td><code>main.c:main</code></td></tr>
<tr><td><code>*</code>アドレス</td><td><code>*0x55551290</code></td></tr>
</tbody></table>
</div>
<h3 id="ステップ実行-1"><a class="header" href="#ステップ実行-1">ステップ実行</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>step</code></td><td><code>s</code></td><td>次の行までステップ実行(関数コールに入って1行を数える)</td></tr>
<tr><td><code>next</code></td><td><code>n</code></td><td>次の行までステップ実行(関数コールはまたいで1行を数える)</td></tr>
<tr><td><code>finish</code></td><td><code>fin</code></td><td>今の関数を終了するまで実行</td></tr>
<tr><td><code>continue</code></td><td><code>c</code></td><td>ブレークポイントに当たるまで実行</td></tr>
<tr><td><code>until</code> 場所</td><td><code>u</code></td><td>指定した場所まで実行(ループを抜けたい時に便利)</td></tr>
<tr><td><code>jump</code> 場所</td><td><code>j</code></td><td>指定した場所から実行を再開(<code>%rip</code>を書き換えて再開に相当)</td></tr>
<tr><td><code>stepi</code></td><td><code>si</code></td><td>次の機械語命令を1つだけ実行して停止(関数コールに入って1命令を数える)</td></tr>
<tr><td><code>nexti</code></td><td><code>ni</code></td><td>次の機械語命令を1つだけ実行して停止(関数コールはまたいで1命令を数える)</td></tr>
</tbody></table>
</div>
<h3 id="式変数レジスタメモリの表示"><a class="header" href="#式変数レジスタメモリの表示">式，変数，レジスタ，メモリの表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>print</code>/フォーマット   式</td><td><code>p</code></td><td>式を実行して値を表示</td></tr>
<tr><td><code>display</code>/フォーマット   式</td><td><code>disp</code></td><td>実行停止毎に<code>print</code>する</td></tr>
<tr><td><code>info display</code></td><td><code>i di</code></td><td><code>display</code>の設定一覧表示</td></tr>
<tr><td><code>undisplay</code>    番号</td><td><code>und</code></td><td><code>display</code>の設定解除</td></tr>
<tr><td><code>x</code>/<em>NFU</em>    アドレス</td><td><code>x</code></td><td>メモリの内容を表示 (examine)</td></tr>
<tr><td><code>info registers</code></td><td><code>i r</code></td><td>全汎用レジスタの内容を表示</td></tr>
<tr><td><code>info all-registers</code></td><td><code>i al</code></td><td>全汎用レジスタの内容を表示</td></tr>
</tbody></table>
</div>
<ul>
<li>表示する「式」は副作用があっても良い．
代入式でも良いし，副作用のある関数呼び出しやライブラリ関数呼び出しでも良い．
(例: <code>p x = 999</code>，<code>p printf (&quot;hello\n&quot;)</code>)．
このため<code>printf</code>コマンドは単なる「実行状態の表示コマンド」ではなく
「実行状態の変更」も可能 (このために<code>gdb</code>は裏で結構すごいことやってる)．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>式</th><th>説明</th></tr></thead><tbody>
<tr><td><code>$</code>レジスタ名</td><td>レジスタ参照</td></tr>
<tr><td>アドレス<code>@</code>要素数</td><td>配列「アドレス[要素数]」として処理</td></tr>
</tbody></table>
</div>
<ul>
<li><em>N</em> は表示個数(デフォルト1)，<em>F</em>はフォーマット，<em>U</em>は単位サイズを指定する．
<em>F</em>と<em>U</em>の順番は逆でも良い． 
(例: <code>4gx</code> は「8バイトデータを16進数表記で4個表示」を意味する)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォーマット <em>F</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td>16進数 (hexadecimal)</td></tr>
<tr><td style="text-align: center"><code>d</code></td><td>符号あり10進数 (decimal)</td></tr>
<tr><td style="text-align: center"><code>u</code></td><td>符号なし10進数 (unsigned)</td></tr>
<tr><td style="text-align: center"><code>t</code></td><td>2進数 (two)</td></tr>
<tr><td style="text-align: center"><code>c</code></td><td>文字 (char)</td></tr>
<tr><td style="text-align: center"><code>s</code></td><td>文字列 (string)</td></tr>
<tr><td style="text-align: center"><code>i</code></td><td>機械語命令 (instruction)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">単位サイズ <em>U</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td>1バイト (byte)</td></tr>
<tr><td style="text-align: center"><code>h</code></td><td>2バイト (half-word)</td></tr>
<tr><td style="text-align: center"><code>w</code></td><td>4バイト (word)</td></tr>
<tr><td style="text-align: center"><code>g</code></td><td>8バイト (giant)</td></tr>
</tbody></table>
</div>
<h3 id="変数レジスタメモリの変更"><a class="header" href="#変数レジスタメモリの変更">変数，レジスタ，メモリの変更</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>set 変数 = 式</code></td><td><code>set</code></td><td>変数に式の値を代入する</td></tr>
</tbody></table>
</div>
<ul>
<li>変数には通常の変数(<code>x</code>)，レジスタ(<code>$rax</code>)，
メモリ (<code>{int}0x0x1200</code>)，
　デバッガ変数 (<code>$foo</code>)が指定できます．</li>
</ul>
<h3 id="スタック表示"><a class="header" href="#スタック表示">スタック表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>backtrace</code></td><td><code>bt</code>, <code>ba</code></td><td>コールスタックを表示 <br/> <code>where</code>, <code>info stakc</code>でも同じ</td></tr>
<tr><td><code>backtrace full</code></td><td><code>bt f</code>, <code>ba f</code></td><td>コールスタックと全局所変数を表示</td></tr>
</tbody></table>
</div>
<h3 id="プログラム表示"><a class="header" href="#プログラム表示">プログラム表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>list</code> 場所</td><td><code>l</code></td><td>ソースコードを表示</td></tr>
<tr><td><code>disassemble</code> 場所</td><td><code>disas</code></td><td>逆アセンブル結果を表示</td></tr>
</tbody></table>
</div>
<ul>
<li><code>disassemble</code>へのオプション</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">オプション</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>/s</code></td><td>ソースコードも表示 (表示順は機械語命令の順番)</td></tr>
<tr><td style="text-align: center"><code>/m</code></td><td>ソースコードも表示 (表示順はソースコードの順番)</td></tr>
<tr><td style="text-align: center"><code>/r</code></td><td>機械語命令の16進ダンプも表示</td></tr>
</tbody></table>
</div>
<h3 id="tui-テキストユーザインタフェース-1"><a class="header" href="#tui-テキストユーザインタフェース-1">TUI (テキストユーザインタフェース)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>layout</code> レイアウト</td><td><code>la</code></td><td>TUIレイアウトを変更</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">レイアウト</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>asm</code></td><td>アセンブリコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>regs</code></td><td>レジスタのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>src</code></td><td>ソースコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>split</code></td><td>ソースとアセンブリコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>next</code></td><td>次のレイアウトを表示</td></tr>
<tr><td style="text-align: center"><code>prev</code></td><td>前のレイアウトを表示</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">キーバインド</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>ctrl-x a</code></td><td>TUIモードのオン・オフ</td></tr>
<tr><td style="text-align: center"><code>ctrl-x 1</code></td><td>ウインドウを1つにする</td></tr>
<tr><td style="text-align: center"><code>ctrl-x 2</code></td><td>ウインドウを2つにする</td></tr>
<tr><td style="text-align: center"><code>ctrl-x o</code></td><td>選択ウインドウを変更</td></tr>
<tr><td style="text-align: center"><code>ctrl-x s</code></td><td>シングルキーモードのオン・オフ</td></tr>
<tr><td style="text-align: center"><code>ctrl-l</code></td><td>ウインドウをリフレッシュ(再表示)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">シングルキーモードの<br/>キーバインド</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>c</code></td><td><code>continue</code></td></tr>
<tr><td style="text-align: center"><code>d</code></td><td><code>down</code></td></tr>
<tr><td style="text-align: center"><code>f</code></td><td><code>finish</code></td></tr>
<tr><td style="text-align: center"><code>n</code></td><td><code>next</code></td></tr>
<tr><td style="text-align: center"><code>o</code></td><td><code>nexti</code></td></tr>
<tr><td style="text-align: center"><code>q</code></td><td>シングルキーモードの終了</td></tr>
<tr><td style="text-align: center"><code>r</code></td><td><code>run</code></td></tr>
<tr><td style="text-align: center"><code>s</code></td><td><code>step</code></td></tr>
<tr><td style="text-align: center"><code>i</code></td><td><code>stepi</code></td></tr>
<tr><td style="text-align: center"><code>v</code></td><td><code>info locals</code></td></tr>
<tr><td style="text-align: center"><code>v</code></td><td><code>where</code></td></tr>
</tbody></table>
</div>
<h3 id="シンボルテーブル"><a class="header" href="#シンボルテーブル">シンボルテーブル</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>info address</code> シンボル</td><td><code>i ad</code></td><td>シンボルのアドレスを表示</td></tr>
<tr><td><code>info symbol</code> アドレス</td><td><code>i s</code></td><td>そのアドレスを持つシンボルを表示</td></tr>
</tbody></table>
</div>
<h3 id="型の表示"><a class="header" href="#型の表示">型の表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>whatis</code> 式または型名</td><td><code>wha</code></td><td>その式や型名の型情報を表示</td></tr>
<tr><td><code>ptype</code> 式または型名</td><td><code>pt</code></td><td>その式や型名の型情報を詳しく表示</td></tr>
<tr><td><code>info types</code> 正規表現</td><td><code>i types</code></td><td>正規表現にマッチする型を表示</td></tr>
</tbody></table>
</div>
<ul>
<li><code>whatis</code>は<code>typedef</code>を1レベルだけ展開します．
<code>ptype</code>は<code>typedef</code>を全て展開します．</li>
<li><code>ptype</code>に<code>/o</code>オプションを付けると，構造体のフィールドの
オフセットとサイズも表示します．</li>
</ul>
<h2 id="その他の使い方"><a class="header" href="#その他の使い方">その他の使い方</a></h2>
<p>どんなものがあるか，ごく簡単に説明します(詳しくは説明しません)．
詳しくは<a href="https://www.sourceware.org/gdb/documentation/">GDBマニュアル</a>を参照下さい．</p>
<h3 id="初期化ファイル"><a class="header" href="#初期化ファイル">初期化ファイル</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ファイル名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>~/.gdbearlyinit</code></td><td><code>gdb</code>の初期化前に読み込まれる初期化ファイル</td></tr>
<tr><td><code>~/.gdbinit</code></td><td><code>gdb</code>の初期化後に読み込まれる初期化ファイル</td></tr>
<tr><td><code>./.gdbinit</code></td><td>最後に読み込まれる初期化ファイル</td></tr>
</tbody></table>
</div>
<ul>
<li>よく使う<code>gdb</code>の設定，<a href="./10-gdb.html#%E3%83%A6%E3%83%BC%E3%82%B6%E5%AE%9A%E7%BE%A9%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89">ユーザ定義コマンド</a>や
<a href="./10-gdb.html#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9">コマンドエイリアス</a>は
　初期化ファイルに記述しておくと便利です．</li>
<li><code>gdb</code>の起動メッセージを抑制する <code>set startup-quietly on</code> は
<code>~/.gdbearlyinit</code> に指定する必要があります．</li>
<li><code>./.gdbinit</code>は個別の設定の記述に便利です．
ただしデフォルトでは許可されていないので，
<code>add-auto-load-safe-path パス</code> や
<code>set auto-load safe-path /</code> を<code>~/.gdbinit</code>に書く必要があります．</li>
</ul>
<h3 id="ユーザ定義コマンド"><a class="header" href="#ユーザ定義コマンド">ユーザ定義コマンド</a></h3>
<p><code>define</code>と<code>end</code>でユーザ定義コマンドを定義できます．</p>
<pre><code>$ cat ~/.gdbinit
define hello
    echo hello, ❶ $arg0\n
end
❷ define start
    b main
    r
end
define ❸ hook-print
    echo size: b (1 byte), h (2 byte), w (4 byte), g (8 byte)\n
end
define ❹ hook-stop
    x/i $rip
end
$ gdb ./a.out
(gdb) hello gdb
hello, gdb
(gdb) start
=&gt; 0x555555555151 &lt;main+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) p main
size: b (1 byte), h (2 byte), w (4 byte), g (8 byte)
$1 = {int ()} 0x555555555149 &lt;main&gt;
(gdb) ❺ help user-defined
User-defined commands.
The commands in this class are those defined by the user.
Use the &quot;define&quot; command to define a command.

List of commands:

hello -- User-defined.
hook-print -- User-defined.
hook-stop -- User-defined.
start -- User-defined.
(gdb) 
</code></pre>
<ul>
<li>ユーザ定義コマンドの引数は，❶ <code>$arg0</code>, <code>$arg1</code>... と参照します．</li>
<li>例えば「毎回 <code>b main</code>と<code>r</code>を2回打つのは面倒だ」
という場合はユーザ定義コマンド❷ <code>start</code>を定義すると便利かも知れません．
(ここでは使っていませんが) <code>if</code>，<code>while</code>，<code>set</code>を組み合わせて
スクリプト的なユーザ定義コマンドも定義可能です．</li>
<li><code>hook-</code>で始まるコマンド名は特別な意味を持ちます．
例えば，❸<code>hook-print</code>は<code>print</code>を実行するたびに実行されるユーザ定義コマンドになります．(ここでは試しにサイズ指定 <code>bhwg</code> の意味を表示しています)．</li>
<li><code>hook-stop</code>はプログラムが一時停止するたびに実行されるユーザ定義コマンドです．</li>
<li><code>help user-defined</code>で，ユーザ定義コマンドの一覧を表示できます．</li>
</ul>
<h3 id="コマンドエイリアス"><a class="header" href="#コマンドエイリアス">コマンドエイリアス</a></h3>
<pre><code>$ cat ~/.gdbinit
❶ alias di = disassemble
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❷ di
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❸ help di
disassemble, di
Disassemble a specified section of memory.
Usage: disassemble[/m|/r|/s] START [, END]
(以下略)
(gdb) ❹ help aliases
User-defined aliases of other commands.

List of commands:

di -- Disassemble a specified section of memory.
</code></pre>
<ul>
<li><code>alias</code>コマンドでコマンドの別名を定義できます．
ここでは<code>alias di = disassemble</code>として，❷<code>di</code>で逆アセンブルができるようにしました．</li>
<li>素晴らしいことに，❸ <code>help</code> がユーザ定義のエイリアスに対応していて，
<code>help di</code>でヘルプを表示できます．</li>
<li>また，❹ <code>help aliases</code>でエイリアスの一覧を表示できます．
(<code>-a</code>オプションで定義したエイリアスは，補完の対象にならず，
エイリアス一覧にも表示されません)．</li>
</ul>
<h3 id="gdb-attach"><a class="header" href="#gdb-attach">プロセスのアタッチとデタッチ (<code>attach</code>, <code>detach</code>)</a></h3>
<p><code>gdb -p</code>オプションや<code>attach</code>を使うと，すでに実行中のプログラムを
<code>gdb</code>の支配下に置けます(これを<strong>プロセスにアタッチする</strong>といいます)．</p>
<pre><code>// inf-loop.c
#include &lt;stdio.h&gt;
int main ()
{
    int x = 1, n = 0;
    while (x != 0) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ ❶ sudo sysctl -w kernel.yama.ptrace_scope=0
$ gcc -g inf-loop.c
$ ./a.out
 ❷^Z
[1]+  Stopped                 ./a.out
$ ❸ bg
[1]+ ./a.out &amp;
$ ps | egrep a.out
❹ 27373 pts/0    00:00:10 a.out
$ ❺ gdb -p 27373
Attaching to process 27373
main () at inf-loop.c:6
6	    while (x != 0) {
(gdb) bt
#0  main () at inf-loop.c:6
(gdb) ❻ kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 27373) killed]
(gdb) q
</code></pre>
<ul>
<li>まず ❶ <code>sudo sysctl -w kernel.yama.ptrace_scope=0</code>として，
プロセスへのアタッチを許可します．デフォルトでは以下のメッセージが出て
アタッチができません．❶の操作はLinuxを再起動するまで有効です．</li>
</ul>
<pre><code>$ gdb -p 27373
Attaching to process 27373
Could not attach to process.  If your uid matches the uid of the target
process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try
again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf
ptrace: Operation not permitted.
</code></pre>
<ul>
<li>ここでは無限ループする<code>inf-loop.c</code>をコンパイルして実行します．
❷<code>ctrl-z</code>で実行をサスペンド(一時中断)して，❸<code>bg</code>で
バックグラウンド実行にします．
(別の端末から<code>gdb</code>を起動するなら，❷❸の作業は不要です)</li>
<li><code>ps</code>コマンドで<code>a.out</code>のプロセス番号を調べると❹<code>27373</code>と分かりました．
❺<code>gdb -p 27373</code>とすると，プロセス番号27373のプロセスを
<code>gdb</code>が支配下に置きます(これを<strong>プロセスにアタッチする</strong>と言います)．</li>
<li>ここでは単に <code>kill</code>コマンドで<code>a.out</code>を終了させました．
終了させたくない場合は，調査後に <code>detach</code>するか<code>gdb</code>を終了すれば，
<code>a.out</code>はそのまま実行を継続できます．</li>
<li><code>gdb</code>起動後に，<code>attach</code>コマンドを使ってもアタッチできます．</li>
</ul>
<h3 id="コアファイルによる事後デバッグ"><a class="header" href="#コアファイルによる事後デバッグ">コアファイルによる事後デバッグ</a></h3>
<h4 id="コアファイルとは"><a class="header" href="#コアファイルとは">コアファイルとは</a></h4>
<p><strong>コアファイル</strong>(core file)あるいは<strong>コアダンプ</strong>(core dump)とは，
実行中のプロセスのメモリやレジスタの値を記録したファイルのことです．
再現性がないバグに対してコアファイルがあると，
後から何度でもそのコアファイルを使ってデバッグできるので便利です．</p>
<details>
<summary>
コアファイルのコアはメモリを意味する
</summary>
<p>コアファイルのコア (core)はメモリを意味します．
これはかつて(大昔)のメモリが<strong>磁気コア</strong>だったことに由来します．</p>
</details>
<h4 id="コアファイルを生成する設定"><a class="header" href="#コアファイルを生成する設定">コアファイルを生成する設定</a></h4>
<p>セキュリティ等の理由で，デフォルトの設定ではコアファイルが生成されません．
以下でコアファイルを生成する設定にできます．</p>
<pre><code>$ ❶ ulimit -c unlimited
$ ❷ sudo sysctl -w kernel.core_pattern=core
</code></pre>
<p>❶でコアファイルのサイズを無制限に設定します．
　❷で，コアファイル名のパターンを<code>core</code>にします
(生成されるファイル名は <code>core.&lt;pid&gt;</code> となります．<code>&lt;pid&gt;</code>はそのプロセスのプロセス番号です)．
❶の設定はそのシェル内のみ，❷の設定はLinuxを再起動するまで有効です．</p>
<h4 id="コアファイルで事後解析してみる"><a class="header" href="#コアファイルで事後解析してみる">コアファイルで事後解析してみる</a></h4>
<p>segmentation faultでクラッシュしたプログラムの事後解析をしてみます．</p>
<pre><code>$ gcc -g segv.c
$ ./a.out
❶ Segmentation fault (core dumped)
$ ls -l core*
❷ -rw------- 1 gondow gondow 307200  8月 25 10:54 core.2224
$ ❸ gdb ./a.out core.2224
Reading symbols from ./a.out...
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000559ad81bb162 in main () at segv.c:6
6	    printf (&quot;%d\n&quot;, *p); 
(gdb) p p
❹ $1 = (int *) 0xdeadbeef
(gdb) bt
#0  0x0000559ad81bb162 in main () at segv.c:6
</code></pre>
<p><code>segv.c</code>をコンパルして実行すると，segmentation fault を起こし，
コアファイルが作成されました(❷)．
<code>gdb</code>にコアファイル名も指定して起動すると(❸)，
segmentation faultが起きた状態でデバッグが可能になりました．
例えば，変数<code>p</code>の値を表示できています
(❹ <code>$1 = (int *) 0xdeadbeef</code>)．</p>
<blockquote>
<p>注: 権藤の環境(仮想マシンVMWare Fusion 上のUbuntu 22.04LTS，ホストマシン macOS 13.4)の共有フォルダ上で上記を行った場合，
作られたコアファイルのサイズが0になってしまいました．
共有フォルダではなく<code>/tmp</code>などでは問題なくコアファイルが作られました．</p>
</blockquote>
<h4 id="動作中のプロセスのコアファイルを生成する"><a class="header" href="#動作中のプロセスのコアファイルを生成する">動作中のプロセスのコアファイルを生成する</a></h4>
<p><code>gcore</code>コマンドや，<code>gdb</code>の<code>gcore</code>コマンドで，
動作中のプロセスのコアファイルを生成できます．</p>
<pre><code>$ gcc -g inf-loop.c 
$ ./a.out &amp;
[1] 2325
$ ❶ sudo sysctl -w kernel.yama.ptrace_scope=0
kernel.yama.ptrace_scope = 0
$ ❷ gcore 2325
0x0000561775b05169 in main ()
Saved corefile core.2325
$ ❸ gdb ./a.out core.2325 
Reading symbols from ./a.out...
Core was generated by `./a.out'.
#0  main () at inf-loop.c:6
6	    while (x != 0) {
</code></pre>
<p>❶で<a href="./10-gdb.html#gdb-attach">アタッチを可能にする設定</a>が必要です．
<code>gcore</code>コマンドが対象プログラムにアタッチするからです．
<code>gcore</code>コマンドでコアファイルを生成し(❷)，<code>gdb</code>でコアファイルを指定すると(❸)，
無事にデバッグ可能になりました．</p>
<pre><code>$ gcc -g inf-loop.c 
$ gdb ./a.out
(gdb) r
Starting program: /tmp/a.out 
❶ ^C
Program received signal SIGINT, Interrupt.
main () at inf-loop.c:6
6	    while (x != 0) {
(gdb) ❷ gcore
Saved corefile core.2369
</code></pre>
<p><code>gdb</code>上でもコアファイルを生成できます．
<code>gdb</code>上で<code>a.out</code>を実行後，このプログラムは無限ループしてるので，
<code>ctrl-c</code> (❶)で実行を中断してから，
<code>gcore</code>コマンドを使うと，コアファイルを生成できました．</p>
<h3 id="キャッチポイント-catch"><a class="header" href="#キャッチポイント-catch">キャッチポイント (<code>catch</code>)</a></h3>
<p>キャッチポイントは様々なイベント発生時にブレークする仕組みです．
キャッチポイントが扱えるイベントには，
例外，<code>exec</code>，<code>fork</code>，<code>vfork</code>，
システムコール(<code>syscall</code>)，
ライブラリのロード・アンロード(<code>load</code>, <code>unload</code>)，
シグナル (<code>signal</code>)などがあります．</p>
<h4 id="システムコールをキャッチしてみる"><a class="header" href="#システムコールをキャッチしてみる">システムコールをキャッチしてみる</a></h4>
<pre><code class="language-bash">$ gcc -g hello.c
$ gdb ./a.out
(gdb) ❶ catch syscall write
Catchpoint 1 (syscall 'write' [1])
(gdb) r

❷ Catchpoint 1 (call to syscall write), 0x00007ffff7d14a37 in __GI___libc_write (fd=1, buf=0x5555555592a0, nbytes=6) at ../sysdeps/unix/sysv/linux/write.c:26
26	../sysdeps/unix/sysv/linux/write.c: No such file or directory.
(gdb) ❸ bt
#0  0x00007ffff7d14a37 in __GI___libc_write (fd=1, buf=0x5555555592a0, 
    nbytes=6) at ../sysdeps/unix/sysv/linux/write.c:26
#1  0x00007ffff7c8af6d in _IO_new_file_write (
    f=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, data=0x5555555592a0, n=6)
    at ./libio/fileops.c:1180
<span class="boring">#2  0x00007ffff7c8ca61 in new_do_write (to_do=6, 
</span><span class="boring">    data=0x5555555592a0 &quot;hello\n&quot;, fp=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;)
</span><span class="boring">    at ./libio/libioP.h:947
</span><span class="boring">#3  _IO_new_do_write (to_do=6, data=0x5555555592a0 &quot;hello\n&quot;, 
</span><span class="boring">    fp=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;) at ./libio/fileops.c:425
</span><span class="boring">#4  _IO_new_do_write (fp=fp@entry=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, 
</span><span class="boring">    data=0x5555555592a0 &quot;hello\n&quot;, to_do=6) at ./libio/fileops.c:422
</span><span class="boring">#5  0x00007ffff7c8cf43 in _IO_new_file_overflow (
</span><span class="boring">    f=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, ch=10) at ./libio/fileops.c:783
</span><span class="boring">#6  0x00007ffff7c8102a in __GI__IO_puts (str=0x555555556004 &quot;hello&quot;)
</span><span class="boring">    at ./libio/ioputs.c:41
</span><span class="boring">#7  0x0000555555555160 in main () at hello.c:5
</span><span class="boring">(gdb) 
</span></code></pre>
<p>❶ <code>catch syscall write</code>で，<code>write</code>システムコールをキャッチしてみます．
<code>printf</code>が最終的には<code>write</code>システムコールを呼ぶはずです．
やってみたら，無事にキャッチできました(❷)．
バックトレースを見ると(❸)，<code>main</code>関数から<code>write</code>が呼ばれるまでの
　関数呼び出しを表示できました．</p>
<h4 id="シグナルをキャッチしてみる-handle-catch-signal"><a class="header" href="#シグナルをキャッチしてみる-handle-catch-signal">シグナルをキャッチしてみる (<code>handle</code>, <code>catch signal</code>)</a></h4>
<h5 id="handleを使う"><a class="header" href="#handleを使う"><code>handle</code>を使う</a></h5>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

void handler (int n)
{
    fprintf (stderr, &quot;I am handler\n&quot;);
}

int main (void)
{
    signal (SIGUSR1, handler);
    while (1) {
        fprintf (stderr, &quot;.&quot;);
        sleep (1);
    }
}
</code></pre>
<pre><code>$ gcc -g sigusr1.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ handle SIGUSR1 
Signal        Stop	Print	Pass to program	Description
SIGUSR1       Yes	Yes	Yes		User defined signal 1
(gdb) r
❷ ........... 
❸ Program received signal SIGUSR1, User defined signal 1.
0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb) ❹ handle SIGUSR1 nostop noprint pass
Signal        Stop	Print	Pass to program	Description
SIGUSR1       No	No	Yes		User defined signal 1
(gdb) ❺ c
Continuing.
❻ I am handler
......I am handler
.....❼ ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	in ../sysdeps/unix/sysv/linux/clock_nanosleep.c
(gdb)
</code></pre>
<ul>
<li>
<p>❶ <code>handle SIGUSR1</code>とすると，
<code>gdb</code>がシグナル<code>SIGUSR1</code>を受け取った時の処理設定が表示されます．</p>
<ul>
<li>Stop Yes: <code>gdb</code>は<code>a.out</code>の実行を一時停止します．</li>
<li>Print Yes: <code>gdb</code>は<code>SIGUSR1</code>を受け取ったことを表示します．</li>
<li>Pass Yes: <code>gdb</code>は<code>a.out</code>に<code>SIGUSR1</code>を渡します．</li>
</ul>
</li>
<li>
<p>❷ 実行を開始すると，<code>a.out</code>は1秒ごとに<code>.</code>を出力しながら<code>SIGUSR1</code>を待ちます．</p>
</li>
<li>
<p>別端末から<code>a.out</code>のプロセス番号を調べて(ここでは2696)，
<code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信しました．
その結果，<code>a.out</code>の実行が一時停止し(❸)，<code>gdb</code>に制御が戻りました．</p>
</li>
<li>
<p>今度は<code>SIGUSR1</code>の設定を変えてやってみます
❹ <code>handle SIGUSR1 nostop noprint pass</code>は，
「<code>SIGUSR1</code>で一時停止しない，表示もしない，<code>a.out</code>に<code>SIGUSR1</code>を渡す」
という設定を意味します
(<code>stop</code>, <code>nostop</code>, <code>print</code>, <code>noprint</code>, <code>pass</code>, <code>nopass</code>を指定可能です)．
<code>gdb</code>が<code>SIGUSR1</code>を受け取った時，
<code>gdb</code>は<code>a.out</code>を一時停止させず，<code>SIGUSR1</code>を<code>a.out</code>に渡すはずです．</p>
</li>
<li>
<p>実行を再開すると (❺ <code>c</code>)，
❻ <code>I am handler</code>が表示されています．
これは先程送った<code>SIGUSR1</code>に対して<code>a.out</code>のシグナルハンドラが出力した表示です．
ここでもう一度， 
<code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信すると，
(<code>gdb</code>は<code>a.out</code>を一時停止させること無く)
再度<code>I am handler</code>が表示されました．期待した通りの動作です．</p>
</li>
<li>
<p><code>ctrl-C</code> (❼ <code>^C</code>)を押して，<code>a.out</code>の動作を一時停止しました．</p>
</li>
</ul>
<h5 id="catch-signalを使う"><a class="header" href="#catch-signalを使う"><code>catch signal</code>を使う</a></h5>
<pre><code>$ gcc -g sigusr1.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ catch signal SIGUSR1
Catchpoint 1 (signal SIGUSR1)
(gdb) r
..........
❷ Catchpoint 1 (signal SIGUSR1), 0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb)
</code></pre>
<ul>
<li>❶ <code>catch signal SIGUSR1</code> で，<code>SIGUSR1</code>をキャッチする設定をします．</li>
<li>別端末から <code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信すると，
期待通り，<code>SIGUSR1</code>をキャッチして<code>a.out</code>の実行が一時停止されました
(❷ <code>Catchpoint 1 (signal SIGUSR1)</code>)．</li>
<li><code>handle</code>も<code>catch</code>もシグナルをキャッチできるのですが，
<code>catch</code>が<code>handle</code>より嬉しいのは，<code>catch</code>を使うと
停止する<a href="./10-gdb.html#%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%83%96%E3%83%AC%E3%83%BC%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">条件</a>や
停止時に実行する
<a href="./10-gdb.html#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E4%BB%98%E3%81%8D%E3%83%96%E3%83%AC%E3%83%BC%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">コマンド</a>を設定できることです．</li>
<li>なお <code>catch</code> を設定すると，<code>handle</code>の<code>nostop</code>設定は無視されます．</li>
</ul>
<h3 id="gdbのpythonプラグイン"><a class="header" href="#gdbのpythonプラグイン">GDBのPythonプラグイン</a></h3>
<p>PythonでGDBのユーザ定義コマンドを定義できます．</p>
<pre><code># gdb-script.py
class python_test (❶ gdb.Command):
    &quot;&quot;&quot;Python Script Test&quot;&quot;&quot;

    def __init__ (self):
        super (python_test, self).__init__ (
            &quot;python_test&quot;, gdb.COMMAND_USER
        )

    def invoke (self, args, from_tty):
        val = ❷ gdb.parse_and_eval (args)
        print (&quot;args = &quot; + args)
        print (&quot;val  = &quot; + str (val))
        ❸ gdb.execute (&quot;p/x&quot; + str (val) + &quot;\n&quot;);

python_test ()        
</code></pre>
<ul>
<li>例えば上の<code>gdb-script.py</code>は<code>python_test</code>というユーザ定義コマンドを定義します．
<code>~/.gdbinit</code>などでこのファイルを<code>source gdb-script.py</code>として読み込む必要があります．</li>
<li>定義するコマンドは❶<code>gdb.Command</code>のサブクラスとして定義します．
❷ <code>gdb.parse_and_eval</code>を使えば与えられた引数を<code>gdb</code>の下で評価できます．
❸ <code>gdb.execute</code>を使えば，<code>gdb</code>のコマンドとして実行できます．</li>
</ul>
<pre><code>$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1180: file fact.c, line 13.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❹ python_test $rsp
args = $rsp
val  = 0x7fffffffde60
$1 = 0x7fffffffde60
(gdb) help user-defined
User-defined commands.
The commands in this class are those defined by the user.
Use the &quot;define&quot; command to define a command.

List of commands:

❺ python_test -- Python Script Test
(gdb) 
</code></pre>
<ul>
<li><code>gdb</code>上で定義した<code>python_test</code>というコマンドを実行すると(❹)
意図通り実行できました(<code>%rsp</code>の値が評価されて<code>0x7fffffffde60</code>になっています)．</li>
<li><code>help user-defined</code>すると，ちゃんと登録されていました(❺)．</li>
</ul>
<h3 id="gdbmi-machine-interface"><a class="header" href="#gdbmi-machine-interface">GDB/MI machine interface</a></h3>
<p><code>gdb</code>のMI(マシンインタフェース)とは
<code>gdb</code>とのやり取りをプログラムで処理しやすくするためのモードです．</p>
<pre><code>$ gdb --interpreter=mi ./a.out
=thread-group-added,id=&quot;i1&quot;
=cmd-param-changed,param=&quot;auto-load safe-path&quot;,value=&quot;/&quot;
~&quot;Reading symbols from ./a.out...\n&quot;
(gdb) 
❶ b main
❷ &amp;&quot;b main\n&quot;
❸ ~&quot;Breakpoint 1 at 0x1180: file fact.c, line 13.\n&quot;
❹ =breakpoint-created,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000000000001180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}
^done
(gdb) 
r
&amp;&quot;r\n&quot;
~&quot;Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out \n&quot;
=thread-group-started,id=&quot;i1&quot;,pid=&quot;5171&quot;
=thread-created,id=&quot;1&quot;,group-id=&quot;i1&quot;
=breakpoint-modified,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}
=library-loaded,id=&quot;/lib64/ld-linux-x86-64.so.2&quot;,target-name=&quot;/lib64/ld-linux-x86-64.so.2&quot;,host-name=&quot;/lib64/ld-linux-x86-64.so.2&quot;,symbols-loaded=&quot;0&quot;,thread-group=&quot;i1&quot;,ranges=[{from=&quot;0x00007ffff7fc5090&quot;,to=&quot;0x00007ffff7fee335&quot;}]
^running
*running,thread-id=&quot;all&quot;
(gdb) 
=library-loaded,id=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,target-name=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,host-name=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,symbols-loaded=&quot;0&quot;,thread-group=&quot;i1&quot;,ranges=[{from=&quot;0x00007ffff7c28700&quot;,to=&quot;0x00007ffff7dbaabd&quot;}]
~&quot;[Thread debugging using libthread_db enabled]\n&quot;
~&quot;Using host libthread_db library \&quot;/lib/x86_64-linux-gnu/libthread_db.so.1\&quot;.\n&quot;
=breakpoint-modified,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;1&quot;,original-location=&quot;main&quot;}
~&quot;\n&quot;
~&quot;Breakpoint 1, main () at fact.c:13\n&quot;
~&quot;13\t    printf (\&quot;%d\\n\&quot;, fact (5));\n&quot;
*stopped,reason=&quot;breakpoint-hit&quot;,disp=&quot;keep&quot;,bkptno=&quot;1&quot;,frame={addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,args=[],file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,arch=&quot;i386:x86-64&quot;},thread-id=&quot;1&quot;,stopped-threads=&quot;all&quot;,core=&quot;1&quot;
(gdb) 
quit
&amp;&quot;quit\n&quot;
=thread-exited,id=&quot;1&quot;,group-id=&quot;i1&quot;
</code></pre>
<ul>
<li><code>gdb</code>のMIは「CSVのようなもの」です．</li>
<li>❶ <code>b main</code>とブレークポイントの設定をすると，
❷ <code>&amp;&quot;b main\n&quot;</code>と入力したコマンドが返り，
その結果 ❸ <code>~&quot;Breakpoint 1 at 0x1180: file fact.c, line 13.\n&quot;</code>と
付属情報が表示されます ❹ <code>=breakpoint-created,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000000000001180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}</code>
各行は1行で，カンマ <code>,</code>などの区切り子(デリミタ)で区切られており，
プログラムで処理しやすい出力になっています．</li>
<li>JSONで出力してくればいいのにと思ったり．
<code>gdb</code>のMI出力をJSONに変換するツール<a href="https://github.com/cs01/pygdbmi">pygdbmi</a>
はあるようです(試していません)．</li>
</ul>
<h3 id="gdb-remote"><a class="header" href="#gdb-remote">遠隔デバッグ (<code>gdbserver</code>, <code>target remote</code>)</a></h3>
<p><code>gdb</code>は遠隔デバッグが可能です．
遠隔デバッグとは，デバッグ対象のプログラムが動作しているマシンとは
異なるマシン上でデバッグすることです．
リソースが貧弱な組み込みシステムなどで，遠隔デバッグは有用です．</p>
<p>ここでは(簡単のため)ローカルホスト，つまり同じマシン上で遠隔デバッグをしてみます</p>
<p>まず予め <code>gdbserver</code>をインストールしておく必要があります．</p>
<pre><code>$ sudo apt install gdbserver
</code></pre>
<p><code>gdbserver</code>を使ってデバッグしたいプログラム<code>a.out</code>を起動します．</p>
<pre><code>$ gdbserver :1234 ./a.out
Process ./a.out created; pid = 5195
Listening on port 1234
</code></pre>
<p><code>:1234</code>は遠隔でバッグに使用するポート番号です．</p>
<pre><code>$ ❶ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❷ target remote localhost:1234
Remote debugging using localhost:1234
Reading /lib64/ld-linux-x86-64.so.2 from remote target...
(gdb) ❸ c
Continuing.
Reading /lib/x86_64-linux-gnu/libc.so.6 from remote target...
[Inferior 1 (process 5195) exited normally]
(gdb) 
</code></pre>
<ul>
<li><code>gdb</code>を起動して(❶)，デバッグ対象を
遠隔で対象は<code>localhost:1234</code>と指定します(❷)．
(<code>localhost</code>を省略して <code>:1234</code>だけ指定してもOKです)．</li>
<li>デバッグ対象のプログラムはすでに実行を開始しているので，
❸<code>c</code>で実行を再開します．その後は通常の<code>gdb</code>と同様の操作が可能です．</li>
</ul>
<h3 id="トレースポイント-trace-actions-collect-tstart-tstop-tfind-tdump-tstatus"><a class="header" href="#トレースポイント-trace-actions-collect-tstart-tstop-tfind-tdump-tstatus">トレースポイント (<code>trace</code>, <code>actions</code>, <code>collect</code>, <code>tstart</code>, <code>tstop</code>, <code>tfind</code>, <code>tdump</code>, <code>tstatus</code>)</a></h3>
<p>通常，<code>gdb</code>を使う時はブレークポイントを使ってプログラムを一時的に停止させて，
対話的にデバッグ作業を行います．
一方，トレースポイントを使うと<strong>プログラムを一時停止させずに</strong>，
プログラムの動作を観察できます．
手順は以下の通りです．</p>
<ol>
<li><a href="./10-gdb.html#gdb-remote">遠隔デバッグ</a>でプログラムを
<code>gdb</code>の監視下に置きます．
(現在，トレースポイントは遠隔デバッグでのみ有効です)．</li>
<li><code>trace</code>と<code>collect</code>を使って，観察したい場所とデータを事前に設定します．</li>
<li><code>tstart</code>と<code>tstop</code>を使って，プログラムのデータ収集の開始と停止を指示します．</li>
<li>事後に<code>tfind</code>, <code>tdump</code>, <code>tstatus</code>で収集したデータを調査します．</li>
</ol>
<pre><code>$ gcc -g -static fact.c
$ gdbserver :1234 ./a.out
Process ./a.out created; pid = 5696
Listening on port 1234
</code></pre>
<p>ここでは簡単のため静的リンクでコンパイルした<code>a.out</code>を使って
遠隔でバッグの準備をします．</p>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) target remote :1234
Remote debugging using :1234
0x0000000000401620 in _start ()
(gdb) ❶ trace fact
Tracepoint 1 at 0x401754: file fact.c, line 5.
(gdb) ❷ actions
Enter actions for tracepoint 1, one per line.
End with a line saying just &quot;end&quot;.
&gt;❸ collect n
&gt;end
(gdb) b 14
Breakpoint 2 at 0x4017a1: file fact.c, line 14.
(gdb) ❹ tstart
(gdb) c
Continuing.

Breakpoint 2, main () at fact.c:14
14	}
(gdb) ❺ tstop
(gdb) ❻ tstatus
Trace stopped by a tstop command ().
Collected 6 trace frames.
Trace buffer has 5237852 bytes of 5242880 bytes free (0% full).
Trace will stop if GDB disconnects.
Not looking at any trace frame.
Trace started at 135843.311816 secs, stopped 5.701432 secs later.
(gdb) ❼ tfind start
Found trace frame 0, tracepoint 1
#0  fact (n=5, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❽ tdump
Data collected at tracepoint 1, trace frame 0:
n = 5
(gdb) ❾ tfind
Found trace frame 1, tracepoint 1
#0  fact (n=4, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 2, tracepoint 1
#0  fact (n=3, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 3, tracepoint 1
#0  fact (n=2, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 4, tracepoint 1
#0  fact (n=1, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 5, tracepoint 1
#0  fact (n=0, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) quit
</code></pre>
<ul>
<li>
<p>事前準備をします．
関数<code>fact</code>にトレースポイントを設定します(❶ <code>trace fact</code>)．
<a href="./10-gdb.html#break-with-commands">コマンド付きブレークポイント</a>の
<code>comands</code>と同じ要領で，
❷ <code>actions</code>を使って，トレースポイントで収集するデータや動作を指定します．
ここでは単に引数$n$の値を収集します (❸ <code>collect n</code>)．</p>
</li>
<li>
<p>❹ <code>tstart</code>でデータの収集を開始します．
<code>continue</code>でプログラムの実行を再開すると，
トレースポイントにヒットした情報が集められます．
❺ <code>tstop</code>で収集を終了します．</p>
</li>
<li>
<p>事後の調査をします．
❻ <code>tstatus</code>で収集状況を調べると，
6回トレースポイントにヒットしてデータを収集していました
(<code>Collected 6 trace frames</code>)．
❼ <code>tfind start</code>で最初の収集データを見ます．
❽ <code>tdump</code>とするとその収集データの内容を全て表示します
(が，ここでは引数<code>n</code>の値しか表示されません)．
引数無しで ❾ <code>tfind</code>とすると，次の収集データを表示します．
引数<code>n</code>の値が，6から0まで変化したことが分かりました．</p>
</li>
</ul>
<p>トレースポイントに関する付記:</p>
<ul>
<li><code>trace</code>には<code>if</code>を使って
ヒットする<a href="./10-gdb.html#%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%83%96%E3%83%AC%E3%83%BC%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">条件</a>を指定可能です．</li>
<li><code>trace</code>は<code>int3</code>などのトラップ命令を使って<strong>計装</strong>(instrumentation)するので遅いです．<code>ftrace</code>を使うと5バイト長のジャンプ命令を使って計装するので高速になります
(が，計装位置の命令長が5バイト以上必要です)．
(試していませんが)静的計装を行う<code>strace</code>もあります．</li>
</ul>
<h3 id="実行の記録とリプレイ逆実行-record-full-reverse-step"><a class="header" href="#実行の記録とリプレイ逆実行-record-full-reverse-step">実行の記録とリプレイ，逆実行 (<code>record full</code>, <code>reverse-step</code>)</a></h3>
<p><code>gdb</code>では実行状態の記録とリプレイが可能です．
またリプレイ機能を使って逆実行も可能です．
リプレイでは実際には機械語命令の実行を行わず，
実行ログの内容を使って，メモリやレジスタの値を変化させます．</p>
<pre><code>$ gcc -g fact.s
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x40177c: file fact.c, line 13.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❶ record full
(gdb) b fact if n==0
Breakpoint 2 at 0x401754: file fact.c, line 5.
(gdb) c
Continuing.

Breakpoint 2, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
(gdb) reverse-TABTAB
reverse-continue  reverse-next      reverse-search    reverse-stepi
reverse-finish    reverse-nexti     reverse-step      
(gdb) ❷ reverse-next
8	        return n * fact (n - 1);
(gdb) (改行のみ入力，以下も同様)
5	    if (n &lt;= 0)
(gdb) 
8	        return n * fact (n - 1);
(gdb) 
5	    if (n &lt;= 0)
(gdb) 
8	        return n * fact (n - 1);
(gdb) ❸ print n
$1 = 3
(gdb) quit
</code></pre>
<ul>
<li>
<p>❶ <code>record full</code>で実行状態の記録を開始します．
ソフトウェア的に全実行状態を保存します．
(当然，メモリを激しく消費します)．</p>
</li>
<li>
<p>❷ <code>reverse-next</code>など逆実行用のステップ実行を行うと，
逆実行できます(実際には実行はせず，元の状態に戻すだけですが)．
❸ <code>n</code>の値が3の状態まで戻りました．</p>
</li>
</ul>
<p>実行の記録とリプレの付記:</p>
<ul>
<li><code>record full</code>ではなく，<code>record btrace pt</code>などとすると，
ハードウェア機能(例えば，Intel PT)を使った高速な記録になりますが，
リングバッファを使うため，バッファがあふれると古いデータは捨てられます．</li>
<li><code>record stop</code>とすると実行の記録を止めて実行ログは破棄されます．
実行ログは <code>record save ファイル名</code>，<code>record restore ファイル名</code>で
保存や回復が可能です．上の例だとファイルサイズは約700KBでした．</li>
<li>x86-64ではAVX命令などが非対応のようです．
例えば，AVX512の<code>vmovdqu</code>命令を試すと，以下のエラーとなりました(2023/8/27現在)．</li>
</ul>
<pre><code>main () at movdqu.s:23
23	vmovdqu (%rsp), %ymm0
(gdb) 
Process record does not support instruction 0xc5 at address 0x555555555171.
Process record: failed to record execution log.
(gdb) 
</code></pre>
<p>glibcなどのライブラリは<code>-O2</code>などでコンパイルされているため，
AVX命令が使われることが多くあります．
試しに<code>hello.c</code>で試した所，同じエラーとなりました．</p>
<pre><code>(gdb) n
5	    printf (&quot;hello\n&quot;);
(gdb) n
Process record does not support instruction 0xc5 at address 0x7ffff7d9d969.
Process record: failed to record execution log.
</code></pre>
<!--
- 最適化されたコードのデバッグ p.193
  - インライン関数，末尾コール最適化，
## 悩みどころ
- 簡単なドリル問題があったほうが良い
- コマンドの短縮形と長い名前(なれるまでは長い名前が理解しやすい)
-->
<!--
⓿ ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴
-->
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 12; }
</style>
<h1 id="x86-64-命令一覧"><a class="header" href="#x86-64-命令一覧">x86-64 命令一覧</a></h1>
<h2 id="概要と記号"><a class="header" href="#概要と記号">概要と記号</a></h2>
<p><a href="./asm/add5.c"><code>add5.c</code></a>を<code>gcc -S add5.c</code>でコンパイルした結果
<a href="./asm/add5.s"><code>add5.s</code></a>(余計なものの削除後)を用いて，
x86-64アセンブリ言語の概要と記号を説明します．</p>
<img src="figs/add5.svg" height="300px" id="fig:add5">
<ul>
<li><code>$ gcc -S add5.c</code>を実行(コンパイル)すると，アセンブリコード<code>add5.s</code>が生成されます．(結果は環境依存なので，<code>add5.s</code>の中身が違ってても気にしなくてOK)</li>
<li>ドット記号 <code>.</code> で始まるのは<strong>アセンブラ命令</strong>(assembler directive)です．</li>
<li>コロン記号 <code>:</code> で終わるのは<strong>ラベル定義</strong>です．</li>
<li>シャープ記号 <code>#</code> から行末までと，<code>/*</code>と<code>*/</code>で囲まれた範囲(複数行可)は<strong>コメント</strong>です．</li>
<li><code>movq %rsp, %rbp</code> は<strong>機械語命令</strong>(2進数)の記号表現(<strong>ニモニック</strong>(mnemonic))です．<code>movq</code>が命令で<strong>オペコード</strong>(opcode)，<code>%rsp</code>と<code>%rbp</code>は引数で<strong>オペランド</strong>(operand)と呼ばれます．</li>
<li>ドル記号 <code>$</code> で始まるのは<strong>即値</strong>(immediate value，定数)です．</li>
<li>パーセント記号 <code>%</code>で始まるのは<strong>レジスタ</strong>です．</li>
<li><code>-4(%rbp)</code>は<a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a>です．この場合は「<code>%rbp-4</code>の計算結果」をアドレスとするメモリの内容にアクセスすることを意味します．</li>
</ul>
<h2 id="命令サフィックス"><a class="header" href="#命令サフィックス">命令サフィックス</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">AT&amp;T形式の<br/>サイズ指定</th><th>Intel形式の<br/>サイズ指定</th><th>メモリオペランドの<br/>サイズ</th><th>AT&amp;T形式での例</th><th>Intel形式での例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td><code>BYTE PTR</code></td><td>1バイト(8ビット)</td><td><code>movb $10, -8(%rbp)</code></td><td><code>mov BYTE PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>w</code></td><td><code>WORD PTR</code></td><td>2バイト(16ビット)</td><td><code>movw $10, -8(%rbp)</code></td><td><code>mov WORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>l</code></td><td><code>DWORD PTR</code></td><td>4バイト(32ビット)</td><td><code>movl $10, -8(%rbp)</code></td><td><code>mov DWORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>q</code></td><td><code>QWORD PTR</code></td><td>8バイト(64ビット)</td><td><code>movq $10, -8(%rbp)</code></td><td><code>mov QWORD PTR [rbp-8], 10</code></td></tr>
</tbody></table>
</div>
<ul>
<li><a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a>ではサイズ指定が必要です
(「何バイト読み書きするのか」が決まらないから)</li>
<li>AT&amp;T形式では<strong>命令サフィックス</strong>(instruction suffix)でサイズを指定します．
例えば<code>movq $10, -8(%rbp)</code>の<code>q</code>は，
「メモリ参照<code>-8(%rbp)</code>への書き込みサイズが8バイト」であることを意味します．</li>
</ul>
<details>
<summary>
サフィックスとプリフィックス
</summary>
<p>サフィックス(suffix)は<strong>接尾語</strong>(後ろに付けるもの)，
プリフィックス(prefix)は<strong>接頭語</strong>(前に付けるもの)という意味です．</p>
</details>
<ul>
<li>Intel形式ではメモリ参照の前に，<code>BYTE PTR</code>などと指定します．</li>
<li>他のオペランドからサイズが決まる場合は命令サフィックスを省略可能です．
例えば，<code>movq %rax, -8(%rsp)</code>は<code>mov %rax, -8(%rsp)</code>にできます．
<code>mov</code>命令の2つのオペランドはサイズが同じで
<code>%rax</code>レジスタのサイズが8バイトだからです．</li>
</ul>
<h2 id="即値定数"><a class="header" href="#即値定数">即値(定数)</a></h2>
<!--
| 種類 | 説明 | 例 |
|-|-|-|
|10進数定数|`0`で始まらない| `pushq $74`|
|16進数定数|`0x`か`0X`で始まる|`pushq $0x4A`|
|8進数定数|`0`で始まる|`pushq $0112`|
|2進数定数|`0b`か`0B`で始まる|`pushq $0b01001010`|
|文字定数|`'`(クオート)で始まる| `pushq $'J`|
|文字定数|`'`(クオート)で囲む| `pushq $'J'`|
|文字定数|`\`バックスラッシュ<br/>でエスケープ可|`pushq $'\n`|
-->
<div class="table-wrapper"><table><thead><tr><th>種類</th><th>説明</th><th>例</th></tr></thead><tbody>
<tr><td>10進数定数</td><td><code>0</code>で始まらない</td><td><code>pushq $74</code></td></tr>
<tr><td>16進数定数</td><td><code>0x</code>か<code>0X</code>で始まる</td><td><code>pushq $0x4A</code></td></tr>
<tr><td>8進数定数</td><td><code>0</code>で始まる</td><td><code>pushq $0112</code></td></tr>
<tr><td>2進数定数</td><td><code>0b</code>か<code>0B</code>で始まる</td><td><code>pushq $0b01001010</code></td></tr>
<tr><td rowspan="3">文字定数</td><td><code>'</code>(クオート)で始まる</td><td><code>pushq $'J</code></td></tr>
<tr><td><code>'</code>(クオート)で囲む</td><td><code>pushq $'J'</code></td></tr>
<tr><td><code>\</code>バックスラッシュ<br/>でエスケープ可</td
><td><code>pushq $'\n</code></td></tr>
</tbody></table>
</div>  
<ul>
<li><strong>即値</strong>(immediate value，定数)には<code>$</code>をつけます</li>
<li>上の例の定数は最後以外は全部，値が同じです</li>
<li>GNUアセンブラでは文字定数の値は<a href="./4-encoding.html#ASCII">ASCIIコード</a>です．
上の例では，文字<code>'J'</code>の値は<code>74</code>です．</li>
<li>バックスラッシュでエスケープできる文字は，
<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>,  <code>\&quot;</code>, <code>\\</code> です．</li>
<li>多くの場合，即値は32ビットまでで，
オペランドのサイズが64ビットの場合，
32ビットの即値は，64ビットの演算前に
<strong>64ビットに<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">符号拡張</a></strong> されます
(<a href="./4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a>だと
負の値が大きな正の値になって困るから)</li>
</ul>
<details>
<summary>
64ビットに符号拡張される例(1)
</summary>
<div id="imm-64bit-signed-extended">
<pre><code class="language-x86asmatt"># asm/add-imm2.s
    .text
    .globl main
    .type main, @function
main:
    movq $0, %rax
    addq $-1, %rax
    ret
    .size main, .-main
</code></pre>
<p>上の<code>addq $-1, %rax</code>命令の即値<code>$-1</code>は
32ビット(以下の場合もあります)の符号あり整数<code>$0xFFFFFFFF</code>として
機械語命令に埋め込まれます．
<code>addq</code>命令が実行される時は，
この<code>$0xFFFFFFFF</code>が64ビットに符号拡張されて<code>$0xFFFFFFFFFFFFFFFF</code>となります．
以下の実行例でもこれが確認できました．</p>
<pre><code>0 + 0xFFFFFFFFFFFFFFFF = 0xFFFFFFFFFFFFFFFF
</code></pre>
<pre><code>$ gcc -g add-imm2.s
$ gdb ./a.out -x add-imm2.txt
Breakpoint 1, main () at add-imm2.s:8
8	    ret
7	    addq $-1, %rax
$1 = 0xffffffffffffffff
# 0xffffffffffffffff が表示されていれば成功
</code></pre>
</div>
</details>
<details>
<summary>
64ビットに符号拡張される例(2)
</summary>
<p>32ビットの即値が，64ビットの演算前に64ビットに符号拡張されることを見てみます．
32ビット符号あり整数が表現できる範囲は<code>-0x80000000</code>から<code>0x7FFFFFFF</code>です．</p>
<pre><code class="language-x86asmatt"># asm/add-imm.s
    .text
    .globl main
    .type main, @function
main:
    movq $0, %rax
    addl $0xFFFFFFFF, %eax          # OK (0xFFFFFFFF = -1)
#    addq $0xFFFFFFFF, %rax         # NG (0x7FFFFFFFを超えている)
    addq $0xFFFFFFFFFFFFFFFF, %rax  # OK (0xFFFFFFFFFFFFFFFF = -1)
    addq $0x7FFFFFFF, %rax          # OK
    addq $-0x80000000, %rax         # OK
    addq $0xFFFFFFFF80000000, %rax  # OK (0xFFFFFFFF80000000 = -0x80000000)
    ret
    .size main, .-main
</code></pre>
<ul>
<li>
<p>7行目の<code>$0xFFFFFFFF</code>は32ビット符号あり整数として<code>-1</code>，
つまり32ビット符号あり整数が表現できる範囲内なのでOKです．</p>
</li>
<li>
<p>一方，8行目の<code>$0xFFFFFFFF</code>は
64ビット符号あり整数として<code>$0x7FFFFFFF</code>を超えてるのでNGです．
(アセンブルするとエラーになります)</p>
</li>
<li>
<p>9行目の<code>$0xFFFFFFFFFFFFFFFF</code>は一見NGですが，
64ビット符号あり整数としての値は<code>-1</code>なので，
GNUアセンブラはこの即値を<code>-1</code>として機械語命令に埋め込みます．</p>
</li>
<li>
<p>いちばん大事なのは最後の2つの<code>addq</code>命令です．
<code>addq $-0x80000000, %rax</code>の
即値<code>$-0x80000000</code>は(機械語命令中では32ビットで埋め込まれますが)
足し算を実行する前に64ビットに符号拡張されるので，
<code>$0xFFFFFFFF80000000</code>という値で足し算されます．
(つまり，<code>$0x80000000</code>を引きます)．
以下の実行例を見ると，その通りの実行結果になっています．</p>
<ul>
<li><code>❶ 0x17ffffffd - $0x80000000 = ❷ 0xfffffffd</code></li>
<li><code>❷ 0xfffffffd - $0x80000000 = ❸ 0x7ffffffd</code></li>
</ul>
<p>一方，もし <code>$-0x80000000</code>を(符号拡張ではなく)
<strong><a href="4-encoding.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5%E3%81%A8%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a></strong> すると，
<code>$0x0000000080000000</code>となるので，
<code>$0x80000000</code>を(引くのではなく)足すことになってしまいます．</p>
</li>
</ul>
<pre><code>$ gcc -g add-imm.s
$ gdb ./a.out -x add-imm.txt
Breakpoint 1, main () at add-imm.s:7
7	    addl $0xFFFFFFFF, %eax          # OK (0xFFFFFFFF = -0x1)
9	    addq $0xFFFFFFFFFFFFFFFF, %rax  # OK (0xFFFFFFFFFFFFFFFF = -0x1)
1: /x $rax = 0xffffffff
10	    addq $0x7FFFFFFF, %rax          # OK
1: /x $rax = 0xfffffffe
11	    addq $-0x80000000, %rax         # OK
1: /x $rax = ❶ 0x17ffffffd
12	    addq $0xFFFFFFFF80000000, %rax  # OK (0xFFFFFFFF80000000 = -0x80000000)
1: /x $rax = ❷ 0xfffffffd
main () at add-imm.s:13
13	    ret
1: /x $rax = ❸ 0x7ffffffd
#以下が表示されていれば成功
#1: /x $rax = 0xffffffff
#1: /x $rax = 0xfffffffe
#1: /x $rax = 0x17ffffffd
#1: /x $rax = 0xfffffffd
#1: /x $rax = 0x7ffffffd
</code></pre>
<p>以下の通り，逆アセンブルすると，
32ビット以下の即値として機械語命令中に埋め込まれていることが分かります．</p>
<pre><code>$ gcc -g add-imm.s
$ objdump -d ./a.out
0000000000001129 &lt;main&gt;:
    1129:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    1130:	83 c0 ff             	add    $0xffffffff,%eax
    1133:	48 83 c0 ff          	add    $0xffffffffffffffff,%rax
    1137:	48 05 ff ff ff 7f    	add    $0x7fffffff,%rax
    113d:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
    1143:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
    1149:	c3                   	ret    
</code></pre>
</details>
<ul>
<li><code>mov</code>命令は例外で64ビットの即値を扱えます</li>
</ul>
<details>
<summary>
64ビットの即値を扱う例
</summary>
<div id="mov-64bit-imm">
<pre><code class="language-x86asmatt"># asm/movqabs-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movabsq $0x99AABBCCDDEEFF00, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g movqabs-1.s
$ gdb ./a.out -x movqabs-1.txt
Breakpoint 1, main () at movqabs-1.s:6
6	    movq $0x1122334455667788, %rax
7	    movabsq $0x99AABBCCDDEEFF00, %rax
1: /x $rax = 0x1122334455667788
main () at movqabs-1.s:8
8	    ret
1: /x $rax = 0x99aabbccddeeff00
# 以下が表示されれば成功
# 1: /x $rax = 0x1122334455667788
# 1: /x $rax = 0x99aabbccddeeff00
</code></pre>
</div>
</details>
<ul>
<li>ジャンプでは64ビットの相対ジャンプができないので，
間接ジャンプを使う必要がある</li>
</ul>
<details>
<summary>
64ビットの相対ジャンプの代わりに間接ジャンプを使う例
</summary>
<pre><code class="language-x86asmatt"># asm/jmp-64bit.s
    .text
    .globl main
    .type main, @function
main:
#    jmp 0x1122334455667788           # NG
    movq $0x1122334455667788, %rax
    jmp *%rax
    ret
    .size main, .-main
</code></pre>
</details>
<h2 id="レジスタ-1"><a class="header" href="#レジスタ-1">レジスタ</a></h2>
<h3 id="汎用レジスタ-2"><a class="header" href="#汎用レジスタ-2">汎用レジスタ</a></h3>
<img src="figs/gp-regs.svg" height="350px" id="fig:gp-regs">
<ul>
<li>上記16個のレジスタが<strong>汎用レジスタ</strong>(general-purpose register)です．
原則として，プログラマが自由に使えます．</li>
<li>ただし，<code>%rsp</code>は<strong>スタックポインタ</strong>，<code>%rbp</code>は<strong>ベースポインタ</strong>と呼び，
<a href="./2-asm-intro.html#stack-rsp-rbp">一番上のスタックフレームの上下を指す</a>
という役割があります．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>
オプションでコンパイルされた<code>a.out</code>中では，<code>%rbp</code>はベースポインタとしてではなく，
汎用レジスタとして使われています)．</li>
</ul>
<h4 id="caller-savecallee-saveレジスタ-1"><a class="header" href="#caller-savecallee-saveレジスタ-1"><a href="./6-inst.html#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<h4 id="引数-1"><a class="header" href="#引数-1"><a href="./6-inst.html#arg-reg">引数</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<ul>
<li>第7引数以降はレジスタではなくスタックを介して渡します</li>
</ul>
<h3 id="プログラムカウンタ命令ポインタ-1"><a class="header" href="#プログラムカウンタ命令ポインタ-1">プログラムカウンタ（命令ポインタ）</a></h3>
<img src="figs/rip.svg" height="100px" id="fig:rip">
<h3 id="ステータスレジスタフラグレジスタ-1"><a class="header" href="#ステータスレジスタフラグレジスタ-1"><a href="./6-inst.html#status-reg">ステータスレジスタ（フラグレジスタ）</a></a></h3>
<img src="figs/rflags.svg" height="100px" id="fig:rflags">
<h4 id="本書で扱うフラグ-1"><a class="header" href="#本書で扱うフラグ-1">本書で扱うフラグ</a></h4>
<p>ステータスレジスタのうち，本書は以下の6つのフラグを扱います．</p>
<div class="table-wrapper"><table><thead><tr><th>フラグ</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td><code>CF</code></td><td>キャリーフラグ</td><td>算術演算で結果の最上位ビットにキャリーかボローが生じるとセット．それ以外はクリア．符号<strong>なし</strong>整数演算でのオーバーフロー状態を表す．</td></tr>
<tr><td><code>OF</code></td><td>オーバーフローフラグ</td><td>符号ビット(MSB)を除いて，整数の演算結果が大きすぎるか小さすぎるかするとセット．それ以外はクリア．2の補数表現での符号<strong>あり</strong>整数演算のオーバーフロー状態を表す．</td></tr>
<tr><td><code>ZF</code></td><td>ゼロフラグ</td><td>結果がゼロの時にセット．それ以外はクリア．</td></tr>
<tr><td><code>SF</code></td><td>符号フラグ</td><td>符号あり整数の符号ビット(MSB)と同じ値をセット．(0は正の数，1は負の数であることを表す)</td></tr>
<tr><td><code>PF</code></td><td>パリティフラグ</td><td>結果の最下位バイトの値1のビットが偶数個あればセット，奇数個であればクリア．</td></tr>
<tr><td><code>AF</code></td><td>調整フラグ</td><td>算術演算で，結果のビット3にキャリーかボローが生じるとセット．それ以外はクリア．BCD演算で使用する(本書ではほとんど使いません)．</td></tr>
</tbody></table>
</div>
<h4 id="ステータスフラグの変化の記法"><a class="header" href="#ステータスフラグの変化の記法">ステータスフラグの変化の記法</a></h4>
<p>x86-64命令を実行すると，ステータスフラグが変化する命令と
変化しない命令があります．
ステータスフラグの変化は以下の記法で表します．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="x86-list.html#status-reg">CF</a></th><th><a href="x86-list.html#status-reg">OF</a></th><th><a href="x86-list.html#status-reg">SF</a></th><th><a href="x86-list.html#status-reg">ZF</a></th><th><a href="x86-list.html#status-reg">PF</a></th><th><a href="x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td>!</td><td>?</td><td>0</td><td>1</td><td></td></tr>
</tbody></table>
</div>
<p>記法の意味は以下の通りです．</p>
<div id="status-reg">
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>意味</th></tr></thead><tbody>
<tr><td>空白</td><td>フラグ値に変化なし</td></tr>
<tr><td>!</td><td>フラグ値に変化あり</td></tr>
<tr><td>?</td><td>フラグ値は未定義(参照禁止)</td></tr>
<tr><td>0</td><td>フラグ値はクリア(0になる)</td></tr>
<tr><td>1</td><td>フラグ値はセット(1になる)</td></tr>
</tbody></table>
</div></div>
<!--
### セグメントレジスタ
-->
<h3 id="レジスタの別名-1"><a class="header" href="#レジスタの別名-1">レジスタの別名</a></h3>
<h4 id="raxレジスタの別名-rbx-rcx-rdxも同様-1"><a class="header" href="#raxレジスタの別名-rbx-rcx-rdxも同様-1"><code>%rax</code>レジスタの別名 (<code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>も同様)</a></h4>
<img src="figs/reg-alias1.svg" height="150px" id="fig:reg-alias1">
<ul>
<li><code>%rax</code>の下位32ビットは<code>%eax</code>としてアクセス可能</li>
<li><code>%eax</code>の下位16ビットは<code>%ax</code>としてアクセス可能</li>
<li><code>%ax</code>の上位8ビットは<code>%ah</code>としてアクセス可能</li>
<li><code>%ax</code>の下位8ビットは<code>%al</code>としてアクセス可能</li>
</ul>
<h4 id="rbpレジスタの別名-rsp-rdi-rsiも同様-1"><a class="header" href="#rbpレジスタの別名-rsp-rdi-rsiも同様-1"><code>%rbp</code>レジスタの別名 (<code>%rsp</code>, <code>%rdi</code>, <code>%rsi</code>も同様)</a></h4>
<img src="figs/reg-alias2.svg" height="150px" id="fig:reg-alias2">
<ul>
<li><code>%rbp</code>の下位32ビットは<code>%ebp</code>としてアクセス可能</li>
<li><code>%ebp</code>の下位16ビットは<code>%bp</code>としてアクセス可能</li>
<li><code>%bp</code>の下位8ビットは<code>%bpl</code>としてアクセス可能</li>
</ul>
<h4 id="r8レジスタの別名-r9r15も同様-1"><a class="header" href="#r8レジスタの別名-r9r15も同様-1"><code>%r8</code>レジスタの別名 (<code>%r9</code>〜<code>%r15</code>も同様)</a></h4>
<img src="figs/reg-alias3.svg" height="150px" id="fig:reg-alias3">
<ul>
<li><code>%r8</code>の下位32ビットは<code>%r8d</code>としてアクセス可能</li>
<li><code>%r8d</code>の下位16ビットは<code>%r8w</code>としてアクセス可能</li>
<li><code>%r8w</code>の下位8ビットは<code>%r8b</code>としてアクセス可能</li>
</ul>
<h4 id="同時に使えない制限-1"><a class="header" href="#同時に使えない制限-1">同時に使えない制限</a></h4>
<ul>
<li>一部のレジスタは<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>と一緒には使えない．</li>
<li>例：<code>movb %ah, (%r8)</code> や <code>movb %ah, %bpl</code>はエラーになる．</li>
<li>正確には<code>REX</code>プリフィックス付きの命令では，<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>を使えない．</li>
</ul>
<h3 id="zero-upper32"><a class="header" href="#zero-upper32">32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする</a></h3>
<ul>
<li>例:<code>movl $0xAABBCCDD, %eax</code>を実行すると<code>%rax</code>の上位32ビットが全てゼロになる</li>
<li>例: <code>movw $0x1122, %ax</code>や<code>movb $0x11, %al</code>では上位をゼロにすることはない</li>
</ul>
<details>
<summary>
上位32ビットをゼロにする実行例
</summary>
<img src="figs/zero-upper32.svg" height="250px" id="fig:zero-upper32">
<pre><code class="language-x86asmatt"># asm/zero-upper32.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movl $0xAABBCCDD, %eax
    movq $0x1122334455667788, %rax
    movw $0x1122, %ax
    movq $0x1122334455667788, %rax
    movb $0x11, %al
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g zero-upper32.s
$ gdb ./a.out -x zero-upper32.txt
Breakpoint 1, main () at zero-upper32.s:7
7	    movl $0xAABBCCDD, %eax
6	    movq $0x1122334455667788, %rax
7	    movl $0xAABBCCDD, %eax
$1 = 0x1122334455667788
8	    movq $0x1122334455667788, %rax
$2 = 0xaabbccdd
# 以下が出力されれば成功
# $1 = 0x1122334455667788
# $2 = 0xaabbccdd
</code></pre>
</details>
<h2 id="アドレッシングモードオペランドの記法"><a class="header" href="#アドレッシングモードオペランドの記法">アドレッシングモード(オペランドの記法)</a></h2>
<h3 id="アドレッシングモードの種類"><a class="header" href="#アドレッシングモードの種類">アドレッシングモードの種類</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th><th>計算するアドレス</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="./6-inst.html#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="./6-inst.html#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="./6-inst.html#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td><td><code>0x100</code></td></tr>
<tr><td><code>movq foo, %rax</code></td><td><code>foo</code></td></tr>
<tr><td rowspan="3">
<p><a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td><td><code>%rsp+8</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td><td><code>%rip+foo</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベルであり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="x86-list.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="メモリ参照の形式"><a class="header" href="#メモリ参照の形式">メモリ参照の形式</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div>
<blockquote>
<p>注：
Intelのマニュアルには「segment: メモリ参照」という形式もあるとありますが，
segment: はほとんど使わないので，省いて説明します．</p>
</blockquote>
<details>
<summary>
segmentは使わないの?(いえ，ちょっと使います)
</summary>
<div id="segment-override">
segment(正確にはsegment-override)はx86-64ではほとんど使いません．
が，segmentを使ったメモリ参照をする場合があります．
例えば，`%fs:0xfffffffffffffffc`がその例です．
<p><code>%fs</code>は<strong>セグメントレジスタ</strong>と呼ばれる16ビット長のレジスタで，
他には<code>%cs</code>，<code>%ds</code>，<code>%ss</code>，<code>%es</code>，<code>%gs</code>があります．
x86-64では<code>%cs</code>，<code>%ds</code>，<code>%ss</code>，<code>%es</code>は使われていません．
<code>%fs:</code>という記法が使われた時は，
「<code>%fs</code>レジスタが示す<strong>ベースアドレス</strong>をアクセスするアドレスに加える」
ことを意味します．</p>
<p><code>%fs</code>のベースレジスタの値を得るには次の方法があります．</p>
<ul>
<li><code>arch_prctl()</code>システムコールを使う (ここでは説明しません)．</li>
<li><code>gdb</code>で<code>p/x $fs_base</code>を実行する．
(なお，<code>p/x $fs</code>を実行すると<code>0</code>が返りますがこの値は嘘です)</li>
<li><code>rdfsbase</code>命令を使う．</li>
</ul>
<details>
<summary>
rdfsbase命令はCPUとOSの設定に依存
</summary>
<p><code>rdfsbase</code>命令が使えるかどうかは，CPUとOSの設定に依存します．
<code>/proc/cpuinfo</code>の<code>flags</code>の表示に<code>fsgsbase</code>があれば，<code>rdfsbase</code>命令は使えます．
(以下の出力例では<code>fsgsbase</code>が入っています)．</p>
<pre><code>$ less /proc/cpuinfo
processor       : 0
cpu family      : 6
model name      : Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz
(一部略)
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities
</code></pre>
</details>
<p>Linuxでは<code>%fs:</code>や<code>%gs:</code>を使って
<strong>スレッドローカルストレージ</strong>(TLS)を実現しています．
スレッドローカルストレージとは「スレッドごとの(一種の)グローバル変数」です．
マルチスレッドはスレッド同士がメモリ空間を共有しているので，
普通にグローバル変数を使うと，他のスレッドに内容が破壊される可能性があります．
スレッドローカルストレージを使えば，他のスレッドに破壊される心配がなくなります．
スレッドごとに<code>%fs</code>レジスタの値を変えて，
（プログラム上では同じ変数に見えても）スレッドごとに別のアドレスを
参照させて実現しているのでしょう．
(CPUがスレッドの実行を停止・再開するたびに，
スレッドが使用しているレジスタの値も退避・回復するので，
見た目上，「スレッドはそれぞれ独自のレジスタセットを持っている」ように動作します)．</p>
<p>C11からは<code>_Thread_local</code>，<code>gcc</code>では<code>__thread</code>というキーワードで，
スレッドローカルな変数を宣言できます．</p>
<pre><code>// tls.c
#include &lt;stdio.h&gt;
❶ __thread int x = 0xdeadbeef;
int main ()
{
    printf (&quot;x=%x\n&quot;, x);
}
</code></pre>
<pre><code>$ gcc -g tls.c
$ ./a.out
x=deadbeef
$ objdump -d ./a.out | less
0000000000001149 &lt;main&gt;:
    1149:  f3 0f 1e fa             endbr64 
    114d:  55                      push   %rbp
    114e:  48 89 e5                mov    %rsp,%rbp
    1151:  64 8b 04 25 fc ff ff    mov  ❷ %fs:0xfffffffffffffffc,%eax
    1158:  ff 
    1159:  89 c6                   mov    %eax,%esi
</code></pre>
<pre><code>$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1151: file tls.c, line 5.
(gdb) r
Breakpoint 1, main () at tls.c:5
5	    printf (&quot;x=%x\n&quot;, x);
(gdb) p/x x
$1 = 0xdeadbeef
(gdb) ❸ p/x $fs_base
$2 = ❹ 0x7ffff7fa9740
(gdb) x/1wx $fs_base - 4
0x7ffff7fa973c:	❺ 0xdeadbeef
</code></pre>
<ul>
<li>❶ <code>__thread</code>キーワードを使って，変数<code>x</code>をスレッドローカルにします．</li>
<li>コンパイルした<code>a.out</code>を逆アセンブルすると，
❷ <code>%fs:0xfffffffffffffffc</code>というメモリ参照があります．
これがスレッドローカルな変数<code>x</code>の実体の場所で，
「<code>%fsのベースレジスタ - 4</code>」が<code>x</code>のアドレスになります．</li>
<li>❸ <code>p/x $fs_base</code>を使って，<code>%fsのベースレジスタ</code>の値を調べると
❹  <code>0x7ffff7fa9740</code>と分かりました．</li>
<li>アドレス<code>$fs_base - 4</code>のメモリの中身(4バイト)を調べると，
変数<code>x</code>の値である❺ <code>0xDEADBEEF</code>が入っていました．</li>
</ul>
<!--
leaq $fs:-4, %rax とすると，アセンブラに怒られる．
gccは  movq %fs:0, %rax で，アドレスを入手している．
つまり，%fs:0番地に%fsのベースレジスタの値が書き込まれていることが前提になっている．
-->
<details>
<summary>
0xDEADBEEFとは
</summary>
<p>バイナリ上でデバッグする際，「ありそうもない値」を使うと便利なことがあります．
<code>1</code>や<code>2</code>だと偶然の一致がありますが，「ありそうもない値」を使うと
「高い確率でこれは私が書き込んだ値だよね」と分かるからです．
<code>0xDEADBEEF</code>は正しい16進数でありながら，英単語としても読めるので，
「ありそうもない値」として便利です．
他には<code>CAFEBABE</code>もよく使われます．
<code>0xDEADBEEF</code>や<code>0xCAFEBABE</code>はバイナリを識別するマジックナンバーとしても使われます．</p>
</details>
<details>
<summary>
%fs:はスタック保護でも使われる
</summary>
<pre><code>$ gcc -S -fstack-protector-all add5.c
</code></pre>
<p><a href="./asm/add5.c"><code>add5.c</code></a>を<code>-fstack-protector-all</code>オプションで
スタック保護機能をオンにしてコンパイルします．
(最近のLinuxの<code>gcc</code>のデフォルトでは，<code>-fstack-protector-strong</code>が有効に
なっています．これはバッファを使用する関数のみにスタック保護機能を加えます．
ここでは<code>-fstack-protector-all</code>を使って全関数にスタック保護機能を加えました)．</p>
<pre><code class="language-x86asmatt">    .text
    .globl  add5
    .type   add5, @function
add5:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $32, %rsp
    movl    %edi, -20(%rbp)
    movq ❶ %fs:40, %rax
    movq ❷ %rax, -8(%rbp)
    xorl    %eax, %eax
    movl    -20(%rbp), %eax
    addl    $5, %eax
    movq ❸ -8(%rbp), %rdx
    subq ❹ %fs:40, %rdx
    je      .L3
    call ❺ __stack_chk_fail@PLT
.L3:
    leave   
    ret     
    .size   add5, .-add5
</code></pre>
<ul>
<li>関数の最初の方で，スレッドローカルストレージの❶ <code>%fs:40</code>の値を，
(<code>%rax</code>経由で)スタック上の<code>-8(%rbp)</code>に書き込みます．</li>
<li>関数の終わりの方で，❸<code>-8(%rbp)</code>の値を<code>%rdx</code>レジスタにコピーし，
❹ <code>%fs:40</code>の値を引き算しています．</li>
<li>もし，引き算の結果がゼロでなければ(つまり❸と❹の値が異なれば)，
「バッファオーバーフローが起きた」と判断して，
❺ <code>__stack_chk_fail@PLT</code>を呼び出して
プロセスを強制終了させます(つまりバッファオーバーフロー攻撃を防げたことになります)．</li>
</ul>
<!--
> 注:「`-8(%rbp)`を飛び越してバッファオーバーフローを起こせたら，
> あるいは偶然，❸と❹の値が同じになってしまったら，
> バッファオーバーフローを検知できないのでは?」と思った方，正解です．
-->
</details>
<!--
TLSの話はここが詳しい．
https://fasterthanli.me/series/making-our-own-executable-packer/part-13
https://www.kernel.org/doc/html/v5.9/x86/x86_64/fsgs.html

C11から，_Thread_local
GCC拡張 __thread
-->
</div>
</details>
<h3 id="メモリ参照で可能な組み合わせ64ビットモードの場合-1"><a class="header" href="#メモリ参照で可能な組み合わせ64ビットモードの場合-1">メモリ参照で可能な組み合わせ(64ビットモードの場合)</a></h3>
<h4 id="通常のメモリ参照-1"><a class="header" href="#通常のメモリ参照-1">通常のメモリ参照</a></h4>
<img src="figs/memory-ref.svg" height="250px" id="fig:memory-ref">
<ul>
<li>disp には符号あり定数を指定する．ただし「64ビット定数]は無いことに注意．
アドレス計算時に64ビット長に符号拡張される．
dispは変位(displacement)を意味する．</li>
<li>base には上記のいずれかのレジスタを指定可能．省略も可．</li>
<li>index には上記のいずれかのレジスタを指定可能．省略も可．
<code>%rsp</code>を指定できないことに注意．</li>
<li>scale を省略すると <code>1</code> と同じ</li>
</ul>
<blockquote>
<p>注: dispの例外．
<code>mov␣</code>命令のみ，64ビットのdispを指定可能．
この場合，<code>movabs␣</code>というニモニックを使用可能．
メモリ参照はdispのみで，base，index，scaleは指定不可．
他方のオペランドは<code>%rax</code>のみ指定可能．</p>
<pre><code>movq     0x1122334455667788, %rax
movabsq  0x1122334455667788, %rax
movq     %rax, 0x1122334455667788
movabsq  %rax, 0x1122334455667788
</code></pre>
</blockquote>
<h4 id="rip相対参照-1"><a class="header" href="#rip相対参照-1"><code>%rip</code>相対参照</a></h4>
<img src="figs/rip-relative.svg" height="120px" id="fig:rip-relative">
<p><code>%rip</code>相対参照では32ビットのdispと<code>%rip</code>レジスタのみが指定可能です．</p>
<h3 id="メモリ参照の例-1"><a class="header" href="#メモリ参照の例-1">メモリ参照の例</a></h3>
<div class="table-wrapper"><table><thead><tr><th><a href="./8-inline.html#att-intel">AT&amp;T形式</a></th><th><a href="./8-inline.html#att-intel">Intel形式</a></th><th>指定したもの</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>8</code></td><td><code>[8]</code></td><td>disp</td><td><code>8</code></td></tr>
<tr><td><code>foo</code></td><td><code>[foo]</code></td><td>disp</td><td><code>foo</code></td></tr>
<tr><td><code>(%rbp)</code></td><td><code>[rbp]</code></td><td>base</td><td><code>%rbp</code></td></tr>
<tr><td><code>8(%rbp)</code></td><td><code>[rbp+8]</code></td><td>dispとbase</td><td><code>%rbp + 8</code></td></tr>
<tr><td><code>foo(%rbp)</code></td><td><code>[rbp+foo]</code></td><td>dispとbase</td><td><code>%rbp + foo</code></td></tr>
<tr><td><code>8(%rbp,%rax)</code></td><td><code>[rbp+rax+8]</code></td><td>dispとbaseとindex</td><td><code>%rbp + %rax + 8</code></td></tr>
<tr><td><code>8(%rbp,%rax, 2)</code></td><td><code>[rbp+rax*2+8]</code></td><td>dispとbaseとindexとscale</td><td><code>%rbp + %rax*2 + 8</code></td></tr>
<tr><td><code>(%rip)</code></td><td><code>[rip]</code></td><td>base</td><td><code>%rip</code></td></tr>
<tr><td><code>8(%rip)</code></td><td><code>[rip+8]</code></td><td>dispとbase</td><td><code>%rip + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>[rip+foo]</code></td><td>dispとbase</td><td><code>%rip + foo</code></td></tr>
<tr><td><code>%fs:-4</code></td><td><code>fs:[-4]</code></td><td><a href="x86-list.html#segment-override">segment</a>とdisp</td><td><code>%fsのベースレジスタ - 4</code></td></tr>
</tbody></table>
</div>
<ul>
<li>メモリに読み書きするサイズの指定方法 (先頭アドレスだけだと，何バイト読み書きすればいいのか不明):
<ul>
<li>
<p>AT&amp;T形式では<a href="x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a> (<code>q</code>, <code>l</code>, <code>w</code>, <code>b</code>)で指定する．例: <code>movq $4, 8(%rbp)</code></p>
</li>
<li>
<p>Intel形式では，メモリ参照の前に
<code>QWORD PTR</code>, <code>DWORD PTR</code>, <code>WORD PTR</code>, <code>BYTE PTR</code>を付加する
(順番に，8バイト，4バイト，2バイト，1バイトを意味する)．
例: `mov QWORD PTR [rbp+8], 4</p>
</li>
</ul>
</li>
</ul>
<h2 id="詳しい記法"><a class="header" href="#詳しい記法">「記法」「詳しい記法」欄で用いるオペランドの記法と注意</a></h2>
<p>以下の機械語命令の説明で使う記法を説明します．
この記法はその命令に許されるオペランドの形式を表します．</p>
<h3 id="オペランド即値定数-1"><a class="header" href="#オペランド即値定数-1">オペランド，即値(定数)</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*op1*|  | 第1オペランド |
|*op2*|  | 第2オペランド |
|*imm*| `$100` |  *imm8*, *imm16*, *imm32*のどれか |
|*imm8*| `$100` | 8ビットの即値(定数) |
|*imm16*| `$100` | 16ビットの即値(定数) |
|*imm32*| `$100` | 32ビットの即値(定数) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>op1</em></td><td></td><td>第1オペランド</td></tr>
<tr><td><em>op2</em></td><td></td><td>第2オペランド</td></tr>
<tr><td rowspan="2"><em>imm</em></td><td><code>$100</code></td><td rowspan="2"><em>imm8</em>, <em>imm16</em>, <em>imm32</em>のどれか</td></tr>
<tr><td><code>$foo</code></td></tr>
<tr><td><em>imm8</em></td><td><code>$100</code></td><td>8ビットの即値(定数)</td></tr> 
<tr><td><em>imm16</em></td><td><code>$100</code></td><td>16ビットの即値(定数)</td></tr>
<tr><td><em>imm32</em></td><td><code>$100</code></td><td>32ビットの即値(定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>多くの場合，サイズを省略して単に<em>imm</em>と書きます．
特にサイズに注意が必要な時だけ，<em>imm32</em>などとサイズを明記します．</li>
<li><a href="./x86-list.html#mov-64bit-imm">一部例外を除き</a>，
x86-64では64ビットの即値を書けません(32ビットまでです)．</li>
</ul>
<h3 id="汎用レジスタ-3"><a class="header" href="#汎用レジスタ-3">汎用レジスタ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>r</em></td><td><code>%rax</code></td><td><em>r8</em>, <em>r16</em>, <em>r32</em>, <em>r64</em>のどれか</td></tr>
<tr><td><em>r8</em></td><td><code>%al</code></td><td>8ビットの汎用レジスタ</td></tr>
<tr><td><em>r16</em></td><td><code>%ax</code></td><td>16ビットの汎用レジスタ</td></tr>
<tr><td><em>r32</em></td><td><code>%eax</code></td><td>32ビットの汎用レジスタ</td></tr>
<tr><td><em>r64</em></td><td><code>%rax</code></td><td>64ビットの汎用レジスタ</td></tr>
</tbody></table>
</div>
<h3 id="メモリ参照-2"><a class="header" href="#メモリ参照-2">メモリ参照</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*r/m*  | `-8(%rbp)` |  *r/m8*, *r/m16*, *r/m32*, *r/m64*のどれか |
|*r/m8* | `-8(%rbp)` | *r8*  または 8ビットのメモリ参照 |
|*r/m16*| `-8(%rbp)` | *r16* または16ビットのメモリ参照 |
|*r/m32*| `-8(%rbp)` | *r32* または32ビットのメモリ参照 |
|*r/m64*| `-8(%rbp)` | *r64* または64ビットのメモリ参照 |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="4"><em>r/m</em></td><td><code>%rbp</code></td><td rowspan="4"><em>r/m8</em>, <em>r/m16</em>, <em>r/m32</em>, <em>r/m32</em>, <em>r/m64</em>のどれか</td></tr>
<tr><td><code>100</code></td></tr>
<tr><td><code>-8(%rbp)</code></td></tr>
<tr><td><code>foo(%rbp)</code></td></tr>
<tr><td><em>r/m8</em></td><td><code>-8(%rbp)</code></td><td><em>r8</em>  または 8ビットのメモリ参照</td></tr>
<tr><td><em>r/m16</em></td><td><code>-8(%rbp)</code></td><td><em>r16</em> また
は16ビットのメモリ参照</td></tr>
<tr><td><em>r/m32</em></td><td><code>-8(%rbp)</code></td><td><em>r32</em> また
は32ビットのメモリ参照</td></tr>
<tr><td><em>r/m64</em></td><td><code>-8(%rbp)</code></td><td><em>r64</em> また
は64ビットのメモリ参照</td></tr>
<tr><td><em>m</em></td><td><code>-8(%rbp)</code></td><td> メモリ参照</td></tr>
</tbody></table>
</div>
<h3 id="ジャンプコール用のオペランド"><a class="header" href="#ジャンプコール用のオペランド">ジャンプ・コール用のオペランド</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*rel*  | `0x100` |  *rel8*, *rel32*のどちらか |
|*rel8* | `0x100` |  8ビット相対アドレス(直接ジャンプ，定数だが$は不要)|
|*rel32*| `0x1000` |  32ビット相対アドレス(直接ジャンプ，定数だが$は不要)|
|*\*r/m64*| `*-8(%rbp)` | *r64* または64ビットのメモリ参照による<br/>絶対・間接ジャンプ (`*`を前につける) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="2"><em>rel</em></td><td><code>0x100</code></td><td rowspan="2"><em>rel8</em>, <em>rel32</em>のどちらか</td></tr>
<tr><td><code>foo</code></td></tr>
<tr><td><em>rel8</em></td><td><code>0x100</code></td><td>8ビット相対アドレス(直接ジャンプ，定数だが<code>$</code>は不要)</td></tr>
<tr><td><em>rel32</em></td><td><code>0x1000</code></td><td>32ビット相対アドレス(直接ジャンプ，定数だが<code>$</code>は不要)</td></tr>
<tr><td rowspan="3"><em>*r/m64</em></td><td><code>*%rax</code></td><td rowspan="3"><em>r64</em> または64ビットのメモリ参照による絶対アドレス<br/>(間接ジャンプ，<code>*</code>が前に必要)</td></tr>
<tr><td><code>*(%rax)</code></td></tr>
<tr><td><code>*-8(%rax)</code></td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>GNUアセンブラの記法のおかしな点</p>
<ul>
<li>直接ジャンプ先の指定<em>rel</em>は，定数なのに<code>$</code>をつけてはいけない</li>
<li>間接ジャンプ先の指定**r/m64<em>は，
(他の</em>r/m*オペランドでは不要だったのに) <code>*</code>をつけなくてはいけない</li>
<li>相対アドレスで<code>rel8</code>か<code>rel32</code>をプログラマは選べない
(<code>jmp</code>命令に命令サフィックス<code>b</code>や<code>l</code>をつけると怒られる．アセンブラにお任せするしか無い)</li>
</ul>
</li>
<li>
<p><code>*%rax</code>と<code>*(%rax)</code>の違いに注意(以下の図を参照)</p>
</li>
</ul>
<img src="figs/indirect-jmp.svg" height="200px" id="fig:indirect-jmp">
<h2 id="データ転送コピー系の命令"><a class="header" href="#データ転送コピー系の命令">データ転送(コピー)系の命令</a></h2>
<h3 id="mov命令-データの転送コピー-1"><a class="header" href="#mov命令-データの転送コピー-1"><code>mov</code>命令: データの転送（コピー）</a></h3>
<div id="mov-plain">
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`mov␣`** *r*, *r/m*| `movq %rax, %rbx` | `%rbx = %rax` |[movq-1.s](./asm/movq-1.s) [movq-1.txt](./asm/movq-1.txt)|
|| `movq %rax, -8(%rsp)` | `*(%rsp - 8) = %rax` |[movq-2.s](./asm/movq-2.s) [movq-2.txt](./asm/movq-2.txt)|
|**`mov␣`** *r/m*, *r*| `movq -8(%rsp), %rax` | `%rax = *(%rsp - 8)` |[movq-3.s](./asm/movq-3.s) [movq-3.txt](./asm/movq-3.txt)|
|**`mov␣`** *imm*, *r*| `movq $999, %rax` | `%rax = 999` | [movq-4.s](./asm/movq-4.s) [movq-4.txt](./asm/movq-4.txt)|
|**`mov␣`** *imm*, *r/m*| `movq $999, -8(%rsp)` | `*(%rsp - 8) = 999` |[movq-5.s](./asm/movq-5.s) [movq-5.txt](./asm/movq-5.txt)||
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#詳しい記法">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td><a href="./asm/movq-1.s">movq-1.s</a> <a href="./asm/movq-1.txt">movq-1.txt</a></td></tr>
<tr><td><code>movq %rax, -8(%rsp)</code></td><td><code>*(%rsp - 8) = %rax</code></td><td><a href="./asm/movq-2.s">movq-2.s</a> <a href="./asm/movq-2.txt">movq-2.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq -8(%rsp), %rax</code></td><td><code>%rax = *(%rsp - 8)</code></td><td><a href="./asm/movq-3.s">movq-3.s</a> <a href="./asm/movq-3.txt">movq-3.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, -8(%rsp)</code></td><td><code>*(%rsp - 8) = 999</code></td><td><a href="./asm/movq-5.s">movq-5.s</a> <a href="./asm/movq-5.txt">movq-5.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
</div>
<ul>
<li><code>␣</code>は<a href="x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a></li>
<li><code>mov</code>命令(および他のほとんどのデータ転送命令)はステータスフラグの値を変更しない</li>
<li><code>mov</code>命令はメモリからメモリへの直接データ転送はできない</li>
</ul>
<h3 id="xchg命令-オペランドの値を交換-1"><a class="header" href="#xchg命令-オペランドの値を交換-1"><code>xchg</code>命令: オペランドの値を交換</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>op1</em>, <em>op2</em></td><td>exchange</td><td><em>op1</em> と <em>op2</em> の値を交換する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xchg %rax, (%rsp)</code></td><td><code>%rax</code>と<code>(%rsp)</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
<tr><td><strong><code>xchg</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xchg (%rsp), %rax</code></td><td><code>(%rsp)</code>と<code>%rax</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>xchg</code>命令は<strong>アトミックに</strong>2つのオペランドの値を交換します．(LOCKプリフィクスをつけなくてもアトミックになります)</li>
<li>この<strong>アトミック</strong>な動作はロックなどの<strong>同期機構</strong>を作るために使えます．</li>
</ul>
<h3 id="lea命令-実効アドレスを計算-1"><a class="header" href="#lea命令-実効アドレスを計算-1"><code>lea</code>命令: 実効アドレスを計算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>op1</em>, <em>op2</em></td><td>load effective address</td><td><em>op1</em> の実効アドレスを <em>op2</em> に代入する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>m</em>, <em>r</em></td><td><code>leaq -8(%rsp, %rsi, 4), %rax</code></td><td><code>%rax=%rsp+%rsi*4-8</code></td><td><a href="./asm/lea.s">lea.s</a> <a href="./asm/lea.txt">lea.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="pushとpop命令-スタックとデータ転送-1"><a class="header" href="#pushとpop命令-スタックとデータ転送-1"><code>push</code>と<code>pop</code>命令: スタックとデータ転送</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>op1</em></td><td>push</td><td><em>op1</em> をスタックにプッシュ</td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>op1</em></td><td>pop</td><td>スタックから <em>op1</em> にポップ</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>imm</em></td><td><code>pushq $999</code></td><td><code>%rsp-=8; *(%rsp)=999</code></td><td><a href="./asm/push1.s">push1.s</a> <a href="./asm/push1.txt">push1.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m16</em></td><td><code>pushw %ax</code></td><td><code>%rsp-=2; *(%rsp)=%ax</code></td><td><a href="./asm/push2.s">push2.s</a> <a href="./asm/push2.txt">push2.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m64</em></td><td><code>pushq %rax</code></td><td><code>%rsp-=8; *(%rsp)=%rax</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m16</em></td><td><code>popw %ax</code></td><td><code>*(%rsp)=%ax; %rsp += 2</code></td><td><a href="./asm/pop2.s">pop2.s</a> <a href="./asm/pop2.txt">pop2.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m64</em></td><td><code>popq %rbx</code></td><td><code>%rbx=*(%rsp); %rsp += 8</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h2 id="四則演算論理演算の命令"><a class="header" href="#四則演算論理演算の命令">四則演算・論理演算の命令</a></h2>
<h3 id="add-adc命令-足し算"><a class="header" href="#add-adc命令-足し算"><code>add</code>, <code>adc</code>命令: 足し算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add</td><td><em>op1</em> を <em>op2</em> に加える</td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add with carry</td><td><em>op1</em> と CF を <em>op2</em> に加える</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>addq $999, %rax</code></td><td><code>%rax += 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>addq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>addq (%rsp), %rax</code></td><td><code>%rax += *(%rsp)</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>adcq $999, %rax</code></td><td><code>%rax += 999 + CF</code></td><td><a href="./asm/adc-1.s">adc-1.s</a> <a href="./asm/adc-1.txt">adc-1.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>adcq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax + CF</code></td><td><a href="./asm/adc-2.s">adc-2.s</a> <a href="./asm/adc-2.txt">adc-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>adcq (%rsp), %rax</code></td><td><code>%rax += *(%rsp) + CF</code></td><td><a href="./asm/adc-3.s">adc-3.s</a> <a href="./asm/adc-3.txt">adc-3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と<code>adc</code>はオペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算する．</li>
</ul>
<h3 id="sub-sbb命令-引き算-1"><a class="header" href="#sub-sbb命令-引き算-1"><code>sub</code>, <code>sbb</code>命令: 引き算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract</td><td><em>op1</em> を <em>op2</em> から引く</td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract with borrow</td><td><em>op1</em> と CF を <em>op2</em> から引く</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>subq $999, %rax</code></td><td><code>%rax -= 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>subq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>subq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp)</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>sbbq $999, %rax</code></td><td><code>%rax -= 999 + CF</code></td><td><a href="./asm/sbb-1.s">sbb-1.s</a> <a href="./asm/sbb-1.txt">sbb-1.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>sbbq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>sbbq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp) + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と同様に，<code>sub</code>と<code>sbb</code>は
オペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算する．</li>
</ul>
<h3 id="mul-imul命令-かけ算-1"><a class="header" href="#mul-imul命令-かけ算-1"><code>mul</code>, <code>imul</code>命令: かけ算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>op1</em></td><td>unsigned multiply</td><td>符号なし乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em></td><td>signed multiply</td><td>符号あり乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em></td><td>signed multiply</td><td>符号あり乗算．<em>op2</em> *= <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em>, <em>op3</em></td><td>signed multiply</td><td>符号あり乗算．<em>op3</em> = <em>op1</em> * <em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>r/m</em></td><td><code>mulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/mul-1.s">mul-1.s</a> <a href="./asm/mul-1.txt">mul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em></td><td><code>imulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/imul-1.s">imul-1.s</a> <a href="./asm/imul-1.txt">imul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>imulq $4, %rax</code></td><td><code>%rax *= 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>imulq %rbx, %rax</code></td><td><code>%rax *= %rbx</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r/m</em>, <em>r</em></td><td><code>imulq $4, %rbx, %rax</code></td><td><code>%rax = %rbx * 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>オペランドが1つの形式では，<code>%rax</code>が隠しオペランドになる．
このため，乗算の前に<code>%rax</code>に値をセットしておく必要がある．
また，8バイト同士の乗算結果は最大で16バイトになるので，
乗算結果を<code>%rdx</code>と<code>%rax</code>に分割して格納する
(16バイトの乗算結果の上位8バイトを<code>%rdx</code>に，下位8バイトを<code>%rax</code>に格納する)．
これをここでは<code>(%rdx:%rax)</code>という記法で表現している．</li>
<li><code>imul</code>だけ例外的に，オペランドが2つの形式と3つの形式がある．
2つか3つの形式では乗算結果が64ビットを超えた場合，
越えた分は破棄される(乗算結果は8バイトのみ)．</li>
</ul>
<h3 id="div-idiv命令-割り算余り-1"><a class="header" href="#div-idiv命令-割り算余り-1"><code>div</code>, <code>idiv</code>命令: 割り算，余り</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>op1</em></td><td>unsigned divide</td><td>符号なし除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>op1</em></td><td>signed divide</td><td>符号あり除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>r/m</em></td><td><code>divq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/div-1.s">div-1.s</a> <a href="./asm/div-1.txt">div-1.txt</a></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>r/m</em></td><td><code>idivq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/idiv-1.s">idiv-1.s</a> <a href="./asm/idiv-1.txt">idiv-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>16バイトの値 <code>%rdx:%rax</code> を第1オペランドで割った商が<code>%rax</code>に入り，
余りが<code>%rdx</code>に入る．</li>
<li>隠しオペランドとして<code>%rdx</code>と<code>%rax</code>が使われるので，事前に値を設定しておく必要がある．
<code>idiv</code>を使う場合，もし<code>%rdx</code>を使わないのであれば，
<code>cqto</code>命令で<code>%rax</code>を<code>%rdx:%rax</code>に符号拡張しておくと良い．</li>
</ul>
<h3 id="inc-dec命令-インクリメントデクリメント-1"><a class="header" href="#inc-dec命令-インクリメントデクリメント-1"><code>inc</code>, <code>dec</code>命令: インクリメント，デクリメント</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>op1</em></td><td>increment</td><td><em>op1</em>の値を1つ増加</td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>op1</em></td><td>decrement</td><td><em>op1</em>の値を1つ減少</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>r/m</em></td><td><code>inc %rax</code></td><td><code>%rax</code>++</td><td><a href="./asm/inc-1.s">inc-1.s</a> <a href="./asm/inc-1.txt">inc-1.txt</a></td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>r/m</em></td><td><code>dec %rax</code></td><td><code>%rax</code>--</td><td><a href="./asm/dec-1.s">dec-1.s</a> <a href="./asm/dec-1.txt">dec-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>inc</code>や<code>dec</code>はオーバーフローしてもCFが変化しないところがポイント．</li>
</ul>
<h3 id="neg命令-符号反転-1"><a class="header" href="#neg命令-符号反転-1"><code>neg</code>命令: 符号反転</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>op1</em></td><td>negation</td><td>2の補数による<em>op1</em>の符号反転</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>r/m</em></td><td><code>neg %rax</code></td><td><code>%rax = -%rax</code></td><td><a href="./asm/neg-1.s">neg-1.s</a> <a href="./asm/neg-1.txt">neg-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<h3 id="not命令-ビット論理演算-1-1"><a class="header" href="#not命令-ビット論理演算-1-1"><code>not</code>命令: ビット論理演算 (1)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>op1</em></td><td>bitwise not</td><td><em>op1</em>の各ビットの反転 (NOT)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>r/m</em></td><td><code>notq %rax</code></td><td><code>%rax = ~%rax</code></td><td><a href="./asm/not-1.s">not-1.s</a> <a href="./asm/not-1.txt">not-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="and-or-xor命令-ビット論理演算-2-1"><a class="header" href="#and-or-xor命令-ビット論理演算-2-1"><code>and</code>, <code>or</code>, <code>xor</code>命令: ビット論理演算 (2)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise and</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理積(AND)</td></tr>
<tr><td><strong><code>or␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise or</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理和(OR)</td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise xor</td><td><em>op1</em>と<em>op2</em>の各ビットごとの排他的論理和(XOR)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>andq $0x0FFF, %rax</code></td><td><code>%rax &amp;= 0x0FFF</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>andq %rax, (%rsp)</code></td><td><code>*(%rsp) &amp;= %rax</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>andq (%rsp), %rax</code></td><td><code>%rax &amp;= *(%rsp)</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>orq $0x0FFF, %rax</code></td><td><code>%rax |= 0x0FFF </code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>orq %rax, (%rsp)</code></td><td><code>*(%rsp) |= %rax</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>orq (%rsp), %rax</code></td><td><code>%rax |= *(%rsp)</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>xorq $0x0FFF, %rax</code></td><td><code>%rax ^= 0x0FFF</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xorq %rax, (%rsp)</code></td><td><code>*(%rsp) ^= %rax</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xorq (%rsp), %rax</code></td><td><code>%rax ^= *(%rsp)</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><em>x</em></th><th style="text-align: center"><em>y</em></th><th style="text-align: center"><em>x</em> &amp; <em>y</em></th><th style="text-align: center"><em>x</em> | <em>y</em></th><th style="text-align: center"><em>x</em> ^ <em>y</em></th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>&amp;</code>, <code>|</code>, <code>^</code>はC言語で，それぞれ，ビットごとの論理積，論理和，排他的論理積です
(忘れた人はC言語を復習しましょう)．</li>
</ul>
<h3 id="sal-sar-shl-shr命令-シフト"><a class="header" href="#sal-sar-shl-shr命令-シフト"><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>命令: シフト</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic left</td><td>算術左シフト</td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical left</td><td>論理左シフト</td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic right</td><td>算術右シフト</td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical right</td><td>論理右シフト</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>r/m</em></td><td><code>salq %rax</code></td><td><code>%rax</code>を1ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>salq $2, %rax</code></td><td><code>%rax</code>を2ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>salq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>r/m</em></td><td><code>shlq %rax</code></td><td><code>%rax</code>を1ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shlq $2, %rax</code></td><td><code>%rax</code>を2ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shlq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>r/m</em></td><td><code>sarq %rax</code></td><td><code>%rax</code>を1ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>sarq $2, %rax</code></td><td><code>%rax</code>を2ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>sarq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>r/m</em></td><td><code>shrq %rax</code></td><td><code>%rax</code>を1ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shrq $2, %rax</code></td><td><code>%rax</code>を2ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<img src="figs/shift.svg" height="300px" id="fig:shift">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li><strong>シフト</strong>とは(指定したビット数だけ)右か左にビット列をずらすことを意味します．
<em>op2</em>がなければ「1ビットシフト」を意味します．</li>
<li><strong>論理シフト</strong>とは「空いた場所に<strong>0を入れる</strong>」，
<strong>算術シフト</strong>とは「空いた場所に<strong>符号ビットを入れる</strong>」ことを意味します．</li>
<li>左シフトの場合は(符号ビットを入れても意味がないので)，論理シフトでも算術シフトでも，0を入れます．その結果，算術左シフト<code>sal</code>と論理左シフト<code>shl</code>は全く同じ動作になります．</li>
<li>C言語の符号あり整数に対する右シフト(&gt;&gt;)は算術シフトか論理シフトかは
決まっていません(実装依存です)．
C言語で，ビット演算は符号なし整数に対してのみ行うようにしましょう．</li>
</ul>
<h3 id="rol-ror-rcl-rcr命令-ローテート"><a class="header" href="#rol-ror-rcl-rcr命令-ローテート"><code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code>命令: ローテート</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left</td><td>左ローテート</td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left through carry</td><td>CFを含めて左ローテート</td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right</td><td>右ローテート</td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right through carry</td><td>CFを含めて右ローテート</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>r/m</em></td><td><code>rolq %rax</code></td><td><code>%rax</code>を1ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rolq $2, %rax</code></td><td><code>%rax</code>を2ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rolq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>r/m</em></td><td><code>rclq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rclq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rclq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>r/m</em></td><td><code>rorq %rax</code></td><td><code>%rax</code>を1ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rorq $2, %rax</code></td><td><code>%rax</code>を2ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rorq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>r/m</em></td><td><code>rcrq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rcrq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rcrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<img src="figs/rotate.svg" height="330px" id="fig:rotate">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li>ローテートは，シフトではみ出したビットを空いた場所に入れます．</li>
<li>ローテートする方向(右か左)，CFを含めるか否かで，4パターンの命令が存在します．</li>
</ul>
<h3 id="cmp-test命令-比較"><a class="header" href="#cmp-test命令-比較"><code>cmp</code>, <code>test</code>命令: 比較</a></h3>
<h4 id="cmp命令-1"><a class="header" href="#cmp命令-1"><code>cmp</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>sub</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>cmpq $999, %rax</code></td><td><code>subq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpq %rax, (%rsp)</code></td><td><code>subq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>cmpq (%rsp), %rax</code></td><td><code>subq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<h4 id="test命令-1"><a class="header" href="#test命令-1"><code>test</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>logical compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>and</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>testq $999, %rax</code></td><td><code>andq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>testq %rax, (%rsp)</code></td><td><code>andq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>testq (%rsp), %rax</code></td><td><code>andq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令と同様に，<code>test</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令と同様に，<code>test</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が0ならジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">testq %rax, %rax
jz L2
</code></pre>
<ul>
<li>例えば<code>%rax</code>が0かどうかを知りたい場合，
<code>cmpq $0, %rax</code>と<code>testq %rax, %rax</code>のどちらでも調べることができます．
どちらの場合も，ZF==1なら，<code>%rax</code>が0と分かります
(<code>testq %rax, %rax</code>はビットごとのANDのフラグ変化を計算するので，
<code>%rax</code>がゼロの時だけ，ZF==1となります)．
コンパイラは<code>testq %rax, %rax</code>を使うことが多いです．
<code>testq %rax, %rax</code>の方が命令長が短くなるからです．</li>
</ul>
<h3 id="movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張-1"><a class="header" href="#movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張-1"><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code>命令: 符号拡張とゼロ拡張</a></h3>
<h4 id="movs-movz命令-1"><a class="header" href="#movs-movz命令-1"><code>movs</code>, <code>movz</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movsx</code> <em>op2</em>, <em>op1</em> </br> <code>movsxd</code> <em>op2</em>, <em>op1</em></td><td>move with sign-extention</td><td><em>op1</em>を符号拡張した値を<em>op2</em>に格納</td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movzx</code> <em>op2</em>, <em>op1</em></td><td>move with zero-extention</td><td><em>op1</em>をゼロ拡張した値を<em>op2</em>に格納</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movslq %eax, %rbx</code></td><td><code>%rbx</code> = <code>%eax</code>を8バイトに符号拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movzwq %ax, %rbx</code></td><td><code>%rbx</code> = <code>%ax</code>を8バイトにゼロ拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><code>␣␣</code>に入るもの</th><th>何の略か</th><th>意味</th></tr></thead><tbody>
<tr><td><code>bw</code></td><td>byte to word</td><td>1バイト→2バイトの拡張</td></tr>
<tr><td><code>bl</code></td><td>byte to long</td><td>1バイト→4バイトの拡張</td></tr>
<tr><td><code>bq</code></td><td>byte to quad</td><td>1バイト→8バイトの拡張</td></tr>
<tr><td><code>wl</code></td><td>word to long</td><td>2バイト→4バイトの拡張</td></tr>
<tr><td><code>wq</code></td><td>word to quad</td><td>2バイト→8バイトの拡張</td></tr>
<tr><td><code>lq</code></td><td>long to quad</td><td>4バイト→8バイトの拡張</td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>movs</code>, <code>movz</code>命令はAT&amp;T形式とIntel形式でニモニックが異なるので注意です．</li>
<li>GNUアセンブラではAT&amp;T形式でも実は<code>movsx</code>, <code>movzx</code>のニモニックが使用できます．
ただし逆アセンブルすると，<code>movslq</code>, <code>movzwq</code>などのニモニックが表示されるので，
<code>movslq</code>, <code>movzwq</code>などを使う方が良いでしょう．</li>
<li><code>movzlq</code> (Intel形式では<code>movzxd</code>)はありません．例えば，<code>%eax</code>に値を入れると，
<code>%rax</code>の上位32ビットは<a href="./x86-list.html#zero-upper32">クリア</a>されるので，
<code>movzlq</code>は不要だからです．</li>
<li>Intel形式では，4バイト→8バイトの拡張の時だけ，
(<code>movsx</code>ではなく)<code>movsxd</code>を使います．</li>
</ul>
<h4 id="cbtw-cqto命令-1"><a class="header" href="#cbtw-cqto命令-1"><code>cbtw</code>, <code>cqto</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td>**<code>c␣t␣</code></td><td><code>c␣␣␣</code></td><td>convert ␣ to ␣</td><td><code>%rax</code> (または<code>%eax</code>, <code>%ax</code>, <code>%al</code>)を符号拡張</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a><br/>(AT&amp;T形式)</th><th>詳しい記法<br/>(Intel形式)</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cbtw</code></strong></td><td><code>cbw</code></td><td><code>cbtw</code></td><td><code>%al</code>(byte)を<code>%ax</code>(word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtl</code></strong></td><td><code>cwde</code></td><td><code>cwtl</code></td><td><code>%ax</code>(word)を<code>%eax</code>(long)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtd</code></strong></td><td><code>cwd</code></td><td><code>cwtd</code></td><td><code>%ax</code>(word)を<code>%dx:%ax</code>(double word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltd</code></strong></td><td><code>cdq</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%edx:%eax</code>(doube long, quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltq</code></strong></td><td><code>cdqe</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%rax</code>(quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cqto</code></strong></td><td><code>cqo</code></td><td><code>cqto</code></td><td><code>%rax</code>(quad)を<code>%rdx:%rax</code>(octuple)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cqto</code>などは<code>idiv</code>で割り算する前に使うと便利(<code>%rdx:%rax</code>が<code>idiv</code>の隠しオペランドなので)．</li>
<li>GNUアセンブラはIntel形式のニモニックも受け付ける．</li>
</ul>
<h2 id="ジャンプ命令-1"><a class="header" href="#ジャンプ命令-1">ジャンプ命令</a></h2>
<h3 id="jmp-無条件ジャンプ-1"><a class="header" href="#jmp-無条件ジャンプ-1"><code>jmp</code>: 無条件ジャンプ</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>jmp</code></strong> <em>op1</em></td><td>jump</td><td><em>op1</em>にジャンプ</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`jmp`** *rel8*| `jmp 0x1000` | `0x1000`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ (`%rip += 0x1000`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *rel32*| `jmp foo` | `foo`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ (`%rip += foo`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *%rax` | `*%rax`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ (`%rip = *rax`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *(%rax)` | `*(%rax)`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ (`%rip = *(%rax)`|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>jmp</code></strong> <em>rel</em></td><td><code>jmp 0x1000</code></td><td><code>0x1000</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += 0x1000</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><code>jmp foo</code></td><td><code>foo</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += foo</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *%rax</code></td><td><code>*%rax</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *(%rax)</code></td><td><code>*(%rax)</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *(%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
</tbody></table>
</div>
---
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64では，相対・直接と絶対・間接の組み合わせしかありません．
(つまり，相対・間接ジャンプや絶対・直接ジャンプはありません．
なお，ここで紹介していないfarジャンプでは絶対・直接もあります)．</li>
<li>相対・直接ジャンプでは符号ありの8ビット(<em>rel8</em>)か
32ビット(<em>rel32</em>)の整数定数で相対アドレスを指定します．
(64ビットの相対アドレスは指定できません．64ビットのジャンプをしたい時は
絶対・間接ジャンプ命令を使います)．</li>
<li><em>rel8</em>か<em>rel32</em>かはアセンブラが勝手に選んでくれます．
逆に<code>jmpb</code>や<code>jmpl</code>などとサフィックスをつけて指定することはできません．</li>
<li>なぜか，定数なのに<em>rel8</em>や<em>rel32</em>にはドルマーク<code>$</code>をつけません．
逆に<em>r/m</em>の前にはアスタリスク<code>*</code>が必要です．
GNUアセンブラのこの部分は一貫性がないので要注意です．</li>
</ul>
<h3 id="条件付きジャンプの概要-1"><a class="header" href="#条件付きジャンプの概要-1">条件付きジャンプの概要</a></h3>
<ul>
<li>条件付きジャンプ命令 <code>j␣</code>は
　ステータスフラグ (CF, OF, PF, SF, ZF)をチェックして，
条件が成り立てばジャンプします．</li>
<li>条件付きジャンプは比較命令と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<ul>
<li>条件付きジャンプ命令のニモニックでは次の用語を使い分けます
<ul>
<li>符号あり整数の大小には less/greater を使う</li>
<li>符号なし整数の大小には above/below を使う</li>
</ul>
</li>
</ul>
<h3 id="条件付きジャンプ-符号あり整数用-1"><a class="header" href="#条件付きジャンプ-符号あり整数用-1">条件付きジャンプ: 符号あり整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em><br/> <strong><code>jnle</code></strong> <em>rel</em></td><td>jump if greater <br/> jump if not less nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==0&amp;&amp;SF==OF</code></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em><br/> <strong><code>jnl</code></strong> <em>rel</em></td><td>jump if greater or equal <br/> jump if not less</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF==OF</code></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em><br/> <strong><code>jng</code></strong> <em>rel</em></td><td>jump if less or equal <br/> jump if not greater</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==1||SF!=OF</code></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em><br/> <strong><code>jnge</code></strong> <em>rel</em></td><td>jump if less <br/> jump if not greater nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF!=OF</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jg foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jnle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnle foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jge foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jnl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnl foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jle foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jng</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jng foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jl foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
<tr><td><strong><code>jnge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnge foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jg</code>と<code>jnle</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==0&amp;&amp;SF==OF</code>と共通です．
他の3つのペア，<code>jge</code>と<code>jnl</code>，<code>jle</code>と<code>jng</code>，<code>jl</code>と<code>jnge</code>も同様です．</li>
</ul>
<h3 id="条件付きジャンプ-符号なし整数用-1"><a class="header" href="#条件付きジャンプ-符号なし整数用-1">条件付きジャンプ: 符号なし整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em><br/> <strong><code>jnbe</code></strong> <em>rel</em></td><td>jump if above <br/> jump if not below nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0&amp;ZF==0</code></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em><br/> <strong><code>jnb</code></strong> <em>rel</em></td><td>jump if above or equal <br/> jump if not below</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em><br/> <strong><code>jna</code></strong> <em>rel</em></td><td>jump if below or equal <br/> jump if not above</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1&amp;&amp;ZF==1</code></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em><br/> <strong><code>jnae</code></strong> <em>rel</em></td><td>jump if below <br/> jump if not above nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>ja foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jnbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnbe foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jae foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jnb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnb foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jbe foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jna</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jna foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jb foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
<tr><td><strong><code>jnae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnae foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>ja</code>と<code>jnbe</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>CF==0&amp;&amp;ZF==0</code>と共通です．
他の3つのペア，<code>jae</code>と<code>jnb</code>，<code>jbe</code>と<code>jna</code>，<code>jb</code>と<code>jnae</code>も同様です．</li>
</ul>
<h3 id="条件付きジャンプ-フラグ用-1"><a class="header" href="#条件付きジャンプ-フラグ用-1">条件付きジャンプ: フラグ用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td>jump if carry</td><td><code>CF==1</code>なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td>jump if not carry</td><td><code>CF==0</code>なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td>jump if overflow</td><td><code>OF==1</code>なら<em>rel</em>にジャンプ</td><td><code>OF==1</code></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td>jump if not overflow</td><td><code>OF==0</code>なら<em>rel</em>にジャンプ</td><td><code>OF==0</code></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td>jump if sign</td><td><code>SF==1</code>なら<em>rel</em>にジャンプ</td><td><code>SF==1</code></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td>jump if not sign</td><td><code>SF==0</code>なら<em>rel</em>にジャンプ</td><td><code>SF==0</code></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em> <br/> <strong><code>je</code></strong> <em>rel</em></td><td>jump if zero <br/> jump if equal</td><td><code>ZF==1</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>==<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==1</code></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em> <br/> <strong><code>jne</code></strong> <em>rel</em></td><td>jump if not zero <br/> jump if not equal</td><td><code>ZF==0</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>!=<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==0</code></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em> <br/> <strong><code>jpe</code></strong> <em>rel</em></td><td>jump if parity <br/> jump if parity even</td><td><code>PF==1</code>なら<em>rel</em>にジャンプ</td><td><code>PF==1</code></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em> <br/> <strong><code>jpo</code></strong> <em>rel</em></td><td>jump if not parity <br/> jump if parity odd</td><td><code>PF==0</code>なら<em>rel</em>にジャンプ</td><td><code>PF==0</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td><code>jc foo</code></td><td>if (<code>CF==1</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td><code>jnc foo</code></td><td>if (<code>CF==0</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td><code>jo foo</code></td><td>if (<code>OF==1</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td><code>jno foo</code></td><td>if (<code>OF==0</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td><code>js foo</code></td><td>if (<code>SF==1</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td><code>jns foo</code></td><td>if (<code>SF==0</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em></td><td><code>jz foo</code></td><td>if (<code>ZF==1</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>je</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>je foo</code></td><td>if (<code>%rax==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em></td><td><code>jnz foo</code></td><td>if (<code>ZF==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jne</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jne foo</code></td><td>if (<code>%rax!=0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em></td><td><code>jp foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpe</code></strong> <em>rel</em></td><td><code>jpe foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em></td><td><code>jnp foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpo</code></strong> <em>rel</em></td><td><code>jpo foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jz</code>と<code>je</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==1</code>と共通です．
他の3つのペア，<code>jnz</code>と<code>jne</code>，<code>jp</code>と<code>jpe</code>，<code>jnp</code>と<code>jpo</code>も同様です．</li>
<li>AFフラグのための条件付きジャンプ命令は存在しません．</li>
</ul>
<h2 id="関数呼び出しコール命令"><a class="header" href="#関数呼び出しコール命令">関数呼び出し(コール命令)</a></h2>
<h3 id="call-ret命令-関数を呼び出すリターンする"><a class="header" href="#call-ret命令-関数を呼び出すリターンする"><code>call</code>, <code>ret</code>命令: 関数を呼び出す，リターンする</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>op1</em></td><td>call procedure</td><td><code>%rip</code>をスタックにプッシュしてから <em>op1</em>にジャンプする<br/> (<code>pushq %rip; %rip</code> = <em>op1</em>)</td></tr>
<tr><td><strong><code>ret</code></strong></td><td>return from procedure</td><td>スタックからポップしたアドレスにジャンプする <br/> (<code>popq %rip</code>)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>rel</em></td><td><code>call foo</code></td><td>相対・直接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>call</code></strong> <em>r/m</em></td><td><code>call *%rax</code></td><td>絶対・間接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>ret</code></strong></td><td><code>ret</code></td><td>関数からリターン</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="enter-leave命令-スタックフレームを作成する破棄する"><a class="header" href="#enter-leave命令-スタックフレームを作成する破棄する"><code>enter</code>, <code>leave</code>命令: スタックフレームを作成する，破棄する</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>op1</em>, <em>op2</em></td><td>make stack frame</td><td>サイズ<em>op1</em>のスタックフレームを作成する</td></tr>
<tr><td><strong><code>leave</code></strong></td><td>discard stack frame</td><td>今のスタックフレームを破棄する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>imm16</em>, <em>imm8</em></td><td><code>enter $0x20, $0</code></td><td><code>pushq %rbp</code><br/><code>movq %rsp, %rbp</code><br/><code>subq $0x20, %rsp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
<tr><td><strong><code>leave</code></strong></td><td><code>leave</code></td><td><code>movq %rbp, %rsp</code><br/><code>popq %rbp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>enter</code>命令の<em>op2</em>には関数のネストレベルを指定するのですが，
C言語では入れ子の関数がない(つまりネストレベルは常にゼロ)なので
常にゼロを指定します．</li>
<li>ただし，<code>enter</code>は遅いので通常は使いません．
代わりに同等の動作をする<code>pushq %rbp; movq %rsp, %rbp; subq $</code><em>n</em><code>, %rsp</code>を使います．</li>
</ul>
<h3 id="calleeとcaller-1"><a class="header" href="#calleeとcaller-1">calleeとcaller</a></h3>
<h3 id="レジスタ退避と回復-1"><a class="header" href="#レジスタ退避と回復-1">レジスタ退避と回復</a></h3>
<h3 id="caller-saveレジスタとcallee-saveレジスタ-1"><a class="header" href="#caller-saveレジスタとcallee-saveレジスタ-1">caller-saveレジスタとcallee-saveレジスタ</a></h3>
<h3 id="スタックフレーム-1"><a class="header" href="#スタックフレーム-1">スタックフレーム</a></h3>
<pre><code>図
</code></pre>
<h3 id="スタックレイアウト-1"><a class="header" href="#スタックレイアウト-1">スタックレイアウト</a></h3>
<h3 id="関数呼び出し規約-calling-convention"><a class="header" href="#関数呼び出し規約-calling-convention">関数呼び出し規約 (calling convention)</a></h3>
<h3 id="引数の渡し方"><a class="header" href="#引数の渡し方">引数の渡し方</a></h3>
<h3 id="関数プロローグとエピローグ"><a class="header" href="#関数プロローグとエピローグ">関数プロローグとエピローグ</a></h3>
<h3 id="レッドゾーン-redzone-1"><a class="header" href="#レッドゾーン-redzone-1">レッドゾーン (redzone)</a></h3>
<h3 id="cコードからアセンブリコードを呼び出す-1"><a class="header" href="#cコードからアセンブリコードを呼び出す-1">Cコードからアセンブリコードを呼び出す</a></h3>
<h3 id="アセンブリコードからcコードを呼び出す-1"><a class="header" href="#アセンブリコードからcコードを呼び出す-1">アセンブリコードからCコードを呼び出す</a></h3>
<h3 id="アセンブリコードからprintfを呼び出す-1"><a class="header" href="#アセンブリコードからprintfを呼び出す-1">アセンブリコードから<code>printf</code>を呼び出す</a></h3>
<h2 id="その他"><a class="header" href="#その他">その他</a></h2>
<h3 id="insn-nop"><a class="header" href="#insn-nop"><code>nop</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
<tr><td><strong><code>nop</code></strong> <em>op1</em></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td><code>nop</code></td><td>何もしない</td><td><a href="./asm/nop.s">nop.s</a> <a href="./asm/nop.txt">nop.txt</a></td></tr>
<tr><td><strong><code>nop</code></strong> <em>r/m</em></td><td><code>nopl (%rax)</code></td><td>何もしない</td><td><a href="./asm/nop2.s">nop2.s</a> <a href="./asm/nop2.txt">nop2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>nop</code>は何もしない命令です(ただしプログラムカウンタ<code>%rip</code>は増加します)．</li>
<li>機械語命令列の間を(何もせずに)埋めるために使います．</li>
<li><code>nop</code>の機械語命令は1バイト長です．</li>
<li><code>nop</code> <em>r/m</em> という形式の命令は2〜9バイト長の<code>nop</code>命令になります．
1バイト長の<code>nop</code>を9個並べるより，
9バイト長の<code>nop</code>を1個並べた方が，実行が早くなります．</li>
<li>「複数バイトの<code>nop</code>命令がある」という知識は，
逆アセンブル時に<code>nopl (%rax)</code>などを見てビックリしないために必要です．</li>
</ul>
<h3 id="cmpxchg-cmpxchg8b-cmpxchg16b命令-cas-compare-and-swap命令"><a class="header" href="#cmpxchg-cmpxchg8b-cmpxchg16b命令-cas-compare-and-swap命令"><code>cmpxchg</code>, <code>cmpxchg8b</code>, <code>cmpxchg16b</code>命令: CAS (compare-and-swap)命令</a></h3>
<h4 id="cmpxchg命令"><a class="header" href="#cmpxchg命令"><code>cmpxchg</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg</code></strong> <em>op1</em>, <em>op2</em></td><td>compare and exchange</td><td><code>%rax</code>と<em>op2</em>を比較し，同じなら<em>op2</em>=<em>op1</em>，異なれば <code>%rax</code>=<em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpxchg %rbx, (%rsp)</code></td><td>if (<code>*(%rsp)==%rax</code>) <code>*(%rsp)=%rbx</code>;<br/> else <code>%rax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg.s">cmpxchg.s</a> <a href="./asm/cmpxchg.txt">cmpxchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<!--
特定のメモリの値が指定した値と等しい時だけ，別に指定した値で書き換える．
-->
<ul>
<li><code>cmpxchg</code>命令などのCAS命令は，lock-free，つまりロックを使わず
同期機構を実現するために使われます．
アトミックに実行する必要があるため，通常，LOCKプリフィックスをつけて使います．</li>
<li>気持ち:
<ul>
<li>あるメモリにある<em>op2</em>を新しい値<em>op1</em>で書き換えたい．</li>
<li>ただし，代入前の<em>op2</em>の値は<code>%rax</code>と同じはずで，
もし(割り込まれて)知らない間に別の値になっていたら，この代入は失敗させる．</li>
<li>代入が失敗したことを知るために，
(他の誰かが更新した最新の)<em>op2</em>の値を<code>%rax</code>に入れる．
<code>cmpxchg</code>実行後に<code>%rax</code>の値を調べれば，無事に<em>op1</em>への代入ができたかどうかが分かる．</li>
</ul>
</li>
</ul>
<h4 id="cmpxchg8b-cmpxchg16b命令"><a class="header" href="#cmpxchg8b-cmpxchg16b命令"><code>cmpxchg8b</code>, <code>cmpxchg16b</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg8b</code></strong> <em>op1</em></td><td>compare and exchange bytes</td><td><code>%edx:%eax</code>と<em>op1</em>を比較し，同じなら<em>op1</em>=<code>%ecx:%ebx</code>，異なれば <code>%edx:%eax</code>=<em>op1</em></td></tr>
<tr><td><strong><code>cmpxchg16b</code></strong> <em>op1</em></td><td>compare and exchange bytes</td><td><code>%rdx:%rax</code>と<em>op1</em>を比較し，同じなら<em>op1</em>=<code>%rcx:%rbx</code>，異なれば <code>%rdx:%rax</code>=<em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg8b</code></strong> <em>m64</em></td><td><code>cmpxchg8b (%rsp)</code></td><td>if (<code>*(%rsp)==%edx:%eax</code>) <code>*(%rsp)=%ecx:%ebx</code>;<br/> else <code>%edx:%eax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg8.s">cmpxchg8b.s</a> <a href="./asm/cmpxchg8.txt">cmpxchg8.txt</a></td></tr>
<tr><td><strong><code>cmpxchg16b</code></strong> <em>m128</em></td><td><code>cmpxchg16b (%rsp)</code></td><td>if (<code>*(%rsp)==%rdx:%rax</code>) <code>*(%rsp)=%rcx:%rbx</code>;<br/> else <code>%rdx:%rax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg16.s">cmpxchg16b.s</a> <a href="./asm/cmpxchg16.txt">cmpxchg16.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td>!</td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmpxchg8b</code>, <code>cmpxchg16b</code>もCAS命令の一種ですが，
<code>cmpxchg</code>とステータスフラグの変化が異なるので，分けて書いています．</li>
<li><code>cmpxchg16b</code>命令が参照するメモリは16バイト境界のアラインメントが必要です．
(つまりメモリアドレスが16の倍数である必要があります)．</li>
</ul>
<h3 id="rdtsc-rdtscp命令-タイムスタンプを読む"><a class="header" href="#rdtsc-rdtscp命令-タイムスタンプを読む"><code>rdtsc</code>, <code>rdtscp</code>命令: タイムスタンプを読む</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rdtsc</code></strong></td><td>read time-stamp counter</td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ</td></tr>
<tr><td><strong><code>rdtscp</code></strong></td><td>read time-stamp counter and processor ID</td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ <br/> <code>%ecx</code> = 32ビットプロセッサID</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rdtsc</code></strong></td><td><code>rdtsc</code></td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ</td><td><a href="./asm/rdtsc.s">rdtsc.s</a> <a href="./asm/rdtsc.txt">rdtsc.txt</a></td></tr>
<tr><td><strong><code>rdtscp</code></strong></td><td><code>rdtscp</code></td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ <br/> <code>%ecx</code> = 32ビットプロセッサID</td><td><a href="./asm/rdtscp.s">rdtscp.s</a> <a href="./asm/rdtscp.txt">rdtscp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64は64ビットの<strong>タイムスタンプカウンタ</strong>
(TSC: time stamp counter)を備えており，
リセット後のCPUのサイクル数を数えています．
原理的には「サイクル数の差分をCPUのクロック周波数で割れば実行時間が得られる」
はずですが，実際にはout-of-order実行などの影響を加味する必要があります．
詳しくは<a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a>を参照して下さい．</li>
<li><code>rdtscp</code>命令を使うと，プロセッサIDも取得できます．</li>
<li><code>rdtsc</code>, <code>rdtsc</code>命令はタイムスタンプカウンタの取得方法に違いがあります．
詳しくは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">x86-64のマニュアルSDM</a>
を参照して下さい．</li>
</ul>
<h3 id="int3命令"><a class="header" href="#int3命令"><code>int3</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>int3</code></strong></td><td>call to interrupt procedure</td><td>ブレークポイントトラップを発生</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>int3</code></strong></td><td><code>int3</code></td><td>ブレークポイントトラップを発生</td><td><a href="./asm/int3.s">int3.s</a> <a href="./asm/int3.txt">int3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>int3</code>命令はブレークポイントトラップ(ソフトウェア割り込みの一種)を発生させます．
通常実行では<code>int3</code>を実行した時点でプロセスは強制終了となりますが，
デバッガ上ではその時点でブレークします．continueコマンドでその後の実行も継続できます．ブレークしたい場所が分かっている場合は，
Cコード中に<code>asm (&quot;int3&quot;);</code>と書くことでデバッガ上でブレークさせることができます．</li>
</ul>
<h3 id="ud2命令"><a class="header" href="#ud2命令"><code>ud2</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>ud2</code></strong></td><td>undefined instruction</td><td>無効オペコード例外を発生させる</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ud2</code></strong></td><td><code>ud2</code></td><td>無効オペコード例外を発生させる</td><td><a href="./asm/ud2.s">ud2.s</a> <a href="./asm/ud2.txt">ud2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>ud2</code>命令は無効オペコード例外を発生させます．
通常実行では<code>ud2</code>を実行した時点でプロセスは，
シグナル<code>SIGILL</code> (illegal instruction)を受け取り，強制終了となります
デバッガ上でも，
<code>Program received signal SIGILL, Illegal instruction.</code>
というメッセージが出て，プロセスは終了になります．
本書では「実行が通るはずがない場所が本当かどうか」の確認のため
<code>ud2</code>を使います．(通るはずがない場所に<code>ud2</code>を置いて，<code>SIGILL</code>が発生しなければOKです)</li>
</ul>
<details>
<summary>
例外 (exception)とは
</summary>
<p><strong>例外</strong>(exception)はCPUが発生させる割り込み(ソフトウェア割り込み)です．
Intel用語で，例外はさらに<strong>フォールト</strong>(fault)，<strong>トラップ</strong>(trap)，
<strong>アボート</strong>(abort)に分類されます．
例えばゼロ割はフォールト，ブレークポイントはトラップです．
マイOS作りたい人は頑張って<a href="https://wiki.osdev.org/Exceptions">勉強</a>して下さい．</p>
</details>
<h3 id="endbr64命令"><a class="header" href="#endbr64命令"><code>endbr64</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>endbr64</code></strong></td><td>end branch 64 bit</td><td>間接ジャンプ先として許す</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>endbr64</code></strong></td><td><code>endbr64</code></td><td>間接ジャンプ先として許す</td><td><a href="./asm/endbr64.s">endbr64.s</a> <a href="./asm/endbr64.txt">endbr64.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>Intel CET IBT技術に対応したCPUの場合，
間接ジャンプ後のジャンプ先が<code>endbr64</code>以外だった場合，
例外が発生してプログラムは強制終了となります．</li>
<li>Intel CET IBT技術に未対応のCPUの場合は，<code>nop</code>命令として動作します．</li>
<li>逆アセンブルして<code>endbr64</code>を見てもビックリしないためにこの説明を書いています．</li>
<li>私のPCが古すぎて，Intel CET未対応だったため，2023/8/17現在，クラッシュが発生するサンプルコードを作れていません．</li>
</ul>
<h3 id="bndプリフィックス"><a class="header" href="#bndプリフィックス"><code>bnd</code>プリフィックス</a></h3>
<p>Intel MPX (Memory Protection Extensions)の機能の一部で，
境界チェックを行います．この機能をサポートしてないCPUでは<code>nop</code>として動作します．</p>
<ul>
<li>逆アセンブルして<code>bnd</code>を見てもビックリしないためにこの説明を書いています．</li>
</ul>
<h3 id="set命令-ステータスフラグの値を取得"><a class="header" href="#set命令-ステータスフラグの値を取得"><code>set␣</code>命令: ステータスフラグの値を取得</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>set␣</code></strong> <em>op1</em></td><td>set byte on condition</td><td>if (条件␣が成立) <em>op1</em>=1; else <em>op1</em>=0;</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`set␣`** *r/m8*| `setz %al`| `%al` = ZF | [setz.s](./asm/setz.s) [setz.txt](./asm/setz.txt)|
|**`set␣`** *r/m8*| `setg %al`| `%al` = より大きい(greater)条件が成立なら1，違えば0 | [setg.s](./asm/setg.s) [setg.txt](./asm/setg.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>set␣</code></strong> <em>r/m8</em></td><td><code>setz %al</code></td><td><code>%al</code> = ZF</td><td><a href="./asm/setz.s">setz.s</a> <a href="./asm/setz.txt">setz.txt</a></td></tr>
<tr><td><code>setg %al</code></td><td> より大きい(greater)条件が成立なら<code>%al</code> =1，違えば<code>%al</code> =0</td><td><a href="./asm/setg.s">setg.s</a> <a href="./asm/setg.txt">setg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>set␣</code>命令はステータスフラグの値を取得します．
<code>␣</code>には条件付きジャンプ命令<code>j␣</code>の<code>␣</code>と同じものをすべて入れられます．</li>
</ul>
<h3 id="命令プリフィックス"><a class="header" href="#命令プリフィックス">命令プリフィックス</a></h3>
<h3 id="ストリング命令"><a class="header" href="#ストリング命令">ストリング命令</a></h3>
<h3 id="xmm0-とか"><a class="header" href="#xmm0-とか">%xmm0 とか</a></h3>
<p>memcpy とかでコンパイラがストリング命令とか%xmm0とか吐いちゃうから…</p>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 13; }
</style>
<h1 id="リンク集"><a class="header" href="#リンク集">リンク集</a></h1>
<ul>
<li>デバッグ情報の仕様書 <a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a></li>
<li>WindowsのLinux環境 <a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> </li>
<li>仮想マシン <a href="https://www.virtualbox.org/">VirtualBox</a></li>
<li>コンテナ環境 <a href="https://www.docker.com/">Docker</a></li>
<li>オンライン開発環境 <a href="https://replit.com/">repl.it</a></li>
<li>OS自作本 <a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a></li>
<li>Linuxディストリビューション <a href="https://www.ubuntulinux.jp/home">Ubuntu</a></li>
<li>GNUアセンブラのマニュアル <a href="https://sourceware.org/binutils/docs-2.40/as/index.html">Using as</a></li>
<li>GCC 9.4のマニュアル <a href="https://gcc.gnu.org/onlinedocs/9.4.0/">9.4 Manuals</a></li>
<li>x86-64のマニュアル <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a></li>
<li>LinuxのABI <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a></li>
</ul>
<!-- - Linuxの標準 [Linux Standard Base (LSB)](https://refspecs.linuxfoundation.org/lsb.shtml) -->
<ul>
<li>
<p>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></p>
</li>
<li>
<p><a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></p>
</li>
<li>
<p>VDSO <a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></p>
</li>
<li>
<p>call frame informationの短い解説 <a href="https://www.imperialviolet.org/2017/01/18/cfi.html">CFI</a></p>
</li>
<li>
<p><code>rdtscp</code>で実行時間を測る際の注意事項 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a></p>
</li>
<li>
<p><a href="https://www.sourceware.org/gdb/documentation/">GDBマニュアル</a></p>
</li>
</ul>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
