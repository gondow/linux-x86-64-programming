<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linuxで学ぶx86-64アセンブリ言語</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="この本は書きかけですが，ご意見は歓迎します">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

	<!-- Tab -->
        <link rel="stylesheet" href="css/tab.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/tab.css">

        <!-- MathJax -->
        <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">準備</li><li class="chapter-item "><a href="1-pre.html"><strong aria-hidden="true">1.</strong> 前書き</a></li><li class="chapter-item affix "><li class="part-title">概要</li><li class="chapter-item "><a href="2-asm-intro.html"><strong aria-hidden="true">2.</strong> アセンブリ言語の概要</a></li><li class="chapter-item "><a href="3-binary.html"><strong aria-hidden="true">3.</strong> バイナリファイル</a></li><li class="chapter-item affix "><li class="part-title">より詳しい説明</li><li class="chapter-item "><a href="5-arch.html"><strong aria-hidden="true">4.</strong> コンピュータアーキテクチャの基本：CPU，メモリ，レジスタなど 90%</a></li><li class="chapter-item "><a href="4-data.html"><strong aria-hidden="true">5.</strong> データ表現，2進数，2の補数 90%</a></li><li class="chapter-item "><a href="6-inst.html"><strong aria-hidden="true">6.</strong> x86-64機械語命令 90%</a></li><li class="chapter-item "><a href="7-asm.html"><strong aria-hidden="true">7.</strong> アセンブラ命令 90%</a></li><li class="chapter-item "><a href="8-inline.html"><strong aria-hidden="true">8.</strong> インラインアセンブラ 90%</a></li><li class="chapter-item "><a href="9-code.html"><strong aria-hidden="true">9.</strong> GCCが生成したアセンブリコードを読む 90%</a></li><li class="chapter-item "><a href="10-gdb.html"><strong aria-hidden="true">10.</strong> デバッガgdbの使い方 90%</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">リファレンス</li><li class="chapter-item "><a href="x86-list.html"><strong aria-hidden="true">11.</strong> x86-64命令一覧 80%</a></li><li class="chapter-item "><a href="links.html"><strong aria-hidden="true">12.</strong> リンク集 10%</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linuxで学ぶx86-64アセンブリ言語</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
		    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
		      <style type="text/css">
body { counter-reset: chapter 1; }
</style>
<h1 id="前書き"><a class="header" href="#前書き">前書き</a></h1>
<h2 id="言い訳"><a class="header" href="#言い訳">言い訳</a></h2>
<p>本書はまだ執筆途中です．不完全な部分があることをお許しください．</p>
<!-- (書き進めることを優先して，内容のチェックが不十分です)． -->
<p>しかしながら，誤りの指摘や改善のためのコメントは歓迎いたします．
本書のGithubリポジトリは<a href="https://github.com/gondow/linux-x86-64-programming">こちら</a>です．</p>
<h2 id="本書の目的"><a class="header" href="#本書の目的">本書の目的</a></h2>
<p>本書は筆者（権藤克彦）が<a href="https://www.titech.ac.jp/">東京工業大学</a>の
<a href="https://educ.titech.ac.jp/cs/">情報工学系</a>で
長年担当したアセンブリ言語の授業の資料をオンライン資料として
まとめ直したものです．
Intel x86-64，Linux，GNUアセンブラを前提として「アセンブリ言語とは何か」
「具体的にどうプログラミングすればいいのか」を分かりやすくお伝えすることが目的です．</p>
<p>ただし，本書では以下は扱っていません．</p>
<ul>
<li>浮動小数点命令</li>
<li>(デバイスドライバの実装に必要な)I/O命令</li>
<li>(OSの実装に必要な)特権命令</li>
<li>MMX/SSE/AVXなどの拡張命令</li>
</ul>
<p>いや，書いてもいいのですが分量が膨大になるので面倒くさいんです．
もしOS自作に興味があるなら書籍<a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a>を強くお勧めします．</p>
<h2 id="本書で使う環境"><a class="header" href="#本書で使う環境">本書で使う環境</a></h2>
<p>本書では以下の環境を使用しています．皆さんの環境がLinuxであれば多少違っても大丈夫なはずです．</p>
<ul>
<li>Ubuntu 22.04 LTS (OS)</li>
<li>GNU gcc-11.3.0 (コンパイラ)</li>
<li>GNU binutils-2.38 (バイナリ・ユーティリティ，GNUアセンブラ<code>as</code>を含む)</li>
<li>GNU gdb-12.1 (デバッガ)</li>
</ul>
<p>デバッガはアセンブリ言語の実行結果を確認するために便利ですので，ぜひ準備して下さい．</p>
<p>しかし，WindowsやmacOSの場合は，本書の内容と大きく異なってしまいます．
アセンブリ言語は環境への依存度が高く，そのため移植性がとても低いからです．</p>
<p>皆さんのパソコンがWindowsやmacOSだった場合，Linux環境を導入する方法として以下のようないろいろな方法があります．筆者のお勧めは</p>
<ul>
<li>WindowsならWSL2を使う</li>
<li>Intel Macなら仮想マシンVirtualBoxをインストールして，Ubuntuをインストールする
(<a href="https://isapplesiliconready.com/jp/app/Virtualbox">Apple Silicon Mac用のVirtualBox</a>は2023/12/6時点でベータ版です)</li>
</ul>
<p>です．</p>
<p>Linux環境を導入する方法：</p>
<ul>
<li><a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> (Windows Subsystem for Linux 2)を使えるように設定する</li>
<li><a href="https://www.virtualbox.org/">VirtualBox</a>や
<a href="https://www.vmware.com/jp/products/fusion.html">VMWare Fusion</a>
などの仮想マシンをインストールして，その仮想マシン上に<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．</li>
<li><a href="https://www.docker.com/">Docker</a>などのコンテナ実行環境をインストールして，その上で<a href="https://www.ubuntulinux.jp/home">Ubuntu</a>などのLinuxをインストールする．既存のイメージを使っても良い．Apple Silicon Mac上のDockerで，Intel Linuxのイメージが動作可能です．</li>
<li>オンライン環境（例えば<a href="https://replit.com/">repl.it</a>）を使う．</li>
</ul>
<p>Linux環境の導入方法を書くと切りが無いので，皆さん自身でググって下さい．</p>
<p>私が使った Ubuntu 22.04 LTSには<code>gcc</code>などが未インストールなので，
以下のコマンドでインストールしました．</p>
<pre><code>$ sudo apt install build-essential
</code></pre>
<h2 id="本書のライセンス"><a class="header" href="#本書のライセンス">本書のライセンス</a></h2>
<p>Copyright (C) 2023 Katsuhiko Gondow</p>
<p>本書は<a href="https://creativecommons.org/licenses/by-nc/4.0/deed.ja">クリエイティブ・コモンズ4.0表示(CC-BY-NC 4.0)</a>で提供します．</p>
<h2 id="本書の作成公開環境"><a class="header" href="#本書の作成公開環境">本書の作成・公開環境</a></h2>
<ul>
<li>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></li>
<li>お絵かきツール <a href="https://www.drawio.com/">draw.io</a></li>
<li>公開環境 <a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></li>
</ul>
<h2 id="本書のお約束"><a class="header" href="#本書のお約束">本書のお約束</a></h2>
<h3 id="メモリの図では0番地が常に上"><a class="header" href="#メモリの図では0番地が常に上">メモリの図では0番地が常に上</a></h3>
<p>本書ではメモリの図を書く時，必ず0番地(低位アドレス)が上，
高位アドレスが下になるようにします．</p>
<img src="figs/oyakusoku-memory.svg" height="150px" id="fig:oyakusoku-memory">
<p>その結果，本書の図では「スタックは上に成長」，「ヒープは下に成長」することになります
(<a href="2-asm-intro.html#fig:memory-layout">メモリレイアウト</a>)．</p>
<h3 id="❶❷などの黒丸数字は説明用"><a class="header" href="#❶❷などの黒丸数字は説明用">❶❷などの黒丸数字は説明用</a></h3>
<p>実行結果中の❶や❷などの黒丸数字は，説明のために私が追加したものです．
実行結果の出力ではありません．
例えば，以下が例で，<code>file</code>コマンドの出力例です．
本文中の説明と実行結果のどこが対応しているのかを明示するために使います．</p>
<pre><code>$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable, x86-64, ❹version 1 (SYSV), ❺not stripped
</code></pre>
<p><a href="https://practicalbinaryanalysis.com/">Practical Binary Analysis</a>
という書籍がこうしていて便利なので真似させてもらっています．</p>
<h3 id="一部を隠してます"><a class="header" href="#一部を隠してます">一部を隠してます．</a></h3>
<p>「細かい説明」「演習問題の答え」などは<code>details</code>タグを使って隠しています．
最初は読み飛ばして構いません．読む場合は▶ボタンを押して下さい．</p>
<details>
<summary>
←このボタン(またはこの行)を押してみて下さい
</summary>
<p>これが隠されていた内容です．</p>
</details>
<h3 id="一部の図はタブ表示にしています"><a class="header" href="#一部の図はタブ表示にしています">一部の図はタブ表示にしています</a></h3>
<p>一部の図はタブ切り替えでパラパラ漫画のように表示しています．
一度に全部を表示するとゴチャゴチャする場合などに使います．
以下はタブ表示の例です．</p>
<form class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="100px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="93px" id="fig:tail-call-opt2">
    </div>
</form>
<h3 id="サンプルコードがあります"><a class="header" href="#サンプルコードがあります"><a href="https://github.com/gondow/linux-x86-64-programming/tree/main/docs/asm">サンプルコード</a>があります</a></h3>
<p><a href="https://github.com/gondow/linux-x86-64-programming/tree/main/docs/asm">サンプルコード</a>
には2種類のファイルがあります．</p>
<ul>
<li><code>*.s</code> アセンブリコード</li>
<li><code>*.txt</code> <code>gdb</code>のコマンド列が書かれたファイル</li>
</ul>
<p>これらのファイルとデバッガ<code>gdb</code>を使って機械語命令を実行・確認する方法は，
<a href="./6-inst.html#how-to-execute-x86-inst">こちら</a>に説明があります．
(サンプルコードの準備，めっちゃ大変だったので活用して頂けるととても嬉しいです)．</p>
<h3 id="説明せず擬似コードを使っている部分があります"><a class="header" href="#説明せず擬似コードを使っている部分があります">(説明せず)擬似コードを使っている部分があります</a></h3>
<p>例えば，<a href="./x86-list.html#mov-plain"><code>mov</code>命令の説明</a>では
<code>movq %rax, %rbx</code>の動作の説明として，<code>%rbx = %rax</code>と書いています．
<code>%rbx = %rax</code>はアセンブリ言語でも無くC言語でも無い，
C言語風の<strong>擬似コード</strong>(psuedo code)です．
「<code>%rax</code>レジスタの値を<code>%rbx</code>レジスタに格納する」という動作を
簡潔に表現する手段として使わせて下さい．</p>
<h2 id="本書のお断り"><a class="header" href="#本書のお断り">本書のお断り</a></h2>
<h3 id="2023105現在日本語検索に対応しました"><a class="header" href="#2023105現在日本語検索に対応しました">2023/10/5現在，<a href="https://github.com/rust-lang/mdBook/issues/2052">日本語検索</a>に対応しました．</a></h3>
<h3 id="ですます調とだである調がまざってる"><a class="header" href="#ですます調とだである調がまざってる">「ですます」調と「だである」調がまざってる</a></h3>
<p>すみません，自覚してますがとりあえず放置です．
後で統一するかも知れませんし，しないかも知れません．</p>
<h3 id="サンプルコードのインデントがおかしい"><a class="header" href="#サンプルコードのインデントがおかしい">サンプルコードのインデントがおかしい</a></h3>
<p>すみません，インデントしたコードブロック中でmdbookの#include機能を使うと
表示が狂ってしまうため，意図的にインデントしていない箇所が多々あります．</p>
<h2 id="todo"><a class="header" href="#todo">Todo</a></h2>
<ul>
<li>
<p>Intel CET対応のtigerlakeでサンプルコードを試していない．</p>
<p>デフォルトのビルドで(endbr64が無い)サンプルコードがこけるとまずい
<strong>どなたか tigerlakeのパソコンを貸して下さい😁</strong></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 2; }
</style>
<h1 id="アセンブリ言語の概要"><a class="header" href="#アセンブリ言語の概要">アセンブリ言語の概要</a></h1>
<h2 id="機械語とアセンブリ言語とは何か短い説明"><a class="header" href="#機械語とアセンブリ言語とは何か短い説明">機械語とアセンブリ言語とは何か？（短い説明）</a></h2>
<p><strong>機械語</strong>（マシン語）：</p>
<ul>
<li>CPUが直接実行できる唯一の言語．</li>
<li>機械語命令を2進数（バイナリ，数字の列）で表現．</li>
</ul>
<p><strong>アセンブリ言語</strong>：</p>
<ul>
<li>機械語を記号で表現したプログラミング言語．</li>
<li>例1：機械語命令<code>01010101</code>をアセンブリ言語では<code>pushq %rbp</code>という記号（<strong>ニモニック</strong>，mnemonic）で表す（x86-64の場合，以下同様）．</li>
<li>例2：メモリのアドレス<code>1000</code>番地をアセンブリ言語では<code>add5</code>などの記号（<strong>ラベル</strong>）で表す．</li>
</ul>
<img src="figs/machine-asm.svg" height="150px" id="fig:machine-asm">
<details>
<summary>
pushq %rbpとは
</summary>
<p>「レジスタ<code>%rbp</code>中の値をスタックにプッシュする」という命令です．
<a href="2-asm-intro.html#push-rbp-pop-rbp">ここ</a>で説明します．</p>
</details>
<p>2進数の機械語命令と，機械語命令のニモニックは概ね，1対1に対応しており，
機械的に変換できます．ただし，その変換方法を覚える必要はありません．
<a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブル</a>や<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>してくれる
コマンド（プログラム）にやってもらえばいいのです．</p>
<p>ただ，アセンブリ言語の仕組みを理解するには，オブジェクトファイル<code>*.o</code>や
実行可能ファイル<code>a.out</code>の中身や仕組みを理解する必要があるため，
<a href="./3-binary.html">バイナリファイル</a>の節では説明が多くなっています．</p>
<h2 id="逆アセンブル"><a class="header" href="#逆アセンブル">機械語とアセンブリ言語の具体例（逆アセンブル）</a></h2>
<p>まず以下の簡単なCのプログラム<code>add5.c</code>を用意して下さい．</p>
<p id="add5.c">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<p><code>add5.c</code>を<code>gcc -c</code>で処理すると，
<strong>オブジェクトファイル</strong><code>add5.o</code>ができます．
この<code>add5.o</code>に対して<code>objdump -d</code>を実行すると，
<strong>逆アセンブル</strong>(disassemble)した結果が表示されます．</p>
<pre><code class="language-bash">$ gcc -c add5.c
$ ls
add5.c  add5.o
$ objdump -d add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 05             	add    $0x5,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<p>逆アセンブルとは，<code>a.out</code>や<code>*.o</code>中の機械語命令を
アセンブリ言語のニモニック表現に変換することです．
上の実行例で，左側に機械語命令，右側にニモニックが表示されています．
(一番左側の数字は，<a href="./3-binary.html#.text"><code>.text</code>セクション</a>の先頭からのバイト数（16進表記）です）．
例えば，4バイト目にある<code>55</code>は機械語命令（を16進数で表記したもの），
<code>55</code>の右側の<code>push %rbp</code>が，<code>55</code>に対応するニモニックです．
16進数を使っているのは，2進数で表記すると長くなるからです．</p>
<h2 id="cコードをアセンブリコードにコンパイルする"><a class="header" href="#cコードをアセンブリコードにコンパイルする">Cコードをアセンブリコードにコンパイルする</a></h2>
<p><a href="2-asm-intro.html#add5.c"><code>add5.c</code></a>に対して，
以下のコマンドを実行して，<code>add5.s</code>を作成して下さい．
これで「アセンブリ言語で書かれたプログラム（アセンブリコード）」がどんなものかを見れます．</p>
<pre><code class="language-bash">$ gcc -S add5.c
$ ls
add5.c  add5.s
</code></pre>
<!-- ![gcc-S](figs/gcc-S.svg) -->
<img src="figs/gcc-S.svg" height="70px" id="fig:gcc-S">
<p><code>-S</code>オプションをつけて処理すると，
<code>gcc</code>はCのプログラム(<code>add5.c</code>)からアセンブリコード(<code>add5.s</code>)を生成します．
この処理を「狭義のコンパイル」と呼びます
（<a href="./3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">広義のコンパイル</a>はCのプログラムから実行可能ファイル(<code>a.out</code>)を
生成する処理を指します）．
<code>gcc -S</code>は「コンパイラ」と呼ばれます．コンパイルするコマンドだからです．</p>
<p><code>add5.s</code>の中身は例えば以下となります．</p>
<blockquote>
<p>注意：
gccのバージョンの違いにより，同じLinuxでも<code>add5.s</code>の中身が以下と異なることがあります．</p>
</blockquote>
<p>以下では表示が長いので省略しています．
全てを表示するには右にある<i class="fa fa-eye"></i>ボタンを押して下さい．
（ここでは<code>add5.s</code>の中身は理解できなくてOKです）．</p>
<pre><code class="language-bash">$ cat add5.s
        .file   &quot;add5.c&quot;
        .text
        .globl  add5
        .type   add5, @function
add5:
.LFB0:
        .cfi_startproc
        endbr64
        pushq   %rbp
<span class="boring">        .cfi_def_cfa_offset 16
</span><span class="boring">        .cfi_offset 6, -16
</span><span class="boring">        movq    %rsp, %rbp
</span><span class="boring">        .cfi_def_cfa_register 6
</span><span class="boring">        movl    %edi, -4(%rbp)
</span><span class="boring">        movl    -4(%rbp), %eax
</span><span class="boring">        addl    $5, %eax
</span><span class="boring">        popq    %rbp
</span><span class="boring">        .cfi_def_cfa 7, 8
</span><span class="boring">        ret
</span><span class="boring">        .cfi_endproc
</span><span class="boring">.LFE0:
</span><span class="boring">        .size   add5, .-add5
</span><span class="boring">        .ident  &quot;GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0&quot;
</span><span class="boring">        .section        .note.GNU-stack,&quot;&quot;,@progbits
</span><span class="boring">        .section        .note.gnu.property,&quot;a&quot;
</span><span class="boring">        .align 8
</span><span class="boring">        .long   1f - 0f
</span><span class="boring">        .long   4f - 1f
</span><span class="boring">        .long   5
</span><span class="boring">0:
</span><span class="boring">        .string &quot;GNU&quot;
</span><span class="boring">1:
</span><span class="boring">        .align 8
</span><span class="boring">        .long   0xc0000002
</span><span class="boring">        .long   3f - 2f
</span><span class="boring">2:
</span><span class="boring">        .long   0x3
</span><span class="boring">3:
</span><span class="boring">        .align 8
</span><span class="boring">4:
</span></code></pre>
<p>このうち実行に関係する部分だけを残したアセンブリコードが以下になります．</p>
<p id="add5.s">
<pre><code class="language-x86asmatt"># add5.s
    .text
    .globl add5
    .type add5, @function
add5:
    pushq %rbp
    movq  %rsp, %rbp
    movl  %edi, -4(%rbp)
    movl  -4(%rbp), %eax
    addl  $5, %eax
    popq  %rbp
    ret
    .size  add5, .-add5
</code></pre>
</p>
<p>各行の意味は<a href="2-asm-intro.html#add5.s-content">次の次の節</a>で説明しますが，
ちょっとだけ説明します．</p>
<ul>
<li><code>.text</code>などドット<code>.</code>で始まる命令は<strong>アセンブラ命令</strong>です</li>
<li><code>add5:</code>など名前の後ろにコロン<code>:</code>があるものは<strong>ラベルの定義</strong>です</li>
<li><code>%rbp</code>など，パーセント<code>%</code>で始まるものは<strong>レジスタ</strong>です</li>
<li><code>$5</code>など，ドル<code>$</code>で始まるものは定数(<strong>即値</strong>)です．</li>
<li><code>addl $5, %eax</code>は「レジスタ<code>%eax</code>の値と定数の5を足し算した結果を
<code>%eax</code>レジスタに格納する」という動作を行う<strong>機械語命令</strong>です</li>
<li><code>#</code>から行末までは<strong>コメント</strong>です</li>
</ul>
<details>
<summary>
AT&T形式とIntel形式とは
</summary>
<p>x86-64用のアセンブラには本書で扱うGNUアセンブラ以外にも，
<a href="https://github.com/netwide-assembler/nasm">NASM</a> (netwide assembler)などいくつかあり，
困ったことにアセンブリ言語の表記が異なります．
この表記方法には大きく2種類：<strong>AT&amp;T形式</strong>と<strong>Intel形式</strong>があります．
本書で扱うGNUアセンブラはAT&amp;T形式，NASMや<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>はIntel形式を使っています．</p>
<p>一番大きな違いは機械語命令の引数(<strong>オペランド</strong>といいます)の順番です．</p>
<ul>
<li>AT&amp;T形式は「左から右へ」，つまり代入先のオペランドを右に書きます</li>
<li>Intel形式は「右から左へ」，つまり代入先のオペランドを左に書きます</li>
</ul>
<img src="figs/att-intel.svg" height="100px" id="fig:att-intel">
<p>他にもAT&amp;T形式には<code>%</code>や<code>$</code>がつくなど，細かい違いがあります．
<a href="./7-asm.html#att-intel">ここ</a>で詳しく説明します．</p>
<p>なお，<code>gcc</code>に<code>-S -masm=intel</code>とオプションを設定すると，
出力されるアセンブリコードをIntel形式に変更できます．</p>
<pre><code class="language-bash">$ gcc -S -masm=intel add5.c
</code></pre>
<pre><code class="language-x86asm">        .intel_syntax noprefix
        .text
        .globl  add5
        .type   add5, @function
add5:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR -4[rbp], edi
        mov     eax, DWORD PTR -4[rbp]
        add     eax, 5
        pop     rbp
        ret
        .size   add5, .-add5
</code></pre>
<p>(<code>DWORD</code>は4バイト (double word)を意味しています)</p>
</details>
<p>なお，消した行の説明を以下に書きますが，読み飛ばしてOKです．</p>
<details>
<summary>
.cfi_とは
</summary>
<p><code>.cfi</code>で始まるもの（アセンブラ命令）は call frame information を扱う命令です．
本書の範囲では不要です．詳細は<a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a>を参照下さい．</p>
</details>
<details>
<summary>
.fileと.identとは
</summary>
<p><code>.file</code>と<a href="./7-asm.html#ident"><code>.ident</code></a>はコメントとほぼ同じで，実行には関与しません．</p>
</details>
<details>
<summary>
.section .note.とは
</summary>
<p>以下の2つはセキュリティ上，実際には重要です（本書では消してしまいますが）．</p>
<ul>
<li><code>.section .note.GNU-stack,&quot;&quot;,@progbits</code>はスタック上の機械語命令を実行不可と指定しています．</li>
<li><code>.section .note.gnu.property,&quot;a&quot;</code>はIntel CETというセキュリティ技術の一部である IBT (indirect branch tracking)と SHSTK (shadow stack) のための指示です．</li>
</ul>
</details>
<details>
<summary>
endbr64とは
</summary>
<p><code>endbr64</code>もセキュリティ上，重要です．
間接ジャンプは脆弱性の大きな原因です．
<code>endbr64</code>はセキュリティ技術であるIntel CET技術の命令であり，
間接ジャンプ先の命令が<code>endbr64</code>以外の時は実行エラーとする，というものです．
本書の学習者としては「<code>endbr64</code>はセキュリティ上，重要だけど，アセンブリ言語を学習する立場では「<code>endbr64</code>は<code>nop</code>命令(何も実行しない命令)」と思えば十分です．</p>
</details>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>の各行の意味の<a href="2-asm-intro.html#add5.s-content">説明</a>の前に，説明の都合上，
<strong>アセンブル</strong>と<strong>アセンブラ</strong>を説明します．</p>
<h2 id="アセンブル"><a class="header" href="#アセンブル">アセンブリコードをオブジェクトファイルにアセンブルする</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>に対して，以下のコマンドを実行すると，
<code>add5.o</code>が生成されます．この処理を<strong>アセンブル</strong>(assemble)といいます．
そして，アセンブルを行うプログラム（コマンド）を
<strong>アセンブラ</strong>(assembler)と呼びます．
<code>gcc -c</code>は内部的にアセンブラ<code>as</code>を呼び出します．
<code>as</code>は本書で使用する<a href="https://sourceware.org/binutils/docs-2.40/as/index.html">GNUアセンブラ</a>のコマンド名です．</p>
<pre><code class="language-bash">$ gcc -c add5.s
$ ls
add5.c add5.o add5.s
</code></pre>
<img src="figs/assemble.svg" height="50px" id="fig:assemble">
<p>アセンブル処理は<a href="2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>とちょうど逆の関係です．
(逆アセンブルは，バイナリから機械語命令のニモニックを復元しますが，
アセンブラ命令やラベルやコメントは復元できません．
ですので，完全な逆の関係ではありません．)</p>
<img src="figs/assemble2.svg" height="70px" id="fig:assemble2">
<p><code>add5.o</code>はバイナリファイルです．
また，<code>add5.o</code>から作成する実行可能ファイル<code>a.out</code>もバイナリファイルです．
バイナリ(の中身)については次の章，<a href="./3-binary.html">3節.バイナリ</a>で説明します．</p>
<h2 id="add5.s-content"><a class="header" href="#add5.s-content">アセンブリ言語の構成要素</a></h2>
<p><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>はアセンブリ言語のプログラムであり，
<strong>アセンブリコード</strong> (assembly code)と呼びます．
アセンブリコードは以下の4つを組み合わせて書きます．</p>
<ul>
<li>機械語命令 (例：<code>pushq %rbp</code>)</li>
<li>アセンブラ命令 (例：<code>.text</code>)</li>
<li>ラベル定義 (例：<code>add5:</code>)</li>
<li>コメント (例：<code># add5.s</code>)</li>
</ul>
<p>特に<strong>機械語命令</strong>(machine instruction)と<strong>アセンブラ命令</strong>(assembler directive)
の違いに注意して下さい．</p>
<ul>
<li>
<p>機械語命令はCPUが実行する命令です．
例えば，<code>pushq %rbp</code>は機械語命令(のニモニック)です．
この<code>pushq %rbp</code>は<code>a.out</code>が実行された時に<strong>CPUが</strong>実行します．</p>
<p>一方，アセンブラがすることは例えば
<code>add5.s</code>中の<code>pushq %rbp</code>という機械語命令のニモニックを
<code>0x55</code>という2進数(ここでは16進数表記)に変換して，<code>add5.o</code>に出力するだけです．
アセンブラは<code>pushq %rbp</code>という機械語命令を実行しません．
アセンブラにとって，<code>pushq %rbp</code>も<code>0x55</code>も両方とも単なるデータに過ぎないのです．</p>
</li>
<li>
<p>アセンブラ命令はアセンブラが実行する命令です．
例えば，<code>.text</code>はアセンブラ命令です．
本書が使用するGNUアセンブラではドット記号<code>.</code>で始まる命令は全てアセンブラ命令です．</p>
<p><a href="2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">アセンブラ</a>は<code>add5.s</code>から<code>add5.o</code>を出力（アセンブル）します．
そのアセンブラに対して行う指示がアセンブラ命令です．
例えば，<code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」を
アセンブラに指示しています．
アセンブラはアセンブル時に<code>.text</code>というアセンブラ命令を実行します
(CPUが<code>a.out</code>を実行するときではありません）．</p>
</li>
</ul>
<h2 id="アセンブリ言語は1行に1つが基本"><a class="header" href="#アセンブリ言語は1行に1つが基本">アセンブリ言語は1行に1つが基本</a></h2>
<p>アセンブリ言語は基本的に1行に1つだけ，
「機械語命令」「アセンブラ命令」「ラベル定義」「コメント」
のいずれかを書くのが基本です．
ただし，複数を組み合わせて1行にできる場合もあります．
以下に可能な例を示します．
(正確な定義は<a href="./7-asm.html#gas-syntax">GNUアセンブラの文法</a>を参照下さい)．</p>
<ul>
<li>OK <code>add5: pushq %rbp</code>   (ラベル定義と機械語命令)</li>
<li>OK <code>pushq %rbp; movq %rsp, %rbp</code>   (機械語命令と機械語命令，セミコロン<code>;</code>で区切る)</li>
<li>OK <code>pushq %rbp  # コメント</code> (機械語命令とコメント)</li>
<li>OK <code>.text  # コメント</code> (アセンブラ命令とコメント)</li>
</ul>
<h2 id="add5s中の-add5s"><a class="header" href="#add5s中の-add5s"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code># add5.s</code></a></h2>
<p><code># add5.s</code>は<code>gcc -S</code>の出力ではなく，私が付け加えた行です．
この行は<strong>コメント</strong>です．<code>#</code>から行末までがコメントとなり，
アセンブラは単にコメントを無視します．
つまりコメントは(C言語のコメントと同じで)人間が読むためだけのものです．</p>
<h2 id="add5s中のtext"><a class="header" href="#add5s中のtext"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>.text</code></a></h2>
<p><code>.text</code>は「出力先を<code>.text</code><a href="./3-binary.html#.text">セクション</a>にせよ」と
アセンブラに指示しています．
<a href="./3-binary.html#.text">セクション</a>でも説明しますが，
<code>add5.o</code>や<code>a.out</code>などのバイナリファイルの中身は<strong>セクション</strong>という単位で
区切られています．
このため，アセンブラが機械語やデータを2進数に変換して出力する時，
「どのセクションに出力するのか」の指定が必要となるのです．</p>
<p><code>.text</code>セクション以外には，代表的なセクションとして，
<code>.data</code>セクション，<code>.rodata</code>セクションがあります．
それぞれの役割は以下の通りです．</p>
<ul>
<li><code>.text</code>    機械語命令(例：<code>pushq %rbp</code>)を置くセクション</li>
<li><code>.data</code>    初期化済みの静的変数の値(例：<code>0x1234</code>)を置くセクション</li>
<li><code>.rodata</code>  読み込みのみ(read only)の値(例：<code>&quot;hello\n\0&quot;</code>)を置くセクション</li>
</ul>
<p>例えば，以下のアセンブリコード<code>foo.s</code>があるとします
(<code>.rodata</code>セクションを指定する際は，<code>.section</code>が必要です)．</p>
<pre><code class="language-x86asmatt"># foo.s
.text            # .textセクションに出力せよ
pushq %rbp
movq %rsp, %rbp
.data            # .dataセクションに出力せよ
.long 0x11223344
.section .rodata # .rodataセクションに出力せよ
.string &quot;hello\n&quot;
</code></pre>
<p>この<code>foo.s</code>をアセンブラが処理すると以下になります(以下の図を見ながら読んで下さい)．</p>
<ul>
<li>
<p><code>pushq %rbp</code>を2進数にすると <code>0x55</code>，
<code>movq %rsp, %rbp</code>を2進数にすると <code>0x48 0x89 0xe5</code> なので，
これら合計4バイトを<code>.text</code>セクションに出力します．</p>
</li>
<li>
<p><code>.data</code>は「<code>.data</code>セクションに出力せよ」
<code>.long</code>は「指定したデータを4バイトの2進数として出力せよ」という意味です．
<code>0x11223344</code>を2進数にすると <code>0x44 0x33 0x22 0x11</code>なので
これら4バイトを<code>.data</code>セクションに出力します．
(出力が逆順になっているように見えるのは
x86-64が<a href="4-data.html#%E3%83%90%E3%82%A4%E3%83%88%E3%82%AA%E3%83%BC%E3%83%80%E3%81%A8%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>だからです．)</p>
</li>
<li>
<p><code>.section .rodata</code>は「<code>.rodata</code>セクションに出力せよ」
<code>.string</code>は「指定した文字列をASCIIコードの2進数として出力せよ」という意味です．
<code>&quot;hello\n&quot;</code>を2進数にすると <code>0x68 0x65 0x6c 0x6c 0x64 0x0a 0x00</code>なので，
これら7バイトを<code>.rodata</code>セクションに出力します．
(最後の'\0'はヌル文字です．C言語では文字列定数の最後に自動的に
ヌル文字が追加されますが，アセンブリ言語では必ずしもそうではありません．
<code>.string</code>はヌル文字を追加します．
一方，(ここでは使っていませんが)<code>.ascii</code>はヌル文字を追加しません)．
<a href="./4-data.html#ASCII">ASCIIコード</a>は<code>man ascii</code>で確認できます．</p>
</li>
</ul>
<img src="figs/section2.svg" height="200px" id="fig:section2">
<details>
<summary>
.bssセクションは?
</summary>
<p><code>.text</code>，<code>.data</code>，<code>rodata</code>に加えて，<code>.bss</code>セクションも代表的なセクションですが，
ここでは説明を省略しました．
<a href="./3-binary.html#.bss"><code>.bss</code>セクション</a>は未初期化の静的変数の実体を格納するセクションなのですが，
ちょっと特殊だからです．
未初期化の静的変数はゼロで初期化されることになっているので，
バイナリファイル中では(サイズの情報等をのぞいて)実体は存在しません．
プログラム実行時に初めてメモリ上で<code>.bss</code>セクションの実体が確保され，
その領域はゼロで初期化されます．</p>
</details>
<h2 id="add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a class="header" href="#add5s中のadd5globl-add5type-add5-functionsize-add5--add5"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>add5:</code>，<code>.globl add5</code>，<code>.type add5, @function</code>，<code>.size add5, .-add5</code></a></h2>
<h3 id="add5はラベルの定義"><a class="header" href="#add5はラベルの定義"><code>add5:</code>はラベルの定義</a></h3>
<p><code>add5:</code>は<code>add5</code>というラベルを定義しています．
ラベルはアドレスを表しています．
もっと具体的には「ラベルは，そのラベル直後の機械語命令や値が，
メモリ上に配置された時のアドレス」になります．</p>
<p>例えば，次のアセンブリコードがあり，</p>
<pre><code class="language-x86asmatt">add5:
    pushq %rbp 
</code></pre>
<p>この<code>pushq %rbp</code>命令の2進数表現<code>0x55</code>が<code>0x1234</code>番地に置かれたとします．</p>
<img src="figs/label.svg" height="150px" id="fig:label">
<p>この時，ラベル<code>add5</code>の値は<code>0x1234</code>になります．
（ここでは話を単純化しています．ラベルの値が最終的に決まるまで，
<a href="./3-binary.html#relocation">再配置</a>(relocation)などの処理が入ります）</p>
<h3 id="ラベルの参照"><a class="header" href="#ラベルの参照">ラベルの参照</a></h3>
<p>で，大事なラベルの使い方（参照）です．
機械語命令のニモニック中で，<strong>アドレスを書ける場所にはラベルも書ける</strong>のです．
例えば，関数をコールする命令<code>call</code>命令で<code>add5</code>関数を呼び出す時，
以下の2行はどちらも同じ意味になります．
ラベル<code>add5</code>の値は<code>0x1234</code>になるからです．
（ここでも話を単純化しています．関数や変数のアドレスは
絶対アドレスではなく，相対アドレスなどが使われることがあるからです）．</p>
<pre><code class="language-x86asmatt">    call 0x1234
    call add5    
</code></pre>
<p>どちらの書き方でも，アセンブラのアセンブル結果は同じになります．
（もちろん通常はラベルを使います．具体的なアドレスを使って
アセンブリコードを書くのは人間にとってはつらいからです）．</p>
<h3 id="記号表がラベルを管理する"><a class="header" href="#記号表がラベルを管理する">記号表がラベルを管理する</a></h3>
<p>アセンブラはラベルのアドレスが何番地になるかを管理するために，
アセンブル時に<strong>記号表</strong>(symbol table)を作ります．
記号表中の情報は割と単純で，主に以下の6つです．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレス</th><th>配置される<br/>セクション</th><th>グローバル<br/>か否か</th><th>型</th><th>サイズ</th><th>ラベル名<br/>(シンボル名)</th></tr></thead><tbody>
<tr><td><code>0x1234</code></td><td><code>.text</code></td><td>グローバル</td><td>関数</td><td>15</td><td><code>add5</code></td></tr>
</tbody></table>
</div>
<p>ここで，<a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>のラベル<code>add5</code>が</p>
<ul>
<li>配置されるセクションが<code>.text</code>なのは，ラベルの定義<code>add5:</code>の前に<code>.text</code>が指定されているから</li>
<li>グローバルなのは，<code>.globl add5</code>と指定されているから</li>
<li>関数という型なのは，<code>.type add5, @function</code>と指定されているから</li>
<li>サイズが15バイトなのは，<code>.size  add5, .-add5</code>と指定されているから
(サイズ15バイトは<code>.-add5</code>から<a href="./7-asm.html#dot-label">自動計算</a>されます)</li>
</ul>
<p>です．
ここでグローバルの意味は，C言語のグローバル関数やグローバル変数と(ほぼ)同じです．
グローバルなシンボルは他のファイルからも参照できます．</p>
<details>
<summary>
ラベル or シンボル？
</summary>
<p>アセンブラが扱うシンボルのうち，アドレスを表すシンボルのことをラベルと呼んでいます．
シンボルはアドレス以外の値も保持できます．
つまりシンボルの一部がラベルであり，<code>add5</code>は関数<code>add5</code>の先頭アドレスを表すシンボルなのでラベルです．</p>
</details>
<details>
<summary>
.-add5 とは
</summary>
<p><code>.-add5</code>はアドレスの引き算をしています．<code>.</code>は特別なラベルで「この行のアドレス」を意味します．<code>add5</code>は<code>add5:</code>のアドレスを意味します．
ですので，<code>.-add5</code>は「最後の<code>ret</code>命令の次のアドレスから，
最初の<code>pushq %rbp</code>命令のアドレスを引いた値」になります．
つまり引き算の結果は「関数<code>add5</code>中の機械語命令の合計サイズ（単位はバイト）」です．</p>
</details>
<p><a href="./3-binary.html#nm"><code>nm</code>コマンド</a>を使うと記号表の中身を表示できます．</p>
<pre><code class="language-bash">$ nm ./a.out |egrep add5
0000000000001234 T add5
</code></pre>
<p>大文字<code>T</code>は「<code>.text</code>中のグローバルシンボル」であることを意味しています．
（小文字<code>t</code>だと「<code>.text</code>中のグローバルではないシンボル」という意味になります）．
この<code>nm</code>の出力では「<code>add5</code>が関数」という情報とサイズが表示できていません．
<code>readelf</code>コマンドを使うと，❶関数であることとサイズが❷15バイトであることを表示できます．</p>
<pre><code class="language-bash">$ readelf -s ./a.out | egrep add5
     1: 0000000000001234    ❷15 ❶FUNC    GLOBAL DEFAULT    1 add5
</code></pre>
<details>
<summary>
readelfコマンドとは
</summary>
<p><code>objdump</code>は汎用のコマンド（ELFバイナリ以外のバイナリにも使える）ため，
<a href="./3-binary.html#ELF">ELF</a>特有の情報を表示できないことがあります．
ELF専用のコマンドである<code>readelf</code>を使えば，ELF特有の情報も表示できます．
例えば，以下では<code>readelf</code>を使って記号表(❶<code>.symtab</code>)のセクションがあることを確認できました．</p>
<pre><code class="language-bash">$ readelf -S add5.o セクションヘッダを表示
There are 12 section headers, starting at offset 0x258:
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000013  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
（中略）↓これが記号表 (symbol table)
  [ 9]❶.symtab           SYMTAB           0000000000000000  000000d8
       00000000000000f0  0000000000000018          10     9     8
</code></pre>
</details>
<h2 id="stack-frame"><a class="header" href="#stack-frame"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の<code>pushq %rbp</code>，<code>movq  %rsp, %rbp</code>，<code>popq  %rbp</code></a></h2>
<h3 id="movq-rsp-rbp"><a class="header" href="#movq-rsp-rbp"><code>movq %rsp, %rbp</code></a></h3>
<p><code>%rsp</code>と<code>%rbp</code>はどちらも<strong>レジスタ</strong>です．
(GNUアセンブラではレジスタの名前の先頭に必ず<code>%</code>が付きます)．
レジスタはCPU内の高速なメモリです．CPUはメモリにアクセスするよりも，
はるかに高速にレジスタにアクセスできます．
<code>%rsp</code>と<code>%rbp</code>はどちらも8バイト長のデータを格納できます．</p>
<p><code>movq %rsp, %rbp</code>という機械語命令は
「<code>%rsp</code>レジスタの値を<code>%rbp</code>にコピーする」という命令です．
<code>movq</code>のmovは「move (移動)」，qは「処理するサイズが8バイト」であることを意味しています．
(moveといいつつ，実行内容はコピーです．<code>%rsp</code>に古い値が残るからです．)</p>
<details>
<summary>
なぜqが8バイト?
</summary>
<p>qはクアッドワード(quad word)の略だからです．
以下の通り，クワッドワードは「ワード2バイトの4個分」なので8バイトになります．</p>
<ul>
<li><strong>ワード</strong>(word)は<strong>バイト</strong>(byte)と同様に情報量の単位ですが，
ワードが何バイトかはCPUごとに異なります．
x86-64ではワードは2バイトです．
x86の元祖であるIntel 8086が16ビットCPUだったことに由来します．</li>
<li><strong>クアッド</strong>(quad)は4を意味します．
例えば，quadrupleは「4倍の」，quad bikeは「4輪バイク」を意味します．</li>
</ul>
</details>
<p>仮に<code>movq %rsp, %rbp</code>を実行する前に，
<code>%rsp</code>の値が<code>0x11223344</code>，<code>%rbp</code>の値が<code>0x55667788</code>とします．
<code>movq %rsp, %rbp</code>を実行すると，
<code>%rsp</code>の値が<code>%rbp</code>にコピーされるので，
<code>%rsp</code>の値も<code>%rbp</code>の値も<code>0x11223344</code>になります．
要するに，<code>movq</code>命令はC言語の代入文と同じです．</p>
<img src="figs/rsp-rbp.svg" height="150px" id="fig:rsp-rbp">
<h3 id="push-rbp-pop-rbp"><a class="header" href="#push-rbp-pop-rbp"><code>pushq %rbp</code>と<code>popq  %rbp</code></a></h3>
<p><code>pushq %rbp</code>は「スタックに<code>%rbp</code>の値を<strong>プッシュ</strong>する」機械語命令です．
以下の図のように，<code>%rbp</code>中の値をスタックの一番上にコピーします．
スタックはコピー先の部分を含めて上に成長します（赤枠の部分がスタック全体）．</p>
<img src="figs/push-rbp.svg" height="200px" id="fig:push-rbp">
<p><code>popq %rbp</code>は「スタックから<strong>ポップ</strong>した値を<code>%rbp</code>に格納する」という機械語命令です．
以下の図のように，スタックの一番上の値を<code>%rbp</code>にコピーします．
スタックはコピー元の部分だけ下に縮みます（赤枠の部分がスタック全体）．</p>
<img src="figs/pop-rbp.svg" height="200px" id="fig:pop-rbp">
<p>これだけだと，<code>pushq %rbp</code>や<code>popq %rbp</code>の役割がよく分かりませんね．
実はこの2つの命令は以下で説明する<strong>スタックフレーム</strong>の処理に関係しています．</p>
<h3 id="データ構造としてのスタック"><a class="header" href="#データ構造としてのスタック">データ構造としてのスタック</a></h3>
<p><strong>スタック</strong>(stack)は超基本的なデータ構造であり，
以下の図の通り，<strong>プッシュ操作</strong>と<strong>ポップ操作</strong>でデータの格納と取り出しを行います．</p>
<ul>
<li>プッシュはスタックの一番上にデータを格納します</li>
<li>ポップはスタックの一番上からデータを取り出します</li>
</ul>
<img src="figs/stack.svg" height="200px" id="fig:stack">
<p>最後に格納したデータが，取り出す時は先に取り出されるので，
<strong>後入れ先出し方式</strong>(LIFO: last in first out)とも呼ばれます．</p>
<p>スタックは関数呼び出しの実装に便利なデータ構造です．
関数呼び出しからリターンするときは，呼び出された順番とは逆順にリターンするからです．</p>
<details>
<summary>
キューqueueは?
</summary>
<p>ちなみに超基本的なデータ構造として<strong>キュー</strong>(queue)も重要です．
こちらは先に格納したデータが，先に取り出されるので
<strong>先入れ先出し方式</strong>(FIFO: first in first out)になります．</p>
</details>
<h3 id="スタックとスタックフレーム"><a class="header" href="#スタックとスタックフレーム">スタックとスタックフレーム</a></h3>
<p><strong>スタック</strong>とはプロセス（実行中のプログラム）が使用するメモリの領域の1つです．
ここでのスタックは関数呼び出しのためのスタックなので，
<strong>コールスタック</strong>(call stack)と呼ぶのが正式名称なのですが，
慣習に習って本書でも単にスタックと呼びます．</p>
<img src="figs/memory-layout.svg" height="300px" id="fig:memory-layout">
<p>関数を呼び出すと，<strong>スタックフレーム</strong>というデータがスタックに追加(プッシュ)されて，
スタックは上に成長します．その関数からリターンすると，
そのスタックフレームはスタックから削除(ポップ)されて縮みます．
スタックフレームは<strong>関数呼び出し1回分のデータ</strong>で，
局所変数，引数，返り値，戻り番地(リターンアドレス)，退避したレジスタの値などを含みます．</p>
<p>例えば，<code>main</code>関数が<code>add5</code>関数を呼び出して，<code>add5</code>からリターンすると以下の図になります．</p>
<img src="figs/stack-frame.svg" height="200px" id="fig:stack-frame">
<h3 id="stack-rsp-rbp"><a class="header" href="#stack-rsp-rbp"><code>%rsp</code>と<code>%rbp</code>は一番上のスタックフレームの上下を指す</a></h3>
<p>さて，ここでようやく<code>%rsp</code>レジスタと<code>%rbp</code>レジスタの出番です．
実は<code>%rsp</code>と<code>%rbp</code>は以下の図のように，
<strong>スタック上の一番上のスタックフレームの上下</strong>を指す役割を担っています．</p>
<img src="figs/stack-frame2.svg" height="200px" id="fig:stack-frame2">
<p>「レジスタがスタックを指す」というのは具体的に以下の図の状態です．
つまり，
スタックフレームの一番上のアドレス(例えば<code>0x11223344</code>)が
<code>%rsp</code>に入っていて，<code>%rsp</code>の値をそのアドレスとして使う意図がある場合，
「<code>%rsp</code>はスタックフレームの一番上を指す」と言い，
<a href="2-asm-intro.html#fig:stack-frame2">上の図</a>のように矢印で図表現します．
(<code>%rbp</code>も同様です)</p>
<img src="figs/stack-frame3.svg" height="170px" id="fig:stack-frame3">
<h3 id="stack-frame4"><a class="header" href="#stack-frame4"><code>%rsp</code>は常にスタックの一番上を指す</a></h3>
<p><code>pushq</code>命令で
プッシュすると<code>%rsp</code>はプッシュしたデータの一番上を指すようにずれるので，
<code>%rsp</code>は常にスタックの一番上(スタックトップ)を指します．
また，<code>%rbp</code>をプッシュしたので下図のように
プッシュした値もスタックフレームの一番下を指しています．</p>
<img src="figs/push-rbp-2.svg" height="120px" id="fig:push-rbp-2">
<p>同様に<code>popq</code>命令でポップした時はポップで取り出したデータ分だけ
<code>%rsp</code>が指す先は下にずれて，やはり<code>%rsp</code>はスタックトップを指します．
下図では保存した<code>%rbp</code>の値をポップして<code>%rbp</code>に格納したので，
この時だけ「ひとつ下のスタックフレームの一番下」を<code>%rbp</code>は指しています
(が，通常，この直後にリターンして一番上のスタックフレームは破棄されます．
ですので，すぐに「<code>%rsp</code>と<code>%rbp</code>は常に一番上のスタックフレームの上下を指す」
という状態に戻ります．)</p>
<img src="figs/pop-rbp-2.svg" height="150px" id="fig:pop-rbp-2">
<h3 id="create-new-stack-frame"><a class="header" href="#create-new-stack-frame"><code>pushq %rbp</code> と <code>movq %rsp, %rbp</code> は新しいスタックフレームを作る</a></h3>
<p>関数を呼び出すと，その関数のための新しくスタックフレームを作る必要があります．
誰が作るのかというと「呼び出された関数自身」が作ります(これは<a href="./3-binary.html#ABI">ABI</a>が定める事項です)．</p>
<p>ここでは関数<code>main</code>が関数<code>add5</code>を<code>call</code>命令で呼び出すとして説明します．</p>
<pre><code class="language-x86asmatt">main:
   ...
   call add5
</code></pre>
<pre><code class="language-x86asmatt">add5:
   pushq %rbp
   movq %rsp, %rbp
</code></pre>
<p>これらの命令を実行した時のスタックの様子は以下の図のとおりです．
(「<code>call</code>前」等のボタンを押して，図を切り替えて下さい)</p>
<form class="tab-wrap">
    <input id="stack-frame4-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame4-1"><code>call</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-1.svg" height="150px" id="fig:stack-frame4-1">
    </div>
    <input id="stack-frame4-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-2"><code>call</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-2.svg" height="150px" id="fig:stack-frame4-2">
    </div>
    <input id="stack-frame4-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-3"><code>push %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-3.svg" height="150px" id="fig:stack-frame4-3">
    </div>
    <input id="stack-frame4-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame4-4"><code>movq %rsp, %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
    </div>
</form>
<p>一つずつ説明していきます．</p>
<ul>
<li><code>call</code>命令実行前は<code>main</code>関数が一番上のスタックフレームです．
その上下を<code>%rsp</code>と<code>%rbp</code>が指しています．</li>
<li><code>call</code>命令を実行して<code>add5</code>関数に実行を移す際に，
<code>call</code>命令はスタック上に<strong>戻り番地</strong>(リターンアドレス)をプッシュします．
戻り番地とは「関数からリターンした時にどのアドレスに実行を戻せばよいか」
　を表す番地です．この場合では<code>call add5</code>命令の次のアドレスが戻り番地になります．</li>
<li><code>push %rbp</code>命令を実行すると，今の<code>%rbp</code>レジスタの値をスタック上にプッシュします．
<a href="2-asm-intro.html#fig:push-rbp-2">上</a>の説明と見比べて下さい．
新しいスタックフレームを作る際に，<code>%rbp</code>に新しい値を設定する必要があるために，
今の<code>%rbp</code>の値をスタック上に退避（保存）するため，<code>pushq %rbp</code>が必要となります．</li>
<li>次に <code>movq %rsp, %rbp</code> を実行します．
実は<code>add5</code>のスタックフレームはとても小さくて「古い<code>%rbp</code>」しか入っていません．
ですので，<code>%rsp</code>の値を<code>%rbp</code>にコピーすれば，
「<code>add5</code>のスタックフレームの上下を<code>%rsp</code>と<code>%rsp</code>が指している」という状態にできます．
この動作も<a href="2-asm-intro.html#movq-rsp-rbp">上</a>で説明したので見比べて下さい．</li>
</ul>
<p>以上で，<code>add5</code>のための新しいスタックフレームを作れました．</p>
<h3 id="popq-rbpは今のスタックフレームを捨てる"><a class="header" href="#popq-rbpは今のスタックフレームを捨てる"><code>popq %rbp</code>は今のスタックフレームを捨てる</a></h3>
<p>これは<a href="2-asm-intro.html#create-new-stack-frame">前節</a>での説明のちょうど逆になります．</p>
<pre><code class="language-x86asmatt">popq %rbp
ret
</code></pre>
<p>を実行すると，スタックフレームは以下の図になります．</p>
<form class="tab-wrap">
    <input id="stack-frame5-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="stack-frame5-1"><code>popq %rbp</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-1.svg" height="150px" id="fig:stack-frame5-1">
    </div>
    <input id="stack-frame5-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-2"><code>popq %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-2.svg" height="150px" id="fig:stack-frame5-2">
    </div>
    <input id="stack-frame5-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame5-3"><code>ret</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame5-3.svg" height="150px" id="fig:stack-frame5-3">
    </div>
</form>
<ul>
<li>
<p><code>popq %rbp</code>の実行前は，スタックトップ付近はこの図の状態になっています．
(コンパイラがこの図の状態になるようにアセンブリコードを出力します．
自分でアセンブリコードを書く場合は，この図の状態になるように正しくプログラムする必要があります)
「この図の状態」をもう少し説明すると以下になります．</p>
<ul>
<li>スタックトップには <strong>古い<code>%rbp</code></strong> が格納されていて，
その <strong>古い<code>%rbp</code></strong> は1つ前のスタックフレームの一番下を指している．</li>
<li>スタックトップのひとつ下には<strong>戻り番地</strong>が格納されている．</li>
<li>さらにその下には<code>add5</code>を呼び出した関数(ここでは<code>main</code>)のスタックフレームがある．</li>
</ul>
</li>
<li>
<p><code>popq %rbp</code>を実行すると，<code>%rbp</code>は<code>main</code>関数のスタックフレームの一番下を
指すようになります．(<a href="2-asm-intro.html#push-rbp-pop-rbp">上の説明</a>と合わせて読んで下さい．)
また，ポップの結果，<code>%rsp</code>が指す先が下にずれて，戻り番地を指すように変わりました．</p>
</li>
<li>
<p><code>ret</code>命令はスタックトップから戻り番地をポップして，次に実行する命令のアドレスをポップした戻り番地に設定します．スタックの状態は<code>add5</code>を呼び出す前の状態に戻りました．</p>
</li>
</ul>
<details>
<summary>
「この図の状態」の例外
</summary>
<div  id="-fomit-frame-pointer">
<p><a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にならないことがあります．
<code>-fomit-frame-pointer</code>というオプション付きでコンパイルすると，
<code>%rbp</code>は「スタックフレームの一番下を指すポインタ(ベースポインタ)」として
使うのではなく，汎用レジスタ(好きな目的のために使えるレジスタ)として使われます．
このため，関数からリターンする直前に<a href="2-asm-intro.html#fig:stack-frame5-1">この図の状態</a>にはなりません．
<code>-O2</code>などの最適化オプションを指定すると，
<code>-fomit-frame-pointer</code>も有効になることが多いです．</p>
</div>
</details>
<details>
<summary>
全てのスタックフレームは「古い`%rbp`」で数珠つなぎ
</summary>
<p>実は下の図のように全てのスタックフレームは「古い<code>%rbp</code>」で数珠つなぎ，
つまり<strong>線形リスト</strong>(linked list)になっています</p>
<img src="figs/stack-frame-list.svg" height="300px" id="fig:stack-frame-list">
</details>
<details>
<summary>
戻り番地とプログラムカウンタ
</summary>
<p>一般的にCPUは<strong>プログラムカウンタ</strong>と呼ばれる特別な役割を持つレジスタを備えています．
プログラムカウンタは「次に実行する機械語命令のアドレス」を保持します．
そして，<code>ret</code>命令などでプログラムカウンタ中のアドレスを変更すると，
「次に実行する機械語命令のアドレス」を変更できるのです．</p>
<p>x86-64では<code>%rip</code>レジスタがプログラムカウンタです．
<code>ret</code>命令はスタックをポップして取り出した戻り番地を
プログラムカウンタ<code>%rip</code>に格納することで，「関数からリターンする」
（つまり，<code>call add5</code>命令の直後の命令を次に実行する）という動作を実現しています．</p>
</details>
<h2 id="add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a class="header" href="#add5s中の-movl--edi--4rbp-movl---4rbp-eax-addl--5-eax"><a href="2-asm-intro.html#add5.s"><code>add5.s</code></a>中の <code>movl  %edi, -4(%rbp)</code>， <code>movl  -4(%rbp), %eax</code>， <code>addl  $5, %eax</code></a></h2>
<p>ここでは以下の3命令を説明します．
直感的にはこの3命令で「<code>n + 5</code>」を計算しています．</p>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
  addl  $5, %eax
</code></pre>
<ul>
<li>
<p>まず<code>-4(%rbp)</code>を説明します．
これは「<code>%rbp</code>中のアドレスから4を引いた数」をアドレスとしてメモリを
読み書きすることを意味しています．以下の図はスタックをより正確に描いています．</p>
<ul>
<li>メモリは1バイトごとにアドレスが付いています．
古い<code>%rbp</code>や戻り番地のデータはそれぞれ8バイトなので，
アドレス8つ分(つまり8バイト)の場所を占めています．</li>
<li>多バイト長のデータはそのデータが占めている<strong>先頭のアドレス</strong>を使って
メモリを読み書きします．(本書の図ではメモリの0番地が常に上にあることを思い出してください)．
ですので，1バイトごとのアドレスで考えると，<code>%rbp</code>はスタックフレームの
一番下を指していません．</li>
<li>そして，<code>-4(%rbp)</code>は「<code>%rbp</code>から4を引いたアドレスのメモリ」ですので，
以下の図で<code>-4(%rbp)</code>が指している場所を先頭とするメモリ領域になります．</li>
</ul>
</li>
</ul>
<img src="figs/stack-layout.svg" height="400px" id="fig:stack-layout">
<ul>
<li>
<p>次に<code>%edi</code>と<code>%eax</code>について説明します．</p>
<ul>
<li>以下の図のようにx86-64には8バイト長の<code>%rdi</code>と<code>%rax</code>という
汎用レジスタがあります(他にも汎用レジスタはありますがここでは割愛)．
その右半分にそれぞれ<code>%edi</code>と<code>%eax</code>という名前が付いています．
<code>%edi</code>と<code>%eax</code>は4バイト長です．</li>
<li><code>%rdi</code>レジスタは関数呼び出しでは<strong>第1引数</strong>を渡すために使われます．
<code>add5</code>の第1引数<code>n</code>は<code>int</code>型で，この場合は4バイト長だったため，
<code>%edi</code>に<code>n</code>の値が入っています．</li>
<li><code>%rax</code>レジスタは関数呼び出しでは<strong>返り値</strong>を返すために使われます．
<code>add5</code>の返り値の方が<code>int</code>型なので，<code>%eax</code>に値を入れてから
関数をリターンすれば，返り値が返せることになります．</li>
</ul>
</li>
</ul>
<img src="figs/edi-eax.svg" height="300px" id="fig:edi-eax">
<ul>
<li>次に以下の2つの命令を説明します．</li>
</ul>
<pre><code class="language-x86asmatt">  movl  %edi, -4(%rbp)
  movl  -4(%rbp), %eax
</code></pre>
<ul>
<li><code>movl</code>の<code>l</code>は4バイトのデータをコピーすることを表しています．ですので，
例えば，<code>movl  %edi, -4(%rbp)</code>は<code>%edi</code>中の4バイトデータを
先頭アドレスが<code>-4(%rbp)</code>から4バイト分の領域
(<a href="2-asm-intro.html#fig:stack-layout">この図</a>で一番上の赤い部分)
にコピーする命令になります．</li>
</ul>
<details>
<summary>
なぜl(エル)が4バイト
</summary>
<p>l(エル)はlongの略で，GNUアセンブラでは以下の通り，longが4バイトを意味するからです．
Intelマニュアルなどでは4バイトのことをdouble wordと呼びます．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>short</td><td>long</td><td>quad</td></tr>
<tr><td>Intelマニュアル</td><td>word</td><td>double word</td><td>quad word</td></tr>
</tbody></table>
</div></details>
<ul>
<li>
<p>この2つの命令で「<code>%edi</code>中の4バイトを<code>-4(%rbp)</code>にコピー」して，次に
「<code>-4(%rbp)</code>中の4バイトを<code>%eax</code>にコピー」しています．
「<code>%edi</code>から<code>%eax</code>に直接コピーすればいいんじゃね?」と思った方，正解です．
実はこの場合は(<code>-4(%rbp)</code>に格納しても使われないので)不要なのですが，
コンパイラは
「引数<code>n</code>の実体の場所を<code>-4(%rbp)</code>としたので，
<code>-4(%rbp)</code>にも<code>n</code>の値を格納する」という判断をしたようです．</p>
</li>
<li>
<p><code>addl  $5, %eax</code>命令を説明します．</p>
<ul>
<li>この命令は<code>%eax</code>の値と定数<code>5</code>の値を足し算した結果を<code>%eax</code>に格納します．</li>
<li>つまり，<code>n + 5</code>の結果がこの命令の実行後に<code>%eax</code>に入ります．</li>
<li>GNUアセンブラでは定数の先頭にはドルマーク<code>$</code>が付きます．
ただし，<code>-4(%rbp)</code>の<code>-4</code>など，ドルマークが付かないこともあります．</li>
</ul>
</li>
</ul>
<p>以上で<code>add5.s</code>の説明が終わりました(お疲れ様でした)．</p>
</details>
<details>
<summary>
即値とは
</summary>
<p>上で<code>$5</code>は定数と説明しましたが，アセンブラ用語では
<strong>即値</strong>(immediate value)と呼びます．
それは機械語命令の2進数の中に
即値の値が埋め込まれており，即座に(つまりメモリやレジスタにアクセスすることなく)
値を取り出せることに由来しています．
x86-64のマニュアルなどで <em>imm32</em> などが出てきます．<em>imm32</em>は「32ビット長の即値」を意味しています．</p>
</details>
</details>
<details>
<summary>
%rspより上のメモリ領域に勝手に書き込んで良いのか(レッドゾーン)
</summary>
<div id="redzone">
<p>LinuxのABI <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>ではOKです．
LinuxのABIでは<code>%rsp</code>レジスタの上，128バイトの領域を<strong>レッドゾーン</strong>と呼び，
この領域には好きに読み書きして良いことになっています．
(ABIが「割り込みハンドラやシグナルハンドラが実行されても，
レッドゾーンの値は破壊されない」ことを保証しています．）
もちろん，自分自身で関数を呼び出すとレッドゾーン中の値は壊れるので，
レッドゾーンは<strong>葉関数</strong>(leaf function)，つまり関数を呼び出さない関数
が使うのが一般的です．
レッドゾーンのおかげで，<code>%rsp</code>をずらさずにメモリの読み書きができるので，
その分だけ実行が高速になります．</p>
<img src="figs/redzone.svg" height="300px" id="fig:redzone">
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 3; }
</style>
<h1 id="バイナリファイル"><a class="header" href="#バイナリファイル">バイナリファイル</a></h1>
<h2 id="バイナリファイルの中身を見る"><a class="header" href="#バイナリファイルの中身を見る">バイナリファイルの中身を見る</a></h2>
<h3 id="hexdump"><a class="header" href="#hexdump">16進ダンプ</a></h3>
<p><code>add5.c</code>や<code>add5.s</code>はテキストファイルですが，
<a href="./2-asm-intro.html#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">2節のアセンブリ言語</a>で作成した
<code>add5.o</code>はバイナリファイルです．
バイナリファイルなので，<code>less</code>コマンドでは中身を読めません．</p>
<pre><code class="language-bash">$ less add5.o
^?❶ELF^B^A^A^@^@^@^@^@^@^@^@^@^A^@&gt;^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@X^B
^@^@^@^@^@^@^@^@^@^@@^@^@^@^@^@@^@^L^@^K^@&lt;F3&gt;^O^^&lt;FA&gt;UH&lt;89&gt;&lt;E5&gt;&lt;89&gt;}&lt;FC&gt;&lt;8B&gt;E
（長いので省略）
</code></pre>
<details id="ELF">
<summary>
❶ELFとは
</summary>
<p>上の<code>less</code>コマンドの結果にELFという文字が見える理由を説明します．
ELFはLinuxが採用している<strong>バイナリ形式</strong>(binary format)です．
このELFのバイナリファイルの先頭4バイトには<strong>マジックナンバー</strong>という
バイナリファイルを識別する特別な数値が入っています．
ELFバイナリのマジックナンバーは <code>7F 45 4C 46</code>です．
<code>45 4C 46</code>はASCII文字で <code>E L F</code> なので，lessコマンドが<code>ELF</code>と表示したわけです． </p>
</details>
<p>バイナリファイルの中身を読むには例えば<code>od</code>コマンドを使います．</p>
<pre><code class="language-bash">$ od -t x1 add5.o
0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
0000020 01 00 3e 00 01 00 00 00 00 00 00 00 00 00 00 00
（長いので省略）
</code></pre>
<p>一番左の数字が「先頭からのバイト数(16進表記)」，
その右側に並んでいるのが「1バイトごとに16進表記したファイルの中身」です．
（1バイトのデータは2桁の16進数で表せることを思い出しましょう．
例えば，<code>add5.o</code>の中身の先頭4バイトの値は<code>7F 45 4C 46</code>です）．</p>
<p><code>-t x1</code>というオプションは「1バイトごとに16進数で表示せよ」という意味です．
このような出力を<strong>16進ダンプ</strong>(hex dump)と言います．
他に16進ダンプするコマンドとして，<code>xxd</code>や<code>hexdump</code>などがあります．</p>
<p>ちなみに，<code>add5.c</code>はテキストファイルですが，内容は2進数で保存されて
いますので，<code>od</code>コマンドで中身を表示できます．</p>
<pre><code class="language-bash">$ od -t x1 add5.c
0000000 69 6e 74 20 61 64 64 35 20 28 69 6e 74 20 6e 29
0000020 0a 7b 0a 20 20 20 20 72 65 74 75 72 6e 20 6e 20
0000040 2b 20 35 3b 0a 7d 0a
0000047
</code></pre>
<p>先頭の<code>69</code>はASCII文字<code>i</code>の文字コード，
同様に，次の<code>6e</code>は文字<code>n</code>，その次の<code>74</code>は文字<code>t</code>なので，
<code>add5.c</code>の先頭3文字が<code>int</code>であることを確認できます．
<a href="./4-data.html#ASCII">ASCIIコード</a>表は<code>man ascii</code>コマンドで閲覧できます．
（例えば，16進数の<code>0x69</code>は10進数の<code>105</code>です．
<a href="./4-data.html#ASCII">ASCIIコード</a>表の<code>105</code>番目の文字は<code>i</code>です．）</p>
<details>
<summary>
manコマンドとは
</summary>
<p><code>man</code>コマンドはLinux上でマニュアルを表示するコマンドです．</p>
<p>例えば<code>man ascii</code>を実行すると以下のように表示されます．</p>
<pre><code class="language-bash">$ man ascii

ASCII(7)                   Linux Programmer's Manual                  ASCII(7)

NAME
       ascii - ASCII character set encoded in octal， decimal， and hexadecimal

DESCRIPTION
       ASCII is the American Standard Code for Information Interchange.  It is
       a 7-bit code.  Many 8-bit codes (e.g.， ISO  8859-1)  contain  ASCII  as
       their  lower  half.  The international counterpart of ASCII is known as
       ISO 646-IRV.

       The following table contains the 128 ASCII characters.

       C program '\X' escapes are noted.

       Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
       ────────────────────────────────────────────────────────────────────────
       000   0     00    NUL '\0' (null character)   100   64    40    @
       001   1     01    SOH (start of heading)      101   65    41    A
       002   2     02    STX (start of text)         102   66    42    B
（以下略）
</code></pre>
<p>デフォルトでは<code>less</code>コマンドで1ページずつ表示されるので，
スペースキーで次のページが，<code>b</code>を押せば前のページが表示されます．
終了するには<code>q</code>を押します．<code>h</code>を押せばヘルプを表示し，<code>/</code>で検索もできます．
例えば，<code>/backspace</code>と入力してリターンを押すと，<code>backspace</code>を検索してくれます．</p>
<p><code>man</code>コマンドは章ごとに分かれています．例えば</p>
<ul>
<li>1章はコマンド (例：<code>ls</code>)</li>
<li>2章はシステムコール (例：<code>open</code>)</li>
<li>3章はライブラリ関数 (例：<code>printf</code>)</li>
</ul>
<p>となっています．
<code>printf</code>というコマンドがあるので，
<code>man printf</code>とすると（ライブラリ関数ではなく）コマンドの<code>printf</code>の
マニュアルが表示されてしまいます．
ライブラリ関数の<code>printf</code>を見たい場合は
<code>man 3 printf</code>と章番号も指定します．</p>
</details>
<p>なお，<code>od</code>コマンドに<code>-c</code>オプションをつけると，
(文字として表示可能なバイトは)文字が表示されます．</p>
<pre><code class="language-bash">$ od -t x1 -c add5.c
0000000  69  6e  74  20  61  64  64  35  20  28  69  6e  74  20  6e  29
          i   n   t       a   d   d   5       (   i   n   t       n   )
0000020  0a  7b  0a  20  20  20  20  72  65  74  75  72  6e  20  6e  20
         \n   {  \n                   r   e   t   u   r   n       n    
0000040  2b  20  35  3b  0a  7d  0a
          +       5   ;  \n   }  \n
0000047
</code></pre>
<h3 id="everything-binary"><a class="header" href="#everything-binary">コンピュータの中のデータはすべて<code>0</code>と<code>1</code>から成る</a></h3>
<p>ここで大事なことを復習しましょう．
それは
<strong>「コンピュータの中のデータは，どんな種類のデータであっても，
機械語命令であっても，すべて<code>0</code>と<code>1</code>だけで表現されている」</strong>
ということです．
ですので，テキストはバイナリでもあるのです．</p>
<ul>
<li>テキスト=文字として表示可能な2進数だけを含むデータ</li>
<li>バイナリ=文字以外の2進数も含んだデータ</li>
</ul>
<img src="figs/text-binary.svg" height="100px" id="fig:text-binary">
<blockquote>
<p>注意：
本書で，テキスト(text)という言葉には2種類の意味があることに注意して下さい．</p>
<ul>
<li>1つは「文字」を意味します．例：「テキストファイル」（文字が入ったファイル）</li>
<li>もう1つは「機械語命令列」を意味します．例：「<a href="3-binary.html#.text">テキストセクション</a>」（機械語命令列が格納されるセクション）</li>
</ul>
</blockquote>
<h3 id="2進数と符号化"><a class="header" href="#2進数と符号化">2進数と符号化</a></h3>
<p><a href="3-binary.html#everything-binary">前節</a>で説明した通り，
コンピュータ中では全てのものを0と1の2進数で表現する必要があります．
そのため，データの種類ごとに2進数での表現方法，つまり<strong>符号化</strong>
(encoding)の方法が定められています．
例えば，</p>
<ul>
<li>文字<code>U</code>をASCII文字として符号化すると，<code>01010101</code>になります．</li>
<li><code>pushq %rbp</code>をx86-64の機械語命令として符号化すると，<code>01010101</code>になります．</li>
</ul>
<p>おや，どちらも同じ<code>01010101</code>になってしまいました．
この2進数が<code>P</code>なのか<code>pushq %rbp</code>なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．</p>
<img src="figs/encode.svg" height="130px" id="fig:encode">
<p>別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する<a href="3-binary.html#.text"><code>.text</code>セクション</a>にある
2進数のデータ列は「<code>.text</code>セクションに存在するから」という理由で
機械語命令として解釈されます．</p>
<h3 id="fileコマンド"><a class="header" href="#fileコマンド"><code>file</code>コマンド</a></h3>
<p><a href="3-binary.html#hexdump">16進ダンプ</a>以外の方法で，<code>add5.o</code>の中身を見てみます．
まずは<code>file</code>コマンドです．
<code>file</code>コマンドはファイルの種類の情報を教えてくれます．</p>
<pre><code class="language-bash">$ file add5.o
add5.o: ❶ELF 64-bit ❷LSB ❸relocatable， x86-64， ❹version 1 (SYSV)， ❺not stripped
</code></pre>
<p>これで，<code>add5.o</code>が64ビットの❶ELFバイナリであることが分かりました．
ELFはバイナリ形式(バイナリを格納するためのファイルフォーマット)の1つです．
Linuxを含めて多くのOSがELFをバイナリ形式として使っています．</p>
<details id="LSB">
<summary>
❷LSBとは
</summary>
<p>多バイト長のデータをバイト単位で格納する順序を<strong>バイトオーダ</strong>(byte order)といいます．
LSBは最下位バイトから順に格納するバイトオーダ (Least Significant Byte first)，
つまり<a href="4-data.html#%E3%83%90%E3%82%A4%E3%83%88%E3%82%AA%E3%83%BC%E3%83%80%E3%81%A8%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>
を意味しています．</p>
<p>x86-64のバイトオーダがリトルエンディアンのため，
このELFバイナリもリトルエンディアンになっています．
ELFバイナリがビッグエンディアンかリトルエンディアンかどうかを示すデータが，
ELFバイナリのヘッダに格納されています．
これは<code>readelf -h</code>コマンドで調べられます❶．</p>
<pre><code>$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:        ELF64
  Data:         2's complement, ❶little endian
  Version:      1 (current)
  OS/ABI:       UNIX - System V
(以下略)
</code></pre>
<p>リトルエンディアンでの注意は16進ダンプする時に，多バイト長データが逆順に表示されることです．
以下で多バイト長データ❶<code>0x11223344</code>を<code>.text</code>セクションに配置してアセンブルした
<code>little.o</code>を逆アセンブルすると，❸<code>44 33 22 11</code>と逆順に表示されています．
(<code>objdump -h</code>の出力から，<code>.text</code>セクションのオフセット(ファイルの先頭からのバイト数)が❷0x40バイトであることを使って，<code>od</code>コマンドに<code>-j0x40</code>オプションを使い，<code>.text</code>セクションの先頭付近の情報を表示しています)</p>
<pre><code class="language-bash">$ cat little.s
.text
❶.long 0x11223344
$ gcc -c little.s
$ objdump -h little.o
foo.o:     file format elf64-x86-64
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000004  0000000000000000  0000000000000000 ❷00000040  2**0
                  CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000044  2**0
                  CONTENTS， ALLOC， LOAD， DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000044  2**0
                  ALLOC
$ od -t x1 -j0x40 little.o | head -n1
0000100 ❸44 33 22 11 00 00 00 00 00 00 00 00 00 00 00 00
</code></pre>
</details>
<!--
これは嘘でしたｗ
LSBはLinuxの標準である[Linux Standard Base](https://refspecs.linuxfoundation.org/lsb.shtml)の略です．LSBはELFバイナリの規格であるSystem V ABIを含んでいます．
ABIはapplication binary interfaceの略です．
-->
<details>
<summary>
❸relocatableとは
</summary>
<p>バイナリ中のアドレスを再配置 (relocate)できるバイナリのことを
再配置可能 (relocatable)であるといいます．オブジェクトファイルはリンク時や実行時にアドレスを変更できるよう，
relocatableであることが多いです．</p>
</details>
<details>
<summary>
❹version 1 (SYSV)とは
</summary>
<p>LinuxのABI（バイナリ互換規約）である<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>
に準拠していることを表しています．</p>
</details>
<details>
<summary>
❺not strippedとは
</summary>
<p>バイナリには実行に直接関係ない<strong>記号表</strong>や<strong>デバッグ情報</strong>などが
含まれていることがよくあります．
この「実行に直接関係ない情報」が削除されたバイナリのことを
stripped binaryと呼びます．
<code>strip</code>コマンドで「実行に直接関係ない情報」を削除できます．
削除された分，サイズが少し減っています．</p>
<pre><code class="language-bash">$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 1368 Jul 19 10:09 add5.o
$ strip add5.o
$ ls -l add5.o
-rw-rw-r-- 1 gondow gondow 880 Jul 19 14:58 add5.o
</code></pre>
</details>
<p>なお，<code>file</code>コマンドはバイナリ以外のファイルにも使えます．</p>
<pre><code class="language-bash">$ file add5.c
add5.c: ASCII text
$ file add5.s
add5.s: assembler source， ASCII text
$ file .
.:  directory
$ file /dev/null
/dev/null: character special (1/3)
</code></pre>
<h3 id=".text"><a class="header" href="#.text">セクションと<code>objdump -h</code>コマンド</a></h3>
<p>バイナリファイルの構造はざっくり以下の図のようになっています．</p>
<img src="figs/section.svg" height="250px" id="fig:text-binary">
<ul>
<li>最初のヘッダ以外の四角を<strong>セクション</strong>(section)と呼びます．</li>
<li>バイナリはセクションという単位で区切られていて，それぞれ別の目的でデータが格納されます．</li>
<li>ヘッダは目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．</li>
</ul>
<p>ヘッダの情報は<code>objdump -h</code>で表示できます．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA               File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000  00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000  00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000  00000053  2**0
             ALLOC
(以下略)
</code></pre>
<p>ここでは「<code>.text</code>，<code>.data</code>，<code>.bss</code>という3つのセクションがある」ことを
見ればOKです．</p>
<details>
<summary>
VMAとLMAとは
</summary>
<p>VMAはvirtual memory addressの略で「メモリ上で実行される時の
このセクションのメモリアドレス」です．
一方，LMAはload memory addressの略で「メモリ上にロード(コピー，配置)する時の
このセクションのメモリアドレス」です．
通常，セクションをメモリにロードした後で，移動せずにそのまま実行するため，VMAとLMAは同じアドレスになります．
<code>add5.o</code>ではアドレスが決まってないので，VMAもLMAもゼロになっています．</p>
</details>
<details>
<summary>
File offとは
</summary>
<p>File offはファイルオフセットを表しています．このセクションがバイナリファイルの先頭から何バイト目から始まっているかを16進表記で表しています．</p>
</details>
<details>
<summary>
Algnとは
</summary>
<p>Algnは<strong>アラインメント</strong>(alignment)を表しています．
例えば「このセクションをメモリ上に配置する時，その先頭アドレスが8の倍数になるようにしてほしい」という状況の時，この部分が<code>2**3</code>となります（2の3乗=8）．</p>
</details>
<details>
<summary>
CONTENTS， ALLOC， LOAD， READONLY， CODEとは
</summary>
<p>これらはセクションフラグと呼ばれるセクションの属性値です．</p>
<ul>
<li>CONTENTS  このセクションには中身がある (例えば，<code>.bss</code>はCONTENTSが無いので(ファイル中では)中身が空のセクションです)</li>
<li>ALLOC     ロード時にこのセクションのためにメモリを割り当てる必要がある</li>
<li>LOAD      このセクションは実行するためにメモリ上にロードする必要がある</li>
<li>READONLY  メモリ上では「読み込みのみ許可（書き込み禁止）」と設定する必要がある</li>
<li>CODE      このセクションは実行可能な機械語命令を含んでいる</li>
</ul>
</details>
<br/>
<div id=".bss">
<p>3つのセクション <code>.text</code> ，<code>.data</code>，<code>.bss</code> の役割は以下の通りです：</p>
<ul>
<li><code>.text</code>セクションは機械語命令を格納します．例えば，<code>pushq %rbp</code>を表す<code>0x55</code>は<code>.text</code>セクションに格納されます．</li>
<li><code>.data</code>セクションは初期化済みの静的変数の値を格納します．例えば，大域変数<code>int x=999;</code>があったとき，999の2進数表現が<code>.data</code>セクションに格納されます．</li>
<li><code>.bss</code>セクションは未初期化の静的変数の値を格納します．例えば，大域変数<code>int y;</code>があったとき，（概念的には）初期値0の2進数表現が<code>.bss</code>セクションに格納されます．</li>
</ul>
</div>
<details>
<summary>
なぜ概念的
</summary>
<p>実はファイル中では<code>.bss</code>セクションにはサイズ情報などごくわずかの情報しか持っていません．実行時にメモリ上に<code>.bss</code>セクションを作る際に，実際に必要なメモリを確保して，そのメモリ領域をすべてゼロで初期化すれば十分だからです（ファイル中に大量のゼロの並びを保持する必要はありません）．</p>
<pre><code>// bss.c
int a [1024];
int main (void)
{
   return a[0];
}
</code></pre>
<p>例えば，<code>bss.c</code>の<code>int a[1024];</code> の変数<code>a</code>は未初期化なので，
変数<code>a</code>の実体は<code>.bss</code>セクションに置かれます．アセンブリコードを見てみると，</p>
<pre><code>$ gcc -S bss.c
$ cat bss.s
(関係する箇所以外は削除)
 ❶ .bss                # 以下を.bssセクションに出力
    .align 32           # 次の出力アドレスを32の倍数にせよ
    .type   a, @object  # ラベルaの型はオブジェクト(関数ではなくデータ)
    .size   a, 4096     # ラベルaのサイズは4096バイト
a:                      # ラベルaの定義
 ❷ .zero   4096        # 4096バイト分のゼロを出力せよ
</code></pre>
<p>❶<code>.bss</code>セクションに❷4096バイト分のゼロを出力するように見えますが，
ヘッダを見てみると，ファイル中の<code>.bss</code>セクションの中身は0バイトだと分かります．</p>
<pre><code>$ gcc -g bss.c
$ objdump -h ./a.out
Sections:
Idx Name          Size      VMA               LMA                File off  Algn
(中略)
23 ❸.bss     ❹ 00001020  0000000000004020  0000000000004020 ❺ 00003010  2**5
                ❼ALLOC
24   .comment    0000002b  0000000000000000  0000000000000000 ❻ 00003010  2**0
                  CONTENTS, READONLY
</code></pre>
<p>❸<code>.bss</code>セクションのサイズは16進数で❹ 0x1020バイト(10進数では4128バイト)ですが，
ファイルオフセットを比較してみると，❺と❻が同じ値(<code>000033010</code>)なので，
ファイル中での<code>.bss</code>セクションのサイズは0バイトだと分かります．
また，セクション属性が❼<code>ALLOC</code>のみで，
<code>CONTENTS</code>(中身がある)が無いことからも0バイトと分かります．</p>
</details>
<p>さらに代表的なセクションである<code>.rodata</code>も説明します．</p>
<ul>
<li><code>.rodata</code>セクションは読み込みのみ(read-only)なデータの値を格納します．例えば，C言語の文字列定数<code>&quot;hello&quot;</code>は書き込み禁止なので，<code>&quot;hello&quot;</code>の2進数表現が<code>.rodata</code>セクションに格納されます．</li>
</ul>
<p>バイナリファイルには上記以外のセクションも数多く使われますが，
まずはこの基本の4種類 (<code>.text</code>， <code>.data</code>， <code>.bss</code>， <code>.rodata</code>) を覚えましょう．</p>
<h3 id="nm"><a class="header" href="#nm">記号表の中身を表示させる(<code>nm</code>コマンド)</a></h3>
<p>バイナリファイル中には<strong>記号表</strong>(symbol table)があることが多いです．
記号表とは「変数名や関数名がバイナリ中では何番地のアドレスになっているか」という情報です．
<code>nm</code>コマンドでバイナリファイル中の記号表を表示できます．
まず，以下の<code>foo.c</code>を準備して下さい．</p>
<pre><code>// foo.c
int g1 = 999;
int g2;
int s1 = 888;
int s2;
int main ()
{
    static int s3 = 777;
    static int s4;
    int ❼i1 = 666;
    int ❼i2;
}
</code></pre>
<p>そしてコンパイルして，<code>nm</code>コマンドで記号表の中身を表示させます．</p>
<pre><code class="language-bash">$ gcc -c foo.c
$ nm foo.o
0000000000000000 ❶D g1
0000000000000000 ❸B g2
0000000000000000 ❺T main
0000000000000004 ❶D s1
0000000000000004 ❸B s2
0000000000000008 ❷d ❻s3.0
0000000000000008 ❹b ❻s4.1
</code></pre>
<p>この出力の読み方は以下の通りです．</p>
<ul>
<li>❶<code>D</code>と❷<code>d</code>は<code>.data</code>セクションのシンボル，❸<code>B</code>と❹<code>b</code>は<code>.bss</code>セクションのシンボル，❺<code>T</code>と<code>t</code>は<code>.text</code>セクションのシンボルであることを表す</li>
<li>大文字はグローバル（ファイルをまたがって有効なシンボル），小文字はファイルローカルなシンボルであることを表す</li>
<li><code>static</code>付きの局所変数を表すシンボルは
他の関数中の同名のシンボルと区別するために，
❻<code>.0</code>や<code>.1</code>などが付加されることがある．</li>
<li>左側の<code>00</code>，<code>04</code>，<code>08</code>がシンボルに対応するアドレスですが，再配置前(relocation前)なので仮のアドレス(各セクションの先頭からのオフセット)</li>
<li>(<code>static</code>のついてない)局所変数❼は記号表には含まれていない．
局所変数(自動変数)は実行時にスタック上に実体が確保されます．</li>
</ul>
<h3 id="ASLR-PIE"><a class="header" href="#ASLR-PIE">ASLRとPIE（ちょっと脱線）</a></h3>
<p>オブジェクトファイルのセクションごとの仮のアドレスは，
リンク後の<code>a.out</code>では具体的なアドレスになります</p>
<pre><code class="language-bash">$ gcc foo.c
$ nm ./a.out | egrep g1
0000000000004010 D g1
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000001129 T main
</code></pre>
<details>
<summary>
U __libc_start_main@@GLIBC_2.34とは
</summary>
<p>バイナリ中で参照されているけど定義がないシンボルがあると，
<code>nm</code>コマンドはundefinedを意味する<code>U</code>を表示します．
実は<code>a.out</code>は<code>main</code>関数を呼び出す前に<code>__libc_start_main</code>という
GLIBC中の関数を(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>した上で)呼び出します．
<code>__libc_start_main</code>は
様々な初期化を行った後，(その名の通り)<code>main</code>関数を呼び出すのが主な役割です．</p>
<p>ちなみに<code>__libc_start_main</code>は<code>_start</code>が呼び出します．</p>
<pre><code>$ readelf -h ./a.out | egrep Entry
  Entry point address:           ❶ 0x1040
$ objdump -d ./a.out | egrep 1040
0000000000001040 ❷ &lt;_start&gt;:
    1040:	f3 0f 1e fa          	endbr64 
</code></pre>
<p><code>a.out</code>の<strong>エントリポイント</strong>(最初に実行するアドレス)は
❶ <code>0x1040</code>番地です．この番地には❷<code>_start</code>があるので，
<code>a.out</code>を実行すると最初に実行される関数は<code>_start</code>と分かります．</p>
</details>
<p>出力が長くなるので，<code>g1</code>と<code>main</code>のアドレスだけ載せています．
<code>g1</code>のアドレスは<code>0x4010</code>番地，<code>main</code>のアドレスは<code>0x1129</code>番地となりました．
ただし，このまま実行すると，<code>g1</code>や<code>main</code>のアドレスはこれらのアドレスにはならず，
実行するたびに変わります．
これは<strong>ASLR</strong>や<strong>PIE</strong>というセキュリティ対策機能のためです．</p>
<p>確かめてみましょう．
以下の<code>foo2.c</code>を普通にコンパイルして実行してみます．</p>
<pre><code class="language-C">// foo2.c
#include &lt;stdio.h&gt;
int g1 = 999;
int main ()
{
    printf (&quot;%p, %p\n&quot;, &amp;g1, main);
}
</code></pre>
<p>以下の通り，<code>g1</code>や<code>main</code>のアドレスは実行するたびに変わりますし，
<code>nm</code>が出力したアドレスとも異なります．</p>
<pre><code class="language-bash">$ gcc foo2.c
$ ./a.out
0x557f2361e010， 0x557f2361b149
$ ./a.out
0x55a40e6f5010， 0x55a40e6f2149
$ ./a.out
0x562750663010， 0x562750660149
$ 
</code></pre>
<p>ここではASLRとPIEの機能を無効にして，アドレスが変わらなくなることを確認します．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0  # ASLRをオフ
$ gcc -no-pie foo2.c                          # PIEをオフ
$ nm ./a.out | egrep main
                 U __libc_start_main@@GLIBC_2.34
0000000000401136 T main
$ nm ./a.out | egrep g1
0000000000404030 D g1
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
$ ./a.out
&amp;g1=0x404030， main=0x401136
</code></pre>
<p>ASLRとPIEの機能をオフにすることで，アドレスが変わらなくなり，
かつ<code>nm</code>が出力するアドレスと同じになることが確認できました．</p>
<blockquote>
<p>注意：
不用意なASLRとPIEの無効化はセキュリティ機能を下げるので避けるべきです．
しかしデバッグ作業ではアドレスが変わらなくなるので
ASLRとPIEの無効化が有用な場合もあります．
なお，デバッガ中ではASLRは無効化されていることが多いです．</p>
</blockquote>
<details>
<summary>
ASLRとは
</summary>
<p>ASLR (address space layout randomizationの略)は，
アドレス空間の配置をランダム化する機能です．
テキスト（実行コード），ライブラリ，スタック，ヒープなどをメモリ上に
配置するアドレスを実行するたびにランダムに変化させます．
以下を実行するとASLRは無効化され，</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=0
</code></pre>
<p>以下を実行するとASLRは有効化されます．</p>
<pre><code class="language-bash">$ sudo sysctl -w kernel.randomize_va_space=1
</code></pre>
</details>
<details id="PIE">
<summary>
PIEとは
</summary>
<p>PIE (position independent executableの略)は位置独立実行可能ファイルを意味します．
通常，動的ライブラリは位置独立コードPIC (position independent code)としてコンパイルされます．
動的ライブラリはメモリ上で共有されるため，どのアドレスに配置してもそのまま再配置せずに，実行したいからです．
PIEは動的ライブラリだけでなく，<code>a.out</code>も位置独立にした実行可能ファイルを指します．
<code>-no-pie</code>オプションでコンパイルすると，PIEを無効化できます．</p>
<pre><code class="language-bash">$ gcc -no-pie foo2.c
</code></pre>
</details>
<h2 id="逆アセンブル再び"><a class="header" href="#逆アセンブル再び">逆アセンブル再び</a></h2>
<p><a href="./2-asm-intro.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB">逆アセンブル</a>で説明した通り，
<code>objdump -d ./a.out</code>で逆アセンブル結果が表示されます（再掲）．</p>
<pre><code class="language-bash">$ objdump -d add5.o
add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	retq   
</code></pre>
<p><code>objdump</code>コマンドは<code>add5.o</code>の<code>.text</code>セクションを抽出し，
そのデータを機械語命令として解釈して，対応するニモニックを出力しています．</p>
<p>この出力によれば，<code>.text</code>セクションの先頭4バイトは<code>F3 0F 1E FA</code>で，
この4バイトが<code>endbr64</code>命令になります
（x86-64の命令長は可変長で，1バイト〜15バイトです）．</p>
<p>以下では<code>.text</code>セクションの先頭4バイトが<code>F3 0F 1E FA</code>であることを確認します．</p>
<p>セクションのヘッダを出力するコマンド<a href="3-binary.html#.text"><code>objdump -h</code></a>の出力を再掲します．</p>
<pre><code class="language-bash">$ objdump -h add5.o
add5.o:     file format elf64-x86-64
Sections:
Idx Name     Size      VMA               LMA                File off  Algn
  0 .text    00000013  0000000000000000  0000000000000000 ❶00000040  2**0
             CONTENTS， ALLOC， LOAD， READONLY， CODE
  1 .data    00000000  0000000000000000  0000000000000000   00000053  2**0
             CONTENTS， ALLOC， LOAD， DATA
  2 .bss     00000000  0000000000000000  0000000000000000   00000053  2**0
             ALLOC
</code></pre>
<p><code>.text</code>セクションの<code>File off</code>の欄を見ると❶<code>00000040</code>とあります．
これは<code>.text</code>セクションが<code>add5.o</code>の先頭から16進数で40バイト
目(以後，0x40と表記)にあることを意味しています．</p>
<p><code>od</code>コマンドの<code>-j</code>オプションを使うと，指定したバイト数だけ，
先頭をスキップしてくれます．
この<code>-j</code>オプションを使って，0x40バイトスキップして，
<code>.text</code>セクションの最初だけを16進ダンプします
（<code>head -n3</code>は先頭の3行だけ表示します）．</p>
<pre><code class="language-bash">$ od -t x1 -j0x40 add5.o | head -n3
0000100 ❶f3 0f 1e fa 55 48 89 e5 89 7d fc 8b 45 fc 83 c0
0000120   05 5d c3 00 47 43 43 3a 20 28 55 62 75 6e 74 75
0000140   20 39 2e 34 2e 30 2d 31 75 62 75 6e 74 75 31 7e
</code></pre>
<p>この結果❶を見ると，<code>.text</code>セクションの最初の4バイトは
<code>F3 0F 1E FA</code>であることが分かります．
これは上の<a href="3-binary.html#%E9%80%86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AB%E5%86%8D%E3%81%B3">逆アセンブルの結果</a>の先頭4バイトと一致しており，
<code>endbr64</code>命令が，<code>add5.o</code>の先頭から0x40バイト目に存在することが分かりました．</p>
<h2 id="広義のコンパイル"><a class="header" href="#広義のコンパイル">広義のコンパイルとリンク</a></h2>
<p>ここでは広義のコンパイル，つまりCのプログラム<code>foo.c</code>から
実行可能ファイル<code>a.out</code>を生成する処理の中身を見ていきます．
いちばん大事なのは最後の<strong>リンク</strong>(link)です．</p>
<img src="figs/compile-all.svg" height="300px" id="fig:compile-all">
<ul>
<li>❶ Cの前処理，すなわち<code>#include</code>や<code>#define</code>などの前処理命令の処理と，マクロ（例えば<code>&lt;stdio.h&gt;</code>が定義する<code>NULL</code>や<code>EOF</code>）の展開を行います．<code>gcc -E</code>コマンドで実行できますが，内部的にはカッコ内の<code>cpp</code>や<code>cc1</code>コマンドが実行されています（現在は<code>cc1</code>）．</li>
<li>❷ 狭義のコンパイル処理で，Cのプログラムをアセンブリコードに変換します．</li>
<li>❸ アセンブラ(<code>as</code>コマンド)によるアセンブル処理で，オブジェクトファイル<code>foo.o</code>を生成します．<code>foo.o</code>中にはバイナリの機械語命令が入っています．</li>
<li>❹ <code>foo.o</code>だけでは実行可能ファイルは作れません．例えば，<code>printf</code>などのライブラリ関数の実体は，
<code>libc.a</code>(<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">静的ライブラリ</a>)や<code>libc.so</code>(<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA">動的ライブラリ</a>)の中にあるからです．
また，<code>main</code>関数を呼び出すためのCスタートアップルーチン(多くの場合，<code>crt*.o</code>というファイル名)も必要です．
また，分割コンパイルの機能を使った結果，<code>foo.o</code>は他のC言語のプログラムをアセンブルしたオブジェクトファイル<code>*.o</code>が必要なことがよくあります．
「このような他のバイナリと<code>foo.o</code>を合体させて<code>a.out</code>を生成する処理」のことを<strong>リンク</strong>(link)と呼びます．</li>
</ul>
<p>広義のコンパイルで具体的にどのような処理が行われてるのかを見るには，
<code>-v</code>をつけて<code>gcc -v</code>とコンパイルすれば表示されます．
（以下では表示を省略しています．全てを表示するには<i class="fa fa-eye"></i>ボタンを押して下さい）．</p>
<pre><code class="language-bash">$ gcc -v main.c add5.s |&amp; tee out
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:amdgcn-amdhsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
<span class="boring"> Configured with: ../src/configure -v --with-pkgversion='Ubuntu 11.3.0-1ubuntu1~22.04.1' --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c，ada，c++，go，brig，d，fortran，objc，obj-c++，m2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-11 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --enable-libphobos-checking=release --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --enable-cet --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32，m64，mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-nvptx/usr，amdgcn-amdhsa=/build/gcc-11-aYxV0E/gcc-11-11.3.0/debian/tmp-gcn/usr --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --with-build-config=bootstrap-lto-lean --enable-link-serialization=2
</span><span class="boring"> Thread model: posix
</span><span class="boring"> Supported LTO compression algorithms: zlib zstd
</span><span class="boring"> gcc version 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04.1) 
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/cc1 -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpdir a- -dumpbase main.c -dumpbase-ext .c -mtune=generic -march=x86-64 -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include-fixed&quot;
</span><span class="boring"> ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/11/../../../../x86_64-linux-gnu/include&quot;
</span><span class="boring"> #include &quot;...&quot; search starts here:
</span><span class="boring"> #include &lt;...&gt; search starts here:
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/include
</span><span class="boring">  /usr/local/include
</span><span class="boring">  /usr/include/x86_64-linux-gnu
</span><span class="boring">  /usr/include
</span><span class="boring"> End of search list.
</span><span class="boring"> GNU C17 (Ubuntu 11.3.0-1ubuntu1~22.04.1) version 11.3.0 (x86_64-linux-gnu)
</span><span class="boring"> 	compiled by GNU C version 11.3.0， GMP version 6.2.1， MPFR version 4.1.0， MPC version 1.2.1， isl version isl-0.24-GMP
</span><span class="boring"> 
</span><span class="boring"> GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
</span><span class="boring"> Compiler executable checksum: e13e2dc98bfa673227c4000e476a9388
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/cc5o7Jgg.o /tmp/ccTw9Mym.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a-'
</span><span class="boring">  as -v --64 -o /tmp/ccUs2R16.o add5.s
</span><span class="boring"> GNU assembler version 2.38 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.38
</span><span class="boring"> COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/
</span><span class="boring"> LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/11/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/11/../../../:/lib/:/usr/lib/
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span><span class="boring">  /usr/lib/gcc/x86_64-linux-gnu/11/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/11/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/11/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgnuv0i.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/11/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/11 -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/11/../../.. /tmp/cc5o7Jgg.o /tmp/ccUs2R16.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/11/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/11/../../../x86_64-linux-gnu/crtn.o
</span><span class="boring"> COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' '-dumpdir' 'a.'
</span></code></pre>
<h2 id="バイナリファイルの種類"><a class="header" href="#バイナリファイルの種類">バイナリファイルの種類</a></h2>
<p>実行可能ファイル<code>a.out</code>に関連するバイナリファイルには
以下の4種類があります：</p>
<ul>
<li>オブジェクトファイル(<code>*.o</code>)</li>
<li>実行可能ファイル(<code>a.out</code>)</li>
<li>静的ライブラリファイル(<code>lib*.a</code>)</li>
<li>動的ライブラリファイル(<code>lib*.so</code>)</li>
</ul>
<h3 id="オブジェクトファイル"><a class="header" href="#オブジェクトファイル">オブジェクトファイル(<code>*.o</code>)</a></h3>
<p><strong>オブジェクトファイル</strong>とはLinuxでファイル名の拡張子が<code>.o</code>なファイルです．
オブジェクトファイルは機械語命令を含んでいますが，
このオブジェクトファイル単体では実行することができません．
実行を可能にするには<a href="3-binary.html#%E5%BA%83%E7%BE%A9%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB"><strong>リンク</strong></a>(link)処理を経て，
<a href="3-binary.html#%E5%AE%9F%E8%A1%8C%E5%8F%AF%E8%83%BD%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB"><strong>実行可能ファイル</strong></a>
を作成する必要があります．</p>
<p>オブジェクトファイルは<strong>再配置可能オブジェクトファイル</strong>
(relocatable object file)と呼ばれることもあります．
オブジェクトファイルはリンク時に再配置（アドレス調整）が可能だからです．</p>
<h3 id="実行可能ファイル"><a class="header" href="#実行可能ファイル">実行可能ファイル(<code>a.out</code>)</a></h3>
<p><strong>実行可能ファイル</strong>(executable file)はその名前の通り，OSに実行を依頼すればそのままで実行できるバイナリファイルのことです．
例えば，hello wordの実行可能ファイル<code>a.out</code>はシェル上で以下のように実行できます．</p>
<pre><code class="language-bash">$ ./a.out
hello， world
</code></pre>
<details>
<summary>
シェルとは
</summary>
<p><strong>シェル</strong> (shell)とは「ユーザが入力したコマンドを解釈実行するプログラム」です．
例えば，<code>bash</code>, <code>zsh</code>, <code>csh</code>, <code>sh</code>, <code>ksh</code>, <code>tcsh</code>などはすべてシェルです．
Linux上ではユーザが自由にどのシェルを使うかを選ぶことができます．
シェルという名前は(OSの実体を<strong>カーネル</strong>(核)と呼ぶのに対して)
シェルがユーザに最も近い位置，つまりコンピュータシステムの外殻にあることに
由来してます(シェルの英語の意味は貝殻の殻(から)です)．
シェルは，ユーザが指定した<code>a.out</code>などのプログラムの実行を，
システムコール<code>execve</code>等を使ってOS(カーネル)に依頼します．</p>
<p>ちなみに<strong>ターミナル</strong> (端末，terminal)，あるいはターミナルエミュレータは，
ユーザの入出力処理を行うプログラムであり，ターミナル上でシェルは動作しています．</p>
</details>
<p><code>ls</code>などのシェル上で実行可能なコマンドも実行可能ファイルです．</p>
<pre><code class="language-bash">$ which ls
/usr/bin/ls
$ file /usr/bin/ls
/usr/bin/ls: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， ❶interpreter /lib64/ld-linux-x86-64.so.2， ❷BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd， for GNU/Linux 3.2.0， stripped
$ ls
a.out add5.c add5.o add5.s
</code></pre>
<p id="interpreter">
<details>
<summary>
❶interpreterとは
</summary>
<p>ELFバイナリの動的リンカのことを（なぜか）interpreterと呼びます．
プログラミング言語処理系のインタプリタとは何の関係もありません．
ELFバイナリでは動的リンカのフルパスを指定することができ，
そのフルパス名をバイナリに埋め込みます．
この場合は <code>/lib64/ld-linux-x86-64.so.2</code> が埋め込まれています．
OSが<code>a.out</code>を実行する際に，
OSはまず動的リンカ(interpreter)をメモリにロードして，
ロードした動的リンカに制御を渡します．
動的リンカは<code>a.out</code>中の他の部分や，動的ライブラリをメモリにロードし，
動的リンクを行ってから，<code>a.out</code>の<strong>エントリポイント</strong>
(最初に実行を開始するアドレス)にジャンプします．
その後，いくつかの初期化を行ってから，<code>main</code>関数が呼び出されます．</p>
<p><code>a.out</code>のエントリポイントは<code>readelf -h</code>コマンドで確認できます．
エントリポイントは<code>0x401050</code>番地でした❶．</p>
<pre><code class="language-bash">$ readelf -h ./a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement， little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
❶Entry point address:               0x401050
  Start of program headers:          64 (bytes into file)
  Start of section headers:          16832 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         36
  Section header string table index: 35
</code></pre>
<p>逆アセンブルすると<code>0x401050</code>番地は<code>_start</code>という関数がありました❷．
<code>a.out</code>は<code>_start</code>関数から実行が始まることが分かりました．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep 401050 -A 5
0000000000401050 ❷ &lt;_start&gt;:
  401050:	f3 0f 1e fa          	endbr64 
  401054:	31 ed                	xor    %ebp，%ebp
  401056:	49 89 d1             	mov    %rdx，%r9
  401059:	5e                   	pop    %rsi
  40105a:	48 89 e2             	mov    %rsp，%rdx
  40105d:	48 83 e4 f0          	and    $0xfffffffffffffff0，%rsp
</code></pre>
</details>
</p>
<details>
<summary>
❷BuildID[sha1]とは
</summary>
<p>BuildIDはバイナリファイルが同じかどうかを識別するユニークな番号（背番号）です．
ここでは<code>2f15</code>で始まる40桁の16進数が <code>/usr/bin/ls</code>のBuildIDです．
BuildIDはLinux ELF特有の機能です．
<code>strip</code>してもBuildIDは変化しないので，<code>strip</code>前後のファイルが同じかの確認に使えます．</p>
<pre><code class="language-bash">$ gcc hello.c
$ cp a.out a.out.stripped
$ strip a.out.stripped
$ file a.out a.out.stripped
a.out:          ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
a.out.stripped: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， stripped
</code></pre>
<p>ここでは説明しませんが<a href="./10-gdb.html#core-file"><strong>コアファイル</strong></a> (core file)にもBuildIDが入っており，
そのコアファイルを出力した<code>a.out</code>を探すことができます．</p>
<p>ちなみにsha1はSHA-1を意味しており，SHA-1は160ビットのハッシュを生成するハッシュ関数です．
<code>git</code>のハッシュはSHA-1を使っています．
<code>sha1sum</code>コマンドでSHA-1のハッシュを計算できます．</p>
<pre><code class="language-bash">$ sha1sum ./a.out
ff99525ad6a48d78d35d3108401af935a6ca9bbe  ./a.out
</code></pre>
<p>この結果から分かる通り，BuildIDのハッシュは，単純に<code>a.out</code>から作ったハッシュ値ではありません．
ELFバイナリのヘッダとセクションの一部からハッシュを計算しているようですが，正確な情報は見つかりませんでした(どうやら未公開のようです)．</p>
</details>
<p>実行可能なコマンドには実行可能ファイルではなく，
スクリプトなことがあります．</p>
<pre><code class="language-bash">$ which shasum
/usr/bin/shasum
$ file /usr/bin/shasum
/usr/bin/shasum: Perl script text executable
$ head -3 /usr/bin/shasum
#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+&quot;$@&quot;}'
	if 0; # ^ Run only under a shell
</code></pre>
<p><code>shasum</code>コマンドは(実行可能ファイルではなく)Perlスクリプトでした．</p>
<h3 id="静的ライブラリ"><a class="header" href="#静的ライブラリ">静的ライブラリ(<code>lib*.a</code>)</a></h3>
<p><strong>静的ライブラリ</strong>(static library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
するときに使われるライブラリです．
<strong>ライブラリ</strong>とは複数のオブジェクトファイルを１つのファイルにまとめたもの（<strong>アーカイブ</strong>）です．</p>
<p>LinuxなどのUNIX系のOSでは静的ライブラリのファイル拡張子は<code>.a</code>が多いです．
またWindowsでは<code>.lib</code>です．
<code>printf</code>の実体が入っているC標準ライブラリの
静的ライブラリのファイル名は<code>libc.a</code>です．</p>
<h3 id="動的ライブラリ"><a class="header" href="#動的ライブラリ">動的ライブラリ(<code>lib*.so</code>)</a></h3>
<p><strong>動的ライブラリ</strong>(dynamic library)は<a href="3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>動的リンク</strong></a>
するときに使われるライブラリです．
動的ライブラリは<strong>共有ライブラリ</strong>(shared library)とも呼ばれます．
動的ライブラリは複数のプロセスからメモリ上で共有されるからです．</p>
<p>Linuxでは動的ライブラリのファイル拡張子は<code>.so</code>です(shared objectの略)．
処理系の都合でファイル拡張子に数字がつくことがあります（例：<code>.so.6</code>）．
動的ライブラリのファイル拡張子はUnix系のOSでも様々です．
Windowsでは<code>.dll</code>です．</p>
<h2 id="静的リンクと動的リンク"><a class="header" href="#静的リンクと動的リンク">静的リンクと動的リンク</a></h2>
<p>静的ライブラリは静的リンクに使われるライブラリで，
動的ライブラリは動的リンクに使われるライブラリです．</p>
<h3 id="静的リンク"><a class="header" href="#静的リンク">静的リンク</a></h3>
<p><strong>静的リンク</strong>とは<strong>コンパイル時</strong>にリンクを行う手法です．
仕組みは単純ですが，ファイルやメモリの使用量が増える欠点があります．
<a href="3-binary.html#fig:compile-all">この図</a>で説明したリンクは実は静的リンクでした．</p>
<p>静的リンクしたファイル<code>a.out</code>はリンク済みなので，
ライブラリ関数(例えば<code>printf</code>)の実体も<code>a.out</code>の中に入っています．</p>
<img src="figs/static-link-printf.svg" height="200px" id="fig:static-link-printf">
<p><code>a.out</code>ごとに<code>printf</code>のコピーが作られるので，
ファイルの使用量が無駄に増えてしまいます．
また<code>a.out</code>中の<code>printf</code>は実行時にもメモリ上で<strong>共有されない</strong>ので，
メモリの使用量も無駄に増えてしまいます．</p>
<h3 id="静的リンクでコンパイルしてみる"><a class="header" href="#静的リンクでコンパイルしてみる">静的リンクでコンパイルしてみる</a></h3>
<pre><code class="language-C">// hello.c
#include &lt;stdio.h&gt;
int main (int ac, char **ag)
{
    printf (&quot;hello (%d)\n&quot;, ac);
}
</code></pre>
<p>静的リンクするには<code>-static</code>オプションをつけます（<code>-static</code>無しだと動的リンクになります）．
<code>printf</code>に第2引数を与えているのは，こうしないと，コンパイラが勝手に
<code>printf</code>の呼び出しを<code>puts</code>に変更してしまうことがあるからです．</p>
<p><code>a.out</code>を<code>file</code>コマンドで確認すると<code>statically linked</code>とあり❶，
静的リンクできたことが分かります．</p>
<pre><code class="language-bash">$ gcc -static hello.c
$ file ./a.out
./a.out: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， ❶statically linked， BuildID[sha1]=40fe6c0daaf2d49fabad4d37bc34fcdd12cb8da9， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<details>
<summary>
練習問題：静的にリンクしたa.out中にprintfの実体があることを確認せよ
</summary>
<p><code>a.out</code>を逆アセンブルし，❶<code>&lt;main&gt;:</code>を含む行から15行を表示させます．
(❷<code>-A 14</code>は「マッチした行の後ろ14行も表示する」というオプションです)．
<code>main</code>関数は(<code>printf</code>ではなく)❸<code>_IO_printf</code>を呼び出していることを確認できます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep ❷-A 14 ❶&quot;&lt;main&gt;:&quot;
0000000000401cb5 &lt;main&gt;:
  401cb5:	f3 0f 1e fa          	endbr64 
  401cb9:	55                   	push   %rbp
  401cba:	48 89 e5             	mov    %rsp，%rbp
  401cbd:	48 83 ec 10          	sub    $0x10，%rsp
  401cc1:	89 7d fc             	mov    %edi，-0x4(%rbp)
  401cc4:	48 89 75 f0          	mov    %rsi，-0x10(%rbp)
  401cc8:	8b 45 fc             	mov    -0x4(%rbp)，%eax
  401ccb:	89 c6                	mov    %eax，%esi
  401ccd:	48 8d 3d 30 33 09 00 	lea    0x93330(%rip)，%rdi        # 495004 &lt;_IO_stdin_used+0x4&gt;
  401cd4:	b8 00 00 00 00       	mov    $0x0，%eax
  401cd9:	e8 72 ec 00 00       	callq  410950 ❸&lt;_IO_printf&gt;
  401cde:	b8 00 00 00 00       	mov    $0x0，%eax
  401ce3:	c9                   	leaveq 
  401ce4:	c3                   	retq   
</code></pre>
<blockquote>
<p>注：ここでは<code>egrep -A 14</code>としてますが，皆さんが試す時は，</p>
<pre><code class="language-bash">$ objdump -d ./a.out | less
</code></pre>
<p>としてから，<code>/&lt;main&gt;:</code>とリターンを入力して検索する方が便利でしょう．</p>
</blockquote>
<p>次に同じく<code>a.out</code>を逆アセンブルし，`&lt;_IO_printf&gt;:'を含む行から数行を表示させます．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;_IO_printf&gt;:&quot;
0000000000410950 &lt;_IO_printf&gt;:
  410950:	f3 0f 1e fa          	endbr64 
  410954:	48 81 ec d8 00 00 00 	sub    $0xd8，%rsp
  41095b:	49 89 fa             	mov    %rdi，%r10
  41095e:	48 89 74 24 28       	mov    %rsi，0x28(%rsp)
  410963:	48 89 54 24 30       	mov    %rdx，0x30(%rsp)
</code></pre>
<p>これは<code>_IO_printf</code>の定義なので，<code>a.out</code>に<code>printf</code>の実体があることを確認できました．
なお，以下の<code>nm</code>コマンドでも，<code>a.out</code>に<code>printf</code>の実体があることを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep _IO_printf
0000000000410950 T _IO_printf
</code></pre>
<p>実は<code>_IO_printf</code>も<code>printf</code>も実体は同じです．処理系の都合で，
「実体は同じだけど別の名前をつける」ことがあり，それをエイリアス（別名）といいます．
0x410950番地で調べると，これを確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 410950
0000000000410950 T _IO_printf
0000000000410950 T __printf
0000000000410950 T printf
</code></pre>
</details>
<h3 id="動的リンク"><a class="header" href="#動的リンク">動的リンク</a></h3>
<p><strong>動的リンク</strong>とは実行を始める際の<strong>ロード時</strong>（<code>a.out</code>をメモリにコピーする時）
あるいは<strong>実行途中</strong>にメモリ上でリンクを行う手法です．
現在ではファイルやメモリの消費量を抑えるため，デフォルトで動的リンクが使われることが多いです．</p>
<p>動的リンクしたファイル<code>a.out</code>には
「ライブラリ関数(例えば<code>printf</code>)とのリンクが必要だよ」という
小さな参照情報だけが入っており，<code>printf</code>の実体は入っていません．
実際のリンクは実行時にメモリ上で行います．</p>
<img src="figs/dynamic-link-printf.svg" height="200px" id="fig:dynamic-link-printf">
<p><code>a.out</code>には<code>printf</code>を含まないので，ファイルの使用量を抑えられます．
また<code>a.out</code>中の<code>printf</code>は実行時にはメモリ上で<strong>共有される</strong>ので，
メモリの使用量も抑えられます．</p>
<p>ファイルサイズを比較してみると，静的リンクした<code>a.out-static</code>は約870KB，
動的リンクした<code>a.out-dynamic</code>は約17KBで，50倍ものサイズ差がありました．</p>
<pre><code class="language-bash">$ gcc -static -o a.out-static hello.c
$ gcc -o a.out-dynamic hello.c
$ ls -l a.out*
-rwxrwxr-x 1 gondow gondow  16696 Jul 20 17:52 a.out-dynamic
-rwxrwxr-x 1 gondow gondow 871832 Jul 20 17:51 a.out-static
</code></pre>
<h3 id="動的リンクでコンパイルしてみる"><a class="header" href="#動的リンクでコンパイルしてみる">動的リンクでコンパイルしてみる</a></h3>
<p>Linuxでは<code>-static</code>オプションをつけなければ動的リンクになります．</p>
<pre><code class="language-bash">$ gcc hello.c
$ file a.out
a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=308260da4f7fb6d4116c12670adf6e503637abba， for GNU/Linux 3.2.0， not stripped
$ ./a.out
hello (1)
</code></pre>
<p>実行時にリンクが必要な動的ライブラリの情報は<code>ldd</code>コマンドで表示できます．</p>
<pre><code class="language-bash">$ ldd ./a.out
	❶linux-vdso.so.1 (0x00007ffd21638000)
	❷libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcfef5c1000)
	❸/lib64/ld-linux-x86-64.so.2 (0x00007fcfef7d8000)

</code></pre>
<p>この<code>a.out</code>は<code>linux-vsdo.so.1</code>，<code>libc.so.6</code>，<code>ld-linux-x86-64.so.2</code>という
3つの動的ライブラリと実行時にリンクする必要があることを表示しています．
<code>libc.so.6</code>は（<code>LD_LIBRARY_PATH</code>などの設定がなければ）
絶対パス<code>/lib/x86_64-linux-gnu/libc.so.6</code>とリンクされます．</p>
<details>
<summary>
❶linux-vdso.so.1とは
</summary>
<p>vDSO (virtual dynamic shared objectの略)で，カーネル空間で実行する必要が無い
システムコール(例えば<code>gettimeofday</code>)を高速に実行するための仕組みです．</p>
<ul>
<li><a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></li>
</ul>
</details>
<details>
<summary>
❷libc.so.6とは
</summary>
<p>C標準ライブラリが入った動的ライブラリです．
<code>nm -D</code>コマンドで調べると，<code>printf</code>の実体が入っていることが分かります．
(<code>-D</code>は共有ライブラリで使われる動的シンボルを表示させるオプションです）</p>
<pre><code class="language-bash">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | egrep ' T printf'
0000000000061c90 T printf
0000000000061100 T printf_size
0000000000061bb0 T printf_size_info
</code></pre>
<p><code>-D</code>オプションをつけないと「❶シンボルが無いよ」と言われてしまいます．
(動的シンボル以外は<code>strip</code>されているからです)</p>
<pre><code class="language-bash">$ nm /lib/x86_64-linux-gnu/libc.so.6
nm: /lib/x86_64-linux-gnu/libc.so.6: ❶no symbols
</code></pre>
</details>
<details>
<summary>
❸ld-linux-x86-64.so.2とは
</summary>
<p>動的リンクを行うプログラム（共有ライブラリ），つまり動的リンカです．
<a href="3-binary.html#interpreter">interpreterとは</a>も参照下さい．</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">man ld-linux.so</a></li>
</ul>
</details>
<details id="LD_LIBRARY_PATH">
<summary>
LD_LIBRARY_PATHとは
</summary>
<p><code>a.out</code>実行時には，
動的リンカは動的ライブラリをある手順に従って検索します（詳細は<code>man ld</code>）．
通常はデフォルトのパス（<code>/lib</code>や<code>/usr/lib</code>など）にある動的ライブラリを使いますが，
環境変数<code>LD_LIBRARY_PATH</code>にディレクトリ（複数ある場合は
コロン<code>:</code>で区切る）をセットすることで検索パスを追加できます．
具体的には，
動的リンカは<code>LD_LIBRARY_PATH</code>で指定したディレクトリを
（デフォルトの検索パスよりも先に）検索し，
そこにある動的ライブラリを優先的に使います．
（<a href="3-binary.html#LD_RUN_PATH"><code>LD_RUN_PATH</code></a>も参照下さい）．</p>
</details>
<details>
<summary>
練習問題：動的にリンクしたa.out中にprintfの実体が無いことを確認せよ
</summary>
<p><code>nm</code>コマンドで<code>a.out</code>には<code>main</code>を始めごく少数の
関数しか定義しておらず，その中に<code>printf</code>は入っていないことが以下で確認できます．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep ' T '
00000000000011f8 T _fini
00000000000011f0 T __libc_csu_fini
0000000000001180 T __libc_csu_init
0000000000001149 T main
0000000000001060 T _start
</code></pre>
<p>また<code>nm</code>の出力を<code>printf</code>で検索すると，GLIBC中の<code>printf</code>への参照はあるが
<code>a.out</code>中では未定義(<code>U</code>)となっていることが分かります．</p>
<pre><code class="language-bash">$ nm ./a.out | egrep 'printf'
                 U printf@@GLIBC_2.34
</code></pre>
<div  id="GOT-PLT">
<p>なお逆アセンブルすると<code>&lt;printf@plt&gt;</code>という小さな関数が見つかりますが，
これは<code>printf</code>の実体ではありません．</p>
<pre><code class="language-bash">$ objdump -d ./a.out | egrep -A 5 &quot;&lt;printf&quot;
0000000000001050 &lt;printf@plt&gt;:
    1050:	f3 0f 1e fa          	endbr64 
    1054:	f2 ff 25 75 2f 00 00 	bnd jmpq ❶*0x2f75(%rip)        # 3fd0 &lt;printf@GLIBC_2.34&gt;
    105b:	0f 1f 44 00 00       	nopl   0x0(%rax，%rax，1)
</code></pre>
<p><code>&lt;printf@plt&gt;</code>は<code>printf</code>を呼び出す単なる踏み台で，
PLT (procedure linkage table)という仕組みです．
PLTは<code>printf</code>の最初の呼び出しまで<code>printf</code>の<strong>アドレス解決</strong>
(address resolution)を遅延します．具体的には次の2ステップになります．</p>
<ul>
<li><code>printf@plt</code>の間接ジャンプ先❶の初期値は「動的リンクする関数（動的リンカ）」になっているため，最初に<code>printf@plt</code>が呼ばれると，動的リンクを行い，その結果，間接ジャンプ先が「<code>printf</code>の実体」に変更されます❷．
そして動的リンカは何もなかったかのように<code>printf</code>を呼び出します．
（ちなみに<code>printf@plt</code>の間接ジャンプで参照するメモリ領域は GOT (global offset table)と呼ばれます）</li>
<li>その結果，2回目以降の以下の間接ジャンプ❶では(動的リンカを経由せずに)<code>printf</code>が呼ばれます．</li>
</ul>
<p>つまり，GOTに<code>printf</code>のアドレスを格納することが，ここではアドレス解決になっています．</p>
<img src="figs/plt-printf.svg" height="400px" id="fig:plt-printf">
</div>
</details>
<h3 id="静的ライブラリを作成してみる"><a class="header" href="#静的ライブラリを作成してみる">静的ライブラリを作成してみる</a></h3>
<p id="main.c-static">
<pre><code class="language-C">// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main (void)
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
</p>
<p id="add5.c-static">
<pre><code class="language-C">// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ ar rcs libadd5.a add5.o  ❶
$ ar t libadd5.a
add5.o  ❷
$ file libadd5.a
libadd5.a: current ar archive
$ gcc ❸-static -o a.out-static main.c ❹-L. ❺-ladd5
$ file a.out-static
file ./a.out-static
./a.out-static: ELF 64-bit LSB executable， x86-64， version 1 (GNU/Linux)， statically linked， BuildID[sha1]=1bf84a77504302513d6219e4b27316309d08ed2d， for GNU/Linux 3.2.0， not stripped
$ ./a.out-static 
15 ❻
</code></pre>
<ul>
<li>❶ <code>ar rcs</code>コマンドで<code>add5.o</code>から<code>libadd5.a</code>を作成します．</li>
<li>❷  <code>ar t</code>コマンドで<code>libadd5.a</code>の中身を調べます．中身は<code>add5.o</code>だけでした．</li>
<li>❸❹❺ <code>gcc</code>で<code>main.c</code>と<code>libadd5.a</code>を静的リンクします．
静的リンクするために❸<code>-static</code>オプションが必要です．
<code>libadd5.a</code>がカレントディレクトリにあることを伝えるために❹<code>-L.</code>が必要です．
静的リンクする静的ライブラリが<code>libadd5.a</code>であることを伝えるために
❺<code>-ladd5</code>が必要です．（前の<code>lib</code>と後の<code>.a</code>は自動的に付加されます）</li>
<li>❻ 実行してみると，静的ライブラリ<code>libadd5.a</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<h3 id="動的ライブラリを作成してみる"><a class="header" href="#動的ライブラリを作成してみる">動的ライブラリを作成してみる</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．</p>
<pre><code class="language-bash">$ gcc -c add5.c   
$ gcc ❶-fPIC ❷-shared -o libadd5.so add5.o
$ file libadd5.so
libadd5.so: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， BuildID[sha1]=415ef51f32145b59c51e836a25959f0f66039768， not stripped
$ gcc main.c -ladd5 -L. ❸-Wl，-rpath .
$ file ./a.out
./a.out: ELF 64-bit LSB shared object， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=a5d4f8ef61cef4e0b063376333f07170d312c546， for GNU/Linux 3.2.0， not stripped
$ ldd ./a.out
	linux-vdso.so.1 (0x00007ffff7fcd000)
	libadd5.so =&gt; ❹./libadd5.so (0x00007ffff7fbd000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7dad000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7fcf000)
$ ./a.out
15 ❺ 
</code></pre>
<ul>
<li>❶❷ <code>add5.c</code>から動的ライブラリ<code>libadd5.so</code>を作ります．
<code>libadd5.so</code>を<strong>位置独立コード</strong>(PIC)にするために，❶<code>-fPIC</code>が必要です．
<code>libadd5.so</code>を<strong>共有オブジェクト</strong>(shared object)にするために，❷<code>-shared</code>が必要です．</li>
<li>❸ <code>gcc</code>で<code>main.c</code>と<code>libadd5.so</code>を動的リンクします．
実行時に動的ライブラリを探索するパスを❸<code>-Wl，-rpath .</code>で指定しています．
ここでは<code>libadd5.so</code>をカレントディレクトリに置いているためです．
（セキュリティ上，実際に使う際は絶対パスを指定する方が安全でしょう）．
ちなみに<code>-Wl，-rpath .</code>を<code>gcc</code>に指定すると，
<a href="https://man7.org/linux/man-pages/man1/ld.1.html"><code>ld</code>コマンド</a>
に<code>-rpath .</code>というオプションが渡されます	．</li>
<li>❹ <code>ldd</code>コマンドで調べると，<code>a.out</code>中の<code>libadd5.so</code>は
<code>./libadd5.so</code>を参照していることを確認できました．</li>
<li>❺ 実行してみると，動的ライブラリ<code>libadd5.so</code>中の<code>add5</code>関数を呼び出せました．</li>
</ul>
<details ID="LD_RUN_PATH">
<summary>
-rpath，LD_RUN_PATH，LD_LIBRARY_PATH
</summary>
<p>❸<code>-Wl，-rpath .</code>はコンパイル時に「動的ライブラリの検索パス」を<code>a.out</code>中に埋め込みます．
以下のコマンド等で確認できます（❻の部分）．</p>
<pre><code>$ readelf -d ./a.out | egrep PATH
 0x000000000000001d (RUNPATH)            Library runpath: ❻[.]
</code></pre>
<p><code>-Wl，-rpath .</code>で指定する検索パスは環境変数<code>LD_RUN_PATH</code>でも指定できます．
（複数の検索パスはコロン<code>:</code>で区切ります）．</p>
<pre><code>$ export LD_RUN_PATH=&quot;.&quot;
$ gcc main.c -ladd5 -L. 
$ readelf -d ./a.out | egrep PATH
 0x000000000000001d (RUNPATH)            Library runpath: [.]
</code></pre>
<p><a href="3-binary.html#LD_LIBRARY_PATH"><code>LD_LIBRARY_PATH</code></a>を使うと，
<code>a.out</code>中の検索パス以外の動的ライブラリを実行時に動的リンクできます．
例えば，以下で<code>ldd</code>コマンドを使うと，
<code>/tmp/libadd5.so</code>が使われることを確認できます❼．</p>
<pre><code>$ export LD_LIBRARY_PATH=&quot;/tmp&quot;
$ cp libadd5.so /tmp
$ ldd ./a.out
	libadd5.so =&gt; ❼/tmp/libadd5.so (0x00007ffffffb8000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fffffd8b000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffffffc4000)
</code></pre>
<p>なお<code>LD_LIBRARY_PATH</code>は危険で強力なので，なるべく使うのは避けるべきです．
使う場合は最新の注意を払って使いましょう．
なぜならば，例えば，<code>/tmp/libc.so.6</code>という悪意のある動的ライブラリがあると，
<code>/tmp/libc.so.6</code>中の<code>printf</code>が呼び出されてしまうからです．
（この<code>printf</code>の中身はコンピュータウイルスかも知れません）</p>
</details>
<details id="PIC">
<summary>
位置独立コードとは
</summary>
<p><strong>位置独立コード</strong>(position independent code， PIC)とはメモリ上の
どこにロードしても，そのまま実行できるコードです．
位置独立コードでは絶対アドレスは使わず（再配置が必要になってしまうから），
相対アドレスか間接アドレス参照だけを使います．
位置独立コードにすることで，メモリ上で動的ライブラリを共有できるため，
メモリ使用量を抑えることができます．</p>
</details>
<h2 id="デバッグ情報"><a class="header" href="#デバッグ情報">デバッグ情報</a></h2>
<h3 id="デバッグ情報とは"><a class="header" href="#デバッグ情報とは">デバッグ情報とは</a></h3>
<p><strong>デバッグ情報</strong>とは<code>gcc</code>に<code>-g</code>オプションをつけると
バイナリに付加される情報で，
デバッグ時に有用なソースコード中の情報を含んでいます．
例えば，変数の型情報や，ソースコード中の行番号が挙げられます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ file ./a.out
./a.out: ELF 64-bit LSB pie executable， x86-64， version 1 (SYSV)， dynamically linked， interpreter /lib64/ld-linux-x86-64.so.2， BuildID[sha1]=68a01f5977ae542600062913c447a7ba7f2fad62， for GNU/Linux 3.2.0， ❷ with debug_info， not stripped
</code></pre>
<p>❶<code>-g</code>オプションをつけてコンパイルしてから，<code>file</code>コマンドで調べると，
❷デバッグ情報が含まれていることを確認できます．</p>
<p>コンパイラは様々なデバッグ情報の形式を扱えます．
LinuxのELFバイナリでは<a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARFデバッグ情報</a>
が使われることが多いです．(以下，DWARFを前提として説明します)</p>
<h3 id="no-debug-info"><a class="header" href="#no-debug-info">デバッグ情報が無いと，デバッガでファイル名や行番号が表示されない</a></h3>
<p>デバッグ情報無しでデバッガ<code>gdb</code>を使うとどうなるか試してみましょう．
<a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>は
前節と同じものを使います．
(<code>gdb</code>の使い方の詳細は<a href="./10-gdb.html">デバッガgdbの使い方</a>を参照下さい)．</p>
<pre><code class="language-bash">$ gcc ❶ main.c add5.c
$ gdb ./a.out
(gdb) ❷ b add5
Breakpoint 1 at 0x1175
(gdb) ❸ r
Starting program: /tmp/a.out 
Breakpoint 1， 0x0000555555555175 in ❹ add5 ()
(gdb) bt
#0 ❻ 0x0000555555555175 in ❺ add5 ()
#1    0x000055555555515b in    main ()
(gdb) quit
</code></pre>
<p><code>-g</code>オプション無しで❶コンパイルしています．
<code>add5</code>関数にブレークポイントを設定❷します．
<strong>ブレークポイント</strong>とはプログラムの実行を一時的に停止する場所です．
関数名<code>add5</code>でブレークポイントを指定したので，
実行すると<code>add5</code>関数の先頭で実行が一時停止します．</p>
<p>❸ runコマンド (<code>r</code>はrunコマンドの省略形)で実行した所，
<code>add5</code>関数でブレーク(実行を一時停止)できたのですが，
関数名<code>add5</code>だけが表示され，<strong>ファイル名や行番号が表示されません</strong>❹．
バックトレースを出力しても同様です❺．</p>
<p>バックトレースとは「<code>main</code>関数から現在実行中の関数までの，
関数呼び出し系列」のことです．
ここでは<code>main</code>関数が<code>add5</code>関数を呼び出しただけなので，
バックトレースは2行しかありません．
❻<code>0x0000555555555175</code>は<code>add5</code>関数が
<code>0x0000555555555175</code>番地の機械語命令を実行する直前で実行を停止していることを
示しています．</p>
<h3 id="デバッグ情報があるとデバッガでファイル名や行番号が表示される"><a class="header" href="#デバッグ情報があるとデバッガでファイル名や行番号が表示される">デバッグ情報があると，デバッガでファイル名や行番号が表示される</a></h3>
<p>今回はデバッグ情報ありでデバッガを使ってみます．</p>
<pre><code class="language-bash">$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1175: ❷ file add5.c， line 2.
(gdb) r
Starting program: /tmp/a.out 
Breakpoint 1， add5 (n=10) at ❸ add5.c:2
2	{
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:2
#1  0x000055555555515b in main () at main.c:5

$ gcc ❶ -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: ❷ file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at ❸ add5.c:3
3	    return n + 5;
(gdb) bt
#0  add5 (n=10) at ❹ add5.c:3
#1  0x000055555555515b in main () at main.c:5
</code></pre>
<ul>
<li>❶ <code>-g</code>をつけたので，<code>a.out</code>にはデバッグ情報が付加されています．</li>
<li><a href="3-binary.html#no-debug-info">先程</a>とは異なり，❷❸❹ファイル名<code>add5.c</code>や行番号<code>3</code>が付加されています．</li>
</ul>
<h3 id="デバッグ情報があると行番号とアドレスを相互変換できる"><a class="header" href="#デバッグ情報があると行番号とアドレスを相互変換できる">デバッグ情報があると，行番号とアドレスを相互変換できる．</a></h3>
<h4 id="addr2line"><a class="header" href="#addr2line">アドレス→行番号の変換</a></h4>
<p>デバッグ情報があるバイナリに対しては，
<code>addr2line</code>コマンドでアドレスを対応する行番号に変換できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ objdump -d ./a.out | egrep -A 4 &quot;&lt;main&gt;:&quot;
0000000000001149 &lt;main&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp，%rbp
    1151:	bf 0a 00 00 00       	mov    $0xa，%edi
$  addr2line -e ./a.out ❶ 0x1149
❷/tmp/main.c:4
</code></pre>
<p>上の実行例では<code>addr2line</code>コマンドで，
<code>0x1149</code>番地の機械語命令はソースコードでは❷<code>/tmp/main.c</code>の4行目に
対応していることが分かりました．</p>
<p>デバッガ上でも確かめてみましょう．</p>
<pre><code>(gdb) b main
Breakpoint 1 at 0x1151: file main.c， line 5.
(gdb) r
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
(gdb) ❶ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
(以下略)
(gdb) ❷ info line *0x0000555555555149 
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
(gdb) ❸ info line main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x555555555149 &lt;main&gt;
   and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<ul>
<li>(objdumpコマンドでも可能ですが)
<code>gdb</code>上でも逆アセンブルできます．
逆アセンブルのコマンドは<code>disassemble</code>ですが長いので，
短縮名<code>disas</code>をここでは使っています．
(<code>gdb</code>は他のコマンドと区別できる範囲で，コマンド名を省略できます)．
<a href="3-binary.html#ASLR-PIE">ASLRとPIE</a>が有効な場合，
デバッガ上で逆アセンブルすると，実際のメモリのアドレスが表示されて便利です．
この場合，<a href="3-binary.html#addr2line">上</a>では<code>0x1149</code>番地だったのに，
<code>0x0000555555555149</code>番地に変わっています．</li>
<li><code>gdb</code>の❷<code>info line</code>コマンドを使うと，アドレスから行番号に変換できます．
<code>0x555555555149</code>番地は<code>main.c</code>の4行目に対応しており，
また，この行は機械語命令では<code>0x555555555149</code>番地から<code>0x555555555151</code>に
対応していると表示されています．</li>
<li><code>gdb</code>上では❸<code>info line</code>コマンドを使って，
行番号からアドレスへの変換もできます．</li>
</ul>
<p>なお，<code>gdb</code>で<code>layout asm</code>とすると逆アセンブル結果を常に表示できます．
ブレークポイント(左端の<code>b</code>や<code>B</code>)や次に実行する機械語命令の位置(<code>&gt;</code>)が
表示されて分かりやすいです．</p>
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<details>
<summary>
B+ってどういう意味
</summary>
<ul>
<li><code>B</code>は少なくても一度はブレークしたブレークポイント</li>
<li><code>b</code>は一度もブレークしていないブレークポイント</li>
<li><code>+</code>は有効化されているブレークポイント</li>
<li><code>-</code>は無効化されているブレークポイント</li>
</ul>
</details>
<h4 id="行番号アドレスの変換"><a class="header" href="#行番号アドレスの変換">行番号→アドレスの変換</a></h4>
<p>コマンドライン上で，行番号をアドレスに変換するには
(コマンドがちょっと長くなりますが)以下のように<code>gdb</code>を使います．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;info line main.c:4&quot; --batch
Line 4 of &quot;main.c&quot; starts at address ❶0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<p>上ではプログラムを実行せずにアドレスを取得したので，
<code>a.out</code>ファイル中のアドレス❶<code>0x1149</code>が表示されています．
実行時のアドレスを表示したいなら，以下のようにします
(バッチモードで，<code>b main</code>，<code>run</code>，<code>info line main.c:4</code>という3つのコマンドを実行しています)．
実行時のアドレス❷<code>0x555555555149</code>を表示できました．</p>
<pre><code class="language-bash">$ gdb ./a.out -ex &quot;b main&quot; -ex &quot;r&quot; -ex &quot;info line main.c:4&quot; --batch
Breakpoint 1， main () at main.c:5
5	    printf (&quot;%d\n&quot;， add5 (10));
Line 4 of &quot;main.c&quot; starts at address ❷0x555555555149 &lt;main&gt; and ends at 0x555555555151 &lt;main+8&gt;.
</code></pre>
<p>以下のように<code>line2addr</code>などの名前でシェル関数を定義すれば，
短く書けます(が，そんなに頻繁には使わないかも)．</p>
<pre><code class="language-bash">$ function line2addr () {
&gt; command gdb $1 -ex &quot;info line $2&quot; --batch
&gt; }
$ line2addr ./a.out main.c:4
Line 4 of &quot;main.c&quot; starts at address 0x1149 &lt;main&gt; and ends at 0x1151 &lt;main+8&gt;.
</code></pre>
<h3 id="デバッグ情報があると逆アセンブル時にソースコードも表示できる"><a class="header" href="#デバッグ情報があると逆アセンブル時にソースコードも表示できる">デバッグ情報があると，逆アセンブル時にソースコードも表示できる</a></h3>
<p>デバッグ情報がある場合，
(<code>objdump -d</code>ではなく)<code>objdump -S</code>で逆アセンブルすると
ソースコードも表示できます．
❶関数<code>add5</code>の定義部分であること，
❷<code>return n + 5;</code>の行のコンパイル結果であること，
などが見やすくなります．</p>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ objdump -S ./add5.o
./add5.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;add5&gt;:
❶ int add5 (int n)
{
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp，%rbp
   8:	89 7d fc             	mov    %edi，-0x4(%rbp)
 ❷ return n + 5;
   b:	8b 45 fc             	mov    -0x4(%rbp)，%eax
   e:	83 c0 05             	add    $0x5，%eax
}
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    
</code></pre>
<h3 id="デバッガでレジスタの値を確認する"><a class="header" href="#デバッガでレジスタの値を確認する">デバッガでレジスタの値を確認する</a></h3>
<p>デバッガでレジスタの値を確認できます．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./aout
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) p ❶ $rdi
$1 = 10
(gdb) ❷ info reg
Undefined info command: &quot;regs&quot;.  Try &quot;help info&quot;.
(gdb) info reg
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffe048      140737488347208
rsi            0x7fffffffe038      140737488347192
rdi            0xa                 10
(以下略，qを押して表示を停止)
</code></pre>
<ul>
<li>❶ <code>gdb</code>では<code>%</code>ではなく<code>$</code>をつけてレジスタ名を指定します．
<code>p</code>は<code>print</code>コマンドの省略名です．<code>%rdi</code>の値が<code>10</code>であることが分かりました．
16進数で表示したい場合は，<code>p/x $rdi</code>と<code>/x</code>をつけます</li>
<li>❷ レジスタの値一覧は<code>info reg</code>で表示できます．ページャが起動されるので，<code>q</code>を押して表示を停止します．</li>
</ul>
<p><code>gdb</code>で<code>layout regs</code>とすると，レジスタの値を常に表示できます．</p>
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
<ul>
<li><code>layout regs</code>するとレジスタの値一覧が表示されます．
上から「レジスタ表示」「ソースコード表示」「コマンド入力」のためのウィンドウです．</li>
<li><code>focus regs</code>や，<code>ctrl-x o</code>などを入力すると，レジスタ表示ウィンドウが選択されます．
この状態で↓キーを押すと(あるいはマウスでスクロールされると）
レジスタ表示ウィンドウの表示をスクロールできます．</li>
<li><code>ctrl-x a</code>を入力すると，元の表示方法に戻ります．</li>
</ul>
<h3 id="デバッガでメモリの値を確認する"><a class="header" href="#デバッガでメモリの値を確認する">デバッガでメモリの値を確認する</a></h3>
<p><a href="3-binary.html#add5.c-static"><code>add5.c</code></a>と<a href="3-binary.html#main.c-static"><code>main.c</code></a>を
を実行し，<code>add5</code>関数のスタックフレームが作成された直後は
以下の図(<a href="./2-asm-intro.html#create-new-stack-frame">ここ</a>で使った図の再掲)
になっています．</p>
<img src="figs/stack-frame4-4.svg" height="143px" id="fig:stack-frame4-4">
<p>これをデバッガで確認しましょう．</p>
<pre><code class="language-bash">$ gcc -g main.c add5.c
$ gdb ./a.out
(gdb) b add5
Breakpoint 1 at 0x1183: file add5.c， line 3.
(gdb) r
Breakpoint 1， add5 (n=10) at add5.c:3
3	    return n + 5;
(gdb) disas
Dump of assembler code for function add5:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    %edi，-0x4(%rbp)
=&gt; 0x0000555555555183 &lt;+11&gt;:	mov    -0x4(%rbp)，%eax
   0x0000555555555186 &lt;+14&gt;:	add    $0x5，%eax
   0x0000555555555189 &lt;+17&gt;:	pop    %rbp
   0x000055555555518a &lt;+18&gt;:	ret    
(gdb) ❶ p/x $rsp
$1 = 0x7fffffffdf10
(gdb) ❷ p/x $rbp
$2 = 0x7fffffffdf10
(gdb) ❸ x/1gx 0x7fffffffdf10
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❹ x/1gx $rsp
0x7fffffffdf10:	0x00007fffffffdf20
(gdb) ❺ x/8bx $rsp
0x7fffffffdf10:	0x20 0xdf 0xff 0xff 0xff 0x7f 0x00 0x00
</code></pre>
<ul>
<li>
<p>❶❷ <code>%rsp</code>と<code>%rbp</code>レジスタの値を調べると，どちらも
<code>0x7fffffffdf10</code>番地でした．</p>
</li>
<li>
<p>❸ <code>x/1gx 0x7fffffffdf10</code> はメモリの中身を表示するコマンドです．</p>
<ul>
<li><code>x</code>のコマンド名は examine memory から来ています．</li>
<li><code>/1gx</code>は出力形式を指定しています．
この場合は「8バイトのデータを16進表記で1つ表示」という意味です．</li>
</ul>
</li>
</ul>
<details>
<summary>
xコマンドの表示オプション
</summary>
<p><code>x</code>コマンドの表示オプションには以下があります(他にもあります)．</p>
<ul>
<li><code>x</code>  16進数</li>
<li><code>d</code>  符号あり10進数</li>
<li><code>u</code>  符号なし10進数</li>
<li><code>t</code>   2進数</li>
<li><code>c</code>  文字</li>
<li><code>s</code>  文字列</li>
</ul>
<p>データのサイズ指定には以下があります．</p>
<ul>
<li><code>b</code>  1バイト (byte)</li>
<li><code>h</code>  2バイト (halfword)</li>
<li><code>w</code>  4バイト (word)</li>
<li><code>g</code>  8バイト (giant)</li>
</ul>
</details>
<details>
<summary>
サイズの用語がバラバラ過ぎる！
</summary>
<p>以下の通り，GNUアセンブラ(AT&amp;T形式)，Intel形式，<code>gdb</code>で各サイズに対する
用語がバラバラです．混乱しやすいので要注意です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1バイト</th><th>2バイト</th><th>4バイト</th><th>8バイト</th></tr></thead><tbody>
<tr><td>GNUアセンブラ</td><td>byte (b)</td><td>short (s)</td><td>long (l)</td><td>quad (q)</td></tr>
<tr><td>Intel形式</td><td>byte</td><td>word</td><td>double word (dword)</td><td>quad word (qword)</td></tr>
<tr><td><code>gdb</code></td><td>byte (b)</td><td>halfword (h)</td><td>word (w)</td><td>giant (g)</td></tr>
</tbody></table>
</div></details>
<ul>
<li>❹ 具体的なアドレス(ここでは<code>0x7fffffffdf10</code>)ではなく，
レジスタ名 (ここでは<code>$rsp</code>)を指定して，
　そのレジスタが指しているメモリの中身を表示できます．</li>
<li>❺ <code>/1gx</code>ではなく<code>/8bx</code>と表示形式を指定すると，
「1バイトのデータを16進表記で8個表示」という意味になります．
<code>0x7FFFFFFFDF10</code>から<code>0x7FFFFFFFDF17</code>までの各番地には，それぞれ，
以下の図の通り，
<code>0x20</code>，<code>0xDF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0xFF</code>，<code>0x7F</code>，<code>0x00</code>，<code>0x00</code>という値が
メモリ中に入っていることが分かります．
この格納されている8バイトのデータ<code>0x00007fffffffdf20</code>はアドレスであり，
以下の図の一番下のアドレス(赤字の部分)を指しています．</li>
</ul>
<img src="figs/stack-add5-layout.svg" height="350px" id="fig:stack-add5-layout">
<pre><code>(上のデバッグの続き)
(gdb) ❻ x/1gx $rsp+8
0x7fffffffdf18:	0x000055555555515b
(gdb) ❼ x/8bx $rsp+8
0x7fffffffdf18:	0x5b	0x51	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) ❽ disas 0x000055555555515b
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp，%rbp
   0x0000555555555151 &lt;+8&gt;:	mov    $0xa，%edi
   0x0000555555555156 &lt;+13&gt;:	call   0x555555555178 &lt;add5&gt;
❾ 0x000055555555515b &lt;+18&gt;:	mov    %eax，%esi
   0x000055555555515d &lt;+20&gt;:	lea    0xea0(%rip)，%rax        # 0x555555556004
   0x0000555555555164 &lt;+27&gt;:	mov    %rax，%rdi
   0x0000555555555167 &lt;+30&gt;:	mov    $0x0，%eax
   0x000055555555516c &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x0000555555555171 &lt;+40&gt;:	mov    $0x0，%eax
   0x0000555555555176 &lt;+45&gt;:	pop    %rbp
   0x0000555555555177 &lt;+46&gt;:	ret    
End of assembler dump.
</code></pre>
<ul>
<li>❻ <code>x/1gx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスの中身を表示させています．
<code>8(%rsp)</code>の意味は「<code>%rsp</code>の値に8を足したアドレス」です．
<code>gdb</code>中では「<code>$rsp + 8</code>」と入力します．</li>
<li>❼ <code>x/8bx</code>を使って，上の図の<code>8(%rsp)</code>のアドレスを1バイトごとに表示しました．
上記の図の通り， 
<code>0x7FFFFFFFDF18</code>から<code>0x7FFFFFFFDF1F</code>までの各番地には，それぞれ，
<code>0x5B</code>，<code>0x51</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x55</code>，<code>0x00</code>，<code>0x00</code>が
格納されていることが分かりました．</li>
<li>❻の結果で得た<code>0x000055555555515b</code>番地を使って❽逆アセンブルしてみると，
❾この番地は「<code>call add5</code>」の次の命令 (この場合は <code>mov %eax， %esi</code>)であることが
分かりました．
このように，<strong>戻り番地</strong> (return address)は通常，
「その関数を呼び出した<code>call</code>命令の次の命令のアドレス」になります．</li>
</ul>
<details>
<summary>
戻り番地が通常ではない場合って?
</summary>
<p><strong>末尾コール最適化</strong> (tail-call optimization; TCO)が起こった時が該当します．</p>
<form class="tab-wrap">
    <input id="tail-call-opt1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="tail-call-opt1">末尾コール最適化の前</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt1.svg" height="150px" id="fig:tail-call1-opt">
    </div>
    <input id="tail-call-opt2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="tail-call-opt2">末尾コール最適化後</label>
    <div class="tab-content">
    	 <img src="figs/tail-call-opt2.svg" height="140px" id="fig:tail-call-opt2">
    </div>
</form>
<ul>
<li>上の「末尾コール最適化の前」の図では<code>main</code>関数が<code>A</code>を呼び，
関数<code>A</code>が<code>B</code>を呼んでいます．また逆の順番でリターンします．
しかし，<code>call B</code>の次の命令が<code>ret</code> (次の命令❷)になっているため，
関数<code>B</code>からリターンした後，関数<code>A</code>では何もせず，<code>main</code>にリターンしています．</li>
<li>そこで「末尾コール最適化の後」の図のように，関数<code>A</code>中の<code>call</code>命令を
無条件ジャンプ命令 <code>jmp</code>に書き換えて，関数<code>B</code>からは(<code>A</code>を経由せず)
直接，<code>main</code>関数のリターンするように書き換えて無駄なリターンを省くことができます．
これが末尾コール最適化です．</li>
<li>その結果，関数<code>B</code>のリターンアドレスは，関数<code>A</code>中の<code>call</code>命令の次のアドレス
(次の命令❷)ではなく，関数<code>main</code>中の「次の命令❶」となってしまいました．
これが戻り番地が通常ではない場合の一例です．</li>
</ul>
</details>
<h3 id="デバッグ情報を直接見る"><a class="header" href="#デバッグ情報を直接見る">デバッグ情報を直接見る</a></h3>
<p><code>objdump</code>，<code>readelf</code>，<code>llvm_dwarfdump</code>コマンドを使うと，
デバッグ情報の中身を直接見ることができます．</p>
<h4 id="objdump--w"><a class="header" href="#objdump--w"><code>objdump -W</code></a></h4>
<p>デバッグ情報には例えば，以下のものがあります</p>
<ul>
<li>デバッグ情報 (<code>.debug_info</code>)</li>
<li>行情報 (<code>.debug_line</code>)</li>
<li>アドレス情報 (<code>.debug_aranges</code>)</li>
<li>フレーム情報 (<code>.eh_frame</code>)</li>
<li>省略情報 (<code>.debug_abbrev</code>)</li>
</ul>
<p><code>objdump -W add5.o</code> とすると，<code>add5.o</code>中のデバッグ情報を全て表示します
<code>-Wi</code>， <code>-Wl</code>， <code>-Wr</code>， <code>-Wf</code>，<code>-Wa</code>とすると，
それぞれ，デバッグ情報，行情報，アドレス情報，フレーム情報，
省略情報だけを表示できます．</p>
<pre><code class="language-bash">$ objdump -W add5.o | less
add5.o:     file format elf64-x86-64

Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string， offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string， offset: 0x5): add5.c
(以下略)
</code></pre>
<p>上記の出力例では例えば「ファイル名<code>add5.c</code>を省略番号<code>1</code>とします」という情報を含んでいます（詳細は省略し．
<strong>コンパイル単位</strong> (compile unit)とはファイルのことです．</p>
<p>例えば，以下の部分は
仮引数の情報として「変数名は❻<code>n</code>，
❷<code>add5.c</code>の❸1行目❹15カラム目で宣言されていて，
型は❺<code>&lt;0x5e&gt;</code>を見てね．変数の場所は❻<code>(DW_OP_fbreg: -20)</code>」となってます．</p>
<pre><code>&lt;2&gt;&lt;50&gt;: Abbrev Number: 3 (DW_TAG_formal_parameter)
    &lt;51&gt;   DW_AT_name        : ❶ n
    &lt;53&gt;   DW_AT_decl_file   : ❷ 1
    &lt;54&gt;   DW_AT_decl_line   : ❸ 1
    &lt;55&gt;   DW_AT_decl_column : ❹ 15
    &lt;56&gt;   DW_AT_type        : ❺ &lt;0x5e&gt;
    &lt;5a&gt;   DW_AT_location    : 2 byte block: 91 6c ❻ (DW_OP_fbreg: -20)
</code></pre>
<details>
<summary>
❻DW_OP_fbreg: -20とは
</summary>
<p>「CFA (canonical frame address)から -20バイトのオフセットの位置」を意味しています．
CFAはDWARFデバッグ情報が定める仮想的なレジスタでCPUごとに異なります．
x86-64の場合は「<code>call</code>命令を実行する直前の<code>%rsp</code>の値」なので，以下になります．
(<code>call</code>命令が戻り番地をスタックにプッシュすることを思い出しましょう)．
引数<code>n</code>(下図で赤い部分)の先頭アドレスは，
CFAからちょうど-20バイトの場所にあることが確認できました．</p>
<img src="figs/stack-layout-CFA.svg" height="400px" id="fig:stack-layout">
<p><a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>でコンパイルされていなければ，
(通常は関数の先頭で<code>push %rbp</code>するので)以下の式が成り立ちます．</p>
<pre><code class="language-math">CFA == %rbp + 16
</code></pre>
<p>なお，<code>fbreg</code> は frame base registerの略だと思います．</p>
</details>
<details>
<summary>
Abbrev Number (省略番号)とは
</summary>
<p>例えば，以下のDIE（<a href="3-binary.html#DIE">デバッグ情報の部品</a>）で Abbrev Number は ❶4となっています．</p>
<pre><code class="language-bash">$ objdump -Wi add5.o
(一部略)
&lt;1&gt;&lt;5e&gt;: Abbrev Number: ❶4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : 4
    &lt;60&gt;   DW_AT_encoding    : 5         (signed)
    &lt;61&gt;   DW_AT_name        : int
</code></pre>
<p><code>objdump -Wa</code>で<code>.debug_abbrev</code>を表示すると4番目のエントリは
以下となっています．つまり，</p>
<ul>
<li>❷4番のAbbrev Number (省略番号)を持つDIEは ❸DW_TAG_base_type である</li>
<li>DW_TAG_base_typeには例えば，❹変数名の情報があり，その型は❺DW_FORM_stringである</li>
</ul>
<p>と分かります．</p>
<pre><code class="language-bash">$ objdump -Wa add5.o
(一部略)
❷4 ❸DW_TAG_base_type    [no children]
    DW_AT_byte_size    DW_FORM_data1
    DW_AT_encoding     DW_FORM_data1
  ❹DW_AT_name       ❺DW_FORM_string
    DW_AT value: 0     DW_FORM value: 0
</code></pre>
<p>要するに<code>.debug_abbrev</code>の情報は<code>.debug_info</code>のメタ情報(型情報)であり，
この場合，4という数字を保持するだけで，
「このDIEはDW_TAG_base_typeである．その内容は…(以下略)」
という情報を持てるのです．</p>
<p>これによりサイズの圧縮が可能になっています．
<code>objdump -W</code>はある程度は散っている情報をまとめて表示していて親切です．</p>
</details>
<details>
<summary>
LEB128とは
</summary>
<p>LEB128 (little endian base 128)は任意の大きさの整数を扱える
可変長の符号化方式です．直感的にはLEB128はUTF-8の整数版です．</p>
<p>LEB128はDWARFやWebAssemblyなどで使われています．
(ですので，DWARFデバッグ情報にはLEB128の符号化が使われている箇所があります．
デバッグ情報の16進ダンプを解析する際は注意しましょう)．</p>
<p>LEB128には符号ありと符号なしの2種類がありますが，以下では符号なしで説明します．</p>
<p>ここでは123456を符号なしLEB128形式に変換します．
結果は最下位バイトから，<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>の3バイトになります．
まず<code>bc</code>コマンドで2進数にします❶．</p>
<pre><code class="language-bash">$ bc
obase=2
123456
❶ 11110001001000000
</code></pre>
<p>次に以下のステップを踏みます．</p>
<form class="tab-wrap">
    <input id="LEB128-1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="LEB128-1">ステップ1</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-1.svg" height="70px" id="fig:LEB128-1">
    </div>
    <input id="LEB128-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-2">ステップ2</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-2.svg" height="70px" id="fig:LEB128-2">
    </div>
    <input id="LEB128-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-3">ステップ3</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-3.svg" height="70px" id="fig:LEB128-3">
    </div>
    <input id="LEB128-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="LEB128-4">ステップ4</label>
    <div class="tab-content">
    	 <img src="figs/LEB128-4.svg" height="85px" id="fig:LEB128-4">
    </div>
</form>
<p>ステップ4の結果を<code>bc</code>コマンドで16進数にします❷．</p>
<pre><code class="language-bash">$ bc
obase=16
ibase=2
000001111100010011000000
❷ 7C4C0
</code></pre>
<p>結果の16進数❷<code>0x7C4C0</code> を1バイトごとに最下位バイトから出力すると，
最終的な結果は<code>0xC0</code>，<code>0xC4</code>，<code>0x07</code>となります．
LEB128の最上位バイトの最上位ビットは必ず0で，
それ以外のバイトはの最上位ビットは1なので，
サイズ情報がなくても，
元の整数に戻す際，どのバイトまで処理すればよいかが分かります．</p>
</details>
<p>型の情報<code>&lt;0x5e&gt;</code>は以下にありました．
「サイズは❼ 4バイト，❽符号あり，型名は❾<code>int</code>」です．</p>
<pre><code>&lt;1&gt;&lt;5e&gt;: Abbrev Number: 4 (DW_TAG_base_type)
    &lt;5f&gt;   DW_AT_byte_size   : ❼ 4
    &lt;60&gt;   DW_AT_encoding    : 5        ❽ (signed)
    &lt;61&gt;   DW_AT_name        : ❾ int
</code></pre>
<div id="DIE">
<p>上記の<code>.debug_info</code>中の情報である，
DW_TAG_formal_parameterやDW_TAG_base_typeなどは
DIE (debug information entry)というデバッグ情報の単位の1つです．
DIEは全体で木構造になっています．</p>
</div>
<img src="figs/DIE-tree.svg" height="150px" id="fig:DIE-tree">
<p>またデバッグ情報情報があちこちに散っています．
例えば，❷「ファイル1」の情報はどこにあるかというと</p>
<pre><code>    &lt;53&gt; ❷ DW_AT_decl_file   : 1
</code></pre>
<p>行情報にありました．
以下でエントリ1の情報を見ると，<code>add5.c</code>と分かりました．</p>
<pre><code class="language-bash">$ objdump -Wl add5.o | less
(中略)
The File Name Table (offset 0x2c, lines 2, columns 2):
  Entry Dir     Name
  0     0       (indirect line string, offset: 0x11): add5.c
  1     0       (indirect line string, offset: 0x18): add5.c
</code></pre>
<h4 id="readelf"><a class="header" href="#readelf"><code>readelf</code></a></h4>
<p><code>readelf</code>コマンドでも<code>objdump</code>と同様にDWARFデバッグ情報を表示できます．
以下は実行例です．</p>
<pre><code class="language-bash">$ readelf -wi ./add5.o
Contents of the .debug_info section:

  Compilation Unit @ offset 0x0:
   Length:        0x62 (32-bit)
   Version:       5
   Unit Type:     DW_UT_compile (1)
   Abbrev Offset: 0x0
   Pointer Size:  8
 &lt;0&gt;&lt;c&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)
    &lt;d&gt;   DW_AT_producer    : (indirect string, offset: 0x5): GNU C17 11.3.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection
    &lt;11&gt;   DW_AT_language    : 29       (C11)
    &lt;12&gt;   DW_AT_name        : (indirect line string, offset: 0x5): add5.c
    &lt;16&gt;   DW_AT_comp_dir    : (indirect line string, offset: 0x0): /tmp
    &lt;1a&gt;   DW_AT_low_pc      : 0x0
    &lt;22&gt;   DW_AT_high_pc     : 0x13
    &lt;2a&gt;   DW_AT_stmt_list   : 0x0
(以下略)
</code></pre>
<h2 id="メモリマップを見る"><a class="header" href="#メモリマップを見る">メモリマップを見る</a></h2>
<h3 id="pmapコマンドでメモリマップを見る"><a class="header" href="#pmapコマンドでメモリマップを見る"><code>pmap</code>コマンドでメモリマップを見る</a></h3>
<p><code>pmap</code>コマンドを使うと，
実行中のプログラム(プロセス)がどのメモリ領域を使用しているか
(メモリマップ)を調べられます．
(この出力は<code>/proc</code>ファイルシステムの <code>/proc/プロセス番号/maps</code>の内容から作られています)．</p>
<pre><code class="language-bash">$ cat 
❶ ^Z   
[1]+  Stopped                 cat
$ ps | egrep cat
❷  7687 pts/0    00:00:00 cat
$ ❸ pmap 7687
7687:   cat
❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
000055f74dafc000    132K rw---   [ anon ]
00007f63a7e00000   6628K r---- locale-archive
00007f63a8600000    160K r---- libc.so.6
00007f63a8628000   1620K r-x-- libc.so.6
00007f63a87bd000    352K r---- libc.so.6
00007f63a8815000     16K r---- libc.so.6
00007f63a8819000      8K rw--- libc.so.6
00007f63a881b000     52K rw---   [ anon ]
00007f63a8829000    148K rw---   [ anon ]
00007f63a885d000      8K rw---   [ anon ]
00007f63a885f000      8K r---- ld-linux-x86-64.so.2
00007f63a8861000    168K r-x-- ld-linux-x86-64.so.2
00007f63a888b000     44K r---- ld-linux-x86-64.so.2
00007f63a8897000      8K r---- ld-linux-x86-64.so.2
00007f63a8899000      8K rw--- ld-linux-x86-64.so.2
❹ 00007fff86f9f000 132K ❺rw---   ❻[ stack ]
00007fff86ff8000     16K r----   [ anon ]
00007fff86ffc000      8K r-x--   [ anon ]
ffffffffff600000      4K --x--   [ anon ]
 total             9560K
$ fg
❽ ^D
</code></pre>
<ul>
<li>
<p>まず <code>cat</code>コマンドを起動します．ファイル名を指定していないので，
標準入力からの入力待ちになります．
ここで❶ ctrl-z を入力して，<code>cat</code>コマンドの実行を中断 (suspend)します．
<code>pmap</code>コマンドは実行中のプロセスにしか実行できないため，
<code>cat</code>コマンドが実行中のまま終了しないように，こうしています．</p>
</li>
<li>
<p>次に<code>ps</code>コマンドで<code>cat</code>コマンドのプロセス番号を調べます．
❷7687がプロセス番号と分かりました．</p>
</li>
<li>
<p>❸プロセス番号7687を引数として<code>pmap</code>コマンドを実行します．</p>
</li>
<li>
<p>出力の各行が使用中のメモリ領域の情報を示しています．例えば，❹の行は次を意味しています．</p>
<p><code>❹ 00007fff86f9f000    132K ❺rw---   ❻[ stack ]
 </code></p>
<ul>
<li>❹アドレス`00007fff86f9f000'からサイズ132KBの領域を使用している．</li>
<li>このメモリ領域の❻アクセス権限は読み書きが可能で，実行は不可．
<ul>
<li><code>r</code> 読み込み可能</li>
<li><code>w</code> 書き込み可能</li>
<li><code>x</code> 実行可能</li>
</ul>
</li>
<li>このメモリ領域は❻スタックとして使用している</li>
</ul>
</li>
<li>
<p><code>cat</code>コマンド自身は以下の5つのメモリ領域を使用しています．</p>
<pre><code class="language-bash">❼000055f74daf2000      8K r---- cat
❼000055f74daf4000     16K r-x-- cat
❼000055f74daf8000      8K r---- cat
❼000055f74dafa000      4K r---- cat
❼000055f74dafb000      4K rw--- cat
</code></pre>
<ul>
<li>アクセス権限が <code>r-x--</code>のものは，<code>.text</code>セクションでしょう．
(<code>.text</code>セクションは通常，実行可能かつ書き込み禁止にするからです)</li>
<li>アクセス権限が <code>rw----</code>のものは，<code>.data</code>セクションでしょう．
(<code>.data</code>セクションは通常，実行禁止かつ書き込み可能にするからです)</li>
<li>残りの3つのアクセス権限が <code>r----</code> のものは，<code>.rodata</code>セクションなどでしょう．
(詳細は調べていません)</li>
<li>使用しているサイズが4KBの倍数なのは，x86-64でよくある
<strong>ページ</strong>(page)サイズが4KBだからです．
(ページとは仮想記憶方式の1つであるページングで使われる，
固定長(例えば4KB)に区切ったメモリ領域のことです)．
プロセスは<code>mmap</code>システムコールを使って，OSからページ単位でメモリを割り当ててもらい，その際にページごとにアクセス権限を設定できます．</li>
</ul>
</li>
<li>
<p>最後に❽で，中断していた<code>cat</code>コマンドを<code>fg</code>コマンドで実行を再開し，
<code>ctrl-D</code>を入力して<code>cat</code>コマンドの実行を終了しています．</p>
</li>
</ul>
<h3 id="gdbでメモリマップを見る"><a class="header" href="#gdbでメモリマップを見る"><code>gdb</code>でメモリマップを見る</a></h3>
<p><code>gdb</code>でもメモリマップを見ることができます</p>
<pre><code class="language-bash">$ gdb /usr/bin/cat
(gdb) r
ctrl-z
Program received signal SIGTSTP, Stopped (user).
(gdb) info proc map
process 7821
Mapped address spaces:

          Start Addr           End Addr       Size     Offset  Perms  objfile
      0x555555554000     0x555555556000     0x2000        0x0  r--p   /usr/bin/cat
      0x555555556000     0x55555555a000     0x4000     0x2000 ❶r-xp   /usr/bin/cat
<span class="boring">      0x55555555a000     0x55555555c000     0x2000     0x6000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555c000     0x55555555d000     0x1000     0x7000  r--p   /usr/bin/cat
</span><span class="boring">      0x55555555d000     0x55555555e000     0x1000     0x8000  rw-p   /usr/bin/cat
</span><span class="boring">      0x55555555e000     0x55555557f000    0x21000        0x0  rw-p   [heap]
</span><span class="boring">      0x7ffff7400000     0x7ffff7a79000   0x679000        0x0  r--p   /usr/lib/locale/locale-archive
</span><span class="boring">      0x7ffff7c00000     0x7ffff7c28000    0x28000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7c28000     0x7ffff7dbd000   0x195000    0x28000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7dbd000     0x7ffff7e15000    0x58000   0x1bd000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e15000     0x7ffff7e19000     0x4000   0x214000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e19000     0x7ffff7e1b000     0x2000   0x218000  rw-p   /usr/lib/x86_64-linux-gnu/libc.so.6
</span><span class="boring">      0x7ffff7e1b000     0x7ffff7e28000     0xd000        0x0  rw-p   
</span><span class="boring">      0x7ffff7f87000     0x7ffff7fac000    0x25000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbb000     0x7ffff7fbd000     0x2000        0x0  rw-p   
</span><span class="boring">      0x7ffff7fbd000     0x7ffff7fc1000     0x4000        0x0  r--p   [vvar]
</span><span class="boring">      0x7ffff7fc1000     0x7ffff7fc3000     0x2000        0x0  r-xp   [vdso]
</span><span class="boring">      0x7ffff7fc3000     0x7ffff7fc5000     0x2000        0x0  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fc5000     0x7ffff7fef000    0x2a000     0x2000  r-xp   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7fef000     0x7ffff7ffa000     0xb000    0x2c000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffb000     0x7ffff7ffd000     0x2000    0x37000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x39000  rw-p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span><span class="boring">      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
</span><span class="boring">  0xffffffffff600000 0xffffffffff601000     0x1000        0x0  --xp   [vsyscall]
</span></code></pre>
<details>
<summary>
アクセス権限rwxpの❶pとは
</summary>
<p><code>mmap</code>でメモリ領域をマップする際に，
フラグとして<code>MAP_PRIVATE</code>を指定すると<code>p</code>，
<code>MAP_SHARED</code>を指定すると<code>s</code>と表示されます．</p>
<ul>
<li>
<p><code>MAP_PRIVATE</code> マップした領域への変更はプロセス間で共有されません．
このマップは<strong>copy-on-write</strong>なので，書き込まれるまで自分専用のコピーは発生せず，共有されます．
(copy-on-writeとは「書き込みが起こるまでコピーを遅延する」というテクニックです)．</p>
</li>
<li>
<p><code>MAP_SHARED</code> マップした領域への変更はプロセス間で共有されます．
すなわちマップした領域に書き込みを行うと，
その変更は他のプロセスにも見えます．
ただし，<code>msync</code>を使う必要があります．</p>
</li>
</ul>
<p>❶<code>.text</code>セクションの共有設定も<code>p</code>となっています．
これは<code>.text</code>セクションも<code>mmap</code>の<code>MAP_PRIVATE</code>でマップしているからです．
動的リンクした実行可能ファイルの<code>.text</code>セクションは
物理メモリ上で共有されていますが，
その共有と<code>MAP_SHARED</code>は関係ないのです．</p>
<!--
ちなみに，そのプロセスが`mmap`で`MAP_SHARED`なマップをすれば，
表示が`s`になります(自分でやってみて確かめました)．

strace して .text を MAP_PRIVATE　してるのを確かめようとしたけど
よくわからんかった．
$ strace /lib64/ld-linux-x86-64.so.2 /usr/bin/cat
もやったんだけどね．
-->
</details>
<h2 id="relocation"><a class="header" href="#relocation">再配置情報</a></h2>
<h3 id="再配置情報の概要"><a class="header" href="#再配置情報の概要">再配置情報の概要</a></h3>
<p><strong>再配置情報</strong>(relocation information)とは「後でアドレス調整する時のために，
機械語命令中のどの場所をどんな方法で書き換えればよいか」を表す情報です．
オブジェクトファイル<code>*.o</code>は一般的に再配置情報を含んでいます．</p>
<pre><code class="language-C">// asm/reloc-main.c
#include &lt;stdio.h&gt;
extern int x;
int main ()
{
    printf (&quot;%d\n&quot;, x);
}
</code></pre>
<pre><code class="language-C">// asm/reloc-sub.c
int x = 999;
</code></pre>
<p>例えば，上の<a href="./asm/reloc-main.c"><code>reloc-main.c</code></a>と
<a href="./asm/reloc-sub.c"><code>reloc-sub.c</code></a>を見て下さい．
<code>reloc-main.c</code>中で参照している変数<code>x</code>の実体は<code>reloc-main.c</code>中には無く，
実体は<code>reloc-sub.c</code>中にあります．</p>
<img src="figs/reloc-overview.svg" height="170px" id="fig:reloc-overview">
<p>ですので，<a href="./asm/reloc-main.s"><code>reloc-main.s</code></a>中の
<code>movq x(%rip), %eax</code>をアセンブルして<code>reloc-main.o</code>を作っても，
この時点では<code>x</code>のアドレスが不明なので，<strong>仮のアドレス</strong>(上図では<code>00 00 00 00</code>)
にするしかありません．
そこで，この<code>movq x(%rip), %eax</code>命令に対する<strong>再配置情報</strong>として
「この命令の2バイト目から4バイトを4バイト長の<code>%rip</code>相対アドレスで埋める」
という情報(<code>R_X86_64_PC32</code>，<a href="3-binary.html#R_X86_64_PC32">後述</a>)を
<code>reloc-main.o</code>中に保持しておき，リンク時に正しいアドレスを埋め込むのです．</p>
<img src="figs/reloc-overview2.svg" height="300px" id="fig:reloc-overview2">
<pre><code>$ gcc -c reloc-main.c
$ gcc -c reloc-sub.c
$ gcc reloc-main.o reloc-sub.o
</code></pre>
<details>
<summary>
なんでgccを3回?
</summary>
<p>通常は<code>gcc reloc-main.c reloc-sub.c</code>と，<code>gcc</code>を一回実行して
<code>a.out</code>を作ります．が，ここでは<code>reloc-main.o</code>の中の再配置情報を
見たいので，わざわざ別々に<code>reloc-main.o</code>と<code>reloc-sub.o</code>を作り，
最後にリンクして<code>a.out</code>を作っています．</p>
</details>
<p><code>reloc-main.o</code>と<code>reloc-sub.o</code>をリンクして<code>a.out</code>を作ると，
(様々な<code>*.o</code>中のセクションを一列に並べることで)
変数<code>x</code>のアドレスが<code>0x4010</code>に決まり，
上図の「次の命令」のアドレスも<code>0x1157</code>に決まりました．
仮のアドレスに埋めたかったのは，<code>%rip</code>相対番地でしたので，
<code>0x4010-0x1157=0x2EB9</code>と計算した<code>0x2EB9</code>番地を仮のアドレスの部分に埋めました．
これが再配置です．</p>
<details>
<summary>
様々な*.o中のセクションを一列に並べることで，とは
</summary>
<br/>
<img src="figs/reloc-overview4.svg" height="200px" id="fig:reloc-overview4">
<p>例えば上図で<code>foo2.o</code>中の変数<code>x</code>のアドレスは仮アドレス<code>0x1000</code>ですが，
<code>foo1.o</code>と<code>foo2.o</code>中のセクションを1列に並べると，
リンク後は「<code>a.out</code>の先頭アドレスが(例えば)<code>0x4000</code>なので，先頭から数えると，
(<code>0x4000 + 0x0500 + 0x1000 = 0x5500</code>という計算をして)
変数<code>x</code>のアドレスは<code>0x5500</code>に決まりますよね」という話です．</p>
</details>
<h3 id="objdump-dr"><a class="header" href="#objdump-dr"><code>objdump -dr</code> で再配置情報を見てみる</a></h3>
<pre><code>$ gcc -g -c reloc-main.c
$ objdump -dr reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	8b 05 ❶ 00 00 00 00    mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
		❷ a: R_X86_64_PC32	x-0x4
   e:	89 c6                	mov    %eax,%esi
  10:	48 8d 05 ❸ 00 00 00 00 	lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
		❹ 13: R_X86_64_PC32	.rodata-0x4
  17:	48 89 c7             	mov    %rax,%rdi
  1a:	b8 00 00 00 00       	mov    $0x0,%eax
  1f:	e8 00 00 00 00       	call   24 &lt;main+0x24&gt;
			20: R_X86_64_PLT32	printf-0x4
  24:	b8 00 00 00 00       	mov    $0x0,%eax
  29:	5d                   	pop    %rbp
  2a:	c3                   	ret    
</code></pre>
<p><a href="3-binary.html#%E5%86%8D%E9%85%8D%E7%BD%AE%E6%83%85%E5%A0%B1%E3%81%AE%E6%A6%82%E8%A6%81">前節</a>の説明を，実際に再配置情報を見ることで確かめます．
上の実行例は<code>objdump -dr</code>で<code>reloc-main.o</code>の逆アセンブルの結果と
再配置情報の両方を表示させたものです．</p>
<ul>
<li>❶を見ると<a href="3-binary.html#fig:reloc-overview">図</a>の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li><span id="R_X86_64_PC32">❷の<code>a: R_X86_64_PC32 x-0x4</code>が再配置情報です．</span>
<ul>
<li><code>a</code>は仮のアドレスを書き換える場所(<code>.text</code>セクションの先頭からのオフセット)です．
命令<code>mov 0x0(%rip), %eax</code>の先頭のオフセットが<code>0x8</code>なので，
<code>0x8</code>に<code>2</code>を足した値が<code>0xa</code>となっています
(この<code>mov</code>命令の最初の2バイトはオペコード)．</li>
<li><code>R_X86_64_PC32</code>は再配置の方法を表しています．
「<code>%rip</code>相対アドレスで4バイト(32ビット)としてアドレスを埋める」ことを意味しています．
(PCはプログラムカウンタ，つまり<code>%rip</code>を使うことを意味しています)．</li>
<li><code>x-0x4</code>は「変数<code>x</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PC32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>S + A - P</code>と定めています．</p>
<ul>
<li><code>S</code> はそのシンボルのアドレス (上の例では<code>0x4010</code>)</li>
<li><code>A</code> は調整用の値 (addend と呼びます．上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では '0x1157 - 4`番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x4010 + (-4) - (0x1157 - 4) = 0x2EB9
</code></pre>
<p>となります．</p>
</details>
<ul>
<li>❸は&quot;%d\n&quot;という文字列の仮アドレス，❹はその仮アドレスの再配置情報です．
❶❷と同様です．</li>
</ul>
<h3 id="readelf--rで再配置情報を見てみる"><a class="header" href="#readelf--rで再配置情報を見てみる"><code>readelf -r</code>で再配置情報を見てみる</a></h3>
<pre><code>$ readelf -r reloc-main.o | less
Relocation section '.rela.text' at offset 0x5b0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000a00000002 R_X86_64_PC32     0000000000000000 x - 4
000000000013  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000020  000b00000004 R_X86_64_PLT32    0000000000000000 printf - 4
(略)
</code></pre>
<p><code>readelf -r</code>でも<code>objdump -dr</code>と同様の結果が得られます．</p>
<h3 id="pltの再配置情報"><a class="header" href="#pltの再配置情報">PLTの再配置情報</a></h3>
<p><code>printf</code>の再配置情報も見てみましょう．</p>
<img src="figs/reloc-overview3.svg" height="300px" id="fig:reloc-overview3">
<pre><code>$ objdump -dr ./reloc-main.o
./reloc-main.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;main&gt;:
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # e &lt;main+0xe&gt;
                        a: R_X86_64_PC32        x-0x4
   e:   89 c6                   mov    %eax,%esi
  10:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 17 &lt;main+0x17&gt;
                        13: R_X86_64_PC32       .rodata-0x4
  17:   48 89 c7                mov    %rax,%rdi
  1a:   b8 00 00 00 00          mov    $0x0,%eax
  1f:   e8 ❶ 00 00 00 00       call   24 &lt;main+0x24&gt;
             ❷ 20: R_X86_64_PLT32      printf-0x4
  24:   b8 00 00 00 00          mov    $0x0,%eax
  29:   5d                      pop    %rbp
  2a:   c3                      ret    
</code></pre>
<pre><code>$ objdump -d ./a.out
0000000000001149 &lt;main&gt;:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       8b 05 b9 2e 00 00       mov    0x2eb9(%rip),%eax        # 4010 &lt;x&gt;
    1157:       89 c6                   mov    %eax,%esi
    1159:       48 8d 05 a4 0e 00 00    lea    0xea4(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1160:       48 89 c7                mov    %rax,%rdi
    1163:       b8 00 00 00 00          mov    $0x0,%eax
    1168:     ❸e8 e3 fe ff ff          call   1050 &lt;printf@plt&gt;
    116d:       b8 00 00 00 00          mov    $0x0,%eax
    1172:       5d                      pop    %rbp
    1173:       c3                      ret    
</code></pre>
<p><a href="3-binary.html#objdump-dr">先程の<code>x</code></a>の場合とほぼ同じです．</p>
<ul>
<li>❶を見ると<a href="3-binary.html#fig:reloc-overview3">図</a>の左側の通り，仮のアドレス <code>00 00 00 00</code>
を確認できます．</li>
<li>❷の<code>20: R_X86_64_PLT32 printf-0x4</code>が再配置情報です．
<ul>
<li><code>20</code>は仮のアドレスを書き換える場所(オフセット)です．</li>
<li><code>R_X86_64_PLT32</code>は再配置の方法を表しており
「<code>printf@plt</code>への<code>%rip</code>相対アドレス (4バイト(32ビット))を埋める」ことを意味しています．</li>
<li><code>printf-0x4</code>は「変数<code>printf@plt</code>のアドレスを使って埋める値を計算せよ．
その際に<code>-0x4</code>を足して調整せよ」を意味しています．</li>
</ul>
</li>
</ul>
<details>
<summary>
-4はどう使うのか
</summary>
<p><code>R_X86_64_PLT32</code>は<a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>が
定めており，埋めるアドレスのサイズは4バイト(32ビット)，
埋めるアドレスの計算方法は<code>L + A - P</code>と定めています．</p>
<ul>
<li><code>L</code> はそのシンボルのPLTエントリのアドレス (上の例では<code>printf@plt</code>のアドレス<code>0x1050</code>)</li>
<li><code>A</code> は調整用のaddend (上の例では<code>-4</code>)</li>
<li><code>P</code> は仮アドレスを書き換える場所 (上の例では '0x116D - 4`番地)</li>
</ul>
<p>なので，計算すると</p>
<pre><code>0x1050 + (-4) - (0x116D - 4) = -0x11D = 0xFFFFFEE3
</code></pre>
<p>となります．</p>
</details>
<ul>
<li><code>a.out</code>中では「次の命令」が<code>0x116D</code>番地，<code>printf@plt</code>が<code>0x1050</code>番地と決まったので，<code>0x1050 - 0x116D = -0x11D = 0xFFFFFEE3</code>番地が
❸の部分に埋め込まれました．</li>
</ul>
<p><a href="3-binary.html#GOT-PLT">ここ</a>でも説明した通り，
<code>printf</code>の実体はCライブラリの中にあり，
(<code>gcc</code>のデフォルト動作である)<a href="3-binary.html#%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF">動的リンク</a>の場合，
PLTとGOTの仕組みを使って，<code>printf</code>を呼び出します．
これは<a href="3-binary.html#objdump-dr">先程の<code>x</code></a>の場合は
「(<code>main</code>関数中の)次の命令と変数<code>x</code>の相対アドレスは固定で決まる」のに対して，
<code>printf</code>の場合は固定で決まらないからです
(Cライブラリが実行時に何番地にロードされるか不明だから)．</p>
<img src="figs/plt-printf2.svg" height="300px" id="fig:plt-printf2">
<p>そこで，</p>
<ul>
<li><code>main</code>関数中では(<code>printf</code>を直接呼ぶのではなく)，
(<code>printf</code>のための踏み台である)<code>printf@plt</code>を呼び出す．</li>
<li><code>printf@plt</code>はGOT領域に実行時に書き込まれる<code>printf</code>のアドレスを使い，
間接ジャンプ (上図では<code>bnd jmp *0x2f75(%rip)</code>)して，
本物の<code>printf</code>を呼び出す．</li>
</ul>
<p>という仕組みになっています．</p>
<!--
どの関数を動的リンクすべきかの情報を，動的リンカに引数として
渡すために必要だったけど，今は渡してないように見える．
(`main`関数が`printf@plt`を呼ぶのではなく，
直接`call *0x2f75(%rip)`すればいいんじゃね？と言われると，
私もそれでいいじゃん，と思ってしまいます．
`ltrace`コマンドがPLTエントリをフックして実装している，などの利点があるのは
分かりますが，それ以外に理由はあるのでしょうか．
ご存知の方はぜひ教えてください．)
-->
<h2 id="ABI"><a class="header" href="#ABI">ABI と API</a></h2>
<p>ABIとAPIはどちらも<strong>互換性</strong>のための規格(お約束)ですが，
対象がそれぞれ，<strong>バイナリ</strong>，<strong>ソースコード</strong>，と異なります．</p>
<h3 id="abi"><a class="header" href="#abi">ABI</a></h3>
<ul>
<li>ABI = Application Binary Interface</li>
<li><strong>バイナリコード</strong>のためのインタフェース規格．</li>
<li>同じABIをサポートするシステム上では<strong>再コンパイル無し</strong>で
同じバイナリを使ったり実行できる．</li>
<li>ABIはコーリングコンベンション(関数呼び出し規約, calling convention)，
バイトオーダ，アラインメント，バイナリ形式などを定める</li>
<li>Linux AMD64のABI は<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a></li>
</ul>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<ul>
<li>API = Application Programming Interface</li>
<li><strong>ソースコード</strong>のためのインタフェース規格</li>
<li>同じAPIをサポートするシステム上では<strong>再コンパイルすれば</strong>
同じソースコードを実行できる．</li>
<li>例えば，POSIXはUNIXのAPIであり，LinuxはPOSIXにほぼ準拠している．<br />
POSIXはシステムコール，ライブラリ関数，マクロなどの形式や意味を定めている
<ul>
<li>POSIXは<a href="https://unixism.net/2020/07/getting-a-pdf-version-of-the-posix-standard-document/">ここ</a>に書いてあるとおり，<a href="https://www.opengroup.org/">opengroup.org</a>に登録することで無料で入手可能</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 4; }
</style>
<h1 id="アーキテクチャ"><a class="header" href="#アーキテクチャ">アーキテクチャ</a></h1>
<h2 id="一般的なコンピュータの構成要素"><a class="header" href="#一般的なコンピュータの構成要素">一般的なコンピュータの構成要素</a></h2>
<h3 id="コンピュータの基本構造"><a class="header" href="#コンピュータの基本構造">コンピュータの基本構造</a></h3>
<img src="figs/basic-arch.svg" height="250px" id="fig:basic-arch">
<ul>
<li>
<p>コンピュータでは上図のように，<strong>CPU</strong>，<strong>メインメモリ</strong>(以後，単にメモリ)，
<strong>入出力装置</strong>が，<strong>バス</strong>(bus)と呼ばれる信号線でつながっています．</p>
</li>
<li>
<p>CPUは<strong>制御装置</strong>，<strong>ALU</strong>(演算装置)，<strong>レジスタ</strong>から構成されています</p>
</li>
<li>
<p><strong>バス</strong>はデジタルの信号線です．
アドレスバス，データバス，制御バスがあります(図にはこの区別は書いていません)．</p>
</li>
<li>
<p>上図には<strong>キャッシュ</strong>や<a href="./5-arch.html#%E4%BB%AE%E6%83%B3%E3%83%A1%E3%83%A2%E3%83%AA"><strong>MMU</strong></a>などがありませんが，
本書の範囲ではこの図の知識で十分です．</p>
</li>
</ul>
<h3 id="cpuの基本構成"><a class="header" href="#cpuの基本構成">CPUの基本構成</a></h3>
<ul>
<li>制御装置 = <a href="./5-arch.html#%E3%83%95%E3%82%A7%E3%83%83%E3%83%81%E5%AE%9F%E8%A1%8C%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB">フェッチ実行サイクル</a>をひたすら繰り返します</li>
<li>ALU = 四則演算や論理演算などを計算します</li>
<li>レジスタ
<ul>
<li>高速・小容量・固定長のメモリです</li>
<li>特定の役割を持つ<strong>専用レジスタ</strong>(例: プログラムカウンタ<code>%rip</code>)と，
様々な用途に使える<strong>汎用レジスタ</strong>(例: <code>%rax</code>)に概ね分かれています．</li>
</ul>
</li>
</ul>
<h3 id="メモリ"><a class="header" href="#メモリ">メモリ</a></h3>
<img src="figs/memory-byte-addr.svg" height="250px" id="fig:memory-byte-addr">
<ul>
<li>メモリはRAMです．揮発性があります(電源が切れると記憶内容は失われます)．</li>
<li>メモリは巨大なバイトの配列です
<ul>
<li>メモリのアドレスを指定して，メモリの内容を読み書きします</li>
<li>バイト単位だけでなく，4バイトや8バイトなどの連続するメモリ領域も読み書きできます</li>
</ul>
</li>
<li>通常，メモリには1バイトごとに連番のアドレスがつきます
これを<strong>バイトアドレッシング</strong>といいます．</li>
</ul>
<blockquote>
<p>実際の物理アドレスには，RAMだけでなく，ROMや memory-mapped I/O
(メモリのアドレスを使ってアクセスする入出力装置，例えばフレームバッファ)も
マップされています．ただし，これらは通常はユーザプロセスからは見えないので気にしなくて良いです．</p>
</blockquote>
<h3 id="フェッチ実行サイクル"><a class="header" href="#フェッチ実行サイクル">フェッチ実行サイクル</a></h3>
<img src="figs/fetch-cycle.svg" height="150px" id="fig:fetch-cycle">
<ul>
<li>
<p>CPUは次の動作をひたすら繰り返します</p>
<ol>
<li><strong>フェッチ</strong>(fetch)</li>
</ol>
<ul>
<li>プログラムカウンタ(<code>%rip</code>)が指す機械語命令を
メモリからCPUに読み込みます</li>
<li>次の機械語命令を指すように，プログラムカウンタの値を増やします</li>
</ul>
<ol start="2">
<li><strong>デコード</strong>(decode)</li>
</ol>
<ul>
<li>読み込んだ命令を解析して，実行の準備をします</li>
<li>例えば，必要ならメモリからオペランドの値をCPUに読み込みます</li>
</ul>
<ol start="3">
<li><strong>実行</strong>(execute)</li>
</ol>
<ul>
<li>読み込んだ機械語命令を実行します</li>
</ul>
</li>
</ul>
<h2 id="x86-64のレジスタ"><a class="header" href="#x86-64のレジスタ">x86-64のレジスタ</a></h2>
<h3 id="汎用レジスタ"><a class="header" href="#汎用レジスタ">汎用レジスタ</a></h3>
<img src="figs/gp-regs.svg" height="350px" id="fig:gp-regs">
<ul>
<li>上記16個のレジスタが<strong>汎用レジスタ</strong>(general-purpose register)です．
原則として，プログラマが自由に使えます．</li>
<li>ただし，<code>%rsp</code>は<strong>スタックポインタ</strong>，<code>%rbp</code>は<strong>ベースポインタ</strong>と呼び，
<a href="./2-asm-intro.html#stack-rsp-rbp">一番上のスタックフレームの上下を指す</a>
という役割があります．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>
オプションでコンパイルされた<code>a.out</code>中では，<code>%rbp</code>はベースポインタとしてではなく，
汎用レジスタとして使われています)．</li>
</ul>
<h4 id="caller-savecallee-saveレジスタ"><a class="header" href="#caller-savecallee-saveレジスタ"><a href="./6-inst.html#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<h4 id="引数"><a class="header" href="#引数"><a href="./6-inst.html#arg-reg">引数</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<h3 id="プログラムカウンタ命令ポインタ"><a class="header" href="#プログラムカウンタ命令ポインタ">プログラムカウンタ（命令ポインタ）</a></h3>
<img src="figs/rip.svg" height="100px" id="fig:rip">
<h3 id="ステータスレジスタフラグレジスタ"><a class="header" href="#ステータスレジスタフラグレジスタ">ステータスレジスタ（フラグレジスタ）</a></h3>
<img src="figs/rflags.svg" height="100px" id="fig:rflags">
<h4 id="本書で扱うフラグ"><a class="header" href="#本書で扱うフラグ">本書で扱うフラグ</a></h4>
<p>ステータスレジスタのうち，本書は以下の6つのフラグを扱います．
フラグの値が1になることを「フラグがセットされる」「フラグが立つ」と表現します．
またフラグの値が0になることを「フラグがクリアされる」「フラグが消える」と表現します．</p>
<div class="table-wrapper"><table><thead><tr><th>フラグ</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td><code>CF</code></td><td>キャリーフラグ</td><td>算術演算で結果の最上位ビットにキャリーかボローが生じるとセット．それ以外はクリア．符号<strong>なし</strong>整数演算でのオーバーフロー状態を表す．</td></tr>
<tr><td><code>OF</code></td><td>オーバーフローフラグ</td><td>符号ビット(MSB)を除いて，整数の演算結果が大きすぎるか小さすぎるかするとセット．それ以外はクリア．2の補数表現での符号<strong>あり</strong>整数演算のオーバーフロー状態を表す．</td></tr>
<tr><td><code>ZF</code></td><td>ゼロフラグ</td><td>結果がゼロの時にセット．それ以外はクリア．</td></tr>
<tr><td><code>SF</code></td><td>符号フラグ</td><td>符号あり整数の符号ビット(MSB)と同じ値をセット．(0は0以上の正の数，1は負の数であることを表す)</td></tr>
<tr><td><code>PF</code></td><td>パリティフラグ</td><td>結果の最下位バイトの値1のビットが偶数個あればセット，奇数個であればクリア．</td></tr>
<tr><td><code>AF</code></td><td>調整フラグ</td><td>算術演算で，結果のビット3にキャリーかボローが生じるとセット．それ以外はクリア．BCD演算で使用する(本書ではほとんど使いません)．</td></tr>
</tbody></table>
</div>
<h4 id="cfフラグが立つ例"><a class="header" href="#cfフラグが立つ例">CFフラグが立つ例</a></h4>
<pre><code class="language-x86asmatt"># asm/cf.s
    .text
    .globl main
    .type main, @function
main:
    movb $0xFF, %al
    addb $1, %al  # オーバーフローでCFが立つ
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g cf.s
$ gdb ./a.out
(gdb) b 8
Breakpoint 1 at 0x112d: file cf.s, line 8.
(gdb) r
Breakpoint 1, main () at cf.s:8
8	    ret
(gdb) p $al
$1 = ❶ 0
(gdb) p $eflags
$2 = [ ❷ CF PF AF ZF IF ]
(gdb) quit
</code></pre>
<img src="figs/cf.svg" height="150px" id="fig:cf">
<ul>
<li><code>movb $0xFF, %al</code>と<code>addb $1, %al</code>で，1バイト符号<strong>なし</strong>整数の加算<code>0xFF+1</code>をすると，オーバーフローが起きて<code>%al</code>の値は❶ 0になります．
(1バイト符号<strong>なし</strong>整数の範囲は0〜255です．<code>0xFF+1</code>は255+1=256となり
(1バイト符号<strong>なし</strong>整数として)オーバーフローが起きています)．</li>
<li><code>p $eflags</code>でステータスフラグを調べると，❷ CF フラグが立っています．</li>
</ul>
<h4 id="ofフラグが立つ例"><a class="header" href="#ofフラグが立つ例">OFフラグが立つ例</a></h4>
<pre><code class="language-x86asmatt"># asm/of.s
    .text
    .globl main
    .type main, @function
main:
    movb $0x7F, %al
    addb $1, %al  # オーバーフローでOFが立つ
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g of.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file of.s, line 6.
(gdb) r
Breakpoint 1, main () at of.s:6
6	    movb $0x7F, %al
(gdb) si
7	    addb $1, %al  # オーバーフローでOFが立つ
(gdb) si
main () at of.s:8
8	    ret
(gdb) p $al
$1 = ❶ -128
(gdb) p $eflags
$1 = [ AF SF IF ❷ OF ]
(gdb) ❸ p/u $al
$2 = ❹ 128
(gdb) quit
</code></pre>
<img src="figs/of.svg" height="150px" id="fig:of">
<ul>
<li><code>movb $0x7F, %al</code>と<code>addb $1, %al</code>で，1バイト符号<strong>あり</strong>整数の加算<code>0x7F+1</code>をすると，オーバーフローが起きて<code>%al</code>の値は❶ -128になります．
(1バイト符号<strong>あり</strong>整数の範囲は-128〜127です．<code>0x7F+1</code>は127+1=128となり
(1バイト符号<strong>あり</strong>整数として)オーバーフローが起きています)．</li>
<li><code>p $eflags</code>でステータスフラグを調べると，❷ OF フラグが立っています．</li>
<li>なお，符号なし(❸<code>u</code>)オプションをつけて<code>%al</code>レジスタの値を表示させると，
符号なしの結果として正しい❹ 128という結果になりました．
(x86-64は符号なし・符号ありを区別せず，どちらに対しても正しい結果を
計算します)．</li>
<li><a href="./4-data.html#signed-overflow">ここ</a>で説明する通り，
符号あり整数のオーバーフローは<strong>未定義動作</strong>になるので，
符号あり整数のオーバーフローを起こすプログラムは書いてはいけません．</li>
</ul>
<h3 id="レジスタの別名"><a class="header" href="#レジスタの別名">レジスタの別名</a></h3>
<h4 id="raxレジスタの別名-rbx-rcx-rdxも同様"><a class="header" href="#raxレジスタの別名-rbx-rcx-rdxも同様"><code>%rax</code>レジスタの別名 (<code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>も同様)</a></h4>
<img src="figs/reg-alias1.svg" height="150px" id="fig:reg-alias1">
<ul>
<li><code>%rax</code>の下位32ビットは<code>%eax</code>としてアクセス可能</li>
<li><code>%eax</code>の下位16ビットは<code>%ax</code>としてアクセス可能</li>
<li><code>%ax</code>の上位8ビットは<code>%ah</code>としてアクセス可能</li>
<li><code>%ax</code>の下位8ビットは<code>%al</code>としてアクセス可能</li>
</ul>
<details>
<summary>
%raxに値を入れて，%eax, %ax, %ah, %alにアクセスする例
</summary>
<pre><code class="language-x86asmatt"># asm/reg.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax # ❶
    ret
    .size main, .-main
</code></pre>
<pre><code class="language-bash">$ gcc -g reg.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file reg.s, line 6.
(gdb) r
Breakpoint 1, main () at reg.s:6
6	    movq $0x1122334455667788, %rax
(gdb) si
main () at reg.s:7
7	    ret
(gdb) p/x $rax
$1 = ❷ 0x1122334455667788
(gdb) p/x $eax
$2 = ❸ 0x55667788
(gdb) p/x $ax
$3 = ❹ 0x7788
(gdb) p/x $ah
$4 = ❺ 0x77
(gdb) p/x $al
$5 = ❻ 0x88
(gdb) q
</code></pre>
<ul>
<li><code>%rax</code>レジスタに❶ <code>0x1122334455667788</code>を入れると，
当たり前ですが<code>%rax</code>レジスタには❷<code>0x1122334455667788</code>が入っています．</li>
<li><code>%eax</code>には(<code>%rax</code>の下位4バイトなので)❸ <code>0x55667788</code>が入っています．</li>
<li><code>%ax</code>には(<code>%rax</code>の下位2バイトなので)❹ <code>0x7788</code>が入っています．</li>
<li><code>%ah</code>には(<code>%ax</code>の上位1バイトなので)❺<code>0x77</code>が入っています．</li>
<li><code>%al</code>には(<code>%ax</code>の下位1バイトなので)❻<code>0x88</code>が入っています．</li>
</ul>
</details>
<h4 id="rbpレジスタの別名-rsp-rdi-rsiも同様"><a class="header" href="#rbpレジスタの別名-rsp-rdi-rsiも同様"><code>%rbp</code>レジスタの別名 (<code>%rsp</code>, <code>%rdi</code>, <code>%rsi</code>も同様)</a></h4>
<img src="figs/reg-alias2.svg" height="150px" id="fig:reg-alias2">
<ul>
<li><code>%rbp</code>の下位32ビットは<code>%ebp</code>としてアクセス可能</li>
<li><code>%ebp</code>の下位16ビットは<code>%bp</code>としてアクセス可能</li>
<li><code>%bp</code>の下位8ビットは<code>%bpl</code>としてアクセス可能</li>
</ul>
<h4 id="r8レジスタの別名-r9r15も同様"><a class="header" href="#r8レジスタの別名-r9r15も同様"><code>%r8</code>レジスタの別名 (<code>%r9</code>〜<code>%r15</code>も同様)</a></h4>
<img src="figs/reg-alias3.svg" height="150px" id="fig:reg-alias3">
<ul>
<li><code>%r8</code>の下位32ビットは<code>%r8d</code>としてアクセス可能</li>
<li><code>%r8d</code>の下位16ビットは<code>%r8w</code>としてアクセス可能</li>
<li><code>%r8w</code>の下位8ビットは<code>%r8b</code>としてアクセス可能</li>
</ul>
<h4 id="同時に使えない制限"><a class="header" href="#同時に使えない制限">同時に使えない制限</a></h4>
<ul>
<li>一部のレジスタは<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>と一緒には使えない．</li>
<li>例：<code>movb %ah, (%r8)</code> や <code>movb %ah, %bpl</code>はエラーになる．</li>
<li>正確には<a href="./4-data.html#REX-prefix"><code>REX</code>プリフィクス</a>付きの命令では，<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>を使えない．</li>
</ul>
<h3 id="32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする"><a class="header" href="#32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする">32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする</a></h3>
<ul>
<li>例:<code>movl $0xAABBCCDD, %eax</code>を実行すると<code>%rax</code>の上位32ビットが全てゼロになる</li>
<li>例: <code>movw $0x1122, %ax</code>や<code>movb $0x11, %al</code>では上位をゼロにすることはない</li>
</ul>
<details>
<summary>
上位32ビットをゼロにする実行例
</summary>
<img src="figs/zero-upper32.svg" height="250px" id="fig:zero-upper32">
<pre><code class="language-x86asmatt"># asm/zero-upper32.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movl $0xAABBCCDD, %eax
    movq $0x1122334455667788, %rax
    movw $0x1122, %ax
    movq $0x1122334455667788, %rax
    movb $0x11, %al
    ret
    .size main, .-main
</code></pre>
<pre><code># zero-upper32.txt
b 7
r
list 6,7
p/z $rax
si
p/z $rax
echo # 以下が出力されれば成功\n
echo # $1 = 0x1122334455667788 (%raxは8バイトの値を保持)\n
echo # $2 = 0x00000000aabbccdd (%raxの上位4バイトがゼロになった)\n
quit
</code></pre>
<pre><code>$ gcc -g zero-upper32.s
$ gdb ./a.out -x zero-upper32.txt
Breakpoint 1, main () at zero-upper32.s:7
7	    movl $0xAABBCCDD, %eax
6	    movq $0x1122334455667788, %rax
7	    movl $0xAABBCCDD, %eax
$1 = 0x1122334455667788
8	    movq $0x1122334455667788, %rax
$2 = 0x00000000aabbccdd
# 以下が出力されれば成功
# $1 = 0x1122334455667788 (%raxは8バイトの値を保持)
# $2 = 0x00000000aabbccdd (%raxの上位4バイトがゼロになった)
</code></pre>
</details>
<h2 id="オペレーティングシステムの存在"><a class="header" href="#オペレーティングシステムの存在">オペレーティングシステムの存在</a></h2>
<h3 id="osは邪魔"><a class="header" href="#osは邪魔">OSは邪魔!?</a></h3>
<img src="figs/os-nuisance.svg" height="250px" id="fig:os-nuisance">
<ul>
<li>アセンブリ言語の利点はCPUや
周辺機器のハードウェア(入出力装置)がよく見えることです</li>
<li>でもユーザプロセス(皆さんが普通に実行しているプログラム)は
OS上で動作するので，OSはCPUやハードウェアの詳細を見せない働きをします
<ul>
<li>この<strong>抽象化</strong>のおかげで，通常のアプリケーションを開発する際に，
CPUやハードウェアの詳細を気にすること無くプログラミングできるわけですが．</li>
</ul>
</li>
<li>例えば，OSは以下を隠しています．以下でもう少し詳しく説明します．
<ul>
<li>OSによる<strong>マルチタスク処理</strong>:
ユーザプロセスはCPUを専有しているように見えます．</li>
<li><strong>ハードウェアの詳細</strong>(例: ハードディスク):
ユーザプロセスは<strong>システムコール</strong>経由でハードウェア等にアクセスします．</li>
<li><strong>物理メモリ</strong>: ユーザプロセスは仮想メモリのみアクセス可能で，
物理メモリへの直接アクセスはできません．</li>
<li><strong>割り込み</strong> (interrupt): ハードウェアがCPUに<strong>非同期的に</strong>(asyncronously)送る信号が割り込みです．
ユーザプロセスが割り込みを直接受け取ることはありません．
　　</li>
</ul>
</li>
</ul>
<h3 id="osによるマルチタスク処理"><a class="header" href="#osによるマルチタスク処理">OSによるマルチタスク処理</a></h3>
<img src="figs/multi-task.svg" height="110px" id="fig:multi-task">
<ul>
<li>ユーザプロセスから見ると「ずっとCPUやレジスタを専有している」ように見えます．</li>
<li>メモリはユーザプロセスごとに割り当てられますが，
CPUの数は少ないので，OSはCPU上で実行するユーザプロセスを定期的に切り替えています．
<ul>
<li>このユーザプロセスの切り替えにはタイマー割り込みを使っています．
タイマー割り込みが発生すると，OSがブート時に設定した割り込みハンドラを
CPUが自動的に起動します．</li>
<li>その際，ユーザプロセスが使っていたCPUのレジスタ値は<strong>メモリに退避</strong>します．
実行再開時にはレジスタ値を<strong>メモリから回復</strong>します．</li>
</ul>
</li>
<li>ユーザプロセスのプログラムを書く時は，
マルチタスクのことを気にする必要はありません(ただしリアルタイムシステムなどは除く)．</li>
</ul>
<h3 id="システムコール"><a class="header" href="#システムコール">システムコール</a></h3>
<img src="figs/syscall.svg" height="130px" id="fig:syscall">
<ul>
<li>ユーザプロセスは直接，周辺機器のハードウェアを操作できません．
ユーザプロセスが直接操作するのは面倒だし危険なので，
通常，OSが「ユーザプロセスによるハードウェア操作」を禁止しているからです．
<ul>
<li>(Linuxではシステムコール<code>ioperm</code>や<code>iopl</code>を使って，
この禁止を解除できますが，本書では説明しません)．</li>
</ul>
</li>
<li>そのため，ユーザプロセスは<strong>システムコール</strong>を使って，
ハードウェア操作をカーネル(OS本体)に依頼します．
<ul>
<li>ユーザプロセスが動作するアドレス空間を<strong>ユーザ空間</strong>，
カーネルが動作するアドレス空間を<strong>カーネル空間</strong>と呼びます．
カーネル空間ではCPUの<strong>特権命令</strong>の実行やハードウェア操作が可能です．</li>
<li><code>printf</code>などのライブラリ関数の呼び出しには<code>call</code>命令と<code>ret</code>命令を使います．
一方，<code>write</code>などのシステムコールの呼び出しは
トラップ命令(ソフトウェア割り込み命令)である，
<code>syscall</code>/<code>sysret</code>，<code>sysenter</code>/<code>sysexit</code>，<code>int</code>/<code>iret</code>などを使います．
システムコールの呼び出しにはユーザ空間からカーネル空間への切り替えが
必要だからです．</li>
</ul>
</li>
<li>システムコール内では入出力命令(<code>in</code>, <code>out</code>, <code>mov</code>)を実行することで
ハードウェアの操作を行います．
ハードウェア側から来る割り込みは，予めOSが設定した割り込みハンドラが対処します．
ユーザ空間ではCPUの特権命令を実行できないので，
ユーザプロセス内では(<code>ioperm</code>や<code>iopl</code>を使わない限り)これらの操作をできません．</li>
</ul>
<h3 id="仮想メモリ"><a class="header" href="#仮想メモリ">仮想メモリ</a></h3>
<img src="figs/paging.svg" height="300px" id="fig:paging">
<ul>
<li>OSはx86-64のページング機能などを使って<strong>仮想メモリ</strong>を有効化しています．
<ul>
<li>上図でプロセスAとプロセスBは物理メモリの一部を仮想メモリとして
(仮想アドレスを使って)アクセスできる状態です．</li>
<li><code>printf</code>はプロセスAとプロセスBで共有しています．</li>
<li>共有している<code>printf</code>以外は，プロセスはお互いに他のプロセスのメモリの中身にアクセスできません．</li>
</ul>
</li>
</ul>
<img src="figs/mmu.svg" height="200px" id="fig:mmu">
<ul>
<li>
<p>仮想メモリが有効な状態では，
CPUが扱うアドレス(<code>%rip</code>やメモリ参照でアクセスするアドレス)
はすべて仮想アドレスです．
CPU上で動作するプログラム(<code>a.out</code>)は
物理メモリのアドレスを使ってのアクセスはできません．</p>
</li>
<li>
<p>仮想アドレスから物理アドレスへの変換:</p>
<ul>
<li>OSは「仮想アドレスと物理アドレスの対応表」である<strong>ページテーブル</strong>を
　物理メモリ上で管理します．</li>
<li>実際の変換はCPU内の<strong>MMU</strong>(memory management unit)が高速に行います．
MMUはCPUから仮想アドレスを受け取り，それを物理アドレスに変換してから，
バス上で物理アドレスを使って物理メモリにアクセスします．</li>
</ul>
</li>
</ul>
<h3 id="割り込みとシグナル"><a class="header" href="#割り込みとシグナル">割り込みとシグナル</a></h3>
<img src="figs/interrupt.svg" height="150px" id="fig:interrupt">
<ul>
<li>CPUはバスを介して周辺機器とつながってます．
例えば，キーボードのキーを押すと，キーを押すたび，離すたびに，
CPUに割り込みを伝えます．</li>
<li><strong>割り込み</strong>(interrupt)は周辺機器側からCPUに<strong>非同期的</strong>(asynchronously)に
送る信号です． </li>
<li>CPUは割り込みを受け取ると，(ブート時にOSが設定した)割り込みハンドラを自動的に
起動して，その割り込みに対処します．</li>
<li>一部の割り込みはユーザプロセスに<strong>UNIXシグナル</strong>として配送されます．
例えば，ユーザプロセスはタイマー割り込みを直接，受け取ることはできませんが，
(<code>alarm</code>や<code>setitimer</code>などのシステムコールを使えば)
<code>SIGALRM</code>というUNIXシグナルを受け取ることができます．</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 5; }
</style>
<h1 id="バイナリ2進数でのデータ表現"><a class="header" href="#バイナリ2進数でのデータ表現">バイナリ(2進数)でのデータ表現</a></h1>
<h2 id="2進数と符号化-1"><a class="header" href="#2進数と符号化-1">2進数と符号化</a></h2>
<p><a href="./3-binary.html#everything-binary">ここ</a>でも説明しましたが，
<strong>コンピュータの中のデータは，どんな種類のデータ(例えば，整数，文字，
音声，画像)であっても，
機械語命令であっても，すべて<code>0</code>と<code>1</code>だけで表現されています．</strong></p>
<p>そして，そのためにデータの種類ごとに2進数での表現方法，つまり<strong>符号化</strong>
(encoding)の方法が定められています．
例えば，</p>
<ul>
<li>文字<code>U</code>をASCII文字として符号化すると，<code>01010101</code>になります．</li>
<li><code>pushq %rbp</code>をx86-64の機械語命令として符号化すると，<code>01010101</code>になります．</li>
</ul>
<p>おや，どちらも同じ<code>01010101</code>になってしまいました．
この2進数が<code>P</code>なのか<code>pushq %rbp</code>なのか，どうやって区別すればいいでしょう？
答えは「これだけでは区別できません」です．</p>
<img src="figs/encode.svg" height="130px" id="fig:encode">
<p>別の手段（情報）を使って，いま自分が注目しているデータが，
文字なのか機械語命令なのかを知る必要があります．
例えば，この後で説明する<a href="./3-binary.html#.text"><code>.text</code>セクション</a>にある
2進数のデータ列は「<code>.text</code>セクションに存在するから」という理由で
機械語命令として解釈されます．</p>
<p>以下では，整数(特に2の補数による負の数の表現)，
ASCII文字コード，機械語命令の符号化などを説明します．</p>
<h2 id="2進数と10進数と16進数"><a class="header" href="#2進数と10進数と16進数">2進数と10進数と16進数</a></h2>
<h3 id="位取り記数法"><a class="header" href="#位取り記数法">位取り記数法</a></h3>
<ul>
<li>10進数で \( 234 \) という数字の値は
\[
2\times 10^2 + 3\times 10^1 + 4\times 10^0 = 200 + 30 + 4 = 234
\]</li>
</ul>
<img src="figs/decimal.svg" height="130px" id="fig:decimal">
<ul>
<li>2進数で \( 1101 \) という数字の値は (2進数→10進数の変換)</li>
</ul>
<p>\[
1\times 2^3 + 1\times 2^2 + 0\times 2^1 + 1\times 2^0 = 8+4+0+1=13
\]</p>
<img src="figs/binary.svg" height="130px" id="fig:binary">
<ul>
<li>
<p>一般的に，n進数で \( d_m d_{m-1} \cdots d_2 d_1 d_0 \) という数字の値は
\[
\sum_{i=0}^m d_i\times n^i = 
d_m\times n^m + d_{m-1}\times n^{m-1} + \cdots
d_2\times n^2 + d_1\times n^1 + d_0\times n^0
\]</p>
<ul>
<li>この「数字を並べる記法」を<strong>位取り記数法</strong> (positional notation)という．</li>
<li>nを<strong>底</strong> (base), あるいは<strong>基数</strong> (radix)と呼ぶ．</li>
</ul>
</li>
<li>
<p>16進数も同様</p>
<ul>
<li>0から9，AからFまでの数字を使う．Aは10，Bは11，\(\cdots\)，Fは15を表す．</li>
<li>16進数で \( 1\mathrm{F}4 \) という数字の値は (16進数→10進数の変換)
\[
1\times 16^2 + \mathrm{F}\times 16^1 + 4\times 16^0 = 256 + 240 + 4 = 500
\]</li>
<li>2進数は表記が長くなるため，16進数を使って短く表記すると便利(だから使う)．</li>
</ul>
</li>
</ul>
<h3 id="対応表"><a class="header" href="#対応表">対応表</a></h3>
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th>10進数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th></tr></thead><tbody>
<tr><td>2進数</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr>
<tr><td>16進数</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr>
</tbody></table>
</div></div>
<h3 id="変換方法"><a class="header" href="#変換方法">変換方法</a></h3>
<h4 id="2進数16進数16進数2進数"><a class="header" href="#2進数16進数16進数2進数">2進数→16進数，16進数→2進数</a></h4>
<ul>
<li>最下位ビットから4桁ずつまとめる(上位ビットには0を埋める)．
4ビットごとに16進数にすれば良い(10進数ではこの方法は使えない)</li>
</ul>
<img src="figs/binary2hex.svg" height="200px" id="fig:binary2hex">
<h4 id="10進数2進数"><a class="header" href="#10進数2進数">10進数→2進数</a></h4>
<ul>
<li>
<p>割り算を使う方法</p>
<ul>
<li>0になるまで繰り返し2で割り，余りを逆順に並べる．</li>
<li>例: 13を2進数に変換</li>
</ul>
<p>\[
\left.
\begin{align}
13\div 2 = 6 \cdots 1 \\
6\div 2 = 3 \cdots  0 \\
3\div 2 = 1 \cdots  1 \\
1\div 2 = 0 \cdots  1 
\end{align}
\right\}  余りを下から上に並べて 1101
\]</p>
<p/>
  <!-- -->
<ul>
<li>これでうまくいく理由は以下の計算と同じだからです</li>
</ul>
</li>
</ul>
<p>\[
\begin{eqnarray}
13 &amp;=&amp; 2\times6 +  \textcolor{red}{1}  \\
&amp;=&amp; 2 \times (2 \times 3 + \textcolor{green}{0}) + \textcolor{red}{1}\\
&amp;=&amp; 2 \times (2 \times (2 \times 1 + \textcolor{blue}{1}) + \textcolor{green}{0}) + \textcolor{red}{1}\\
&amp;=&amp; 2 \times ( 2 \times (2 \times (2 \times 0 + \textcolor{magenta}{1})  + \textcolor{blue}{1}) + \textcolor{green}{0}) + \textcolor{red}{1}\\
&amp;=&amp; 2 \times ( 2 \times (2^2 \times 0 + 2^1 \times \textcolor{magenta}{1} + 2 ^0 \times \textcolor{blue}{1})  + \textcolor{green}{0}) + \textcolor{red}{1}\\
&amp;=&amp; 2 \times ( 2^3 \times 0 + 2^2 \times \textcolor{magenta}{1} + 2^1 \times \textcolor{blue}{1} + 2^0 \times \textcolor{green}{0}) + \textcolor{red}{1}\\
&amp;=&amp; 2^4 \times 0 + 2^3 \times \textcolor{magenta}{1} + 2^2 \times \textcolor{blue}{1} + 2^1 \times \textcolor{green}{0} + 2^0 \times \textcolor{red}{1}\\
&amp;=&amp; (2進数で)\textcolor{magenta}{1}\textcolor{blue}{1}\textcolor{green}{0}\textcolor{red}{1}\\
\end{eqnarray}
\]</p>
<ul>
<li>
<p>2のべき乗を使う方法</p>
<ul>
<li>大きい2のべき乗から順番に，
例えば，\(2^3=8\)を引けたら，\(2^3\)の位を1にする．
0になるまで繰り返す．</li>
<li>例: 13を2進数に変換</li>
</ul>
</li>
</ul>
<p>\[
\left.
\begin{eqnarray}
13 - 2^3 &amp;=&amp; 5 \rightarrow 2^3の位は1 \\
5 - 2^2 &amp;=&amp; 1 \rightarrow 2^2の位は1 \\
1 - 2^1 &amp;=&amp; 引けない \rightarrow 2^1の位は0 \\
1 - 2^0 &amp;=&amp; 0 \rightarrow 2^0の位は1 
\end{eqnarray}
\right\}  上から下に並べて 1101
\]</p>
<ul>
<li>
<p><code>bc</code>コマンドを使う方法</p>
<ul>
<li>
<p><code>bc</code>は電卓コマンド．</p>
<pre><code>$ bc
1+2*3+10/5
9
^D         (ctrl-dで終了)
$
</code></pre>
</li>
<li>
<p>例: 10進数 13を2進数に変換</p>
<pre><code>$ bc
obase=2  (出力の底を2に変更)
13
1101     (13の2進数は1101)
^D
$
</code></pre>
</li>
<li>
<p>例: 16進数 1F4 を2進数に変換</p>
<pre><code>$ bc
obase=2    (出力の底を2に変更)
ibase=16   (入力の底を16に変更，入力の底の変更は出力の後が良い)
1F4
111110100  (1F4の2進数は111110100)
^D
$
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="用語-ビットバイトlsbmsb"><a class="header" href="#用語-ビットバイトlsbmsb">用語: ビット，バイト，LSB，MSB</a></h2>
<h3 id="ビットとバイト"><a class="header" href="#ビットとバイト">ビットとバイト</a></h3>
<img src="figs/bit-byte.svg" height="130px" id="fig:bit-byte">
<ul>
<li>
<p><strong>ビット</strong> (bit)</p>
<ul>
<li>ビットはコンピュータが扱うデータ量の最小単位．binary digit の略．</li>
<li>2進数のひと桁が1ビット．1ビットで<strong>0か1かの2通りの状態</strong>を表現．</li>
</ul>
</li>
<li>
<p><strong>バイト</strong> (byte)</p>
<ul>
<li>通常，8ビットのこと</li>
</ul>
</li>
</ul>
<details>
<summary>
通常，8ビット?
</summary>
<p>現在では1バイト=8ビットのコンピュータしか目にしませんが，
かつてはそうではないコンピュータもありました．
そのため，厳密に8ビットを指すための言葉として，
<strong>オクテット</strong>(octet)という言葉も使われています．
ですが，1バイト=8ビットと考えて問題ありません．</p>
</details>
<ul>
<li>ビットやバイトはレジスタやメモリなどの記憶領域の<strong>容量</strong>の単位としても使われます
<ul>
<li>レジスタ<code>%rax</code>は8バイトのデータを格納できます．</li>
<li>(バイトアドレッシングの)メモリは1つのアドレスごとに1バイトのデータを格納できます</li>
</ul>
</li>
</ul>
<details>
<summary>
バイトアドレッシング
</summary>
<p><strong>バイトアドレッシング</strong>なメモリとは
1つのアドレスごとに1バイトのデータを格納できるメモリのこと．
つまり，1バイトの配列としてアクセスするメモリのことです．
一方，ワード(バイト数はアーキテクチャ依存)の配列としてアクセスするメモリを
<strong>ワードアドレッシング</strong>なメモリと言います．</p>
</details>
<h3 id="msbとlsb"><a class="header" href="#msbとlsb">MSBとLSB</a></h3>
<img src="figs/LSB-MSB.svg" height="80px" id="fig:LSB-MSB">
<ul>
<li>ビット列で最左のビットを<strong>最上位ビット</strong> (MSB, most significant bit)といいます</li>
<li>ビット列で最右のビットを<strong>最下位ビット</strong> (LSB, least significant bit)といいます</li>
<li>多倍長データの最上位バイト (most significant byte)と
最下位バイト (least significant byte)も略称がMSBとLSBなので，
どちらを指すかは要注意です</li>
</ul>
<h3 id="ビットの呼び方"><a class="header" href="#ビットの呼び方">ビットの呼び方</a></h3>
<img src="figs/bit-0origin.svg" height="100px" id="fig:bit-0origin">
<ul>
<li>LSBから左に(0から始めて)0ビット目，1ビット目，...，7ビット目と呼ぶことが多いです
(例えばIntelのマニュアルで <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a>)</li>
<li>0から数え始めることを<strong>0オリジン</strong> (zero-origin)，あるいは<strong>0ベース</strong> (zero-based)といいます</li>
</ul>
<h3 id="ワードロングクアッド"><a class="header" href="#ワードロングクアッド">ワード，ロング，クアッド</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>サイズ<br/>(バイト)</th><th>サイズ<br/>(ビット)</th><th>Cのデータ型<br/>(LP64)</th><th>アセンブラ<br/>命令</th><th>命令<br/>サフィックス</th></tr></thead><tbody>
<tr><td>バイト</td><td>1</td><td>8</td><td><code>char</code></td><td><code>.byte</code></td><td><code>mov<span style="color:red">b</span></code></td></tr>
<tr><td>ワード</td><td>2</td><td>16</td><td><code>short</code></td><td><code>.word</code></td><td><code>mov<span style="color:red">w</span></code></td></tr>
<tr><td>ロング，<br/>ダブルワード</td><td>4</td><td>32</td><td><code>int</code></td><td><code>.long</code></td><td><code>mov<span style="color:red">l</span></code></td></tr>
<tr><td>クアッド</td><td>8</td><td>64</td><td><code>long</code>,<br/>ポインタ</td><td><code>.quad</code></td><td><code>mov<span style="color:red">q</span></code></td></tr>
</tbody></table>
</div>
<ul>
<li>ワード，ロング，クアッドのサイズはアーキテクチャ依存です．
x86-64では，それぞれ，2バイト，4バイト，8バイトになります．</li>
<li>C言語の整数型やポインタ型のサイズはプラットフォーム依存です．
最近主流のLP64データモデルでは，
上記の通り，<code>int</code>は4バイト，<code>long</code>とポインタは8バイトになります．</li>
<li>GNUアセンブラでは次の表記等でデータのサイズを指定します．
<ul>
<li>アセンブラ命令で整数データを出力する際には，
サイズに応じて，<code>.byte</code>，<code>.word</code>，<code>.long</code>，<code>.quad</code>を使います</li>
<li>多くの機械語命令でオペランドのサイズを命令サフィックスで指定します．
例えば，<code>mov<span style="color:red">q</spa></code>は
オペランドのサイズが8バイトであることを示します</li>
</ul>
</li>
</ul>
<h3 id="stdinth"><a class="header" href="#stdinth"><code>&lt;stdint.h&gt;</code></a></h3>
<ul>
<li>符号あり</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>型名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>int8_t</code></td><td>符号あり8ビット</td></tr>
<tr><td><code>int16_t</code></td><td>符号あり16ビット</td></tr>
<tr><td><code>int32_t</code></td><td>符号あり32ビット</td></tr>
<tr><td><code>int64_t</code></td><td>符号あり64ビット</td></tr>
<tr><td><code>intptr_t</code></td><td>符号ありポインタ用</td></tr>
</tbody></table>
</div>
<ul>
<li>符号なし</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>型名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>uint8_t</code></td><td>符号なし8ビット</td></tr>
<tr><td><code>uint16_t</code></td><td>符号なし16ビット</td></tr>
<tr><td><code>uint32_t</code></td><td>符号なし32ビット</td></tr>
<tr><td><code>uint64_t</code></td><td>符号なし64ビット</td></tr>
<tr><td><code>uintptr_t</code></td><td>符号なしポインタ用</td></tr>
</tbody></table>
</div>
<ul>
<li><code>&lt;stdint.h&gt;</code>は標準ヘッダファイルで，固定長の整数や
符号の有無を確実に扱いたい時に便利です．</li>
</ul>
<h2 id="文字コード"><a class="header" href="#文字コード">文字コード</a></h2>
<h3 id="文字コードとは"><a class="header" href="#文字コードとは">文字コードとは</a></h3>
<ul>
<li>文字コード = 各文字を区別するために，重複無く割り振った番号です
<ul>
<li>ASCIIコードで文字<code>A</code>の文字コードは(7ビットの)65</li>
<li>ASCIIコードで文字<code>9</code>の文字コードは(7ビットの)57</li>
</ul>
</li>
</ul>
<pre><code>// ascii.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;'%c', %d\n&quot;, 'A', 'A');
    printf (&quot;'%c', %d\n&quot;, '9', '9');
}
</code></pre>
<pre><code>$ gcc -g ascii.c
$ ./a.out
'A', 65
'9', 57
</code></pre>
<ul>
<li>
<p>文字コードにはいろいろな種類がありますが，GNUアセンブラではASCIIコードのみを使います．</p>
</li>
<li>
<p>文字コードはフォント(書体)や文字の大きさの情報は含んでいません．</p>
<img src="figs/font.svg" height="100px" id="fig:font">
<p>例えば，上図の文字Aはフォントも大きさも異なりますが，
どちらもASCIIコードでは同じ「1バイトの65」です．</p>
</li>
</ul>
<h2 id="ASCII"><a class="header" href="#ASCII">ASCIIコード</a></h2>
<h3 id="asciiコード表"><a class="header" href="#asciiコード表">ASCIIコード表</a></h3>
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th><th>番号</th><th>文字</th></tr></thead><tbody>
<tr><td>0</td><td><code>^@</code></td><td>16</td><td><code>^P</code></td><td>32</td><td>␣</td><td>48</td><td><code>0</code></td><td>64</td><td><code>@</code></td><td>80</td><td><code>P</code></td><td>96</td><td><code>`</code></td><td>112</td><td><code>p</code></td></tr>
<tr><td>1</td><td><code>^A</code></td><td>17</td><td><code>^Q</code></td><td>33</td><td><code>!</code></td><td>49</td><td><code>1</code></td><td>65</td><td><code>A</code></td><td>81</td><td><code>Q</code></td><td>97</td><td><code>a</code></td><td>113</td><td><code>q</code></td></tr>
<tr><td>2</td><td><code>^B</code></td><td>18</td><td><code>^R</code></td><td>34</td><td><code>&quot;</code></td><td>50</td><td><code>2</code></td><td>66</td><td><code>B</code></td><td>82</td><td><code>R</code></td><td>98</td><td><code>b</code></td><td>114</td><td><code>r</code></td></tr>
<tr><td>3</td><td><code>^C</code></td><td>19</td><td><code>^S</code></td><td>35</td><td><code>#</code></td><td>51</td><td><code>3</code></td><td>67</td><td><code>C</code></td><td>83</td><td><code>S</code></td><td>99</td><td><code>c</code></td><td>115</td><td><code>s</code></td></tr>
<tr><td>4</td><td><code>^D</code></td><td>20</td><td><code>^T</code></td><td>36</td><td><code>$</code></td><td>52</td><td><code>4</code></td><td>68</td><td><code>D</code></td><td>84</td><td><code>T</code></td><td>100</td><td><code>d</code></td><td>116</td><td><code>t</code></td></tr>
<tr><td>5</td><td><code>^E</code></td><td>21</td><td><code>^U</code></td><td>37</td><td><code>%</code></td><td>53</td><td><code>5</code></td><td>69</td><td><code>E</code></td><td>85</td><td><code>U</code></td><td>101</td><td><code>e</code></td><td>117</td><td><code>u</code></td></tr>
<tr><td>6</td><td><code>^F</code></td><td>22</td><td><code>^V</code></td><td>38</td><td><code>&amp;</code></td><td>54</td><td><code>6</code></td><td>70</td><td><code>F</code></td><td>86</td><td><code>V</code></td><td>102</td><td><code>f</code></td><td>118</td><td><code>v</code></td></tr>
<tr><td>7</td><td><code>^G</code></td><td>23</td><td><code>^W</code></td><td>39</td><td><code>'</code></td><td>55</td><td><code>7</code></td><td>71</td><td><code>G</code></td><td>87</td><td><code>W</code></td><td>103</td><td><code>g</code></td><td>119</td><td><code>w</code></td></tr>
<tr><td>8</td><td><code>^H</code></td><td>24</td><td><code>^X</code></td><td>40</td><td><code>(</code></td><td>56</td><td><code>8</code></td><td>72</td><td><code>H</code></td><td>88</td><td><code>X</code></td><td>104</td><td><code>h</code></td><td>120</td><td><code>x</code></td></tr>
<tr><td>9</td><td><code>^I</code></td><td>25</td><td><code>^Y</code></td><td>41</td><td><code>)</code></td><td>57</td><td><code>9</code></td><td>73</td><td><code>I</code></td><td>89</td><td><code>Y</code></td><td>105</td><td><code>i</code></td><td>121</td><td><code>y</code></td></tr>
<tr><td>10</td><td><code>^J</code></td><td>26</td><td><code>^Z</code></td><td>42</td><td><code>*</code></td><td>58</td><td><code>:</code></td><td>74</td><td><code>J</code></td><td>90</td><td><code>Z</code></td><td>106</td><td><code>j</code></td><td>122</td><td><code>z</code></td></tr>
<tr><td>11</td><td><code>^K</code></td><td>27</td><td><code>^[</code></td><td>43</td><td><code>+</code></td><td>59</td><td><code>;</code></td><td>75</td><td><code>K</code></td><td>91</td><td><code>[</code></td><td>107</td><td><code>k</code></td><td>123</td><td><code>{</code></td></tr>
<tr><td>12</td><td><code>^L</code></td><td>28</td><td><code>^\</code></td><td>44</td><td><code>,</code></td><td>60</td><td><code>&lt;</code></td><td>76</td><td><code>L</code></td><td>92</td><td><code>\</code></td><td>108</td><td><code>l</code></td><td>124</td><td>`</td></tr>
<tr><td>13</td><td><code>^M</code></td><td>29</td><td><code>^]</code></td><td>45</td><td><code>-</code></td><td>61</td><td><code>=</code></td><td>77</td><td><code>M</code></td><td>93</td><td><code>]</code></td><td>109</td><td><code>m</code></td><td>125</td><td><code>}</code></td></tr>
<tr><td>14</td><td><code>^N</code></td><td>30</td><td><code>^^</code></td><td>46</td><td><code>.</code></td><td>62</td><td><code>&gt;</code></td><td>78</td><td><code>N</code></td><td>94</td><td><code>^</code></td><td>110</td><td><code>n</code></td><td>126</td><td><code>~</code></td></tr>
<tr><td>15</td><td><code>^O</code></td><td>31</td><td><code>^_</code></td><td>47</td><td><code>/</code></td><td>63</td><td><code>?</code></td><td>79</td><td><code>O</code></td><td>95</td><td><code>_</code></td><td>111</td><td><code>o</code></td><td>127</td><td><code>^?</code></td></tr>
</tbody></table>
</div></div>
<ul>
<li>128個の文字を扱うコード体系
<ul>
<li>通常，MSBを0にした1バイトデータとして扱う</li>
</ul>
</li>
<li>英字アルファベット，数字，記号，<strong>制御文字</strong> (control character)を含む</li>
</ul>
<h3 id="制御文字"><a class="header" href="#制御文字">制御文字</a></h3>
<ul>
<li>制御文字は出力装置に(文字表示以外の)動作を要求します
<ul>
<li>
<p>例: 改行文字 <code>^J</code> (line feed, C言語では<code>\n</code>)は端末ディスプレイに改行を要求する．
「次に表示する位置を変更する」という動作を要求しています．</p>
</li>
<li>
<p>例: エスケープ文字 <code>^[</code>で始まる文字列 <code>^[[7m</code>は文字反転，
<code>^[[0m</code>は元に戻すというANSIエスケープシーケンスです．
「次に表示する文字と背景の色を変更する」という動作を要求しています．</p>
<pre><code>$ echo -e "aaa \E[7mbbb\E[0m ccc"
aaa <span style="color:white;background-color:black">bbb</span> ccc
$ cat
aaa  ^[[7mbbb  ^[[0mccc     (ctrl-vを押してからエスケープキーを入力)
aaa  <span style="color:white;background-color:black">bbb</span>  ccc
</code></pre>
<p><code>echo</code>コマンドの<code>-e</code>は「バックスラッシュによるエスケープを解釈する」というオプションです．また，<code>\E</code>は<code>bash</code>でエスケープ文字を表すエスケープシーケンスです．
ほとんどの端末ソフトで文字列<code>bbb</code>と背景色の色が反転します．
<code>cat</code>コマンドの場合は，<code>ctrl-v</code>を押してからエスケープキーを押すと
エスケープ文字が入力できて，<code>^[</code>と表示されます(2文字に見えますがこれで1文字です)．</p>
</li>
<li>
<p>ASCIIの以下の制御文字は覚えておきましょう．</p>
<div class="table-wrapper"><table><thead><tr><th>制御文字</th><th>意味</th><th>C言語のエスケープ文字</th><th>キーボード中のキー</th></tr></thead><tbody>
<tr><td><code>^@</code></td><td>ヌル文字</td><td><code>\0</code></td><td></td></tr>
<tr><td><code>^D</code></td><td>End of File (EOF)</td><td></td><td></td></tr>
<tr><td><code>^H</code></td><td>Back Space (後退)</td><td><code>\b</code></td><td>Back Space</td></tr>
<tr><td><code>^I</code></td><td>Horizontal Tab (水平タブ)</td><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>^J</code></td><td>Line Feed (改行)</td><td><code>\n</code></td><td></td></tr>
<tr><td><code>^M</code></td><td>Carriage Return (復帰)</td><td><code>\r</code></td><td>Enter</td></tr>
<tr><td><code>^[</code></td><td>Escape (エスケープ)</td><td></td><td>Esc</td></tr>
<tr><td><code>^?</code></td><td>Delete (削除)</td><td></td><td>Delete</td></tr>
</tbody></table>
</div></li>
</ul>
</li>
</ul>
<details>
<summary>
制御文字Deleteが127である理由
</summary>
<p>パンチカード時代に「穴が開いているビットは1」と扱っていて，
Deleteを127 (2進数で1111111)にしておけば，
「どんな文字に対しても全てのビットの穴を開ければ，
その文字を削除できたから」です．
なおパンチカードの実物は私も見たことはありません．
(大昔のゴジラの映画で見た貴ガス)．</p>
</details>
<h3 id="ctrl-j-や-ctrl-m-で改行できることが多い理由"><a class="header" href="#ctrl-j-や-ctrl-m-で改行できることが多い理由"><code>ctrl-j</code> や <code>ctrl-m</code> で改行できる(ことが多い)理由</a></h3>
<ul>
<li>歴史的な話ですが，<code>ctrl</code>キーを押しながら，あるキー(例えば<code>j</code>)を押すと，
<code>j</code>のASCIIコード(2進数8ビット表記で 01101010)の
上位３ビットをゼロにした 00001010 (つまり改行文字 <code>^J</code>)を入力できました．</li>
<li>そのなごりで，今でも<code>ctrl-j</code>や<code>ctrl-m</code>を押すとEnterキーの入力と同じ動作を
するソフトウェアが多くあります．
同様に，<code>ctrl-i</code>でTabを，<code>ctrl-[</code>でEscapeを，<code>ctrl-h</code>でBack Spaceを
入力できるソフトウェアが多いです．</li>
<li>もちろん，現在ではキーの処理はソフトウェアごとに自由に決められるので，
<code>ctrl-j</code>で常に改行できるわけではありません．</li>
</ul>
<h3 id="ファイルの改行文字"><a class="header" href="#ファイルの改行文字">ファイルの改行文字</a></h3>
<div class="table-wrapper"><table><thead><tr><th>OS</th><th>ファイル中の<br/>改行文字</th><th>記号</th></tr></thead><tbody>
<tr><td>Linux, macOS</td><td><code>^J</code></td><td>LF</td></tr>
<tr><td>Windows</td><td><code>^M</code> <code>^J</code></td><td>CR LF</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>LinuxやmacOSのファイルでは，通常，ファイル中の改行を
Line Feed (<code>^j</code>, LF)の1文字で表します．
一方，Windows では 
Carriage Return (<code>^m</code>, CR)とLine Feed (<code>^j</code>, LF)の2文字で表すことが多いです．
(ファイル中の改行文字はエディタの設定で通常，変更可能)．</p>
</li>
<li>
<p>このため，Windows で作成したファイルを Linux で開くと，
行末に <code>^M</code> が見えることがあります．「改行が CR LF なんだな」と思って下さい．</p>
<pre><code>$ ❶ cat foo2.txt
hello
byebye
$ ❷ cat -v foo2.txt
❸ hello^M
byebye^M

$ ❹ od -c -t x1 foo2.txt
0000000   h   e   l   l   o ❺ \r  \n   b   y   e   b   y   e  \r  \n
         68  65  6c  6c  6f    0d  0a  62  79  65  62  79  65  0d  0a
0000017
</code></pre>
<ul>
<li>例えば，改行が CR LF なファイル<code>foo2.txt</code>を用意して，
❶ <code>cat</code>で表示すると普通に表示されますが，
❷ <code>-v</code>オプション(制御文字を可視化)を使うと，❸<code>^M</code>が表示されました．</li>
<li>❹ <code>od</code>コマンドを使っても，CRの存在を確認できます (❺ <code>\r</code>)．</li>
</ul>
</li>
</ul>
<h3 id="文字集合と符号化方式unicodeとutf-8"><a class="header" href="#文字集合と符号化方式unicodeとutf-8">文字集合と符号化方式，UnicodeとUTF-8</a></h3>
<p>GNUアセンブラではASCIIコードのみを使用するので，
この節の話はスキップ可能です．</p>
<ul>
<li>ASCIIコードでは文字コード(文字の背番号，<strong>コードポイント</strong>)をそのままバイナリ表現として使っていました．</li>
<li>一方，多くの文字コード体系では<strong>文字集合</strong>と<strong>符号化方式</strong>を区別しています．
<ul>
<li>
<p>例えば，Unicodeは(ほぼ世界中の)文字を定める<strong>文字集合</strong>です．
Unicodeで日本語の「あ」のコードポイントは<code>0x3042</code>です．</p>
</li>
<li>
<p>UTF-8はUnicodeの<strong>符号化方式</strong>の一つです．
UTF-8で「あ」をバイト列に符号化すると，<code>0xE3</code>，<code>0x81</code>，<code>0x82</code>になります．
(Unicodeの他の符号化方式として，UTF-16やUTF-32もあります)．</p>
<img src="figs/utf8.svg" height="170px" id="fig:utf8">
<pre><code>$ cat a.txt
あ
$ od -t x1 a.txt
0000000 e3 81 82 0a
0000004
</code></pre>
<p><code>od</code>コマンドで確かめると「あ」が<code>0xE3</code>，<code>0x81</code>，<code>0x82</code>のバイト列と確認できます．
最後の<code>0x0A</code>は改行文字 (<code>\n</code>)ですね．</p>
</li>
<li>
<p><span style="color:white;background-color:black">1110</span>や
<span style="color:white;background-color:black">10</span>を使う理由は
あるバイトが文字の<strong>最初のバイト</strong>なのか，<strong>２バイト目以降</strong>なのかを簡単に
区別できるからです．
また，1バイトの文字 (例えば <code>A</code>)と混同する心配もありません．</p>
</li>
<li>
<p>UTF-8はASCIIと互換性があるのが大きな利点です．
ASCIIコードで書かれたテキストはそのままUTF-8として処理できます．</p>
</li>
</ul>
</li>
</ul>
<h2 id="符号なし整数"><a class="header" href="#符号なし整数">符号なし整数</a></h2>
<h3 id="符号なし整数のビット表現"><a class="header" href="#符号なし整数のビット表現">符号なし整数のビット表現</a></h3>
<ul>
<li>2進数の各桁をそのままビット表現とする
<ul>
<li>例: 2を8ビットの符号なし整数で表現すると，
2の2進数は10なので，00000010 になる．
(余った上位ビットに0を入れることに注意)</li>
</ul>
</li>
</ul>
<h3 id="符号なし整数の一覧表"><a class="header" href="#符号なし整数の一覧表">符号なし整数の一覧表</a></h3>
<ul>
<li>前半</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ビット表現</th><th style="text-align: center">10進数</th><th style="text-align: center">16進数</th></tr></thead><tbody>
<tr><td style="text-align: center">00000000</td><td style="text-align: center">0</td><td style="text-align: center">0x0</td></tr>
<tr><td style="text-align: center">00000001</td><td style="text-align: center">1</td><td style="text-align: center">0x1</td></tr>
<tr><td style="text-align: center">00000010</td><td style="text-align: center">2</td><td style="text-align: center">0x2</td></tr>
<tr><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td></tr>
<tr><td style="text-align: center">01111110</td><td style="text-align: center">126</td><td style="text-align: center">0x7E</td></tr>
<tr><td style="text-align: center">01111111</td><td style="text-align: center">127</td><td style="text-align: center">0x7F</td></tr>
</tbody></table>
</div>
<ul>
<li>後半</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ビット表現</th><th style="text-align: center">10進数</th><th style="text-align: center">16進数</th></tr></thead><tbody>
<tr><td style="text-align: center">10000000</td><td style="text-align: center">128</td><td style="text-align: center">0x80</td></tr>
<tr><td style="text-align: center">10000001</td><td style="text-align: center">129</td><td style="text-align: center">0x81</td></tr>
<tr><td style="text-align: center">10000010</td><td style="text-align: center">130</td><td style="text-align: center">0x82</td></tr>
<tr><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td></tr>
<tr><td style="text-align: center">11111110</td><td style="text-align: center">254</td><td style="text-align: center">0xFE</td></tr>
<tr><td style="text-align: center">11111111</td><td style="text-align: center">255</td><td style="text-align: center">0xFF</td></tr>
</tbody></table>
</div>
<h3 id="符号なし整数の扱える範囲"><a class="header" href="#符号なし整数の扱える範囲">符号なし整数の扱える範囲</a></h3>
<ul>
<li>固定長の整数の範囲は有限
<ul>
<li>例: 8ビット符号なし整数が表現できる範囲は \(0\)から\(255\)まで</li>
</ul>
</li>
<li>一般に\(n\)ビット符号なし整数の範囲は \(0\)から\(2^n-1\)まで</li>
<li>(符号なしなので当然ですが)負の値は表現できない</li>
</ul>
<h3 id="符号なし整数の最大値と最小値のビットパターン"><a class="header" href="#符号なし整数の最大値と最小値のビットパターン">符号なし整数の最大値と最小値のビットパターン</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>ビット表現</th><th>10進数</th><th>16進数</th></tr></thead><tbody>
<tr><td>8ビットの最小値</td><td>00000000</td><td>0</td><td>0x0</td></tr>
<tr><td>8ビットの最大値</td><td>11111111</td><td>255=\(2^8-1\)</td><td>0xFF</td></tr>
<tr><td>16ビットの最小値</td><td>00000000 00000000</td><td>0</td><td>0x0</td></tr>
<tr><td>16ビットの最大値</td><td>11111111 11111111</td><td>65535=\(2^{16}-1\)</td><td>0xFFFF</td></tr>
<tr><td>32ビットの最小値</td><td>00000000 00000000 00000000 00000000</td><td>0</td><td>0x0</td></tr>
<tr><td>32ビットの最大値</td><td>11111111 11111111 11111111 11111111</td><td>4294967295=\(2^{32}-1\)</td><td>0xFFFFFFFF</td></tr>
</tbody></table>
</div>
<ul>
<li>見やすさのため8ビットごとにスペースを入れてます</li>
<li>最小値は全てのビットが0，最大値は全てのビットが1</li>
<li>32ビット符号なし整数の最大値は約42.9億．現在の世界の人口(約80億人)を数えられない</li>
</ul>
<h3 id="符号なし整数のオーバーフロー"><a class="header" href="#符号なし整数のオーバーフロー">符号なし整数のオーバーフロー</a></h3>
<ul>
<li>演算の結果，表現できる範囲を超えた場合を<strong>オーバーフロー</strong> (overflow)と言う．</li>
<li>8ビット符号なし整数が表現できる範囲は0から255まで(復習)</li>
<li>例: 8ビット符号なし整数の255に1を足すと，256は表現できる範囲外なので，
オーバーフローして結果は0になる</li>
</ul>
<pre><code>// overflow1.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main ()
{
    uint8_t x = 255;    
    x++;
    printf (&quot;%d\n&quot;, x);
}
</code></pre>
<pre><code>$ gcc -g overflow1.c 
$ ./a.out
0
</code></pre>
<ul>
<li>例: 8ビット符号なし整数の0から1を引くと，-1は表現できる範囲外なので，
オーバーフローして結果は255になる</li>
</ul>
<pre><code>// overflow2.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main ()
{
    uint8_t x = 0;
    x--;
    printf (&quot;%d\n&quot;, x);
}
</code></pre>
<pre><code>$ gcc -g overflow2.c 
$ ./a.out
255
</code></pre>
<ul>
<li>8ビット符号なし整数のオーバーフロー時の動作:
0から255までの範囲に収まるように，<strong>256で割った余り</strong>を計算結果とする
(これはC言語規格の定義とも合致する)．</li>
<li>一般的には\(n\)ビット符号なし整数の場合，
オーバーフローの結果は，\(0\)から\(2^n-1\)の範囲に収まるように，
<strong>\(2^n\)で割った余り</strong>を計算結果とする．</li>
</ul>
<details>
<summary>
「割った余りを計算結果とする」の別の言い方
</summary>
<p>「\(2^n\)で割った余りを計算結果とする」の別の言い方として，
以下の言い方をすることがあります．</p>
<ul>
<li>「<strong>モジュロ</strong> (modulo) \(2^n\)を取る」</li>
<li>「\(2^n\)を<strong>法</strong>とする」</li>
</ul>
</details>
<h3 id="キャリーとボロー"><a class="header" href="#キャリーとボロー">キャリーとボロー</a></h3>
<ul>
<li>
<p><strong>キャリー</strong> (carry)は繰り上げ，<strong>ボロー</strong>(borrow)は繰り下げのこと</p>
</li>
<li>
<p>符号なし整数のオーバーフローはキャリーやボローの有無でチェックできる</p>
</li>
<li>
<p>例: 8ビット符号なし整数で255+1を計算すると，キャリーが発生する</p>
<img src="figs/carry.svg" height="170px" id="fig:carry">
</li>
<li>
<p>例: 8ビット符号なし整数で0-1を計算すると，ボローが発生する</p>
<img src="figs/borrow.svg" height="170px" id="fig:borrow">
</li>
<li>
<p>x86-64では符号<strong>なし</strong>整数のオーバーフローは，
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0"><strong>キャリーフラグ</strong>(CF)</a>で検出できる．
キャリーやボローが発生するとキャリーフラグが立つから．</p>
<ul>
<li>cf. x86-64では符号<strong>あり</strong>整数のオーバーフローは，
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0"><strong>オーバーフローフラグ</strong>(OF)</a>で検出できる</li>
</ul>
</li>
</ul>
<h2 id="符号あり整数2の補数"><a class="header" href="#符号あり整数2の補数">符号あり整数，2の補数</a></h2>
<h3 id="符号あり整数のビット表現"><a class="header" href="#符号あり整数のビット表現">符号あり整数のビット表現</a></h3>
<ul>
<li>
<p>非負(0か正数)の数は2進数の各桁をそのままビット表現，
負の数は<strong>2の補数</strong> (two's complement)を使う</p>
<ul>
<li>MSBは符号ビットになる．0なら非負，1なら負になる．</li>
<li>2の補数以外にも負の数の表現方法はある．
2の補数を使う理由は，(1) 減算を加算処理で行えるから，
(2) x86-64が2の補数を使っているからです．</li>
</ul>
</li>
<li>
<p>例: 8ビットの符号あり整数の場合，</p>
<ul>
<li>前半の00000000〜01111111を0と正の数に，
後半の10000000〜11111111を負の数にする．</li>
<li>例えば，126に対する(8ビットの場合の)2の補数は130(=256-126)なので，
130の2進表記 10000010 を -126 のビット表現とする．</li>
</ul>
</li>
</ul>
<h3 id="一覧表"><a class="header" href="#一覧表">一覧表</a></h3>
<ul>
<li>前半 (0と正の数)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ビット表現</th><th style="text-align: center">10進数</th><th style="text-align: center">16進数</th></tr></thead><tbody>
<tr><td style="text-align: center">00000000</td><td style="text-align: center">0</td><td style="text-align: center">0x0</td></tr>
<tr><td style="text-align: center">00000001</td><td style="text-align: center">1</td><td style="text-align: center">0x1</td></tr>
<tr><td style="text-align: center">00000010</td><td style="text-align: center">2</td><td style="text-align: center">0x2</td></tr>
<tr><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td></tr>
<tr><td style="text-align: center">01111110</td><td style="text-align: center">126</td><td style="text-align: center">0x7E</td></tr>
<tr><td style="text-align: center">01111111</td><td style="text-align: center">127</td><td style="text-align: center">0x7F</td></tr>
</tbody></table>
</div>
<ul>
<li>後半 (負の数)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ビット表現</th><th style="text-align: center">10進数</th><th style="text-align: center">16進数</th></tr></thead><tbody>
<tr><td style="text-align: center">10000000</td><td style="text-align: center">-128</td><td style="text-align: center">-0x80</td></tr>
<tr><td style="text-align: center">10000001</td><td style="text-align: center">-127</td><td style="text-align: center">-0x7F</td></tr>
<tr><td style="text-align: center">10000010</td><td style="text-align: center">-126</td><td style="text-align: center">-0x7E</td></tr>
<tr><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td><td style="text-align: center">\(\vdots\)</td></tr>
<tr><td style="text-align: center">11111110</td><td style="text-align: center">-2</td><td style="text-align: center">-0x2</td></tr>
<tr><td style="text-align: center">11111111</td><td style="text-align: center">-1</td><td style="text-align: center">-0x1</td></tr>
</tbody></table>
</div>
<h3 id="2の補数と1の補数"><a class="header" href="#2の補数と1の補数">2の補数と1の補数</a></h3>
<ul>
<li>
<p>2の補数とは(キャリーを無視して)加算して全てのビットが0になる数です</p>
<ul>
<li>
<p>例: 8ビットの場合，126 (2進数で 01111110)の2の補数は10000010 (=130)です．
01111110+10000010=00000000になるからです(キャリーを無視すれば)．
\(126+130=256=2^8\)</p>
<img src="figs/2comp.svg" height="170px" id="fig:2comp">
</li>
</ul>
</li>
<li>
<p>1の補数とは(キャリーを無視して)加算して全てのビットが1になる数です</p>
<ul>
<li>
<p>例: 8ビットの場合，126 (2進数で 01111110)の1の補数は
10000001 (=129)です．
01111110+10000001=11111111になるからです．
\(126+129=255=2^8-1\)</p>
<img src="figs/1comp.svg" height="170px" id="fig:1comp">
</li>
</ul>
</li>
<li>
<p>2の補数の求め方: 各ビットを反転してから，LSBに1を加えれば良い</p>
<img src="figs/2comp2.svg" height="220px" id="fig:2comp2">
</li>
<li>
<p>一般的に，\(n\)進数に対して，\(n\)の補数と，\((n-1)\)の補数が存在します</p>
<ul>
<li>\(n\)の補数は「足すとちょうど桁が上がる数」です．
10進数で2桁の数を考える時，\(65\)に対する10の補数は\(35\)になります．
足すと\(100\)になるから．</li>
<li>\(n-1\)の補数は「足してもギリギリ桁が上がらない数」です．
10進数で2桁の数を考える時，\(65\)に対する9の補数は\(34\)になります．
足すと\(99\)になるから．</li>
</ul>
</li>
</ul>
<h3 id="符号なし整数と符号あり整数の関係"><a class="header" href="#符号なし整数と符号あり整数の関係">符号なし整数と符号あり整数の関係</a></h3>
<ul>
<li>
<p>8ビットの場合，符号なし整数の128〜255の範囲のビット表現を，
符号あり整数の-128〜-1の範囲にシフトしたことになる．</p>
<img src="figs/unsigned-signed.svg" height="220px" id="fig:unsigned-signed">
</li>
<li>
<p>シフトの幅がどれもちょうど256であることがポイント．</p>
</li>
<li>
<p>「130を足す」のと「126を引く」のは同じ</p>
<ul>
<li>8ビット整数の場合，256を足しても引いても値は変化しませんよね．
キャリーやボローとしてはみ出るだけだからです．</li>
<li>例えば，1 + 256 = 1 ですし，1 - 256 = 1 です．
(数式ではこれを \(1 + 256 \equiv 1 \pmod {256}\) と書きます．
「256で割った余りで考えれば，同じ値である」という意味です．
ここでは単に = を使います)．</li>
<li>ですので，4 - 126 = 4 + (-126) = 4 + 256 + (-126) = 4 + 130 となります．</li>
</ul>
</li>
<li>
<p>時計で考えると分かりやすいかも．時計の上で，「7時間足す」のと「5時間引く」のは同じ．</p>
<img src="figs/clock.svg" height="220px" id="fig:clock">
</li>
</ul>
<h3 id="扱える範囲"><a class="header" href="#扱える範囲">扱える範囲</a></h3>
<ul>
<li>例: 8ビット符号あり整数が表現できる範囲は \(-128\)から\(127\)まで
<ul>
<li>\(128\)まででは無いのはプラス側にはゼロ (0)があるから</li>
</ul>
</li>
<li>一般に\(n\)ビット符号なし整数の範囲は \(-2^n/2\)から\(2^n/2-1\)まで
<ul>
<li>\(n\)ビットの場合，\(2^n\)通りの数が扱える．
正と負で半分ずつ使ってる (\(2^n/2\))が，
正の方はゼロ (0)があるので \(-1\)となる．</li>
</ul>
</li>
</ul>
<h3 id="最大値と最小値のビットパターン"><a class="header" href="#最大値と最小値のビットパターン">最大値と最小値のビットパターン</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>ビット表現</th><th>10進数</th><th>16進数</th></tr></thead><tbody>
<tr><td>8ビットの最小値</td><td>10000000</td><td>-128=\(-2^8/2\)</td><td>-0x80</td></tr>
<tr><td>8ビットの最大値</td><td>01111111</td><td>127=\(2^8/2-1\)</td><td>0x7F</td></tr>
<tr><td>16ビットの最小値</td><td>10000000 00000000</td><td>-32768=\(-2^{16}/2\)</td><td>-0x8000</td></tr>
<tr><td>16ビットの最大値</td><td>01111111 11111111</td><td>32767=\(2^{16}/2-1\)</td><td>0x7FFF</td></tr>
<tr><td>32ビットの最小値</td><td>10000000 00000000 00000000 00000000</td><td>-2147483648=\(-2^{32}/2\)</td><td>0x80000000</td></tr>
<tr><td>32ビットの最大値</td><td>01111111 11111111 11111111 11111111</td><td>2147483647=\(2^{32}/2-1\)</td><td>0x7FFFFFFF</td></tr>
</tbody></table>
</div>
<ul>
<li>見やすさのため8ビットごとにスペースを入れてます</li>
<li>最小値はMSBが1でそれ以外の全ビットが0，最大値はMSBが0でそれ以外の全ビットが1</li>
</ul>
<h3 id="x86-64は符号の有無を気にせず加算するどちらの結果も正しい"><a class="header" href="#x86-64は符号の有無を気にせず加算するどちらの結果も正しい">x86-64は符号の有無を気にせず加算する→どちらの結果も正しい</a></h3>
<ul>
<li>
<p>2の補数の利点 = 足し算回路で引き算ができる</p>
</li>
<li>
<p>例: 31-126は，31と -126 のビット表現の加算で計算できる．</p>
<ul>
<li>つまり 00011111 + 10000010 = 10100001 = -95</li>
<li>この結果が 31 + 130 = 10100001 = 161 の結果と，ビット表現が一致することに注意</li>
<li>これは当然で，8ビットの場合，31 + (-126) = 31 + 256 + (-126) = 31 + 130 だから
<img src="figs/unsigned-signed2.svg" height="150px" id="fig:unsigned-signed2"></li>
</ul>
</li>
<li>
<p>実際，x86-64は整数が符号ありか符号なしかを<strong>区別せずに加算</strong>している．
計算結果はどちらに対しても正しい．</p>
<ul>
<li>プログラマ(あるいはコンパイラ)は符号ありか符号なしかを意識する必要がある．
オーバーフローの判定に，キャリーフラグ(CF)とオーバーフローフラグ(OF)の
どちらを使うべきかを判断する必要があるから．</li>
</ul>
</li>
</ul>
<h3 id="signed-overflow"><a class="header" href="#signed-overflow">符号あり整数のオーバーフロー</a></h3>
<ul>
<li>
<p>8ビット符号あり整数の64に64を足すと，オーバーフローして結果は-128になる
(64 + 64 = 128 は８バイト符号あり整数が表現可能な-128〜127の範囲を超えている)．</p>
<img src="figs/overflow.svg" height="150px" id="fig:overflow">
</li>
<li>
<p>C言語の規格上，符号あり整数のオーバーフローは<strong>未定義動作</strong>(undefined behavior)．
つまり，符号あり整数をオーバーフローさせてはいけない．</p>
<ul>
<li>未定義動作を含むプログラムに対して，コンパイラはどのように振る舞っても良い．
<ul>
<li>コンパイルエラーにしても良いし，実行するたびに異なる結果を出力するコードを出力しても良いし，それっぽい答え(ここではオーバーフローしたビット表現)を出力しても良い</li>
</ul>
</li>
<li>ここでは-128の結果を得たが，C言語の規格上，他の結果がでる可能性がある</li>
</ul>
</li>
</ul>
<h3 id="符号あり整数ではオーバーフローとキャリーの有無は関係ない"><a class="header" href="#符号あり整数ではオーバーフローとキャリーの有無は関係ない">符号あり整数では，オーバーフローとキャリーの有無は関係ない</a></h3>
<ul>
<li>
<p>符号あり整数ではオーバーフローとキャリーの有無は関係ありません</p>
<img src="figs/overflow2.svg" height="220px" id="fig:overflow2">
<ul>
<li>例: 8ビット符号あり整数で，64+64=128 は，表現可能な-128〜127を超えているのでオーバーフロー発生．しかしキャリーは0</li>
<li>例: 8ビット符号あり整数で，(-1)+(-1)=-2は，表現可能な-128〜127の範囲内なので
オーバーフローは発生していない．しかしキャリーは1</li>
</ul>
</li>
<li>
<p>このため，x86-64では符号あり整数のオーバーフローを(キャリーフラグ(CF)ではなく)
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0"><strong>オーバーフローフラグ</strong>(OF)</a>で検出する</p>
<ul>
<li>一方，符号なし整数のオーバーフローは
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0"><strong>キャリーフラグ</strong>(CF)</a>で検出する</li>
</ul>
</li>
<li>
<p>なお人間が判断する場合は以下で簡単に判定できる</p>
<ul>
<li>正と正の数同士(どちらもMSBは0)を足して，負になったら(MSBは1)オーバーフロー発生</li>
<li>負と負の数同士(どちらもMSBは1)を足して，正になったら(MSBは0)オーバーフロー発生</li>
<li>正と負の数同士の足し算では決してオーバーフローは発生しない</li>
</ul>
</li>
</ul>
<h3 id="c言語で整数計算に注意が必要な場合"><a class="header" href="#c言語で整数計算に注意が必要な場合">C言語で整数計算に注意が必要な場合</a></h3>
<h4 id="符号あり整数のオーバーフロー-未定義動作"><a class="header" href="#符号あり整数のオーバーフロー-未定義動作">符号あり整数のオーバーフロー (未定義動作)</a></h4>
<pre><code>// overflow4.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main ()
{
    int32_t x1 = 10 * 10000 * 10000; // 10億
    int32_t x2 = 15 * 10000 * 10000; // 15億
    int32_t x3 = x1 + x2; // オーバーフロー
    printf (&quot;%d\n&quot;, x3); // -1794967296
}
</code></pre>
<pre><code>$ gcc -g overflow4.c
$ ./a.out
-1794967296
</code></pre>
<ul>
<li>符号あり整数のオーバーフローはセキュリティ上の脆弱性になるため避けるべきです．
<code>-ftrapv</code>オプションをつけると符号あり整数のオーバーフロー時に
トラップが発生します．
試した所，シグナル<code>SIGABRT</code>が発生してプログラムは終了しました．</li>
</ul>
<pre><code>$ gcc -g -ftrapv overflow4.c
$ ./a.out
Aborted
</code></pre>
<h4 id="絶対値を計算できない数がある"><a class="header" href="#絶対値を計算できない数がある">絶対値を計算できない数がある</a></h4>
<pre><code>// overflow5.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main ()
{
    int8_t  x1 = -128;
    int16_t x2 = -32768;
    int32_t x3 = -2147483648;
    x1 = -x1;
    x2 = -x2;
    x3 = -x3;
    printf (&quot;%d, %d, %d\n&quot;, x1, x2, x3);
}
</code></pre>
<pre><code>$ gcc -g overflow5.c
$ ./a.out
-128, -32768, -2147483648
</code></pre>
<ul>
<li>符号あり整数で表現可能な最小の数は絶対値を計算できません．</li>
<li>例えば8ビット符号あり整数-128の絶対値は計算できません．
絶対値の128が，表現可能な範囲-128〜127を超えてしまうからです．</li>
<li>この場合もオーバーフローが起きているので未定義動作となります．</li>
</ul>
<h4 id="符号ありと符号なしを混ぜると直感に反する結果になる"><a class="header" href="#符号ありと符号なしを混ぜると直感に反する結果になる">符号ありと符号なしを混ぜると直感に反する結果になる</a></h4>
<pre><code>// signed-unsigned.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main ()
{
    int32_t x1 = -1;
    uint32_t x2 = 0;
    printf (&quot;%d\n&quot;, x1 &lt; x2); // 0
}
</code></pre>
<pre><code>$ gcc -g singed-unsigned.c
$ ./a.out
0
</code></pre>
<ul>
<li>これはオーバーフローではなくC言語の規格に関する話です．</li>
<li>上の<code>signed-unsigned.c</code>を実行すると<code>0</code>が返りました．
(<code>-1 &lt; 0</code>は真なので<code>1</code>が返って欲しいのに)．</li>
<li>これは違う型同士の演算ではC言語ではまず型を同じにするためです
(通常の算術型変換といいます)．
この場合は<code>-1</code>を符号なしに変換します．
その結果，<code>0xFFFFFFFF</code>という大きな正の数になり，
<code>0xFFFFFFFF &lt; 0</code>を比較して<code>0</code>が返るわけです．</li>
<li>この問題があるため，C言語では符号ありと符号なしを混ぜて使うことを避けるべきです．
<ul>
<li>通常は符号ありの整数を使う</li>
<li>ビット演算をしたい場合などに限定して符号なしの整数を使う
(符号あり整数へのビット演算は(未定義動作ではないが)
処理系定義の動作を引き起こす場合があるため)．</li>
</ul>
</li>
</ul>
<h2 id="機械語命令の符号化"><a class="header" href="#機械語命令の符号化">機械語命令の符号化</a></h2>
<h3 id="覚える必要はありません"><a class="header" href="#覚える必要はありません">覚える必要はありません</a></h3>
<ul>
<li>機械語命令の符号化方法はCPUごとに異なります</li>
<li>x86-64の機械語命令の符号化方法はx86-64のマニュアル <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a>に書いてありますし，アセンブラが自動変換してくれるので，私達は覚える必要は全くありません</li>
<li>とはいえ，「機械語命令も2進数で符号化されている」ことを確認するために，
機械語命令の符号化をちょっとだけ見てみましょう</li>
</ul>
<h3 id="概要"><a class="header" href="#概要">概要</a></h3>
<ul>
<li>x86-64はCISC (complex instruction set computer)なので，
「1つの命令で複雑な処理をする」という設計哲学です．
そのため命令は可変長(1バイト〜15バイト)で複雑です．
一方，RISC (reduced instruction set computer)では命令長は固定長で，
1命令が処理する内容は単純なことが多いです．</li>
</ul>
<h3 id="命令フォーマット"><a class="header" href="#命令フォーマット">命令フォーマット</a></h3>
<img src="figs/inst-format.svg" height="200px" id="fig:inst-format">
<ul>
<li>上図はx86-64の基本的な命令フォーマットです(この図と異なる例外的な命令もあります)．</li>
<li><strong>命令プリフィクス</strong> (instruction prefix)には例えばLOCKプリフィクスがあります．
LOCKプリフィクスはメモリアクセスをアトミックにする効果がありますが，
LOCKプリフィクスをつけて良い命令は一部に限定されています．
また，以下ではREXプリフィクスも登場します．</li>
<li><strong>ModR/M</strong>バイトと<strong>SIB</strong>バイトは，
アドレッシングモード，レジスタやメモリオペランドを指定します．</li>
<li><strong>変位</strong>(displacement)と<strong>即値</strong>(immediate)はどちらも定数です．
<code>pushq 4(%rsp)</code>の<code>4</code>が変位，<code>pushq $4</code>の<code>4</code>が即値です．</li>
</ul>
<h3 id="処理方向ビット"><a class="header" href="#処理方向ビット">処理方向ビット</a></h3>
<img src="figs/direction-flag.svg" height="200px" id="fig:direction-flag">
<ul>
<li>2つのオペランドを持つ多くの命令で，
1バイトのオペコードの
(LSBを0ビット目と数えて)1ビット目が<strong>処理方向ビット</strong>(operation direction bit)になります．</li>
<li>処理方向ビットが<code>0</code>の時，代入の方向は<em>reg</em>→<em>r/m</em>になります．
一方<code>1</code>の時，代入の方向は<em>r/m</em>→<em>reg</em>になります．</li>
<li>例えば，上図で <code>movq</code> <em>r64, r/m64</em>のオペコードは<code>REX.W 89</code>，
<code>movq</code> <em>r/m64, r64</em>のオペコードは<code>REX.W 8B</code>です．
確かに，処理方向ビットがそれぞれ<code>0</code>と<code>1</code>になっています．
(<code>REX.W</code>は命令プリフィクスで，オペランドサイズを64ビットにします)．</li>
</ul>
<h3 id="REX-prefix"><a class="header" href="#REX-prefix"><code>REX</code>プリフィクス</a></h3>
<img src="figs/rex.svg" height="150px" id="fig:rex">
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Intelマニュアル表記</th><th>意味</th></tr></thead><tbody>
<tr><td style="text-align: center">REX.W</td><td>オペランドサイズを64ビットにする</td></tr>
<tr><td style="text-align: center">REX.R</td><td>ModR/MのRegフィールドの拡張</td></tr>
<tr><td style="text-align: center">REX.X</td><td>SIBのIndexフィールドの拡張</td></tr>
<tr><td style="text-align: center">REX.B</td><td>ModR/MのR/M，SIBのBase，オペコードのRegフィールドの拡張</td></tr>
</tbody></table>
</div>
<ul>
<li><code>REX</code>プリフィクスはx86-64で追加された1バイト長の命令プリフィクスです．</li>
<li>GNUアセンブラが自動挿入するので，アセンブリコードでプログラマが
明示的に<code>REX</code>プリフィクスを記述する必要は通常はありません．</li>
<li><code>REX.W</code>はオペランドサイズを64ビットにします．</li>
<li><code>REX.R</code>，<code>REX.X</code>，<code>REX.B</code>はレジスタを指定する際に使われます．
これらの値が1の時，新しいレジスタ<code>%r8</code>〜<code>%r15</code>を指定したことになります．</li>
</ul>
<h3 id="modrmバイトとsibバイト"><a class="header" href="#modrmバイトとsibバイト">ModR/MバイトとSIBバイト</a></h3>
<img src="figs/modrm-sib.svg" height="130px" id="fig:modrm-sib">
<ul>
<li>ModR/Mバイトは上図のように分割されてます．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Mod</th><th>意味</th></tr></thead><tbody>
<tr><td style="text-align: center">00</td><td>メモリ参照，変位は無し．ただしR/M=101の時は例外あり(以下参照)</td></tr>
<tr><td style="text-align: center">01</td><td>メモリ参照，変位は1バイト</td></tr>
<tr><td style="text-align: center">10</td><td>メモリ参照，変位は4バイト</td></tr>
<tr><td style="text-align: center">11</td><td>レジスタ参照</td></tr>
</tbody></table>
</div>
<ul>
<li>ModR/MのModフィールドの意味は上記のとおりです．</li>
</ul>
<pre><code>$ gcc -g movq-10.s
$ objdump -d ./a.out
0000000000001129 &lt;main&gt;:
  1129: 4c 89 c0             	mov %r8,%rax        # Mod=11，レジスタ
  112c: 4c 89 00             	mov %r8,(%rax)      # Mod=00, メモリ参照，変位無し
  112f: 4c 89 40 08          	mov %r8,0x8(%rax)   # Mod=01，メモリ参照，変位1バイト (0x08)
  1133: 4c 89 80 e8 03 00 00 	mov %r8,0x3e8(%rax) # Mod=10, メモリ参照，変位4バイト (0xE8, 0x03, 0x00, 0x00)
</code></pre>
<ul>
<li>
<p>ModR/MのRegフィールドは<code>REX.R</code>の1ビットと合わせて，レジスタを指定します(以下の表参照)．</p>
</li>
<li>
<p>オペランドが1つの時はRegフィールドはレジスタの指定ではなく，
オペコードの一部として使われることがあります(なので図中でOpcodeと書いています)．</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>REX.R</code></th><th style="text-align: center">Reg</th><th style="text-align: center">指定される<br/>レジスタ</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">000</td><td style="text-align: center"><code>%rax</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">001</td><td style="text-align: center"><code>%rcx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">010</td><td style="text-align: center"><code>%rdx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">011</td><td style="text-align: center"><code>%rbx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">100</td><td style="text-align: center"><code>%rsp</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">101</td><td style="text-align: center"><code>%rbp</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">110</td><td style="text-align: center"><code>%rsi</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">111</td><td style="text-align: center"><code>%rdi</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">000</td><td style="text-align: center"><code>%r8</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">001</td><td style="text-align: center"><code>%r9</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">010</td><td style="text-align: center"><code>%r10</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">011</td><td style="text-align: center"><code>%r11</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">100</td><td style="text-align: center"><code>%r12</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">101</td><td style="text-align: center"><code>%r13</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">110</td><td style="text-align: center"><code>%r14</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">111</td><td style="text-align: center"><code>%r15</code></td></tr>
</tbody></table>
</div>
<ul>
<li>ModR/MのR/Mフィールドは<code>REX.B</code>の1ビットと合わせて，レジスタやメモリ参照を指定します．
<ul>
<li>Mod=11の時はR/Mフィールドは下の表のレジスタを指定します．</li>
<li>Mod\(\neq\)11の時はR/Mフィールドは下の表のメモリ参照を指定します．
<ul>
<li>ただし，R/M=100の時はSIBバイトを使うことを意味します．
また，R/M=101の時は<code>%rip</code>相対アドレッシングを使うことを意味します．
R/M=101の時，(本来はMod=00は変位無しですが)
Mod=00でもMod=10でも変位が4バイトになります．</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>REX.B</code></th><th style="text-align: center">R/M</th><th style="text-align: center">指定される<br/>レジスタ<br/>(Mod=11)</th><th style="text-align: center">指定される<br/>メモリ参照<br/>(Mod\(\neq\)11)</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">000</td><td style="text-align: center"><code>%rax</code></td><td style="text-align: center"><code>(%rax)</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">001</td><td style="text-align: center"><code>%rcx</code></td><td style="text-align: center"><code>(%rcx)</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">010</td><td style="text-align: center"><code>%rdx</code></td><td style="text-align: center"><code>(%rdx)</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">011</td><td style="text-align: center"><code>%rbx</code></td><td style="text-align: center"><code>(%rbx)</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">100</td><td style="text-align: center"><code>%rsp</code></td><td style="text-align: center">SIB使用</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">101</td><td style="text-align: center"><code>%rbp</code></td><td style="text-align: center"><code>%rip</code>相対</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">110</td><td style="text-align: center"><code>%rsi</code></td><td style="text-align: center"><code>(%rsi)</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">111</td><td style="text-align: center"><code>%rdi</code></td><td style="text-align: center"><code>(%rdi)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">000</td><td style="text-align: center"><code>%r8</code></td><td style="text-align: center"><code>(%r8)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">001</td><td style="text-align: center"><code>%r9</code></td><td style="text-align: center"><code>(%r9)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">010</td><td style="text-align: center"><code>%r10</code></td><td style="text-align: center"><code>(%r10)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">011</td><td style="text-align: center"><code>%r11</code></td><td style="text-align: center"><code>(%r11)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">100</td><td style="text-align: center"><code>%r12</code></td><td style="text-align: center">SIB使用</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">101</td><td style="text-align: center"><code>%r13</code></td><td style="text-align: center"><code>%rip</code>相対</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">110</td><td style="text-align: center"><code>%r14</code></td><td style="text-align: center"><code>(%r14)</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">111</td><td style="text-align: center"><code>%r15</code></td><td style="text-align: center"><code>(%r15)</code></td></tr>
</tbody></table>
</div>
<ul>
<li>SIBの各フィールドは，Scale，Indexレジスタ, Baseレジスタを指定します．
(例えば，メモリ参照 <code>(%rax, %rbx, 2)</code>で，
<code>%rax</code>がBaseレジスタ，<code>%rbx</code>がIndexレジスタ，<code>2</code>がScaleです)．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Scaleの値</th><th>乗数</th></tr></thead><tbody>
<tr><td style="text-align: center">00</td><td>1</td></tr>
<tr><td style="text-align: center">01</td><td>2</td></tr>
<tr><td style="text-align: center">10</td><td>4</td></tr>
<tr><td style="text-align: center">11</td><td>8</td></tr>
</tbody></table>
</div>
<pre><code>$ gcc -g movq-11.s
$ objdump -d ./a.out
0000000000001129 &lt;main&gt;:
  1129: 4c 89 05 e8 03 00 00 	mov  %r8,0x3e8(%rip)
  1130: 4e 89 84 48 e8 03 00 	mov  %r8,0x3e8(%rax,%r9,2)
  1137: 00 
</code></pre>
<img src="figs/inst-rip.svg" height="200px" id="fig:inst-rip">
<ul>
<li>
<p><code>mov %r8, 0x3e8(%rip)</code>の機械語バイト列を見てみます</p>
<ul>
<li>Mod=00で，メモリ参照，変位は4バイトを意味します(これはR/M=101の時の例外)．</li>
<li><code>REX.R</code>=1と<code>Reg</code>=000で，<code>%r8</code>レジスタを意味します．</li>
<li><code>R/M</code>=101で，<code>%rip</code>相対アドレッシングを意味します．</li>
<li><code>89</code>は<code>movq</code>のオペコードです．
<a href="./4-data.html#%E5%87%A6%E7%90%86%E6%96%B9%E5%90%91%E3%83%93%E3%83%83%E3%83%88">処理方向ビット</a>が0なので<code>Reg</code>を<code>R/M</code>に代入を意味します．</li>
<li>最後の4バイト (<code>E8 03 00 00</code>)は4バイトの変位です．</li>
</ul>
</li>
</ul>
<br/>
<img src="figs/inst-sib.svg" height="230px" id="fig:inst-sib">
<ul>
<li>
<p><code>movq %r8, 0x3e8(%rax,%r9,2)</code>の機械語バイト列を見てみます</p>
<ul>
<li>Mod=10で，メモリ参照，変位は4バイトを意味します．</li>
<li><code>REX.R</code>=1とReg=000で，<code>%r8</code>レジスタを意味します．</li>
<li>R/M=100で，SIBバイトの使用を意味します．</li>
<li>Scale=01で，<code>0x3e8(%rax,%r9,2)</code>の<code>2</code>を意味します．</li>
<li><code>REX.B</code>=0とBase=000で，Indexレジスタとして<code>%rax</code>を使用します．</li>
<li><code>REX.X</code>=1とIndex=001で，Baseレジスタとして<code>%r9</code>を使用します．</li>
</ul>
</li>
<li>
<p>SIBバイトのBaseフィールドは<code>REX.B</code>とともにBaseレジスタを指定します．
ただし，❶❷の部分が特別扱いです．</p>
<ul>
<li>❶❷の101かつMod=00の場合，<code>(%rbp)</code>というメモリアクセスではなく，
32ビットの変位のみでのメモリアクセスになります．</li>
<li>例えば，<code>movq %r8,0x1000</code>の機械語バイト列は
<code>4c 89 04 25 00 10 00 00</code>になります．
Mod=00, Base=101となっていますね．</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>REX.B</code></th><th style="text-align: center">Base</th><th style="text-align: center">指定される<br/>Baseレジスタ</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">000</td><td style="text-align: center"><code>%rax</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">001</td><td style="text-align: center"><code>%rcx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">010</td><td style="text-align: center"><code>%rdx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">011</td><td style="text-align: center"><code>%rbx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">100</td><td style="text-align: center"><code>%rsp</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">❶101</td><td style="text-align: center"><code>%rbp</code>，Mod=00の時は4バイトの変位のみ</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">110</td><td style="text-align: center"><code>%rsi</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">111</td><td style="text-align: center"><code>%rdi</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">000</td><td style="text-align: center"><code>%r8</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">001</td><td style="text-align: center"><code>%r9</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">010</td><td style="text-align: center"><code>%r10</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">011</td><td style="text-align: center"><code>%r11</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">100</td><td style="text-align: center"><code>%r12</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">❷101</td><td style="text-align: center"><code>%r13</code>，Mod=00の時は4バイトの変位のみ</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">110</td><td style="text-align: center"><code>%r14</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">111</td><td style="text-align: center"><code>%r15</code></td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>SIBバイトのIndexフィールドは<code>REX.X</code>と合わせて，Indexレジスタを指定します．</p>
<ul>
<li>ただし%rspは指定不可です</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>REX.X</code></th><th style="text-align: center">Index</th><th style="text-align: center">Reg</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">000</td><td style="text-align: center"><code>%rax</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">001</td><td style="text-align: center"><code>%rcx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">010</td><td style="text-align: center"><code>%rdx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">011</td><td style="text-align: center"><code>%rbx</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">100</td><td style="text-align: center">無し(<code>%rsp</code>は使用不可)</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">101</td><td style="text-align: center"><code>%rbp</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">110</td><td style="text-align: center"><code>%rsi</code></td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">111</td><td style="text-align: center"><code>%rdi</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">000</td><td style="text-align: center"><code>%r8</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">001</td><td style="text-align: center"><code>%r9</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">010</td><td style="text-align: center"><code>%r10</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">011</td><td style="text-align: center"><code>%r11</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">100</td><td style="text-align: center"><code>%r12</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">101</td><td style="text-align: center"><code>%r13</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">110</td><td style="text-align: center"><code>%r14</code></td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">111</td><td style="text-align: center"><code>%r15</code></td></tr>
</tbody></table>
</div>
<h2 id="データの変換"><a class="header" href="#データの変換">データの変換</a></h2>
<h3 id="ゼロ拡張"><a class="header" href="#ゼロ拡張">ゼロ拡張</a></h3>
<ul>
<li><strong>ゼロ拡張</strong> (zero extension)は上位ビットを0で埋めてビット列を大きくする変換．</li>
<li>符号なし整数をゼロ拡張すると，値は変化しない．
<ul>
<li>例: 2バイトの符号なし整数65535をゼロ拡張で4バイトに変換しても，値は変化しない．</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>データサイズ</th><th>ビット表現</th><th>値</th></tr></thead><tbody>
<tr><td>2バイト</td><td>11111111 11111111</td><td>65535</td></tr>
<tr><td>4バイト</td><td>00000000 00000000 11111111 11111111</td><td>65535</td></tr>
</tbody></table>
</div>
<h3 id="符号拡張"><a class="header" href="#符号拡張">符号拡張</a></h3>
<ul>
<li><strong>符号拡張</strong> (sign extension)は
<ul>
<li>上位ビットを元データのMSBで埋めてビット列を大きくする変換．</li>
<li>つまり，正の場合は0を，負の場合は1を上位ビットに埋める．</li>
</ul>
</li>
<li>符号あり整数を符号拡張すると，値は変化しない．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>データサイズ</th><th>ビット表現</th><th>値</th></tr></thead><tbody>
<tr><td>2バイト</td><td>01111111 11111111</td><td>32767</td></tr>
<tr><td>4バイト</td><td>00000000 00000000 01111111 11111111</td><td>32767</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>データサイズ</th><th>ビット表現</th><th>値</th></tr></thead><tbody>
<tr><td>2バイト</td><td>11111111 11111111</td><td>-1</td></tr>
<tr><td>4バイト</td><td>11111111 11111111 11111111 11111111</td><td>-1</td></tr>
</tbody></table>
</div>
<ul>
<li>符号あり整数をゼロ拡張すると，値が変化する．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>データサイズ</th><th>ビット表現</th><th>値</th></tr></thead><tbody>
<tr><td>2バイト</td><td>11111111 11111111</td><td>-1</td></tr>
<tr><td>4バイト</td><td>00000000 00000000 11111111 11111111</td><td>65535</td></tr>
</tbody></table>
</div>
<h3 id="movzmovs命令"><a class="header" href="#movzmovs命令"><a href="./6-inst.html#movs-movz"><code>movz␣␣</code>，<code>movs␣␣</code>命令</a></a></h3>
<ul>
<li><code>movz␣␣</code>はゼロ拡張をしてデータをコピーする命令 (move with zero extension)</li>
<li><code>movs␣␣</code>は符号拡張をしてデータをコピーする命令 (move with sign extension)</li>
<li>通常，値を変化させたくないので，符号なし整数には<code>movz␣␣</code>を使い，
符号あり整数には<code>movs␣␣</code>命令を使う．</li>
</ul>
<h3 id="切り詰め-truncation"><a class="header" href="#切り詰め-truncation">切り詰め (truncation)</a></h3>
<ul>
<li>切り詰め = 上位ビットを捨ててビット列を小さくする変換</li>
<li>符号あり整数を切り詰めると，正負が変わることがある</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>データサイズ</th><th>ビット表現</th><th>値</th></tr></thead><tbody>
<tr><td>4バイト</td><td>00000000 00000001 10000110 10100000</td><td>100000</td></tr>
<tr><td>2バイト</td><td>10000110 10100000</td><td>-31072</td></tr>
</tbody></table>
</div>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int main (void)
{
    int32_t i = 100000;
    int16_t s = i;
    printf (&quot;%d\n&quot;, s);
}

</code></pre>
<pre><code>$ gcc -g trunc.c
$ ./a.out
-31072
</code></pre>
<ul>
<li>4バイトから2バイトへ切り詰めは，
例えば，<code>%eax</code>に値を入れて，<code>%ax</code>で値を取り出せば可能．</li>
</ul>
<pre><code># asm/trunc2.s
    .text
    .globl main
    .type main, @function
main:
    movl $100000, %eax
    movw %ax, %bx
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g trunc2.s
$ gdb ./a.out -x trunc2.txt
Breakpoint 1 at 0x1131: file trunc2.s, line 8.
Breakpoint 1, main () at trunc2.s:8
8	    ret
$1 = -31072
# -31072 が出力されれば成功
</code></pre>
<h2 id="メモリレイアウト"><a class="header" href="#メモリレイアウト">メモリレイアウト</a></h2>
<h3 id="多バイト長データはメモリの連続領域に格納"><a class="header" href="#多バイト長データはメモリの連続領域に格納">多バイト長データはメモリの連続領域に格納</a></h3>
<img src="figs/memory-multibyte.svg" height="150px" id="fig:memory-multibyte">
<ul>
<li>通常，メモリはバイトアドレッシングです．
つまり，1つの番地ごとに1バイトの情報を格納できます．</li>
<li>多バイト長データ(2バイト以上のデータ)をメモリに格納する時は，
メモリの連続領域を使ってデータを格納します．
<ul>
<li>上図では4バイトのデータ <code>0x11223344</code>をメモリの1000〜1003番地を使って格納していることを示しています．</li>
<li>このデータを読み書きする場合は，先頭番地の1000番地を使います．</li>
</ul>
</li>
</ul>
<h3 id="バイトオーダとエンディアン"><a class="header" href="#バイトオーダとエンディアン">バイトオーダとエンディアン</a></h3>
<ul>
<li>
<p>多バイト長のデータをメモリに格納するには1バイトごとに分割して格納します．
多バイト長のデータをバイト単位で格納する順序を<strong>バイトオーダ</strong>(byte order)といいます．</p>
</li>
<li>
<p>多バイト長データで最下位のバイトをLeast Significant Byte (<strong>LSB</strong>)，
最上位のバイトをMost Significant Byte (<strong>MSB</strong>)と呼びます．</p>
<ul>
<li>例えば，<code>0x11223344</code>という4バイトのデータのLSBは<code>0x44</code>，MSBは<code>0x11</code>です．</li>
</ul>
</li>
<li>
<p>多バイト長データをメモリに格納する時，</p>
<ul>
<li>LSBから先にメモリに格納する方法を<div style="display:inline-block" id="リトルエンディアン"><strong>リトルエンディアン</div></strong> (little endian)</li>
<li>MSBから先にメモリに格納する方法を<strong>ビッグエンディアン</strong> (big endian) と呼びます．</li>
</ul>
</li>
</ul>
<img src="figs/endian.svg" height="200px" id="fig:endian">
<details>
 <summary>
 エンディアンの由来とは
 </summary>
<p><strong>エンディアン</strong>(endian)という言葉はガリバー旅行記から来ています．
お話の中で，卵の殻は尖った方からむくべき派 (little endian)と
丸い方からむくべき派 (big endian)が争うのです．なのでインディアンとは何の関係もありません．</p>
</details>
<h3 id="アラインメントとパディング"><a class="header" href="#アラインメントとパディング">アラインメントとパディング</a></h3>
<h4 id="alignment"><a class="header" href="#alignment">アラインメント</a></h4>
<div class="table-wrapper"><table><thead><tr><th>型</th><th>アラインメント制約</th></tr></thead><tbody>
<tr><td>1バイト整数</td><td>1の倍数のアドレス</td></tr>
<tr><td>2バイト整数</td><td>2の倍数のアドレス</td></tr>
<tr><td>4バイト整数</td><td>4の倍数のアドレス</td></tr>
<tr><td>8バイト整数</td><td>8の倍数のアドレス</td></tr>
<tr><td>ポインタ(8バイト長)</td><td>8の倍数のアドレス</td></tr>
<tr><td>16バイト整数</td><td>16の倍数のアドレス</td></tr>
<tr><td>スタックフレーム</td><td>16の倍数のアドレス</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>アラインメント</strong> (境界調整，alignment)とは，
特定のアドレス(例: 16の倍数のアドレス)にデータを格納することです
<ul>
<li>16の倍数のアドレスに格納することを，
<strong>16バイト境界</strong> (16-byte boundary)に格納する，という言い方もします．</li>
</ul>
</li>
<li>ABIはアラインメントを守ることを
プログラムに要求します．このお約束を<strong>アラインメント制約</strong>といいます．
上の表は <a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>
が定めるアラインメント制約です．
<ul>
<li>スタックフレームの16バイト境界への制約は
<code>call</code>命令実行時に<code>%rsp</code>の値が16の倍数であることを要求しています．</li>
</ul>
</li>
</ul>
<h4 id="アラインメント制約に違反すると最悪クラッシュする"><a class="header" href="#アラインメント制約に違反すると最悪クラッシュする">アラインメント制約に違反すると最悪，クラッシュする</a></h4>
<ul>
<li>アラインメント制約に違反すると，実行速度が遅くなったり，
Segmentation faultなどの実行時エラーが生じます(例: AVX命令の<code>movdqa</code>)．
このため，コンパイラはアラインメント制約を満たすコードを出力します．
人手でアセンブリコードを書く場合は，
プログラマがアラインメント制約を守るよう注意する必要があります．</li>
</ul>
<h4 id="alignment-padding"><a class="header" href="#alignment-padding">アラインメント調整 (<code>.align</code>)とパディング</a></h4>
<ul>
<li>
<p>アラインメント制約はアセンブラ命令<code>.align</code>を使って満たせます
(他にも <code>.skip</code>, <code>.space</code>, <code>.zero</code>などのアセンブラ命令でも可能です)．</p>
<pre><code>char x1 = 10;
int  x2 = 20;
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x1
    .data
    .type   x1, @object
    .size   x1, 1
x1:
    .byte   10
    .globl  x2
  ❶.align 4
    .type   x2, @object
    .size   x2, 4
x2:
    .long   20
</code></pre>
<img src="figs/align.svg" height="200px" id="fig:align">
<ul>
<li>例えば，上の<code>char</code>型の<code>x1</code>と<code>int</code>型の<code>x2</code>というグローバル変数の宣言があった場合，コンパイラは上のようなアセンブリコードを出力します．</li>
<li>仮に<code>x1</code>を1000番地に配置したとすると，そのまま次の領域に<code>x2</code>を配置すると
<code>x2</code>は1001番地に配置することになります．
1001番地は4バイト境界(4の倍数のアドレス)
ではないのでアラインメント制約違反になってしまいます．</li>
<li>これを避けるため❶<code>.align 4</code>というアセンブラ命令を使用します．
<code>.align 4</code>は「次に出力するアドレスを4の倍数になるよう(最小限増やして)調整しろ」という意味です．その結果，<code>x2</code>のアドレスは1004番地になります．</li>
<li>なお未使用の1001〜1003番地のメモリ領域のことを<strong>パディング</strong>(詰め物，padding)といいます．</li>
</ul>
</li>
</ul>
<h4 id="構造体のパディング"><a class="header" href="#構造体のパディング">構造体のパディング</a></h4>
<pre><code>// asm/struct3.c
struct foo {
    char x1;
    int x2;
};
struct foo f = {10, 20};
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8            # 構造体全体を8バイト境界に配置
    .type   f, @object
    .size   f, 8
f:
    .byte   10          # f.x1
    .zero   3           # 3バイトのゼロを出力(3バイトのパディング)
    .long   20          # f.x2
</code></pre>
<img src="figs/align-struct.svg" height="200px" id="fig:align-struct">
<ul>
<li>アラインメント制約のために，構造体の中にもパディングが生じます</li>
<li>上の例では<code>char</code>型の<code>x1</code>と<code>int</code>型の<code>x2</code>の間に3バイトのパディングができています</li>
<li>構造体の先頭にパディングが入ることはありません．
一方，構造体の末尾にパディングが入ることはあります(次の節で説明)</li>
</ul>
<h4 id="配列のためのパディング"><a class="header" href="#配列のためのパディング">配列のためのパディング</a></h4>
<ul>
<li>
<p>(構造体にはパディングが生じますが)配列にはパディングは入りません．
配列のすべての要素は常にぴったりくっついて，
メモリ上で連続したアドレスに格納されます．
例えば，<code>int a1 [3];</code> のメモリレイアウトは以下の図になります．
(配列の各要素(ここでは<code>int</code>)もアラインメント制約を満たしています
(ここではアドレスが4の倍数になっています))</p>
<img src="figs/array1.svg" height="300px" id="fig:array1">
</li>
<li>
<p>これは2次元配列になっても同じです．
例えば，<code>int a2 [2][3];</code>のメモリレイアウトは(C言語では)以下の図になります．</p>
<img src="figs/array2.svg" height="600px" id="fig:array2">
</li>
<li>
<p>「じゃあ，サイズが5バイトの構造体を作って，その構造体の配列を定義したら，
その配列の要素はアラインメント制約を満たせないのでは?」</p>
<p>答えは「はい，満たせなくなります．ですので，(構造体中に<code>int</code>型など
アラインメント制約を持つメンバーがある場合は)サイズが5バイトの構造体は作れません」「その場合は<strong>構造体のお尻にパディングが入ります</strong>」．
(なお構造体のメンバーが<code>char</code>や<code>char[]</code>など，どの場所にも置けるデータのみの
場合は5バイトの構造体を作れます)．</p>
</li>
</ul>
<pre><code>// asm/struct4.c
#include &lt;stdio.h&gt;
struct foo2 {
    int x2;
    char x1;
};
struct foo2 f = {10, 20};
int main ()
{
    printf (&quot;%ld\n&quot;, sizeof (struct foo2));
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8
    .type   f, @object
    .size   f, 8  # 構造体全体のサイズは8バイト
f:
    .long   10
    .byte   20
    .zero   3     # 構造体のお尻に3バイトのパディングが入っている
</code></pre>
<img src="figs/align-struct2.svg" height="200px" id="fig:align-struct2">
<p>実際にやってみると，構造体のお尻に3バイトのパディングが入りました．</p>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 6; }
</style>
<h1 id="x86-64機械語命令"><a class="header" href="#x86-64機械語命令">x86-64機械語命令</a></h1>
<h2 id="how-to-execute-x86-inst"><a class="header" href="#how-to-execute-x86-inst">x86-64機械語命令の実行方法</a></h2>
<h3 id="概要デバッガ上で実行します"><a class="header" href="#概要デバッガ上で実行します">概要：デバッガ上で実行します</a></h3>
<p>機械語命令を実行しても，単に<code>a.out</code>を実行するだけでは
意図通りに実行できたかの確認が難しいです．
(アセンブリコード内から<code>printf</code>を呼び出せばいいのですが，
そのコードもうざいので)．
そこで本書では<strong>デバッガを使って</strong>機械語命令の実行と確認を行います．</p>
<p>以下では例として<code>movq $999, %rax</code>という機械語命令を実行してみます．
(これらのファイルは<a href="https://github.com/gondow/linux-x86-64-programming/tree/main/src/asm">サンプルコード</a>から入手できます)．
<code>movq $999, %rax</code>は「定数<code>999</code>を<code>%rax</code>レジスタに格納する」という命令ですので，
実行後，<code>%rax</code>レジスタに<code>999</code>という値が入っていれば，
うまく実行できたことを確認できます．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p>実行確認のための<code>gdb</code>のコマンド列を書いたファイルも用意しています．</p>
<div id="asm/movq-4.txt">
<pre><code># asm/movq-4.txt
b 7
r
list 6,6
p $rax
echo # %raxの値が999なら成功\n
quit
</code></pre>
</div>
<h3 id="デバッガ上で実行gdbコマンドを手入力"><a class="header" href="#デバッガ上で実行gdbコマンドを手入力">デバッガ上で実行：<code>gdb</code>コマンドを手入力</a></h3>
<p><code>asm/movq-4.txt</code>中の<code>gdb</code>コマンドを
以下のように1行ずつ入力してみて下さい．
(この章でも<code>gdb</code>の使い方を説明していきますが，
<code>gdb</code>の使い方の詳細は<a href="./10-gdb.html">デバッガgdbの使い方</a>にもまとめてあります)．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶
(gdb) b 7 ❷
Breakpoint 1 at 0x1130: file movq-4.s, line 6.
(gdb) r ❸
Breakpoint 1, main () at movq-4.s:6
6	    ret
(gdb) list 6,6 ❹
5	    movq $999, %rax
(gdb) p $rax ❺
$1 = 999
(gdb) quit
</code></pre>
<ul>
<li>❶ コンパイルした<code>a.out</code>を<code>gdb</code>上で実行</li>
<li>❷ ブレークポイントを7行目(<code>movq $999, %rax</code>の次の行)に設定 (<code>b</code>はbreakの略)</li>
<li>❸ 実行開始 (<code>r</code> は run の略)</li>
<li>❹ ソースコードの6行目だけを表示</li>
<li>❺ レジスタ<code>%rax</code>の値を(10進表記で)表示 (<code>p</code>はprintの略)</li>
<li><a href="6-inst.html#asm/movq-4.txt"><code>movq-4.txt</code></a>
の最後の行 <code>echo # %raxの値が999なら成功\n</code>は，
「どうなると正しく実行できたか」を確認するメッセージを出力するコマンドですので，
ここでは入力不要です．
❺の結果と一致したので「正しい実行」と確認できました．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力--xオプションを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力--xオプションを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>-x</code>オプションを使う)</a></h3>
<p><code>gdb</code>コマンドを手入力して，よく使う<code>gdb</code>コマンドを覚えることは良いことです．
とはいえ，手入力は面倒なので，自動入力も使いましょう．</p>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out ❶ -x movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	 ❷ movq $999, %rax
❸ $1 = 999 
❹ # %raxの値が999なら成功
(gdb) 

</code></pre>
<ul>
<li>❶ <code>-x movq-4.txt</code> というオプションをつけると，指定したファイル(ここでは<code>movq-4.txt</code>)の中に書かれている<code>gdb</code>コマンドを1行ずつ順番に実行してくれます</li>
<li><code>list 6,6</code>を実行した結果，❷6行目の<code>movq $999, %rax</code> が表示されています</li>
<li><code>p $rax</code>を実行した結果，<code>%rax</code>レジスタの値が❸999であると表示されています．
(<code>$1</code>は<code>gdb</code>が扱う変数です．ここでは無視して下さい)</li>
<li><code>echo # %raxの値が999なら成功\n</code> を<code>gdb</code>が実行した結果，
❹ <code># %raxの値が999なら成功</code>というメッセージが表示されています．
このメッセージと❸の実行結果を見比べれば「実行結果が正しい」ことを確認できます．</li>
</ul>
<h3 id="デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う"><a class="header" href="#デバッガ上で実行gdbコマンドを自動入力-sourceコマンドを使う">デバッガ上で実行：<code>gdb</code>コマンドを自動入力 (<code>source</code>コマンドを使う)</a></h3>
<pre><code class="language-nohighlight">$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) ❶ source movq-4.txt
Breakpoint 1, main () at movq-4.s:7
7	    ret
6	    movq $999, %rax
$1 = 999
# %raxの値が999なら成功
</code></pre>
<p><code>gdb</code>は通常通りに実行開始して，
❶ <code>source</code>コマンドを使えば，<code>movq-4.txt</code>中の<code>gdb</code>コマンドを実行できます．
<code>-x</code>オプションと<code>source</code>コマンドは好きな方を使って下さい．</p>
<h2 id="アドレッシングモード-オペランドの表記方法"><a class="header" href="#アドレッシングモード-オペランドの表記方法">アドレッシングモード (オペランドの表記方法)</a></h2>
<h3 id="アドレッシングモードの概要"><a class="header" href="#アドレッシングモードの概要">アドレッシングモードの概要</a></h3>
<p>機械語命令は命令(<strong>オペコード</strong>(opcode))と
その引数の<strong>オペランド</strong>(operand)から構成されています．
例えば，<code>movq $999, %rax</code>という命令では，
<code>movq</code>がオペコードで，<code>$999</code>と<code>%rax</code>がオペランドです．</p>
<img src="figs/opcode-operand.svg" height="100px" id="fig:opcode-operand">
<p><strong>アドレッシングモード</strong>とはオペランドの書き方のことです．
(元々は「メモリのアドレスを指定する記法」という意味で「アドレッシングモード」という用語が使われています).
x86-64では大きく，以下の4種類の書き方ができます．</p>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="6-inst.html#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="6-inst.html#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="6-inst.html#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td></tr>
<tr><td><code>movq foo, %rax</code></td></tr>
<tr><td rowspan="3">
<p><a href="6-inst.html#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベル（その値はアドレス）であり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="addr-mode-imm"><a class="header" href="#addr-mode-imm">アドレッシングモード：即値（定数）</a></h3>
<h4 id="定数-999"><a class="header" href="#定数-999">定数 <code>$999</code></a></h4>
<p><strong>即値</strong>(immediate value，定数)には<code>$</code>をつけます．
例えば<code>$999</code>は定数<code>999</code>を意味します．</p>
<pre><code class="language-x86asmatt"># asm/movq-4.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-4.s"><code>movq-4.s</code></a>の6行目の
<code>movq $999, %rax</code>は「定数<code>999</code>をレジスタ<code>%rax</code>に格納する」という意味です．
デバッガで動作を確認します
(デバッガの操作手順は<a href="./asm/movq-4.txt"><code>movq-4.txt</code></a>にもあります)．</p>
<pre><code>$ gcc -g movq-4.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-4.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-4.s:6
6	    movq $999, %rax
(gdb) si
main () at movq-4.s:7
7	    ret
(gdb) p $rax
$1 = 999
</code></pre>
<p>確かに<code>%rax</code>レジスタ中に<code>999</code>が格納されていました．</p>
<p>なお，多くの場合，即値は32ビットまでで，オペランドのサイズが64ビットの場合，
32ビットの即値は，64ビットの演算前に
<strong>64ビットに<a href="./4-data.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5">符号拡張</a></strong> されます
(<a href="./4-data.html#%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a>だと
負の値が大きな正の値になって困るからです)．
64ビットに符号拡張される例は<a href="x86-list.html#imm-64bit-signed-extended">こちら</a>
を見て下さい．
例外は<code>movq</code>命令で，64ビットの即値を扱えます．
実行例は<a href="x86-list.html#mov-64bit-imm">こちら</a>を見て下さい．</p>
<h4 id="ラベル-main"><a class="header" href="#ラベル-main">ラベル <code>$main</code></a></h4>
<p>定数が書ける場所にはラベル(その値はアドレス)も書けます．
ラベルは関数名やグローバル変数の実体があるメモリの先頭番地を
示すために使われます(それ以外にはジャンプのジャンプ先としても使われます)．
ですので，<code>main</code>関数の先頭番地を示す<code>main</code>というラベルが
<code>main</code>関数をコンパイルしたアセンブリコード中に存在します．</p>
<pre><code class="language-x86asmatt"># asm/movq-6.s
    .text
    .globl main
    .type main, @function
main:
    movq $main, %rax
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-6.s">movq-6.s</a>の6行目の<code>movq $main, %rax</code>は
「ラベル<code>main</code>が表すアドレスを<code>%rax</code>レジスタに格納する」という意味です．
<code>gdb</code>で確かめます．</p>
<pre><code>$ gcc ❶ -no-pie -g movq-6.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at ❷ 0x40110a: file movq-6.s, line 7.
(gdb) r
Breakpoint 1, main () at movq-6.s:7
7   ❸  movq $main, %rax
(gdb) ❹ si
main () at movq-6.s:8
8	ret
(gdb) p/x $rax
$1 = ❺ 0x40110a 
</code></pre>
<ul>
<li>まず❶ <code>-no-pie</code>オプションをつけてコンパイルして下さい．
(<code>-static</code>オプションを使ってもうまくいくと思います)</li>
</ul>
<details>
<summary>
なぜ -no-pieオプション
</summary>
<p><code>-no-pie</code>オプションをつけないと以下のエラーが出てしまうからです．</p>
<pre><code>$ gcc -g movq-6.s
/usr/bin/ld: /tmp/ccqHsPbg.o: relocation R_X86_64_32S against symbol `main' can not be used when making a PIE object; recompile with -fPIE
/usr/bin/ld: failed to set dynamic section sizes: bad value
collect2: error: ld returned 1 exit status
</code></pre>
<p><code>-no-pie</code>は「位置独立実行可能ファイル
(<a href="./3-binary.html#ASLR-PIE">PIE</a>，<a href="./3-binary.html#PIE">PIE</a>)を生成しない」
というオプションです．
最近のLinuxの<code>gcc</code>では，PIEがデフォルトで有効になっている事が多いです．
<a href="./3-binary.html#PIC">PIC</a>(位置独立コード)やPIEは「再配置(アドレス調整)無しに
どのメモリ番地に配置しても，そのまま実行可能」という機械語命令列です．
そのため，PIEやPICのメモリ参照では<strong>絶対アドレス</strong>(absolute address)が使えません．</p>
<p><code>-no-pie</code>オプションが無いと，
アセンブラは<code>movq $main, %rax</code>という命令中の<code>main</code>というラベルを
「絶対アドレスだ」と解釈してエラーにするようです．</p>
<details>
<summary>
絶対アドレス，相対アドレスとは
</summary>
<div id="絶対アドレス・相対アドレス">
<img src="figs/absolute-addr.svg" height="250px" id="fig:absolute-addr">
<p><strong>絶対アドレス</strong>とは「メモリの先頭0番地から何バイト目か」で示すアドレスです．
上図で青色のメモリ位置の絶対アドレスは<code>0x1000</code>番地となります．
一方，<strong>相対アドレス</strong>(relative address)は(0番地ではなく)別の何かを起点とした差分のアドレスです．
x86-64では<code>%rip</code>レジスタ(プログラムカウンタ)を起点とすることが多いです．
上図では青色のメモリ位置の相対アドレスは
<code>%rip</code>を起点とすると，<code>-0x500</code>番地となります(<code>0x1000 - 0x1500 = -0x500</code>)．</p>
<p>また，相対アドレスに起点のアドレスを足すと絶対アドレスになります
(<code>-0x500 + 0x1500 = 0x1000</code>)．</p>
</div>
</details>
<p>なぜ PICやPIEで絶対アドレスが使えないかと言うと，
機械語命令列を何番地に置くかで，絶対アドレスが変化してしまうからです．</p>
<details>
<summary>
もうちょっと具体的に
</summary>
<p>例えば，<code>movq $main, %rax</code>という命令は
<code>main</code>関数のアドレスを<code>%rax</code>レジスタに格納するわけですが，
このアドレスが絶対アドレスの場合，出力される機械語命令に
絶対アドレスが埋め込まれてしまいます．</p>
<pre><code>$ gcc -no-pie -g movq-6.s
$ objdump -d ./a.out
(一部略)
000000000040110a &lt;main&gt;:
  40110a:  48 c7 c0 ❷ 0a 11 40 00    mov ❶$0x40110a,%rax
  401111:  c3                        ret    
</code></pre>
<p>上の逆アセンブル結果を見ると，確かに<code>main</code>関数のアドレス❶ <code>0x40110a</code>が
機械語命令列に❷埋め込まれています．
(x86-64は<a href="./3-binary.html#LSB">リトルエンディアン</a>なので，バイトの並びが逆順に見えることに注意)．</p>
<p>相対アドレスだと大丈夫なことも見てみます．
<a href="./asm/leaq-1.s"><code>leaq-1.s</code></a>中の
<code>leaq main(%rip), %rax</code>は，
「<code>%rip</code>を起点とした<code>main</code>の相対アドレスと，
<code>%rip</code>の値との和を<code>%rax</code>レジスタに格納する」という命令です．
(<code>lea</code> は load effective address の略です．effective addressは日本語では<strong>実効アドレス</strong>です)．</p>
<pre><code class="language-x86asmatt"># asm/leaq-1.s
    .text
    .globl main
    .type main, @function
main:
    leaq main(%rip), %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g leaq-1.s
$ objdump -d ./a.out
(一部略)
0000000000001129 &lt;main&gt;:
 ❶ 1129:  48 8d 05 ❸ f9 ff ff ff    lea    ❷ -0x7(%rip),%rax  # 1129 &lt;main&gt;
 ❹ 1130:  c3                      ret    
</code></pre>
<p>上のように逆アセンブルすると以下が分かります．</p>
<ul>
<li><code>main</code>関数の(ファイル<code>a.out</code>中での)アドレスは❶ <code>0x1129</code>番地</li>
<li><code>leaq main(%rip), %rax</code>の <code>%rip</code>の値は❸ <code>0x1130</code>番地
(プログラムカウンタ <code>%rip</code>は「次に実行する機械語命令のアドレス」を保持しています)．</li>
<li>機械語命令に埋め込まれているアドレスは相対アドレスで，
❶ <code>0x1129</code> - ❸ <code>0x1130</code> = ❷ <code>-0x7</code> = ❸ <code>0xFFFFFFF9</code> です．</li>
</ul>
<p>❶ <code>0x1129</code> や ❹ <code>0x1130</code> のアドレスは，
<code>main</code>関数がどのアドレスに配置されるかで変化します．
しかし，この相対アドレス❷ <code>-0x7</code> は
<code>main</code>関数がどのアドレスに配置されても変化しないので，
この機械語命令はPICやPIEとして使えるわけです．</p>
<p>❷ <code>-0x7</code> が ❸ <code>0xFFFFFFF9</code> として埋め込まれているのは，
<a href="xxx">2の補数表現</a>だからですね</p>
<p>なお，相対アドレスが固定にならない場合(例えば，<code>printf</code>関数のアドレス)もあります．
その場合は<a href="./3-binary.html#GOT-PLT">GOTやPLT</a>を使います．
<code>printf</code>関数のアドレスを機械語命令列(<code>.text</code>セクション)に埋め込むのではなく，
別の書込み可能なセクション(例：<code>got</code>セクション)に格納し，
そのアドレスを使って<strong>間接コール</strong>(indirect call)するのです．</p>
</details>
</details>
<details>
<summary>
-staticオプションとは
</summary>
<p><code>-static</code>オプションは(動的リンクではなく)
<a href="./3-binary.html#%E9%9D%99%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF%E3%81%A8%E5%8B%95%E7%9A%84%E3%83%AA%E3%83%B3%E3%82%AF"><strong>静的リンク</strong></a>
せよという，<code>gcc</code>への指示になります．</p>
</details>
<ul>
<li>
<p><code>main</code>関数の先頭にブレークポイントを設定します．
<code>main</code>関数の先頭アドレスが❷ <code>0x40110a</code>と分かります．</p>
</li>
<li>
<p>❸ <code>movq $main, %rax</code>の実行直前で止まっているので，
❹ <code>si</code>で1命令実行を進めます．</p>
</li>
<li>
<p>❺ <code>%rax</code>レジスタ中に<code>main</code>関数のアドレス❷ <code>0x40110a</code>が入っていました．</p>
</li>
</ul>
<h3 id="addr-mode-reg"><a class="header" href="#addr-mode-reg">アドレッシングモード：レジスタ参照</a></h3>
<pre><code class="language-x86asmatt"># asm/movq-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $999, %rax
    movq %rax, %rbx
    ret
    .size main, .-main
</code></pre>
<p><a href="./asm/movq-1.s"><code>movq-1.s</code></a>中の<code>movq %rax, %rbx</code>は
「<code>%rax</code>レジスタ中の値を<code>%rbx</code>に格納する」という意味です．</p>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1129: file movq-1.s, line 6.
(gdb) r
Breakpoint 1, main () at movq-1.s:6
6	    ❶ movq $999, %rax
(gdb) si
7	    ❷ movq %rax, %rbx
(gdb) si
main () at movq-1.s:8
8	    ret
(gdb) p $rax
$1 = ❸ 999
(gdb) p $rbx
$2 = ❹ 999
</code></pre>
<p><code>gdb</code>上での実行で，❶ 定数<code>999</code>が<code>%rax</code>に格納され，
❷ <code>%rax</code>中の<code>999</code>がさらに<code>%rbx</code>に格納されたことを
❸❹確認できました．</p>
<h3 id="addr-mode-direct"><a class="header" href="#addr-mode-direct">アドレッシングモード：直接メモリ参照</a></h3>
<p><strong>直接メモリ参照</strong>はアクセスするメモリ番地が定数となるメモリ参照です．
以下の例ではラベル<code>x</code>を使ってメモリ参照していますが，
これは直接メモリ参照になります．
アセンブル時に(つまり実行する前に)アドレスが具体的に(以下では<code>0x404028</code>番地)と決まるからです．</p>
<pre><code class="language-x86asmatt"># asm/movq-7.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-7.s
$ gdb ./a.out -x movq-7.txt
Breakpoint 1, main () at movq-7.s:10
10	    ret
9	    movq x, %rax
$1 = ❶ 999
# %raxの値が999なら成功
</code></pre>
<p>以下の図で<code>0x401106&lt;main&gt;</code>は「ラベル<code>main</code>が示すアドレスは<code>0x401106</code>番地」
「ラベル<code>x</code>が示すアドレスは<code>0x404028</code>番地」であることを示してます．</p>
<img src="figs/label2.svg" height="250px" id="fig:label2">
<p>そして<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の以下の3行で，以下は</p>
<pre><code class="language-x86asmatt">    .data
x:
    .quad 999 
</code></pre>
<p>「<code>.data</code>セクションにサイズが8バイトのデータとして値<code>999</code>を配置せよ」
「そのデータの先頭アドレスをラベル<code>x</code>として定義せよ」を意味しています
(<code>quad</code>が8バイトを意味しています)．
ですので，実行時には上図のように
「<code>.data</code>セクションのある場所(上図では<code>0x404028</code>番地)に値<code>999</code>が入っていて，
ラベル<code>x</code>の値は<code>0x404028</code>」となっています．</p>
<p>ですので，<a href="./asm/movq-7.s"><code>movq-7.s</code></a>中の<code>movq x, %rax</code>は
「ラベル<code>x</code>が表すアドレス(上図では<code>0x404028</code>番地)のメモリの中身(上図では<code>999</code>)
を<code>%rax</code>レジスタにコピーせよ」を意味します．</p>
<p>実行すると<code>movq x, %rax</code>の実行で，<code>x</code>中の<code>999</code>が<code>%rax</code>レジスタに
コピーされたことを確認できました❶．</p>
<p>ここで$マークの有無，つまり<code>x</code>と<code>$x</code>の違いに注意しましょう
(<a href="6-inst.html#label2">上図</a>も参照)．</p>
<pre><code class="language-x86asmatt">movq x, %rax    # x はメモリの中身を表す
movq $x, %rax   # $x はアドレスを表す
</code></pre>
<p>以下のように<code>movq $x, %rax</code>を実行すると，
<code>%rax</code>レジスタにはアドレス(ここでは<code>0x404028</code>番地)が
入っていることを確認できました❷．</p>
<details>
<summary>
-8(%rbp)の-8には(定数なのに)$マークが付かない
</summary>
<p><a href="6-inst.html#addr-mode-indirect">以下</a>でも説明しますが，
例えば<code>-8(%rbp)</code>とオペランドに書いた時，<code>-8</code>は($マークが無いのに)
定数として扱われます．
そして，<code>-8(%rbp)</code>は，<code>%rbp - 8</code>の計算結果をアドレスとするメモリの中身を意味します．　
ちなみにこの<code>-8</code>のことは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intelのマニュアル</a>では<strong>変位</strong> (displacement)と呼ばれています．
つまり「変位は定数だけど$マークはつきません」．</p>
</details>
<pre><code class="language-x86asmatt"># asm/movq-8.s
    .data
x:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    movq $x, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie movq-8.s
$ gdb ./a.out -x movq-8.txt
Breakpoint 1, main () at movq-8.s:10
10	    ret
9	    movq $x, %rax
$1 = 0x404028 ❷
nm ./a.out | egrep 'd x'
0000000000404028 d x
# %raxの値と nmコマンドによるxのアドレスが一致すれば成功
</code></pre>
<p>ちなみに，<code>x</code>のアドレスが<code>0x404028</code>になると分かっていれば，</p>
<pre><code class="language-x86asmatt">movq x, %rax          # これと
movq 0x404028, %rax   # これは同じ意味
</code></pre>
<p>上の2行は全く同じ意味(<code>0x404028</code>番地のメモリの中身)になります．
しかし，何番地になるか事前に分からないのが普通なので，
通常はラベル(ここでは<code>x</code>)を使います．</p>
<h3 id="addr-mode-indirect"><a class="header" href="#addr-mode-indirect">アドレッシングモード：間接メモリ参照</a></h3>
<p><strong>間接メモリ参照</strong>はアクセスするメモリ番地が変数となるメモリ参照です．
アセンブリ言語では変数という概念は無いので，
正確には「実行時に決まるレジスタの値を使って，
参照先のメモリアドレスを計算して決める」という参照方式です．
以下では3つの例が出てきます(<a href="6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>でより複雑な間接メモリ参照を説明します)．</p>
<div class="table-wrapper"><table><thead><tr><th>間接メモリ参照</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>(%rsp)</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>8(%rsp)</code></td><td><code>%rsp + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>%rip + foo</code></td></tr>
</tbody></table>
</div><br/>
<img src="figs/addr-mode-indirect.svg" height="250px" id="fig:addr-mode-indirect">
<p>以下の<a href="./asm/movq-9.s">movq-9.s</a>を<code>pushq $777</code>まで実行すると，
メモリの状態は上図のようになっています．
(<code>%rsp</code>が指す<code>777</code>のひとつ下のアドレスが<code>%rsp+8</code>なのは，
<code>pushq $777</code>命令が「サイズが8バイトの値<code>777</code>をスタックにプッシュしたから」です)．</p>
<pre><code class="language-x86asmatt"># asm/movq-9.s
    .data
foo:
    .quad 999 
    .text
    .globl main
    .type main, @function
main:
    pushq $888
    pushq $777
    movq (%rsp), %rax
    movq 8(%rsp), %rbx
    movq foo(%rip), %rcx
    ret
    .size main, .-main
</code></pre>
<ul>
<li><code>(%rsp)</code> は「アドレスが <code>%rsp</code>の値のメモリ」なので値<code>777</code>が入っている部分を参照します</li>
<li><code>8(%rsp)</code> は「アドレスが <code>%rsp + 8</code>の値のメモリ」なので値<code>888</code>が入っている部分を参照します</li>
<li><code>foo(%rip)</code> はちょっと特殊です．この形式は <strong><code>%rip</code>相対アドレッシング</strong> といいます．
この形式の時，ラベル<code>foo</code>の値はプログラムカウンタ<code>%rip</code>中のアドレスを起点とした
<a href="6-inst.html#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">相対アドレス</a>
になります．ですので，<code>%rip + foo</code>は<code>foo</code>の
<a href="6-inst.html#%E7%B5%B6%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%83%BB%E7%9B%B8%E5%AF%BE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9">絶対アドレス</a>
になるので，
<code>foo(%rip)</code>はラベル<code>foo</code>のメモリ部分，つまり<code>999</code>が入っている部分になります．</li>
</ul>
<details>
<summary>
gdbでの実行結果
</summary>
<pre><code>$ gcc -g movq-9.s
$ gdb ./a.out -x movq-9.txt
Breakpoint 1, main () at movq-9.s:14
14	    ret
11	    movq (%rsp), %rax
12	    movq 8(%rsp), %rbx
13	    movq foo(%rip), %rcx
$1 = 777
$2 = 888
$3 = 999
# 777, 888, 999なら成功
</code></pre>
</details>
<h3 id="メモリ参照"><a class="header" href="#メモリ参照">メモリ参照</a></h3>
<p><a href="6-inst.html#addr-mode-indirect">前節</a>では，
<code>(%rsp)</code>，<code>8(%rsp)</code>，<code>foo(%rip)</code>という間接メモリ参照の例を説明しました．
ここではメモリ参照の一般形を説明します．
以下がx86-64のメモリ参照の形式です．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./7-asm.html#att-intel">AT&amp;T形式</a></th><th><a href="./7-asm.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div><details>
<summary>
「segment: メモリ参照」という形式
</summary>
<p>実は「segment: メモリ参照」という形式もあるのですが，
あまり使わないので，ここでは省いて説明します．
興味のある人は<a href="x86-list.html#segment-override">こちら</a>を参照下さい．</p>
</details>
<p>disp (base, index, scale)
でアクセスするメモリのアドレスは
base + index * scale + disp で計算します．
disp(<code>%rip</code>)でアクセスするメモリのアドレスは
disp + <code>%rip</code>で計算します．
disp，base，index，scaleとして指定可能なものは次の節で説明します．</p>
<h3 id="メモリ参照で可能な組み合わせ64ビットモードの場合"><a class="header" href="#メモリ参照で可能な組み合わせ64ビットモードの場合">メモリ参照で可能な組み合わせ(64ビットモードの場合)</a></h3>
<h4 id="通常のメモリ参照"><a class="header" href="#通常のメモリ参照">通常のメモリ参照</a></h4>
<p>通常のメモリ参照では，disp，base，index，scaleに以下を指定できます．</p>
<img src="figs/memory-ref.svg" height="250px" id="fig:memory-ref">
<ul>
<li>disp には符号あり定数を指定する．ただし「64ビット定数」は無いことに注意．
アドレス計算時に64ビット長に符号拡張される．
dispは変位(displacement)を意味する．</li>
<li>base には上記のいずれかのレジスタを指定可能．省略も可．</li>
<li>index には上記のいずれかのレジスタを指定可能．省略も可．
<code>%rsp</code>を指定できないことに注意．</li>
<li>scale を省略すると <code>1</code> と同じ</li>
</ul>
<blockquote>
<p>注: dispの例外．
<code>mov␣</code>命令のみ，64ビットのdispを指定可能．
この場合，<code>movabs␣</code>というニモニックを使用可能．
(<code>abs</code>はおそらく絶対アドレス absolute address から)．
メモリ参照はdispのみで，base，index，scaleは指定不可．
他方のオペランドは<code>%rax</code>のみ指定可能．</p>
<pre><code>movq     0x1122334455667788, %rax
movabsq  0x1122334455667788, %rax
movq     %rax, 0x1122334455667788
movabsq  %rax, 0x1122334455667788
</code></pre>
</blockquote>
<h4 id="rip相対参照"><a class="header" href="#rip相対参照"><code>%rip</code>相対参照</a></h4>
<img src="figs/rip-relative.svg" height="120px" id="fig:rip-relative">
<p><code>%rip</code>相対参照では32ビットのdispと<code>%rip</code>レジスタのみが指定可能です．</p>
<h3 id="メモリ参照の例"><a class="header" href="#メモリ参照の例">メモリ参照の例</a></h3>
<p>以下がメモリ参照の例です．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="./7-asm.html#att-intel">AT&amp;T形式</a></th><th><a href="./7-asm.html#att-intel">Intel形式</a></th><th>指定したもの</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>8</code></td><td><code>[8]</code></td><td>disp</td><td><code>8</code></td></tr>
<tr><td><code>foo</code></td><td><code>[foo]</code></td><td>disp</td><td><code>foo</code></td></tr>
<tr><td><code>(%rbp)</code></td><td><code>[rbp]</code></td><td>base</td><td><code>%rbp</code></td></tr>
<tr><td><code>8(%rbp)</code></td><td><code>[rbp+8]</code></td><td>dispとbase</td><td><code>%rbp + 8</code></td></tr>
<tr><td><code>foo(%rbp)</code></td><td><code>[rbp+foo]</code></td><td>dispとbase</td><td><code>%rbp + foo</code></td></tr>
<tr><td><code>8(%rbp,%rax)</code></td><td><code>[rbp+rax+8]</code></td><td>dispとbaseとindex</td><td><code>%rbp + %rax + 8</code></td></tr>
<tr><td><code>8(%rbp,%rax, 2)</code></td><td><code>[rbp+rax*2+8]</code></td><td>dispとbaseとindexとscale</td><td><code>%rbp + %rax*2 + 8</code></td></tr>
<tr><td><code>(%rip)</code></td><td><code>[rip]</code></td><td>base</td><td><code>%rip</code></td></tr>
<tr><td><code>8(%rip)</code></td><td><code>[rip+8]</code></td><td>dispとbase</td><td><code>%rip + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>[rip+foo]</code></td><td>dispとbase</td><td><code>%rip + foo</code></td></tr>
<tr><td><code>%fs:-4</code></td><td><code>fs:[-4]</code></td><td><a href="./x86-list.html#segment-override">segment</a>とdisp</td><td><code>%fsのベースレジスタ - 4</code></td></tr>
</tbody></table>
</div><details>
<summary>
なんでこんな複雑なアドレッシングモード?
</summary>
<p>x86-64はRISCではなくCISCなので「よく使う1つの命令で複雑な処理が
できれば，それは善」という思想だからです(知らんけど)．
例えば，以下のCコードの配列<code>array[i]</code>へのアクセスはアセンブリコードで
<code>movl (%rdi,%rsi,4), %eax</code>の1命令で済みます．
(ここでは<code>sizeof(int)</code>が<code>4</code>なので，scaleが<code>4</code>になっています．
配列の先頭アドレスが<code>array</code>の，<code>i</code>番目の要素のアドレスは，
<code>array + i * sizeof(int)</code>で計算できることを思い出しましょう．
なお，<code>array.s</code>の出力を得るには，<code>gcc -S -O2 array.c</code>として下さい．
私の環境では<code>-O2</code>が無いと<code>gcc</code>は冗長なコードを吐きましたので)．</p>
<pre><code>// array.c
int foo (int array [], int i)
{
    return array [i];
}
</code></pre>
<pre><code>	.text
	.p2align 4
	.globl	foo
	.type	foo, @function
foo:
	endbr64
	movslq	%esi, %rsi
	movl	(%rdi,%rsi,4), %eax
	ret
	.size	foo, .-foo
</code></pre>
</details>
<h2 id="オペランドの表記方法"><a class="header" href="#オペランドの表記方法">オペランドの表記方法</a></h2>
<p>以下の機械語命令の説明で使う記法を説明します．
この記法はその命令に許されるオペランドの形式を表します．</p>
<h3 id="オペランド即値定数"><a class="header" href="#オペランド即値定数">オペランド，即値(定数)</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*op1*|  | 第1オペランド |
|*op2*|  | 第2オペランド |
|*imm*| `$100` |  *imm8*, *imm16*, *imm32*のどれか |
|*imm8*| `$100` | 8ビットの即値(定数) |
|*imm16*| `$100` | 16ビットの即値(定数) |
|*imm32*| `$100` | 32ビットの即値(定数) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>op1</em></td><td></td><td>第1オペランド</td></tr>
<tr><td><em>op2</em></td><td></td><td>第2オペランド</td></tr>
<tr><td rowspan="2"><em>imm</em></td><td><code>$100</code></td><td rowspan="2"><em>imm8</em>, <em>imm16</em>, <em>imm32</em>のどれか</td></tr>
<tr><td><code>$foo</code></td></tr>
<tr><td><em>imm8</em></td><td><code>$100</code></td><td>8ビットの即値(定数)</td></tr> 
<tr><td><em>imm16</em></td><td><code>$100</code></td><td>16ビットの即値(定数)</td></tr>
<tr><td><em>imm32</em></td><td><code>$100</code></td><td>32ビットの即値(定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>多くの場合，サイズを省略して単に<em>imm</em>と書きます．
特にサイズに注意が必要な時だけ，<em>imm32</em>などとサイズを明記します．</li>
<li><a href="./x86-list.html#mov-64bit-imm">一部例外を除き</a>，
x86-64では64ビットの即値を書けません(32ビットまでです)．</li>
</ul>
<h3 id="汎用レジスタ-1"><a class="header" href="#汎用レジスタ-1">汎用レジスタ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>r</em></td><td><code>%rax</code></td><td><em>r8</em>, <em>r16</em>, <em>r32</em>, <em>r64</em>のどれか</td></tr>
<tr><td><em>r8</em></td><td><code>%al</code></td><td>8ビットの汎用レジスタ</td></tr>
<tr><td><em>r16</em></td><td><code>%ax</code></td><td>16ビットの汎用レジスタ</td></tr>
<tr><td><em>r32</em></td><td><code>%eax</code></td><td>32ビットの汎用レジスタ</td></tr>
<tr><td><em>r64</em></td><td><code>%rax</code></td><td>64ビットの汎用レジスタ</td></tr>
</tbody></table>
</div>
<h3 id="メモリ参照-1"><a class="header" href="#メモリ参照-1">メモリ参照</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*r/m*  | `-8(%rbp)` |  *r/m8*, *r/m16*, *r/m32*, *r/m64*のどれか |
|*r/m8* | `-8(%rbp)` | *r8*  または 8ビットのメモリ参照 |
|*r/m16*| `-8(%rbp)` | *r16* または16ビットのメモリ参照 |
|*r/m32*| `-8(%rbp)` | *r32* または32ビットのメモリ参照 |
|*r/m64*| `-8(%rbp)` | *r64* または64ビットのメモリ参照 |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="4"><em>r/m</em></td><td><code>%rbp</code></td><td rowspan="4"><em>r/m8</em>, <em>r/m16</em>, <em>r/m32</em>, <em>r/m32</em>, <em>r/m64</em>のどれか</td></tr>
<tr><td><code>100</code></td></tr>
<tr><td><code>-8(%rbp)</code></td></tr>
<tr><td><code>foo(%rbp)</code></td></tr>
<tr><td><em>r/m8</em></td><td><code>-8(%rbp)</code></td><td><em>r8</em>  または 8ビットのメモリ参照</td></tr>
<tr><td><em>r/m16</em></td><td><code>-8(%rbp)</code></td><td><em>r16</em> また
は16ビットのメモリ参照</td></tr>
<tr><td><em>r/m32</em></td><td><code>-8(%rbp)</code></td><td><em>r32</em> また
は32ビットのメモリ参照</td></tr>
<tr><td><em>r/m64</em></td><td><code>-8(%rbp)</code></td><td><em>r64</em> また
は64ビットのメモリ参照</td></tr>
<tr><td><em>m</em></td><td><code>-8(%rbp)</code></td><td> メモリ参照</td></tr>
</tbody></table>
</div>
<h2 id="x86-64機械語命令転送など"><a class="header" href="#x86-64機械語命令転送など">x86-64機械語命令：転送など</a></h2>
<h3 id="nop命令-何もしない"><a class="header" href="#nop命令-何もしない"><code>nop</code>命令: 何もしない</a></h3>
<p><code>nop</code>は転送命令ではありませんが，最も簡単な命令ですので最初に説明します．</p>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
<tr><td><strong><code>nop</code></strong> <em>op1</em></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td><code>nop</code></td><td>何もしない</td><td><a href="./asm/nop.s">nop.s</a> <a href="./asm/nop.txt">nop.txt</a></td></tr>
<tr><td><strong><code>nop</code></strong> <em>r/m</em></td><td><code>nopl (%rax)</code></td><td>何もしない</td><td><a href="./asm/nop2.s">nop2.s</a> <a href="./asm/nop2.txt">nop2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./5-arch.html#status-reg">CF</a></th><th><a href="./5-arch.html#status-reg">OF</a></th><th><a href="./5-arch.html#status-reg">SF</a></th><th><a href="./5-arch.html#status-reg">ZF</a></th><th><a href="./5-arch.html#status-reg">PF</a></th><th><a href="./5-arch.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
<ul>
<li><code>nop</code>は何もしない命令です(ただしプログラムカウンタ<code>%rip</code>は増加します)．
フラグも変化しません．</li>
<li>機械語命令列の間を(何もせずに)埋めるために使います．</li>
<li><code>nop</code>の機械語命令は1バイト長です．
(なのでどんな長さの隙間にも埋められます)．</li>
<li><code>nop</code> <em>r/m</em> という形式の命令は2〜9バイト長の<code>nop</code>命令になります．
1バイト長の<code>nop</code>を9個並べるより，
9バイト長の<code>nop</code>を1個並べた方が，実行が早くなります．</li>
<li>「複数バイトの<code>nop</code>命令がある」という知識は，
逆アセンブル時に<code>nopl (%rax)</code>などを見て「なんじゃこりゃ」とビックリしないために必要です．</li>
</ul>
<h3 id="mov命令-データの転送コピー"><a class="header" href="#mov命令-データの転送コピー"><code>mov</code>命令: データの転送（コピー）</a></h3>
<div id="mov-plain">
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#詳しい記法">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td><a href="./asm/movq-1.s">movq-1.s</a> <a href="./asm/movq-1.txt">movq-1.txt</a></td></tr>
<tr><td><code>movq %rax, -8(%rsp)</code></td><td><code>*(%rsp - 8) = %rax</code></td><td><a href="./asm/movq-2.s">movq-2.s</a> <a href="./asm/movq-2.txt">movq-2.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq -8(%rsp), %rax</code></td><td><code>%rax = *(%rsp - 8)</code></td><td><a href="./asm/movq-3.s">movq-3.s</a> <a href="./asm/movq-3.txt">movq-3.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, -8(%rsp)</code></td><td><code>*(%rsp - 8) = 999</code></td><td><a href="./asm/movq-5.s">movq-5.s</a> <a href="./asm/movq-5.txt">movq-5.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
</div>
<ul>
<li><code>mov</code>命令は第1オペランドの値を第2オペランドに転送(コピー)します．
例えば，<code>movq %rax, %rbx</code>は「<code>%rax</code>の値を<code>%rbx</code>にコピー」することを意味します．</li>
</ul>
<details>
<summary>
movq-1.sの実行例
</summary>
<pre><code>$ gcc -g movq-1.s
$ gdb ./a.out -x movq-1.txt
Breakpoint 1, main () at movq-1.s:8
8	    ret
7	    movq %rax, %rbx
# p $rbx
$1 = 999
# %rbxの値が999なら成功
</code></pre>
</details>
<details>
<summary>
movq-2.sの実行例
</summary>
<pre><code>$ gcc -g movq-2.s
$ gdb ./a.out -x movq-2.txt
Breakpoint 1, main () at movq-2.s:8
8	    ret
7	    movq %rax, -8(%rsp)
# x/1gd $rsp-8
0x7fffffffde90:	999
# -8(%rsp)の値が999なら成功
</code></pre>
</details>
<ul>
<li>
<p>オペランドには，即値，レジスタ，メモリ参照を組み合わせて指定できますが，
メモリからメモリへの直接データ転送はできません．</p>
</li>
<li>
<p><code>␣</code>には<a href="./x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a>
(<code>q</code>, <code>l</code>, <code>w</code>, <code>b</code>)を指定します．
命令サフィックスは転送するデータのサイズを明示します
(順番に，8バイト，4バイト，2バイト，1バイトを示します)．</p>
<ul>
<li><code>movb $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>1バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movw $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>2バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movl $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>4バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
<li><code>movq $0x11, (%rsp)</code> は値<code>0x11</code>を<strong>8バイト</strong>のデータとして<code>(%rsp)</code>に書き込む</li>
</ul>
</li>
</ul>
<form class="tab-wrap">
    <input id="mov1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="mov1"><code>movb $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov1.svg" height="300px" id="fig:mov1">
    </div>
    <input id="mov2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov2"><code>movw $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov2.svg" height="300px" id="fig:mov2">
    </div>
    <input id="mov3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov3"><code>movl $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov3.svg" height="300px" id="fig:mov3">
    </div>
    <input id="mov4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="mov4"><code>movq $0x11, (%rax)</code></label>
    <div class="tab-content">
    	 <img src="figs/mov4.svg" height="300px" id="fig:mov4">
    </div>
</form>
<h4 id="機械語命令のバイト列をアセンブリコードに直書きできる"><a class="header" href="#機械語命令のバイト列をアセンブリコードに直書きできる">機械語命令のバイト列をアセンブリコードに直書きできる</a></h4>
<p><code>movq %rax, %rbx</code>をコンパイルして逆アセンブルすると，
機械語命令のバイト列は<code>48 89 C3</code>となります．
<code>.byte</code>というアセンブラ命令を使うと，
アセンブラに指定したバイト列を出力できます．
例えば，次のように<code>.byte 0x48, 0x89, 0xC3</code>と書くと，
<code>.text</code>セクションに<code>0x48, 0x89, 0xC3</code>というバイト列を出力できます．</p>
<pre><code class="language-x86asmatt"># asm/byte.s
    .text
    .globl main
    .type main, @function
main:
    movq %rax, %rbx          # これと
    .byte 0x48, 0x89, 0xC3   # これは同じ意味
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:   ❶48 89 c3     ❸mov    %rax,%rbx
    112c:   ❷48 89 c3     ❹mov    %rax,%rbx
    112f:   c3               ret    
</code></pre>
<p>コンパイルして逆アセンブルしてみると，
❷<code>0x48, 0x89, 0xC3</code>を出力できています．
一方，❶<code>0x48, 0x89, 0xC3</code>にも同じバイト列が並んでいます．
これは❸<code>movq %rax, %rbx</code>命令の機械語命令バイト列ですね．
さらに❷<code>0x48, 0x89, 0xC3</code>の逆アセンブル結果として，
❹<code>movq %rax, %rbx</code>とも表示されています．</p>
<p>つまり，アセンブラにとっては，</p>
<ul>
<li><code>movq %rax, %rbx</code> というニモニック</li>
<li><code>.byte 0x48, 0x89, 0xC3</code> というバイト列</li>
</ul>
<p>は全く同じ意味になるのでした．
ですので，<code>.text</code>セクションにニモニックで機械語命令を書く代わりに，
<code>.byte</code>を使って直接，機械語命令のバイト列を書くことができます．</p>
<h4 id="異なる機械語のバイト列で同じ動作のmov命令がある"><a class="header" href="#異なる機械語のバイト列で同じ動作のmov命令がある">異なる機械語のバイト列で，同じ動作の<code>mov</code>命令がある</a></h4>
<ul>
<li>質問： <code>%rax</code>の値を<code>%rbx</code>にコピーしたい時，
<code>movq</code> <em>r</em>, <em>r/m</em> と <code>movq</code> <em>r/m</em>, <em>r</em> のどちらを使えばいいのでしょう?</li>
<li>答え： どちらを使ってもいいです．ただし，異なる機械語命令のバイト列に
なることがあります．</li>
</ul>
<p>実は<code>0x48, 0x89, 0xC3</code>というバイト列は，
<code>movq</code> <em>r</em>, <em>r/m</em> を使った時のものです．
一方，<code>movq</code> <em>r/m</em>, <em>r</em> という形式を使った場合は，
バイト列は <code>0x48, 0x8B, 0xD8</code>になります．確かめてみましょう．</p>
<pre><code class="language-x86asmatt"># asm/byte2.s
    .text
    .globl main
    .type main, @function
main:
    .byte 0x48, 0x89, 0xC3
    .byte 0x48, 0x8B, 0xD8
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g byte2.s
$ objdump -d ./a.out
(中略)
0000000000001129 &lt;main&gt;:
    1129:    ❶48 89 c3      ❸mov    %rax,%rbx
    112c:    ❷48 8b d8      ❹mov    %rax,%rbx
    112f:      c3             ret    
</code></pre>
<p>❶<code>48 89 c3</code>と❷<code>48 8b d8</code>は異なるバイト列ですが
逆アセンブル結果としては
❸<code>mov %rax,%rbx</code>と❹<code>mov %rax,%rbx</code>と，どちらも同じ結果になりました．</p>
<p>このように同じニモニック命令に対して，複数の機械語のバイト列が存在する時，
アセンブラは「実行が速い方」あるいは「バイト列が短い方」を適当に選んでくれます．
(そして，アセンブラが選ばない方をどうしても使いたい場合は，
<code>.byte</code>等を使って機械語のバイト列を直書きするしかありません)．</p>
<h3 id="xchg命令-オペランドの値を交換"><a class="header" href="#xchg命令-オペランドの値を交換"><code>xchg</code>命令: オペランドの値を交換</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>op1</em>, <em>op2</em></td><td>exchange</td><td><em>op1</em> と <em>op2</em> の値を交換する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xchg %rax, (%rsp)</code></td><td><code>%rax</code>と<code>(%rsp)</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
<tr><td><strong><code>xchg</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xchg (%rsp), %rax</code></td><td><code>(%rsp)</code>と<code>%rax</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>xchg</code>命令は<strong>アトミックに</strong>2つのオペランドの値を交換します．(LOCKプリフィクスをつけなくてもアトミックになります)</li>
<li>この<strong>アトミック</strong>な動作はロックなどの<strong>同期機構</strong>を作るために使えます．</li>
</ul>
<details>
<summary>
xchg.sの実行例
</summary>
<pre><code>$ gcc -g xchg.s
$ gdb ./a.out -x xchg.txt
Breakpoint 1, main () at xchg.s:9
9	    xchg %rax, (%rsp)
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
10	    xchg (%rsp), %rax
1: /x $rax = 0x1122334455667788
2: /x *(void **)($rsp) = 0x99aabbccddeeff00
11	    popq %rax
1: /x $rax = 0x99aabbccddeeff00
2: /x *(void **)($rsp) = 0x1122334455667788
# 値が入れ替わっていれば成功
</code></pre>
</details>
<details>
<summary>
機械語1命令の実行はアトミックとは限らない
</summary>
<p>機械語1命令の実行はアトミックとは限りません．
例えば，<code>inc</code>命令(オペランドを1増やす命令)は
マニュアルによると「<code>LOCK</code>プリフィックスをつければアトミックに実行される」とあります．
<code>inc</code>命令に<code>LOCK</code>プリフィックスがない場合には(たまたまアトミックに実行されるかも知れませんが)
「常にアトミックである」と期待してはいけないのです(マニュアルで「アトミックだ」と明記されていない限り)．</p>
<p>なお，<code>inc</code>は「メモリから読んだ値に1を足して書き戻す」ため
アトミックにならない可能性がありますが，<strong>読むだけ</strong>または<strong>書くだけ</strong>でかつ，
<strong>適切にアラインメント</strong>されていれば，
そのメモリ操作は<a href="https://stackoverflow.com/questions/36624881/why-is-integer-assignment-on-a-naturally-aligned-variable-atomic-on-x86/36685056#36685056">アトミックになります</a>．</p>
</details>
<h3 id="lea命令-実効アドレスを計算"><a class="header" href="#lea命令-実効アドレスを計算"><code>lea</code>命令: 実効アドレスを計算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>op1</em>, <em>op2</em></td><td>load effective address</td><td><em>op1</em> の実効アドレスを <em>op2</em> に代入する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>m</em>, <em>r</em></td><td><code>leaq -8(%rsp, %rsi, 4), %rax</code></td><td><code>%rax=%rsp+%rsi*4-8</code></td><td><a href="./asm/leaq-2.s">leaq-2.s</a> <a href="./asm/leaq-2.txt">leaq-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>lea</code>命令は第1オペランド(常にメモリ参照)の実効アドレスを計算して，
第2オペランドに格納します．</li>
<li><code>lea</code>命令はアドレスを計算するだけで，メモリにはアクセスしません．</li>
</ul>
<details>
<summary>
leaq-2.sの実行例
</summary>
<pre><code>$ gcc -g lea.s
$ gdb ./a.out -x lea.txt
Breakpoint 1, main () at leaq-2.s:8
8	    ret
# p/x $rsp
$1 = 0x7fffffffde98
# p/x $rsi
$2 = 0x8
# p/x $rax
$3 = 0x7fffffffdeb0
# %rax == %rsp + %rsi * 4 なら成功
</code></pre>
</details>
<ul>
<li><strong>実効アドレス</strong>とは<a href="6-inst.html#addr-mode-direct">直接メモリ参照</a>や
<a href="6-inst.html#addr-mode-indirect">間接メモリ参照</a>で計算したアドレスことです．</li>
</ul>
<details>
<summary>
実効アドレスとリニアアドレスの違いは?→(ほぼ)同じ
</summary>
<br/>
<img src="figs/effective-addr.svg" height="300px" id="fig:effective-addr">
<ul>
<li><strong>実効アドレス</strong>(effective address)は
<a href="./6-inst.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">メモリ参照</a>で
disp (base, index, scale) や disp (<code>%rip</code>)から計算したアドレスのことです．</li>
<li>x86-64のアセンブリコード中のアドレスは<strong>論理アドレス</strong> (logical address)といい，
<strong>セグメント</strong>と<strong>実効アドレス</strong>のペアとなっています．
このペアをx86-64用語で<strong>farポインタ</strong>とも呼びます．
(本書ではfarポインタは扱いません)．</li>
<li>セグメントが示すベースアドレスと実効アドレスを加えたものが
<strong>リニアアドレス</strong>(linear address)です．
例えば64ビットアドレス空間だと，リニアアドレスは0番地から2<sup>64</sup>-1番地
まで一直線に並ぶのでリニアアドレスと呼ばれています．
リニアアドレスは<strong>仮想アドレス</strong>(virtual address)と等しくなります．</li>
<li>また，x86-64では<a href="./x86-list.html#segment-override">%fsと%gs</a>を除き，
セグメントが示すベースアドレスが0番地なので，
<strong>実効アドレスとリニアアドレスは等しくなります</strong>．</li>
<li>リニアアドレス(仮想アドレス)はCPUのページング機構により，
物理アドレスに変換されて，最終的なメモリアクセスが行われます．</li>
</ul>
</details>
<ul>
<li>コンパイラは加算・乗算を高速に実行するため<code>lea</code>命令を使うことがあります．</li>
</ul>
<p>例えば，</p>
<pre><code class="language-x86asmatt">movq $4, %rax
addq %rbx, %rax
shlq $2, %rsi   # 左論理シフト．2ビット左シフトすることで%rsiを4倍にしている
addq %rsi, %rax
</code></pre>
<p>は，<code>%rax = %rbx + %rsi * 4 + 4</code>という計算を4命令でしていますが，
<code>lea</code>命令なら以下の1命令で済みます</p>
<pre><code class="language-x86asmatt">leaq 4(%rbx, %rsi, 4), %rax
</code></pre>
<blockquote>
<p>注: 実行時間は命令ごとに異なりますので，命令数だけで
実行時間を比較することはできません．</p>
</blockquote>
<h3 id="pushとpop命令-スタックとデータ転送"><a class="header" href="#pushとpop命令-スタックとデータ転送"><code>push</code>と<code>pop</code>命令: スタックとデータ転送</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>op1</em></td><td>push</td><td><em>op1</em> をスタックにプッシュ</td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>op1</em></td><td>pop</td><td>スタックから <em>op1</em> にポップ</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>imm</em></td><td><code>pushq $999</code></td><td><code>%rsp-=8; *(%rsp)=999</code></td><td><a href="./asm/push1.s">push1.s</a> <a href="./asm/push1.txt">push1.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m16</em></td><td><code>pushw %ax</code></td><td><code>%rsp-=2; *(%rsp)=%ax</code></td><td><a href="./asm/push2.s">push2.s</a> <a href="./asm/push2.txt">push2.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m64</em></td><td><code>pushq %rax</code></td><td><code>%rsp-=8; *(%rsp)=%rax</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m16</em></td><td><code>popw %ax</code></td><td><code>*(%rsp)=%ax; %rsp += 2</code></td><td><a href="./asm/pop2.s">pop2.s</a> <a href="./asm/pop2.txt">pop2.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m64</em></td><td><code>popq %rbx</code></td><td><code>%rbx=*(%rsp); %rsp += 8</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<br/>
<form class="tab-wrap">
    <input id="push-pop1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="push-pop1"><code>pushq %rax前</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop1.svg" height="350px" id="fig:push-pop1">
    </div>
    <input id="push-pop2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop2"><code>pushq %rax後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop2.svg" height="350px" id="fig:push-pop2">
    </div>
    <input id="push-pop3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="push-pop3"><code>popq %rbx後</code></label>
    <div class="tab-content">
    	 <img src="figs/push-pop3.svg" height="350px" id="fig:push-pop3">
    </div>
</form>
<ul>
<li><code>push</code>命令はスタックポインタ<code>%rsp</code>を<strong>減らしてから</strong>，
スタックトップ(スタックの一番上)にオペランドの値を格納します．</li>
<li><code>pop</code>命令はスタックトップの値をオペランドに<strong>格納してから</strong>，
スタックポインタを増やします．</li>
<li>64ビットモードでは，32ビットの<code>push</code>と<code>pop</code>はできません．</li>
<li>抽象データ型のスタックは(スタックトップに対する)プッシュ操作とポップ操作しか
できませんが，x86-64のスタック操作はスタックトップ以外の部分にも自由にアクセス可能です(例えば，<code>-8(%rsp)</code>や<code>-8(%rbp)</code>などへのメモリ参照で)．</li>
<li>一番右側の図(<code>popq %rbx後</code>)で，ポップ後も<code>%rsp</code>よりも上に古い値が残っています
(<code>0x11</code>〜<code>0x88</code>)．このように，ポップしてもスタック上に古い値がゴミとして残ります．</li>
</ul>
<details>
<summary>
push1.sの実行例
</summary>
<pre><code>$ gcc -g push1.s
$ gdb ./a.out -x push1.txt
Breakpoint 1, main () at push1.s:6
6	    pushq $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push1.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde90
# x/1gd $rsp
0x7fffffffde90:	999
# %rsp が8減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
push2.sの実行例
</summary>
<pre><code>$ gcc -g push2.s
$ gdb ./a.out -x push2.txt
Breakpoint 1, main () at push2.s:6
6	    pushw $999
# p/x $rsp
$1 = 0x7fffffffde98
main () at push2.s:7
7	    ret
# p/x $rsp
$2 = 0x7fffffffde96
# x/1hd $rsp
0x7fffffffde96:	999
# %rsp が2減って，(%rsp)の値が999なら成功
</code></pre>
</details>
<details>
<summary>
pop2.sの実行例
</summary>
<pre><code>$ gcc -g pop2.s
$ gdb ./a.out -x pop2.txt
Breakpoint 1, main () at pop2.s:7
7	    popw %ax
# p/x $rsp
$1 = 0x7fffffffde96
main () at pop2.s:8
8	    ret
# p/x $rsp
$2 = 0x7fffffffde98
# p/d $ax
$3 = 999
# %rsp が2増えて，%axの値が999なら成功
</code></pre>
</details>
<details>
<summary>
push-pop.sの実行例
</summary>
<pre><code>$ gcc -g push-pop.s
$ gdb ./a.out -x push-pop.txt
Breakpoint 1, main () at push-pop.s:8
8	    pushq %rax
# p/x $rsp
$1 = 0x7fffffffde98
main () at push-pop.s:9
9	    popq  %rbx
# p/x $rsp
$2 = 0x7fffffffde90
# x/8bx $rsp
0x7fffffffde90:	0x88	0x77	0x66	0x55	0x44	0x33	0x22	0x11
# %rsp の値が8減って，スタックトップ8バイトが 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11なら成功
</code></pre>
</details>
<h2 id="x86-64機械語命令-算術論理演算"><a class="header" href="#x86-64機械語命令-算術論理演算">x86-64機械語命令: 算術・論理演算</a></h2>
<h3 id="概要とステータスフラグ"><a class="header" href="#概要とステータスフラグ">概要とステータスフラグ</a></h3>
<p>ここでは以下の算術・論理演算を説明します．</p>
<div class="table-wrapper"><table><thead><tr><th>演算の種類</th><th>主な命令</th></tr></thead><tbody>
<tr><td>算術</td><td><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>inc</code>, <code>dec</code>, <code>not</code></td></tr>
<tr><td>論理</td><td><code>and</code>, <code>or</code>, <code>not</code>, <code>xor</code></td></tr>
<tr><td>シフト</td><td><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>, <code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code></td></tr>
<tr><td>比較</td><td><code>cmp</code>, <code>test</code></td></tr>
<tr><td>変換(拡張)</td><td><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code></td></tr>
</tbody></table>
</div>
<p>これらの命令のほとんどが演算の結果として，
<a href="./5-arch.html#%E6%9C%AC%E6%9B%B8%E3%81%A7%E6%89%B1%E3%81%86%E3%83%95%E3%83%A9%E3%82%B0">ステータスフラグ</a>
の値を変化させます．
本書ではステータスフラグの変化を以下の記法で表します．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="6-inst.html#status-reg">CF</a></th><th><a href="6-inst.html#status-reg">OF</a></th><th><a href="6-inst.html#status-reg">SF</a></th><th><a href="6-inst.html#status-reg">ZF</a></th><th><a href="6-inst.html#status-reg">PF</a></th><th><a href="6-inst.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td>!</td><td>?</td><td>0</td><td>1</td><td></td></tr>
</tbody></table>
</div>
<p>記法の意味は以下の通りです．</p>
<div id="status-reg">
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>意味</th></tr></thead><tbody>
<tr><td>空白</td><td>フラグ値に変化なし</td></tr>
<tr><td>!</td><td>フラグ値に変化あり</td></tr>
<tr><td>?</td><td>フラグ値は未定義(参照禁止)</td></tr>
<tr><td>0</td><td>フラグ値はクリア(0になる)</td></tr>
<tr><td>1</td><td>フラグ値はセット(1になる)</td></tr>
</tbody></table>
</div></div>
<h3 id="add命令-足し算"><a class="header" href="#add命令-足し算"><code>add</code>命令: 足し算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add</td><td><em>op1</em> を <em>op2</em> に加える</td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add with carry</td><td><em>op1</em> と CF を <em>op2</em> に加える</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>addq $999, %rax</code></td><td><code>%rax += 999</code></td><td><a href="./asm/add-1.s">add-1.s</a> <a href="./asm/add-1.txt">add-1.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>addq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>addq (%rsp), %rax</code></td><td><code>%rax += *(%rsp)</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>adcq $999, %rax</code></td><td><code>%rax += 999 + CF</code></td><td><a href="./asm/adc-1.s">adc-1.s</a> <a href="./asm/adc-1.txt">adc-1.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>adcq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax + CF</code></td><td><a href="./asm/adc-2.s">adc-2.s</a> <a href="./asm/adc-2.txt">adc-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>adcq (%rsp), %rax</code></td><td><code>%rax += *(%rsp) + CF</code></td><td><a href="./asm/adc-3.s">adc-3.s</a> <a href="./asm/adc-3.txt">adc-3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と<code>adc</code>はオペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算します．</li>
<li><code>adc</code>は例えば，多倍長整数(任意の桁数の整数)を実装する時の
「繰り上がり」の計算に便利です．</li>
</ul>
<details>
<summary>
add-1.sの実行例
</summary>
<pre><code>$ gcc -g add-1.s
$ gdb ./a.out -x add-1.txt
Breakpoint 1, main () at add-1.s:8
8	    ret
# p $rax
$1 = 1000
# %raxが1000なら成功
</code></pre>
</details>
<details>
<summary>
add-2.sの実行例
</summary>
<pre><code>$ gcc -g add-2.s
$ gdb ./a.out -x add-2.txt
Breakpoint 1, main () at add-2.s:10
10	    popq %rbx
# p $rax
$1 = 1001
# x/1gd $rsp
0x7fffffffde90:	1000
# %raxが1001，(%rsp)が1000なら成功
</code></pre>
</details>
<details>
<summary>
adc-1.sの実行例
</summary>
<pre><code>$ gcc -g adc-1.s
$ gdb ./a.out -x adc-1.txt
reakpoint 1, main () at adc-1.s:8
8	    adcq $2, %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-1.s:9
9	    ret
# p $rax
$3 = 3
# %rflagsでCFが立っていて，%raxが3なら成功
</code></pre>
</details>
<details>
<summary>
adc-2.sの実行例
</summary>
<pre><code>$ gcc -g adc-2.s
$ gdb ./a.out -x adc-2.txt
Breakpoint 1, main () at adc-2.s:9
9	    adcq $2, (%rsp)
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-2.s:10
10	    ret
x/1gd $rsp
0x7fffffffde90:	1002
# %rflagsでCFが立っていて，(%rsp)が1002なら成功
</code></pre>
</details>
<details>
<summary>
adc-3.sの実行例
</summary>
<pre><code>$ gcc -g adc-3.s
$ gdb ./a.out -x adc-3.txt
Breakpoint 1, main () at adc-3.s:9
9	    adcq (%rsp), %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at adc-3.s:10
10	    ret
# p $rax
$3 = 1000
# %rflagsでCFが立っていて，%raxが1000なら成功
</code></pre>
</details>
<h3 id="sub-sbb命令-引き算"><a class="header" href="#sub-sbb命令-引き算"><code>sub</code>, <code>sbb</code>命令: 引き算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract</td><td><em>op1</em> を <em>op2</em> から引く</td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract with borrow</td><td><em>op1</em> と CF を <em>op2</em> から引く</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>subq $999, %rax</code></td><td><code>%rax -= 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>subq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>subq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp)</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>sbbq $999, %rax</code></td><td><code>%rax -= 999 + CF</code></td><td><a href="./asm/sbb-1.s">sbb-1.s</a> <a href="./asm/sbb-1.txt">sbb-1.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>sbbq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>sbbq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp) + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と同様に，<code>sub</code>と<code>sbb</code>は
オペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算します．</li>
</ul>
<details>
<summary>
sub-1.sの実行例
</summary>
<pre><code>$ gcc -g sub-1.s
$ gdb ./a.out -x sub-1.txt
Breakpoint 1, main () at sub-1.s:8
8	    ret
# p $rax
$1 = 1
# %raxが1なら成功
</code></pre>
</details>
<details>
<summary>
sub-2.sの実行例
</summary>
<pre><code>$ gcc -g sub-2.s
$ gdb ./a.out -x sub-2.txt
Breakpoint 1, main () at sub-2.s:10
10	    popq %rbx
# p $rax
$1 = -997
# x/1gd $rsp
0x7fffffffde90:	998
# %raxが-997，(%rsp)が998なら成功
</code></pre>
</details>
<details>
<summary>
sbb-1.sの実行例
</summary>
<pre><code>$ gcc -g sbb-1.s
$ gdb ./a.out -x sbb-1.txt
Breakpoint 1, main () at sbb-1.s:8
8	    sbbq $2, %rax
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
main () at sbb-1.s:9
9	    ret
# p $rax
$3 = -3
# %rflagsでCFが立っていて，%raxが-3なら成功
</code></pre>
</details>
<details>
<summary>
sbb-2.sの実行例
</summary>
<pre><code>$ gcc -g sbb-2.s
$ gdb ./a.out -x sbb-2.txt
Breakpoint 1, main () at sbb-2.s:9
9	    sbbq $2, (%rsp)
# p $rax
$1 = 0
# p $eflags
$2 = [ CF PF AF ZF IF ]
10	    sbbq (%rsp), %rax
main () at sbb-2.s:11
11	    ret
x/1gd $rsp
0x7fffffffde90:	996
# p $rax
$3 = -996
# %rflagsでCFが立っていて，(%rsp)が996，%raxが-996なら成功
</code></pre>
</details>
<h3 id="mul-imul命令-かけ算"><a class="header" href="#mul-imul命令-かけ算"><code>mul</code>, <code>imul</code>命令: かけ算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>op1</em></td><td>unsigned multiply</td><td>符号なし乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em></td><td>signed multiply</td><td>符号あり乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em></td><td>signed multiply</td><td>符号あり乗算．<em>op2</em> *= <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em>, <em>op3</em></td><td>signed multiply</td><td>符号あり乗算．<em>op3</em> = <em>op1</em> * <em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>r/m</em></td><td><code>mulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/mul-1.s">mul-1.s</a> <a href="./asm/mul-1.txt">mul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em></td><td><code>imulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/imul-1.s">imul-1.s</a> <a href="./asm/imul-1.txt">imul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>imulq $4, %rax</code></td><td><code>%rax *= 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>imulq %rbx, %rax</code></td><td><code>%rax *= %rbx</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r/m</em>, <em>r</em></td><td><code>imulq $4, %rbx, %rax</code></td><td><code>%rax = %rbx * 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<br/>
<img src="figs/imul.svg" height="250px" id="fig:imul">
<ul>
<li>オペランドが1つの形式では，<code>%rax</code>が隠しオペランドになります．
このため，乗算の前に<code>%rax</code>に値をセットしておく必要があります．
また，8バイト同士の乗算結果は最大で16バイトになるので，
乗算結果を<code>%rdx</code>と<code>%rax</code>に分割して格納します
(16バイトの乗算結果の上位8バイトを<code>%rdx</code>に，下位8バイトを<code>%rax</code>に格納します)．
これをここでは<code>(%rdx:%rax)</code>という記法で表現しています．</li>
<li><code>imul</code>だけ例外的に，オペランドが2つの形式と3つの形式があります．
2つか3つの形式では乗算結果が8バイトを超えた場合，
越えた分は破棄されます(乗算結果は8バイトのみ)．</li>
</ul>
<details>
<summary>
mul-1.sの実行例
</summary>
<pre><code>$ gcc -g mul-1.s
$ gdb ./a.out -x mul-1.txt
Breakpoint 1, main () at mul-1.s:9
9	    ret
# p $rdx
$1 = 0
# p $rax
$2 = 6
# %rdxが0, %raxが6なら成功
</code></pre>
</details>
<details>
<summary>
imul-1.sの実行例
</summary>
<pre><code>$ gcc -g imul-1.s
$ gdb ./a.out -x imul-1.txt
Breakpoint 1, main () at imul-1.s:9
9	    ret
# p $rdx
$1 = 0xffffffffffffffff
# p $rax
$2 = -6
# %rdxが0xFFFFFFFFFFFFFFFF, %raxが-6なら成功
</code></pre>
</details>
<details>
<summary>
imul-2.sの実行例
</summary>
<pre><code>$ gcc -g imul-2.s
$ gdb ./a.out -x imul-2.txt
Breakpoint 1, main () at imul-2.s:8
8	    imulq $4, %rax
9	    imulq %rbx, %rax
1: $rax = -8
10	    imulq $5, %rbx, %rax
1: $rax = 24
main () at imul-2.s:11
11	    ret
1: $rax = -15
# %raxが-8, 24, -15なら成功
</code></pre>
</details>
<h3 id="div-idiv命令-割り算余り"><a class="header" href="#div-idiv命令-割り算余り"><code>div</code>, <code>idiv</code>命令: 割り算，余り</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>op1</em></td><td>unsigned divide</td><td>符号なし除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>op1</em></td><td>signed divide</td><td>符号あり除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>r/m</em></td><td><code>divq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/div-1.s">div-1.s</a> <a href="./asm/div-1.txt">div-1.txt</a></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>r/m</em></td><td><code>idivq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/idiv-1.s">idiv-1.s</a> <a href="./asm/idiv-1.txt">idiv-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>16バイトの値 <code>%rdx:%rax</code> を第1オペランドで割った商が<code>%rax</code>に入り，
余りが<code>%rdx</code>に入ります．</li>
<li>隠しオペランドとして<code>%rdx</code>と<code>%rax</code>が使われるので，
事前に値を設定しておく必要があります．
<code>idiv</code>を使う場合，もし<code>%rdx</code>を使わないのであれば，
<code>cqto</code>命令で<code>%rax</code>を<code>%rdx:%rax</code>に符号拡張しておくと良いです．</li>
</ul>
<details>
<summary>
div-1.sの実行例
</summary>
<pre><code>$ gcc -g div-1.s
$ gdb ./a.out -x div-1.txt
Breakpoint 1, main () at div-1.s:10
10	    ret
# p $rax
$1 = 33
# p $rdx
$2 = 9
# %raxが33, %rdxが9なら成功
</code></pre>
</details>
<details>
<summary>
idiv-1.sの実行例
</summary>
<pre><code>$ gcc -g idiv-1.s
$ gdb ./a.out -x idiv-1.txt
Breakpoint 1, main () at idiv-1.s:9
9	    idivq %rbx
# p/x $rdx
$1 = 0xffffffffffffffff
main () at idiv-1.s:10
10	    ret
# p $rax
$2 = -33
# p $rdx
$3 = -9
# 最初の%rdxが0xFFFFFFFFFFFFFFFF, %raxが-33, 2番目の%rdxが-9なら成功
</code></pre>
</details>
<h3 id="inc-dec命令-インクリメントデクリメント"><a class="header" href="#inc-dec命令-インクリメントデクリメント"><code>inc</code>, <code>dec</code>命令: インクリメント，デクリメント</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>op1</em></td><td>increment</td><td><em>op1</em>の値を1つ増加</td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>op1</em></td><td>decrement</td><td><em>op1</em>の値を1つ減少</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>r/m</em></td><td><code>inc %rax</code></td><td><code>%rax</code>++</td><td><a href="./asm/inc-1.s">inc-1.s</a> <a href="./asm/inc-1.txt">inc-1.txt</a></td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>r/m</em></td><td><code>dec %rax</code></td><td><code>%rax</code>--</td><td><a href="./asm/dec-1.s">dec-1.s</a> <a href="./asm/dec-1.txt">dec-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>inc</code>や<code>dec</code>はオーバーフローしてもCFが変化しないところがポイントです．</li>
</ul>
<details>
<summary>
inc-1.sの実行例
</summary>
<pre><code>$ gcc -g inc-1.s
$ gdb ./a.out -x inc-1.txt
Breakpoint 1, main () at inc-1.s:8
8	    ret
# p $rax
$1 = 1
# %raxが1なら成功
</code></pre>
</details>
<details>
<summary>
dec-1.sの実行例
</summary>
<pre><code>$ gcc -g dec-1.s
$ gdb ./a.out -x dec-1.txt
reakpoint 1, main () at dec-1.s:8
8	    ret
# p $rax
$1 = -1
# %raxが-1なら成功
</code></pre>
</details>
<h3 id="neg命令-符号反転"><a class="header" href="#neg命令-符号反転"><code>neg</code>命令: 符号反転</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>op1</em></td><td>negation</td><td>2の補数による<em>op1</em>の符号反転</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>r/m</em></td><td><code>neg %rax</code></td><td><code>%rax = -%rax</code></td><td><a href="./asm/neg-1.s">neg-1.s</a> <a href="./asm/neg-1.txt">neg-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<details>
<summary>
neg-1.sの実行例
</summary>
<pre><code>$ gcc -g neg-1.s
$ gdb ./a.out -x neg-1.txt
Breakpoint 1, main () at neg-1.s:7
7	    neg %rax
1: $rax = 999
8	    neg %rax
1: $rax = -999
main () at neg-1.s:9
9	    ret
1: $rax = 999
# %raxが 999 → -999 → 999 と変化すれば成功
</code></pre>
</details>
<h3 id="not命令-ビット論理演算-1"><a class="header" href="#not命令-ビット論理演算-1"><code>not</code>命令: ビット論理演算 (1)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>op1</em></td><td>bitwise not</td><td><em>op1</em>の各ビットの反転 (NOT)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>r/m</em></td><td><code>notq %rax</code></td><td><code>%rax = ~%rax</code></td><td><a href="./asm/not-1.s">not-1.s</a> <a href="./asm/not-1.txt">not-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<details>
<summary>
not-1.sの実行例
</summary>
<pre><code>$ gcc -g not-1.s
$ gdb ./a.out -x not-1.txt
Breakpoint 1, main () at not-1.s:7
7	    not %al
1: /t $al = 11001010
8	    not %al
1: /t $al = 110101
main () at not-1.s:9
9	    ret
1: /t $al = 11001010
# %alが 11001010 → 110101 → 11001010 と変化すれば成功
</code></pre>
</details>
<h3 id="and-or-xor命令-ビット論理演算-2"><a class="header" href="#and-or-xor命令-ビット論理演算-2"><code>and</code>, <code>or</code>, <code>xor</code>命令: ビット論理演算 (2)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise and</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理積(AND)</td></tr>
<tr><td><strong><code>or␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise or</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理和(OR)</td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise xor</td><td><em>op1</em>と<em>op2</em>の各ビットごとの排他的論理和(XOR)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>andq $0x0FFF, %rax</code></td><td><code>%rax &amp;= 0x0FFF</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>andq %rax, (%rsp)</code></td><td><code>*(%rsp) &amp;= %rax</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>andq (%rsp), %rax</code></td><td><code>%rax &amp;= *(%rsp)</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>orq $0x0FFF, %rax</code></td><td><code>%rax |= 0x0FFF </code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>orq %rax, (%rsp)</code></td><td><code>*(%rsp) |= %rax</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>orq (%rsp), %rax</code></td><td><code>%rax |= *(%rsp)</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>xorq $0x0FFF, %rax</code></td><td><code>%rax ^= 0x0FFF</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xorq %rax, (%rsp)</code></td><td><code>*(%rsp) ^= %rax</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xorq (%rsp), %rax</code></td><td><code>%rax ^= *(%rsp)</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><em>x</em></th><th style="text-align: center"><em>y</em></th><th style="text-align: center"><em>x</em> &amp; <em>y</em></th><th style="text-align: center"><em>x</em> | <em>y</em></th><th style="text-align: center"><em>x</em> ^ <em>y</em></th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>&amp;</code>, <code>|</code>, <code>^</code>はC言語で，それぞれ，ビットごとの論理積，論理和，排他的論理積です
(忘れた人はC言語を復習しましょう)．</li>
</ul>
<details>
<summary>
and-1.sの実行例
</summary>
<pre><code>$ gcc -g and-1.s
$ gdb ./a.out -x and-1.txt
Breakpoint 1, main () at and-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 10001000

Breakpoint 2, main () at and-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	00001000
# p/t $al
$2 = 0
# 表示される値が 10001000, 00001000, 0 なら成功
</code></pre>
</details>
<details>
<summary>
or-1.sの実行例
</summary>
<pre><code>$ gcc -g or-1.s
$ gdb ./a.out -x or-1.txt
Breakpoint 1, main () at or-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 11101110

Breakpoint 2, main () at or-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	11101111
# p/t $al
$2 = 11111111
# 表示される値が 11101110, 11101111, 11111111 なら成功
</code></pre>
</details>
<details>
<summary>
xor-1.sの実行例
</summary>
<pre><code>$ gcc -g xor-1.s
$ gdb ./a.out -x xor-1.txt
Breakpoint 1, main () at xor-1.s:8
8	    pushq $0B00001111
# p/t $al
$1 = 1100110

Breakpoint 2, main () at xor-1.s:12
12	    ret
# x/1bt $rsp
0x7fffffffde90:	01101001
# p/t $al
$2 = 10011110
# 表示される値が 1100110, 01101001, 10011110 なら成功
</code></pre>
</details>
<h3 id="sal-sar-shl-shr-シフト"><a class="header" href="#sal-sar-shl-shr-シフト"><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>: シフト</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic left</td><td>算術左シフト</td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical left</td><td>論理左シフト</td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic right</td><td>算術右シフト</td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical right</td><td>論理右シフト</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>r/m</em></td><td><code>salq %rax</code></td><td><code>%rax</code>を1ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>salq $2, %rax</code></td><td><code>%rax</code>を2ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>salq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>r/m</em></td><td><code>shlq %rax</code></td><td><code>%rax</code>を1ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shlq $2, %rax</code></td><td><code>%rax</code>を2ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shlq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>r/m</em></td><td><code>sarq %rax</code></td><td><code>%rax</code>を1ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>sarq $2, %rax</code></td><td><code>%rax</code>を2ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>sarq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>r/m</em></td><td><code>shrq %rax</code></td><td><code>%rax</code>を1ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shrq $2, %rax</code></td><td><code>%rax</code>を2ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<img src="figs/shift.svg" height="300px" id="fig:shift">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li><strong>シフト</strong>とは(指定したビット数だけ)右か左にビット列をずらすことを意味します．
<em>op2</em>がなければ「1ビットシフト」を意味します．</li>
<li><strong>論理シフト</strong>とは「空いた場所に<strong>0を入れる</strong>」，
<strong>算術シフト</strong>とは「空いた場所に<strong>符号ビットを入れる</strong>」ことを意味します．</li>
<li>左シフトの場合は(符号ビットを入れても意味がないので)，論理シフトでも算術シフトでも，0を入れます．その結果，算術左シフト<code>sal</code>と論理左シフト<code>shl</code>は全く同じ動作になります．</li>
<li>C言語の符号あり整数に対する右シフト(&gt;&gt;)は算術シフトか論理シフトかは
決まっていません(実装依存です)．
C言語で，ビット演算は符号なし整数に対してのみ行うようにしましょう．</li>
</ul>
<details>
<summary>
sal-1.sの実行例
</summary>
<pre><code>$ gcc -g sal-1.s
$ gdb ./a.out -x sal-1.txt
Breakpoint 1, main () at sal-1.s:8
8	    salq %rax
1: /t $rax = 11111111
9	    salq $2, %rax
1: /t $rax = 111111110
10	    salq %cl, %rax
1: /t $rax = 11111111000
main () at sal-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
shl-1.sの実行例
</summary>
<pre><code>$ gcc -g shl-1.s
$ gdb ./a.out -x shl-1.txt
reakpoint 1, main () at shl-1.s:8
8	    shlq %rax
1: /t $rax = 11111111
9	    shlq $2, %rax
1: /t $rax = 111111110
10	    shlq %cl, %rax
1: /t $rax = 11111111000
main () at shl-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
sar-1.sの実行例
</summary>
<pre><code>$ gcc -g sar-1.s
$ gdb ./a.out -x sar-1.txt
Breakpoint 1, main () at sar-1.s:8
8	    sarq %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000000
9	    sarq $2, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111110000000
10	    sarq %cl, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111111100000
main () at sar-1.s:11
11	    ret
1: /t $rax = 1111111111111111111111111111111111111111111111111111111111111100
# 表示される値が 1111111111111111111111111111111111111111111111111111111100000000, 1111111111111111111111111111111111111111111111111111111110000000, 1111111111111111111111111111111111111111111111111111111111100000, 1111111111111111111111111111111111111111111111111111111111111100 なら成功
</code></pre>
</details>
<details>
<summary>
shr-1.sの実行例
</summary>
<pre><code>$ gcc -g shr-1.s
$ gdb ./a.out -x shr-1.txt
reakpoint 1, main () at shr-1.s:8
8	    shrq %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000000
9	    shrq $2, %rax
1: /t $rax = 111111111111111111111111111111111111111111111111111111110000000
10	    shrq %cl, %rax
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100000
main () at shr-1.s:11
11	    ret
1: /t $rax = 1111111111111111111111111111111111111111111111111111111100
# 表示される値が 1111111111111111111111111111111111111111111111111111111100000000, 111111111111111111111111111111111111111111111111111111110000000, 1111111111111111111111111111111111111111111111111111111100000, 1111111111111111111111111111111111111111111111111111111100 なら成功
</code></pre>
</details>
<h3 id="rol-ror-rcl-rcr-ローテート"><a class="header" href="#rol-ror-rcl-rcr-ローテート"><code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code>: ローテート</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left</td><td>左ローテート</td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left through carry</td><td>CFを含めて左ローテート</td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right</td><td>右ローテート</td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right through carry</td><td>CFを含めて右ローテート</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>r/m</em></td><td><code>rolq %rax</code></td><td><code>%rax</code>を1ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rolq $2, %rax</code></td><td><code>%rax</code>を2ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rolq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>r/m</em></td><td><code>rclq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rclq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rclq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>r/m</em></td><td><code>rorq %rax</code></td><td><code>%rax</code>を1ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rorq $2, %rax</code></td><td><code>%rax</code>を2ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rorq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>r/m</em></td><td><code>rcrq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rcrq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rcrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<img src="figs/rotate.svg" height="330px" id="fig:rotate">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li>ローテートは，シフトではみ出したビットを空いた場所に入れます．</li>
<li>ローテートする方向(右か左)，CFを含めるか否かで，4パターンの命令が存在します．</li>
</ul>
<details>
<summary>
rol-1.sの実行例
</summary>
<pre><code>$ gcc -g rol-1.s
$ gdb ./a.out -x rol-1.txt
Breakpoint 1, main () at rol-1.s:8
8	    rolq %rax
1: /t $rax = 11111111
9	    rolq $2, %rax
1: /t $rax = 111111110
10	    rolq %cl, %rax
1: /t $rax = 11111111000
main () at rol-1.s:11
11	    ret
1: /t $rax = 11111111000000
# 表示される値が 11111111, 111111110, 11111111000, 11111111000000 なら成功
</code></pre>
</details>
<details>
<summary>
rcl-1.sの実行例
</summary>
<pre><code>$ gcc -g rcl-1.s
$ gdb ./a.out -x rcl-1.txt
Breakpoint 1, main () at rcl-1.s:10
10	    rclq %rax
1: /t $rax = 11111111
11	    rclq $2, %rax
1: /t $rax = 111111111
12	    rclq %cl, %rax
1: /t $rax = 11111111100
main () at rcl-1.s:13
13	    ret
1: /t $rax = 11111111100000
# 表示される値が 11111111, 111111111, 11111111100, 11111111100000 なら成功
</code></pre>
</details>
<details>
<summary>
ror.sの実行例
</summary>
<pre><code>$ gcc -g ror.s
$ gdb ./a.out -x ror.txt
Breakpoint 1, main () at ror-1.s:8
8	    rorq %rax
1: /t $rax = 11111111
9	    rorq $2, %rax
1: /t $rax = 1000000000000000000000000000000000000000000000000000000001111111
10	    rorq %cl, %rax
1: /t $rax = 1110000000000000000000000000000000000000000000000000000000011111
main () at ror-1.s:11
11	    ret
1: /t $rax = 1111110000000000000000000000000000000000000000000000000000000011
# 表示される値が 11111111, 1000000000000000000000000000000000000000000000000000000001111111, 1110000000000000000000000000000000000000000000000000000000011111, 1111110000000000000000000000000000000000000000000000000000000011 なら成功
</code></pre>
</details>
<details>
<summary>
rcr-1.sの実行例
</summary>
<pre><code>$ gcc -g rcr-1.s
$ gdb ./a.out -x rcr-1.txt
Breakpoint 1, main () at rcr-1.s:10
10	    rcrq %rax
1: /t $rax = 11111010
11	    rcrq $2, %rax
1: /t $rax = 1000000000000000000000000000000000000000000000000000000001111101
12	    rcrq %cl, %rax
1: /t $rax = 1010000000000000000000000000000000000000000000000000000000011111
main () at rcr-1.s:13
13	    ret
1: /t $rax = 1101010000000000000000000000000000000000000000000000000000000011
# 表示される値が 11111010, 1000000000000000000000000000000000000000000000000000000001111101, 1010000000000000000000000000000000000000000000000000000000011111, 1101010000000000000000000000000000000000000000000000000000000011 なら成功
</code></pre>
</details>
<h3 id="cmp-test-比較"><a class="header" href="#cmp-test-比較"><code>cmp</code>, <code>test</code>: 比較</a></h3>
<h4 id="cmp命令"><a class="header" href="#cmp命令"><code>cmp</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>sub</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>cmpq $999, %rax</code></td><td><code>subq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpq %rax, (%rsp)</code></td><td><code>subq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>cmpq (%rsp), %rax</code></td><td><code>subq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<details>
<summary>
cmp-1.sの実行例
</summary>
<pre><code>$ gcc -g cmp-1.s
$ gdb ./a.out -x cmp-1.txt
reakpoint 1, main () at cmp-1.s:8
8	    cmpq $1, %rax       # %rax (=0) - 1
9	    cmpq %rax, (%rsp)   # (%rsp) (=1) - %rax (=0)
1: $eflags = [ CF PF AF SF IF ]
10	    cmpq (%rsp), %rax   # %rax (=0) - (%rsp) (=1)
1: $eflags = [ IF ]
main () at cmp-1.s:11
11	    ret
1: $eflags = [ CF PF AF SF IF ]
# 表示されるステータスフラグが以下なら成功
# 1: $eflags = [ CF PF AF SF IF ] (SF==1 → 結果は負)
# 1: $eflags = [ IF ]             (SF==0 → 結果は0か正)
# 1: $eflags = [ CF PF AF SF IF ] (SF==1 → 結果は負)
</code></pre>
</details>
<h4 id="test命令"><a class="header" href="#test命令"><code>test</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>logical compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>and</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>testq $999, %rax</code></td><td><code>andq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>testq %rax, (%rsp)</code></td><td><code>andq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>testq (%rsp), %rax</code></td><td><code>andq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令と同様に，<code>test</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令と同様に，<code>test</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が0ならジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">testq %rax, %rax
jz L2
</code></pre>
<ul>
<li>例えば<code>%rax</code>が0かどうかを知りたい場合，
<code>cmpq $0, %rax</code>と<code>testq %rax, %rax</code>のどちらでも調べることができます．
どちらの場合も，ZF==1なら，<code>%rax</code>が0と分かります
(<code>testq %rax, %rax</code>はビットごとのANDのフラグ変化を計算するので，
<code>%rax</code>がゼロの時だけ，ZF==1となります)．
コンパイラは<code>testq %rax, %rax</code>を使うことが多いです．
<code>testq %rax, %rax</code>の方が命令長が短くなるからです．</li>
</ul>
<details>
<summary>
test-1.sの実行例
</summary>
<pre><code>$ gcc -g test-1.s
$ gdb ./a.out -x test-1.txt
Breakpoint 1, main () at test-1.s:8
8	    testq $0, %rax       # %rax (=1) &amp; 0
9	    testq %rax, (%rsp)   # (%rsp) (=1) &amp; %rax (=1)
1: $eflags = [ PF ZF IF ]
10	    testq (%rsp), %rax   # %rax (=1) &amp; (%rsp) (=1)
1: $eflags = [ IF ]
main () at test-1.s:11
11	    ret
1: $eflags = [ IF ]
# 表示されるステータスフラグが以下なら成功
# 1: $eflags = [ PF ZF IF ] (ZF==1 → 結果は0)
# 1: $eflags = [ IF ]       (ZF==0 → 結果は非0)
# 1: $eflags = [ IF ]       (ZF==0 → 結果は非0)
</code></pre>
</details>
<h3 id="movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張"><a class="header" href="#movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張"><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code>命令: 符号拡張とゼロ拡張</a></h3>
<h4 id="movs-movz"><a class="header" href="#movs-movz"><code>movs</code>, <code>movz</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movsx</code> <em>op2</em>, <em>op1</em> </br> <code>movsxd</code> <em>op2</em>, <em>op1</em></td><td>move with sign-extention</td><td><em>op1</em>を符号拡張した値を<em>op2</em>に格納</td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movzx</code> <em>op2</em>, <em>op1</em></td><td>move with zero-extention</td><td><em>op1</em>をゼロ拡張した値を<em>op2</em>に格納</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movslq %eax, %rbx</code></td><td><code>%rbx</code> = <code>%eax</code>を8バイトに符号拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movzwq %ax, %rbx</code></td><td><code>%rbx</code> = <code>%ax</code>を8バイトにゼロ拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><code>␣␣</code>に入るもの</th><th>何の略か</th><th>意味</th></tr></thead><tbody>
<tr><td><code>bw</code></td><td>byte to word</td><td>1バイト→2バイトの拡張</td></tr>
<tr><td><code>bl</code></td><td>byte to long</td><td>1バイト→4バイトの拡張</td></tr>
<tr><td><code>bq</code></td><td>byte to quad</td><td>1バイト→8バイトの拡張</td></tr>
<tr><td><code>wl</code></td><td>word to long</td><td>2バイト→4バイトの拡張</td></tr>
<tr><td><code>wq</code></td><td>word to quad</td><td>2バイト→8バイトの拡張</td></tr>
<tr><td><code>lq</code></td><td>long to quad</td><td>4バイト→8バイトの拡張</td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>movs</code>, <code>movz</code>命令はAT&amp;T形式とIntel形式でニモニックが異なるので注意です．</li>
<li>GNUアセンブラではAT&amp;T形式でも実は<code>movsx</code>, <code>movzx</code>のニモニックが使用できます．
ただし逆アセンブルすると，<code>movslq</code>, <code>movzwq</code>などのニモニックが表示されるので，
<code>movslq</code>, <code>movzwq</code>などを使う方が良いでしょう．</li>
<li><code>movzlq</code> (Intel形式では<code>movzxd</code>)はありません．例えば，<code>%eax</code>に値を入れると，
<code>%rax</code>の上位32ビットは<a href="./x86-list.html#zero-upper32">クリア</a>されるので，
<code>movzlq</code>は不要だからです．</li>
<li>Intel形式では，4バイト→8バイトの拡張の時だけ，
(<code>movsx</code>ではなく)<code>movsxd</code>を使います．</li>
</ul>
<details>
<summary>
movs-movz.sの実行例
</summary>
<pre><code>$ gcc -g movs-movz.s
$ gdb ./a.out -x movs-movz.txt
Breakpoint 1, main () at movs-movz.s:7
7	    movslq %eax, %rbx
8	    movzwq %ax, %rbx
1: /x $rbx = 0xffffffffffffffff
main () at movs-movz.s:9
9	    ret
1: /x $rbx = 0xffff
# 以下が表示されれば成功
# 1: /x $rbx = 0xffffffffffffffff
# 1: /x $rbx = 0xffff
</code></pre>
</details>
<h4 id="cbtw-cqto命令"><a class="header" href="#cbtw-cqto命令"><code>cbtw</code>, <code>cqto</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>c␣t␣</code></strong></td><td><code>c␣␣␣</code></td><td>convert ␣ to ␣</td><td><code>%rax</code> (または<code>%eax</code>, <code>%ax</code>, <code>%al</code>)を符号拡張</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a><br/>(AT&amp;T形式)</th><th>詳しい記法<br/>(Intel形式)</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cbtw</code></strong></td><td><code>cbw</code></td><td><code>cbtw</code></td><td><code>%al</code>(byte)を<code>%ax</code>(word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtl</code></strong></td><td><code>cwde</code></td><td><code>cwtl</code></td><td><code>%ax</code>(word)を<code>%eax</code>(long)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtd</code></strong></td><td><code>cwd</code></td><td><code>cwtd</code></td><td><code>%ax</code>(word)を<code>%dx:%ax</code>(double word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltd</code></strong></td><td><code>cdq</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%edx:%eax</code>(double long, quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltq</code></strong></td><td><code>cdqe</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%rax</code>(quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cqto</code></strong></td><td><code>cqo</code></td><td><code>cqto</code></td><td><code>%rax</code>(quad)を<code>%rdx:%rax</code>(octuple)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cqto</code>などは<code>idiv</code>で割り算する前に使うと便利(<code>%rdx:%rax</code>が<code>idiv</code>の隠しオペランドなので)．</li>
<li>GNUアセンブラはIntel形式のニモニックも受け付ける．</li>
</ul>
<details>
<summary>
cbtw.sの実行例
</summary>
<pre><code>$ gcc -g cbtw.s
$ gdb ./a.out -x cbtw.txt
Breakpoint 1, main () at cbtw.s:7
7	    cbtw   # %al -&gt; %ax
9	    cwtl   # %ax -&gt; %eax
$1 = -1
$2 = 0xffff
11	    cwtd   # %ax -&gt; %dx:%ax
$3 = -1
$4 = 0xffffffff
13	    cltd   # %eax -&gt; %edx:%eax
$5 = {-1, -1}
$6 = {0xffff, 0xffff}
15	    cltq   # %eax -&gt; %rax
$7 = {-1, -1}
$8 = {0xffffffff, 0xffffffff}
17	    cqto   # %rax -&gt; %rdx:%rax
$9 = -1
$10 = 0xffffffffffffffff
main () at cbtw.s:19
19	    ret
$11 = {-1, -1}
$12 = {0xffffffffffffffff, 0xffffffffffffffff}
# 以下が表示されれば成功
# $1 = -1
# $2 = 0xffff
# $3 = -1
# $4 = 0xffffffff
# $5 = {-1, -1}
# $6 = {0xffff, 0xffff}
# $7 = {-1, -1}
# $8 = {0xffffffff, 0xffffffff}
# $9 = -1
# $10 = 0xffffffffffffffff
# $11 = {-1, -1}
# $12 = {0xffffffffffffffff, 0xffffffffffffffff}
</code></pre>
</details>
<h2 id="ジャンプ命令"><a class="header" href="#ジャンプ命令">ジャンプ命令</a></h2>
<ul>
<li><strong>ジャンプ</strong>とは「次に実行する命令を(『次の番地の命令』ではなく)
『別の番地の命令』にすることです．
ジャンプの仕組みは簡単で「ジャンプ先のアドレスをプログラムカウンタ
<code>%rip</code>に代入する」だけです．
C言語風に書くと<code>%rip = ジャンプ先のアドレス</code>となります
(ジャンプ先が相対アドレスで与えられた場合は，
<code>%rip += 相対アドレス</code>になります)．</li>
<li><strong>無条件ジャンプ</strong>はC言語の<code>goto</code>文と同じで常にジャンプします．
<strong>条件付きジャンプ</strong>は条件が成り立った時だけジャンプします．
条件付きジャンプをC言語風に書くと<code>if (条件) goto ジャンプ先;</code>になります．</li>
</ul>
<h3 id="abs-rel-jump"><a class="header" href="#abs-rel-jump">絶対ジャンプと相対ジャンプ</a></h3>
<img src="figs/abs-rel-jump.svg" height="250px" id="fig:abs-rel-jump">
<ul>
<li><strong>絶対ジャンプ</strong> (absolute jump)は<strong>絶対アドレス</strong>，
つまりメモリの先頭からのオフセットでジャンプ先のアドレスを指定するジャンプです．
上の例で，AからBにジャンプする時，<code>jmp 0x1000</code>は絶対ジャンプになります．</li>
<li><strong>相対ジャンプ</strong> (relative jump)は
プログラムカウンタ<code>%rip</code>を起点とする<strong>相対アドレス</strong>で
ジャンプ先のアドレスを指定するジャンプです．
上の例で，AからBにジャンプする時，<code>jmp -0x500</code>は相対ジャンプになります．
(プログラムカウンタは「次に実行する命令を指すレジスタ」なので，
正確には「Aの一つ前の命令からBにジャンプする時」になります)．</li>
</ul>
<h3 id="dir-indir-jump"><a class="header" href="#dir-indir-jump">直接ジャンプと間接ジャンプ</a></h3>
<img src="figs/direct-indirect-jump.svg" height="350px" id="fig:direct-indirect-jump">
<ul>
<li>
<p><strong>直接ジャンプ</strong> (direct jump)はジャンプ先のアドレスを
<strong>即値</strong> (<strong>定数</strong>)で指定するジャンプです．
上の例で一番左の<code>jmp 0x1000</code>は直接ジャンプです．</p>
</li>
<li>
<p><strong>間接ジャンプ</strong> (indirect jump)はジャンプ先のアドレスを
<strong>レジスタ</strong>や<strong>メモリ</strong>で指定して，その中に格納されている値を
ジャンプ先のアドレスとするジャンプです．</p>
<ul>
<li>上の例で真ん中の<code>jmp *%rax</code>は<strong>レジスタ</strong>を使った間接ジャンプです．
レジスタ中のアドレス (ここでは<code>0x1000</code>番地)にジャンプします．
(なぜアスタリスク<code>*</code>が必要なのかは謎です．GNUアセンブラの記法です．)</li>
<li>上の例で一番右の<code>jmp *(%rax)</code>は<strong>メモリ参照</strong>を使った間接ジャンプです．
メモリ中のアドレス (ここでは<code>0x1000</code>番地)にジャンプします．</li>
</ul>
</li>
</ul>
<h3 id="jmp-無条件ジャンプ"><a class="header" href="#jmp-無条件ジャンプ"><code>jmp</code>: 無条件ジャンプ</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>jmp</code></strong> <em>op1</em></td><td>jump</td><td><em>op1</em>にジャンプ</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`jmp`** *rel8*| `jmp 0x1000` | `0x1000`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *rel32*| `jmp foo` | `foo`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *%rax` | `*%rax`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *(%rax)` | `*(%rax)`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>jmp</code></strong> <em>rel</em></td><td><code>jmp 0x1000</code></td><td><code>0x1000</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += 0x1000</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><code>jmp foo</code></td><td><code>foo</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += foo</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *%rax</code></td><td><code>*%rax</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *(%rax)</code></td><td><code>*(%rax)</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *(%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
</tbody></table>
</div>
---
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64では，相対・直接と絶対・間接の組み合わせしかありません．
(つまり，相対・間接ジャンプや絶対・直接ジャンプはありません．
なお，ここで紹介していないfarジャンプでは絶対・直接もあります)．</li>
<li>相対・直接ジャンプでは符号ありの8ビット(<em>rel8</em>)か
32ビット(<em>rel32</em>)の整数定数で相対アドレスを指定します．
(64ビットの相対アドレスは指定できません．64ビットのジャンプをしたい時は
絶対・間接ジャンプ命令を使います)．</li>
<li><em>rel8</em>か<em>rel32</em>かはアセンブラが勝手に選んでくれます．
逆に<code>jmpb</code>や<code>jmpl</code>などとサフィックスをつけて指定することはできません．</li>
<li>なぜか，定数なのに<em>rel8</em>や<em>rel32</em>にはドルマーク<code>$</code>をつけません．
逆に<em>r/m</em>の前にはアスタリスク<code>*</code>が必要です．
GNUアセンブラのこの部分は一貫性がないので要注意です．</li>
</ul>
<h3 id="条件付きジャンプの概要"><a class="header" href="#条件付きジャンプの概要">条件付きジャンプの概要</a></h3>
<ul>
<li>条件付きジャンプ命令 <code>j␣</code>は
　ステータスフラグ (CF, OF, PF, SF, ZF)をチェックして，
条件が成り立てばジャンプします．
条件が成り立たない場合はジャンプせず，次の命令に実行を進めます．</li>
<li>条件付きジャンプは比較命令と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<ul>
<li>条件付きジャンプ命令のニモニックでは次の用語を使い分けます
<ul>
<li>符号あり整数の大小には less/greater を使う</li>
<li>符号なし整数の大小には above/below を使う</li>
</ul>
</li>
</ul>
<h3 id="条件付きジャンプ-符号あり整数用"><a class="header" href="#条件付きジャンプ-符号あり整数用">条件付きジャンプ: 符号あり整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em><br/> <strong><code>jnle</code></strong> <em>rel</em></td><td>jump if greater <br/> jump if not less nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==0&amp;&amp;SF==OF</code></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em><br/> <strong><code>jnl</code></strong> <em>rel</em></td><td>jump if greater or equal <br/> jump if not less</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF==OF</code></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em><br/> <strong><code>jng</code></strong> <em>rel</em></td><td>jump if less or equal <br/> jump if not greater</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==1||SF!=OF</code></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em><br/> <strong><code>jnge</code></strong> <em>rel</em></td><td>jump if less <br/> jump if not greater nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF!=OF</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jg foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jnle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnle foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jge foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jnl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnl foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jle foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jng</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jng foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jl foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
<tr><td><strong><code>jnge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnge foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jg</code>と<code>jnle</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==0&amp;&amp;SF==OF</code>と共通です．
他の3つのペア，<code>jge</code>と<code>jnl</code>，<code>jle</code>と<code>jng</code>，<code>jl</code>と<code>jnge</code>も同様です．</li>
</ul>
<details>
<summary>
なぜ ZF==0&&SF=OF が(符号ありの場合の)op2>op1になるのか
</summary>
<ul>
<li>復習: <code>cmp␣</code> <em>op1</em>, <em>op2</em>は (<em>op2</em> - <em>op1</em>)という引き算を計算した時の
フラグ変化を計算します．</li>
<li>①: OF==0(オーバーフロー無し)の場合:
<ul>
<li>SF==0 だと引き算の結果は0以上→ <em>op2</em> - <em>op1</em> &gt;= 0 → <em>op2</em> &gt;= <em>op1</em></li>
</ul>
</li>
<li>②: OF==1(オーバーフローあり)の場合:
<ul>
<li>結果の正負が逆になる．つまり SF==1 だと引き算の結果は負(OF==1で逆になるので正)→ <em>op2</em> - <em>op1</em> &gt;= 0 → <em>op2</em> &gt;= <em>op1</em></li>
</ul>
</li>
<li>③:  ①と②から，(OF==0&amp;&amp;SF==0)||(OF==1&amp;&amp;SF==1)なら，<em>op2</em> &gt;= <em>op1</em> になる．
(OF==0&amp;&amp;SF==0)||(OF==1&amp;&amp;SF==1)を簡単にすると OF==SF になる．</li>
<li>④: ③に ZF==0 (結果はゼロではない)という条件を加えると，
ZF==0&amp;&amp;SF=OF が <em>op2</em> &gt; <em>op1</em> と等価になる．</li>
</ul>
<img src="figs/of-sf.svg" height="250px" id="fig:of-sf">
<ul>
<li>上の例で，OF==1の時，引き算結果の大小関係(SF)が逆になることを見てみます．
<ul>
<li>(+64)-(-64)はオーバーフローが起きて，結果は-128になります(SF==1)．
引き算の結果は負ですが，大小関係は (+64) &gt; (-64) です(逆になってます)．</li>
<li>(-64)-(+65)はオーバーフローが起きて，結果は127になります(SF==0)．
引き算の結果は正ですが，大小関係は (-64) &lt; (+65) です(逆になってます)．</li>
</ul>
</li>
</ul>
</details>
<h3 id="条件付きジャンプ-符号なし整数用"><a class="header" href="#条件付きジャンプ-符号なし整数用">条件付きジャンプ: 符号なし整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em><br/> <strong><code>jnbe</code></strong> <em>rel</em></td><td>jump if above <br/> jump if not below nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0&amp;ZF==0</code></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em><br/> <strong><code>jnb</code></strong> <em>rel</em></td><td>jump if above or equal <br/> jump if not below</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em><br/> <strong><code>jna</code></strong> <em>rel</em></td><td>jump if below or equal <br/> jump if not above</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1&amp;&amp;ZF==1</code></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em><br/> <strong><code>jnae</code></strong> <em>rel</em></td><td>jump if below <br/> jump if not above nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>ja foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jnbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnbe foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jae foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jnb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnb foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jbe foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jna</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jna foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jb foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
<tr><td><strong><code>jnae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnae foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>ja</code>と<code>jnbe</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>CF==0&amp;&amp;ZF==0</code>と共通です．
他の3つのペア，<code>jae</code>と<code>jnb</code>，<code>jbe</code>と<code>jna</code>，<code>jb</code>と<code>jnae</code>も同様です．</li>
</ul>
<!--
### 条件付きジャンプ: カウンタ用
ほぼ使わないので割愛
-->
<h3 id="条件付きジャンプ-フラグ用"><a class="header" href="#条件付きジャンプ-フラグ用">条件付きジャンプ: フラグ用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td>jump if carry</td><td><code>CF==1</code>なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td>jump if not carry</td><td><code>CF==0</code>なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td>jump if overflow</td><td><code>OF==1</code>なら<em>rel</em>にジャンプ</td><td><code>OF==1</code></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td>jump if not overflow</td><td><code>OF==0</code>なら<em>rel</em>にジャンプ</td><td><code>OF==0</code></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td>jump if sign</td><td><code>SF==1</code>なら<em>rel</em>にジャンプ</td><td><code>SF==1</code></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td>jump if not sign</td><td><code>SF==0</code>なら<em>rel</em>にジャンプ</td><td><code>SF==0</code></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em> <br/> <strong><code>je</code></strong> <em>rel</em></td><td>jump if zero <br/> jump if equal</td><td><code>ZF==1</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>==<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==1</code></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em> <br/> <strong><code>jne</code></strong> <em>rel</em></td><td>jump if not zero <br/> jump if not equal</td><td><code>ZF==0</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>!=<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==0</code></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em> <br/> <strong><code>jpe</code></strong> <em>rel</em></td><td>jump if parity <br/> jump if parity even</td><td><code>PF==1</code>なら<em>rel</em>にジャンプ</td><td><code>PF==1</code></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em> <br/> <strong><code>jpo</code></strong> <em>rel</em></td><td>jump if not parity <br/> jump if parity odd</td><td><code>PF==0</code>なら<em>rel</em>にジャンプ</td><td><code>PF==0</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td><code>jc foo</code></td><td>if (<code>CF==1</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td><code>jnc foo</code></td><td>if (<code>CF==0</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td><code>jo foo</code></td><td>if (<code>OF==1</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td><code>jno foo</code></td><td>if (<code>OF==0</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td><code>js foo</code></td><td>if (<code>SF==1</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td><code>jns foo</code></td><td>if (<code>SF==0</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em></td><td><code>jz foo</code></td><td>if (<code>ZF==1</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>je</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>je foo</code></td><td>if (<code>%rax==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em></td><td><code>jnz foo</code></td><td>if (<code>ZF==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jne</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jne foo</code></td><td>if (<code>%rax!=0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em></td><td><code>jp foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpe</code></strong> <em>rel</em></td><td><code>jpe foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em></td><td><code>jnp foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpo</code></strong> <em>rel</em></td><td><code>jpo foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jz</code>と<code>je</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==1</code>と共通です．
他の3つのペア，<code>jnz</code>と<code>jne</code>，<code>jp</code>と<code>jpe</code>，<code>jnp</code>と<code>jpo</code>も同様です．</li>
<li>AFフラグのための条件付きジャンプ命令は存在しません．</li>
</ul>
<h3 id="call-return"><a class="header" href="#call-return"><code>call</code>, <code>ret</code>命令: 関数を呼び出す，リターンする</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>op1</em></td><td>call procedure</td><td><code>%rip</code>をスタックにプッシュしてから <em>op1</em>にジャンプする<br/> (<code>pushq %rip; %rip</code> = <em>op1</em>)</td></tr>
<tr><td><strong><code>ret</code></strong></td><td>return from procedure</td><td>スタックからポップしたアドレスにジャンプする <br/> (<code>popq %rip</code>)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>rel</em></td><td><code>call foo</code></td><td>相対・直接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>call</code></strong> <em>r/m</em></td><td><code>call *%rax</code></td><td>絶対・間接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>ret</code></strong></td><td><code>ret</code></td><td>関数からリターン</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<details>
<summary>
call.sの実行例
</summary>
<pre><code>$ gcc -g call.s
$ gdb ./a.out -x call.txt
reakpoint 1, main () at call.s:12
12	    call foo
1: /x $rip = 0x401107
# info address foo
Symbol &quot;foo&quot; is at ❶0x401106 in a file compiled without debugging.
Breakpoint 2 at 0x401106: file call.s, line 6.
❷Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106

❸Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106

❹Breakpoint 2, foo () at call.s:6
6	    ret
1: /x $rip = 0x401106
# 3回，関数fooを呼び出して，リターンできていれば成功
</code></pre>
<ul>
<li><code>info address foo</code>コマンドで，<code>foo</code>のアドレスは
<code>❶0x401106</code>番地と分かりました．</li>
<li>❷❸❹より3回，<code>foo</code>を呼び出せていることが分かります．</li>
</ul>
</details>
<blockquote>
<p>注: <strong>関数呼び出し規約</strong>(calling convention)，スタックレイアウトなどは
<a href="./3-binary.html#ABI">ABI</a>が定めるお約束です．
以下では<a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>に基づいて説明します．</p>
</blockquote>
<h4 id="return-address-stack"><a class="header" href="#return-address-stack">関数の呼び出しとリターンでは，<strong>戻り番地をスタックに積む</strong></a></h4>
<p>関数呼び出しとリターンには<strong>スタック</strong>を使います(スタック超重要)．
スタックは以下の図の通り，プロセスが使うメモリの一部の領域です．</p>
<img src="figs/memory-layout.svg" height="300px" id="fig:memory-layout">
<p>関数呼び出しにジャンプ命令(<code>jmp</code>)を使うと，
(一般的に呼び出す側は複数箇所なので)
リターン時に<strong>どこに戻ればよいかが分かりません</strong>．
そこで，戻る場所(<strong>戻り番地</strong> (return address))をスタックに保存しておきます．
<code>call</code>命令はこの「戻り番地をスタックに保存する」ことを自動的にやってくれます．
以下で具体例<code>call2.s</code>を見てみましょう．
<code>call2.s</code>では関数<code>main</code>から関数<code>foo</code>を<code>call</code>命令で呼び出して，
関数<code>foo</code>から関数<code>main</code>に<code>ret</code>命令でリターンしています．</p>
<pre><code class="language-x86asmatt"># asm/call2.s
    .text

    .type foo, @function
foo:
    ret
    .size foo, .-foo

    .globl main
    .type main, @function
main:
    call foo
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g -no-pie call2.s
$ objdump -d ./a.out
(中略)
0000000000401106 &lt;foo&gt;:
❷401106:	c3                   	ret    

0000000000401107 &lt;main&gt;:
  401107:	e8 fa ff ff ff       	call   401106 &lt;foo&gt;
❶40110c:	c3                   	ret    
</code></pre>
<p><code>-no-pie</code>オプションは
<a href="./3-binary.html#ASLR-PIE">実行するたびにアドレスが変わらない</a>ためにつけています．
<code>-no-pie</code>オプション無しでも仕組みは変わりません．</p>
<form class="tab-wrap">
    <input id="call1" type="radio" name="TAB" class="tab-switch" checked="checked" />
    <label class="tab-label" for="call1"><code>call foo</code>実行直前</label>
    <div class="tab-content">
    	 <img src="figs/call1.svg" height="300px" id="fig:call1">
    </div>
    <input id="call2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="call2"><code>call foo</code>実行直後</label>
    <div class="tab-content">
    	 <img src="figs/call2.svg" height="300px" id="fig:call2">
    </div>
    <input id="call3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="call3">関数<code>foo</code>の<code>ret</code>実行直後</label>
    <div class="tab-content">
    	 <img src="figs/call3.svg" height="300px" id="fig:call3">
    </div>
</form>
<ul>
<li>
<p><code>call foo</code>実行直前: 図(左)が示す通り<code>%rip</code>は<code>call foo</code>命令を指しています．
ここで，<code>call foo</code>命令を実行すると，</p>
<ul>
<li><code>%rip</code>は<code>call foo</code>命令の次の命令(ここでは<code>main</code>関数中の<code>ret</code>命令)を指します．
(<code>%rip</code>は「実行中の命令の<strong>次の命令</strong>」を指すことを思い出しましょう)．</li>
<li><code>call foo</code>はまず<code>%rip</code>の値(上図では❶<code>0x40110C</code>)をスタックにプッシュします．
その結果，スタック上に<code>0x40110C</code>が書き込まれます．
この<code>0x40110C</code>が(関数<code>foo</code>からリターンする際の)戻り番地となります．</li>
<li>次に，<code>call foo</code>は関数<code>foo</code>の先頭番地(上図では❷<code>0x401106</code>)にジャンプします．</li>
</ul>
</li>
<li>
<p><code>call foo</code>実行直後: 図(中)が示す通り<code>%rip</code>は<code>foo</code>関数の<code>ret</code>命令を指しています．
一方，スタックトップ(<code>%rsp</code>が指している場所)には
戻り番地<code>0x40110C</code>が格納されています．
ここで，<code>ret</code>命令を実行すると，</p>
<ul>
<li>スタックから戻り番地 <code>0x40110C</code>をポップして取り出して，
<code>%rip</code>に格納します(つまり<code>0x40110C</code>番地にジャンプします)．</li>
</ul>
</li>
<li>
<p>関数<code>foo</code>の<code>ret</code>実行直後:
無事に関数<code>main</code>の<code>call foo</code>命令の次の命令(ここでは<code>ret</code>命令ｌ)に戻ってこれました．</p>
</li>
</ul>
<p>このように戻り番地をスタックに格納すれば，(メモリ不足にならない限り)
どれだけ数多くの関数呼び出しが続いても，正しい順番でリターンすることができます．
戻り番地の格納にスタックを使えば，
「コールした順番とは逆の順序で戻りアドレスを取り出せる」からです．</p>
<img src="figs/call-stack.svg" height="200px" id="fig:call-stack">
<p>例えば，上図のようにA→B→C→Dという順番で関数コールをした場合，
上図の順番で「Aへの戻り番地」「Bへの戻り番地」「Cへの戻り番地」が
スタックに積まれます．
リターンするときはD→C→B→Aという逆の順番になるわけですが，
スタックを使っているので，
ポップするたびに「Cへの戻り番地」「Bへの戻り番地」「Aへの戻り番地」
という逆の順番で戻り番地を正しく取り出せます．</p>
<h4 id="c言語の関数ポインタと間接call命令"><a class="header" href="#c言語の関数ポインタと間接call命令">C言語の<strong>関数ポインタ</strong>と，間接<code>call</code>命令</a></h4>
<pre><code>// asm/fp.c
int add5 (int n)
{
    return n + 5;
}

int main ()
{
    int (*fp)(int n);
    fp = add5;
    return fp (10);
}
</code></pre>
<pre><code>$ gcc -g fp.c
$ objdump -d ./a.out
(中略)
000000000000113c &lt;main&gt;:
    113c:	f3 0f 1e fa          	endbr64 
    1140:	55                   	push   %rbp
    1141:	48 89 e5             	mov    %rsp,%rbp
    1144:	48 83 ec 10          	sub    $0x10,%rsp
    1148:	48 8d 05 da ff ff ff ❷ lea    -0x26(%rip),%rax        # 1129 &lt;add5&gt;
    114f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    1153:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1157:	bf 0a 00 00 00       	mov    $0xa,%edi
    115c:	ff d0                ❶ call   *%rax
    115e:	c9                   	leave  
    115f:	c3                   	ret    
</code></pre>
<ul>
<li>C言語で関数ポインタを使うと，間接<code>call</code>命令にコンパイルされます．
<code>asm/fp.c</code>中の</li>
</ul>
<pre><code>    int (*fp)(int n);
</code></pre>
<p>の部分は「『<code>int</code>型の引数をもらい，<code>int</code>型を返す関数』へのポインタを
格納する変数<code>fp</code>を定義しています．
そして，<code>fp = add5</code>と代入を行い，<code>fp (10)</code>することで，
関数ポインタを使って間接的に<code>add5</code>関数を呼び出しています．</p>
<ul>
<li>このCコードをコンパイルして逆アセンブルすると，
関数ポインタを使った関数呼び出しは，
間接<code>call</code>命令 (ここでは❶ call *%rax)になっていることが分かります．
<code>%rax</code>には関数<code>add5</code>の先頭アドレスが入っています
(ここでは ❷ <code>lea -0x26(%rip),%rax</code>を実行することで)．</li>
</ul>
<details>
<summary>
fp = add5 であってる?
</summary>
<p><code>fp = add5</code>ではなく<code>fp = &amp;add5</code>が正しいのでは?と思った人はいますか?
<code>fp = add5</code>で正しいです．
(<code>sizeof</code>や単項演算子<code>&amp;</code>のオペランドであるときを除いて)
式中では「<strong>関数</strong>は<strong>関数へのポインタ</strong>」に暗黙的に型変換されます．
ですので，式中で<code>add5</code>の型は「関数へのポインタ」になり，
<code>fp</code>と<code>add5</code>は同じ型になります
(<code>fp = &amp;add5</code>としても動くんですけどね)．</p>
<p><code>fp (10)</code>も同様です．「<code>fp</code>は関数へのポインタなのだから，
<code>(*fp) (10)</code>が正しいのでは?」と思うかも知れません．
でも，<code>fp (10)</code>で正しいです．
そもそも関数呼び出しの文法は「関数 ( 引数の列 )」ではなく，
「関数へのポインタ ( 引数の列 )」です．
<code>add5 (10)</code>の<code>add5</code>の型は<strong>関数へのポインタ</strong>なんです．
ちなみに<code>(*fp)(10)</code>としても動きます．
<code>(*fp)</code>は「関数へのポインタを関数」に戻しますが，その戻った関数型は
すぐに「関数型へのポインタ」に変換されるからです．
ですので，<code>(******fp)(10)</code>でも動きます．</p>
</details>
<h3 id="enter-leave命令-スタックフレームを作成する解放する"><a class="header" href="#enter-leave命令-スタックフレームを作成する解放する"><code>enter</code>, <code>leave</code>命令: スタックフレームを作成する，解放する</a></h3>
<h4 id="スタックフレーム"><a class="header" href="#スタックフレーム">スタックフレーム</a></h4>
<ul>
<li><a href="6-inst.html#return-address-stack">戻り番地はスタックに格納</a>しますが，
それ以外のデータ(例えば，局所変数，引数，返り値，退避したレジスタの値など)も
スタックを使います．</li>
<li>スタック上で管理する，<strong>関数呼び出し1回分のデータ</strong>のことを
<strong>スタックフレーム</strong> (stack frame)といいます．</li>
</ul>
<p>例えば，<code>main</code>関数が<code>add5</code>関数を呼び出して，<code>add5</code>からリターンすると以下の図になります．
スタックフレームにはいろいろなデータが入っていますが，
スタックフレームまるごとでプッシュしたりポップしたりします．
ですので，関数を呼び出したりリターンする時はこの
「スタックフレームをプッシュしたり，ポップしたり」，
つまり「スタックフレームを作成したり，破棄したり」する機械語命令列を
使う必要があります(以下で説明します)．</p>
<img src="figs/stack-frame.svg" height="200px" id="fig:stack-frame">
<p>そして<code>%rsp</code>と<code>%rbp</code>は以下の図のように，
<strong>スタック上の一番上のスタックフレームの上下</strong>を指す役割を担っています．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>
オプションでコンパイルされている場合を除く)．</p>
<img src="figs/stack-frame2.svg" height="200px" id="fig:stack-frame2">
<h4 id="enter-leave命令"><a class="header" href="#enter-leave命令"><code>enter</code>, <code>leave</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>op1</em>, <em>op2</em></td><td>make stack frame</td><td>サイズ<em>op1</em>のスタックフレームを作成する</td></tr>
<tr><td><strong><code>leave</code></strong></td><td>discard stack frame</td><td>今のスタックフレームを破棄する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>imm16</em>, <em>imm8</em></td><td><code>enter $0x20, $0</code></td><td><code>pushq %rbp</code><br/><code>movq %rsp, %rbp</code><br/><code>subq $0x20, %rsp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
<tr><td><strong><code>leave</code></strong></td><td><code>leave</code></td><td><code>movq %rbp, %rsp</code><br/><code>popq %rbp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>enter</code>命令の<em>op2</em>には関数のネストレベルを指定するのですが，
C言語では入れ子の関数がない(つまりネストレベルは常にゼロ)なので
常にゼロを指定します．</li>
<li>ただし，<code>enter</code>は遅いので通常は使いません．
代わりに同等の動作をする<code>pushq %rbp; movq %rsp, %rbp; subq $</code><em>size</em><code>, %rsp</code>を使います．(<em>size</em>は新しいスタックフレームで確保するバイトサイズです)．
スタックは0番地に向かって成長するので，足し算ではなく引き算を使います．</li>
</ul>
<details>
<summary>
enter命令はどのぐらい遅いのか(3〜4倍?)
</summary>
<pre><code>$ gcc -g rdtscp-enter.c
$ ./a.out
processor ID = 0
processor ID = 0
processor ID = 0
240966
60796
$ ./a.out
processor ID = 0
processor ID = 0
processor ID = 0
165718
46368
$ ./a.out
processor ID = 1
processor ID = 1
processor ID = 1
204346
49530
</code></pre>
<p>インラインアセンブラを使ったCプログラム<a href="./asm/rdtscp-enter.c"><code>rdtscp-enter.c</code></a>で，以下のコードを10000万回繰り返して，
タイムスタンプカウンタの差分を調べた所，
(単純な調べ方ですが)概ね3〜4倍という結果になりました．</p>
<pre><code># 遅い
asm volatile (&quot;enter $32, $0; leave&quot;);
</code></pre>
<pre><code># 速い
asm volatile ( &quot;pushq %rbp; movq %rsp, %rbp;&quot;
               &quot;subq $32, %rsp; leave&quot;);
</code></pre>
<p><code>leave</code>を入れないとスタックを使い切ってしまうので<code>leave</code>を入れています．
<code>leave</code>を除いて計測すればもうちょっと差が開くかも知れません．</p>
</details>
<p>というわけで，<code>enter</code>は遅いので，コンパイラが<code>enter</code>の代わりに出力する
機械語命令列で説明します．</p>
<pre><code class="language-x86asmatt"># asm/stack-frame.s
    .text
    .type foo, @function
foo:
    pushq %rbp
    movq %rsp, %rbp	
    subq $32, %rsp
    # 本来はここにfoo関数本体の機械語列が来る
    leave # movq %rbp, %rsp; pop %rbp と同じ
    ret

    .globl main
    .type main, @function
main:
    call foo
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g enter2.s
$ gdb ./a.out -x stack-frame.txt
</code></pre>
<form class="tab-wrap">
    <input id="stack-frame6-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame6-1"><code>call</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-1.svg" height="150px" id="fig:stack-frame6-1">
    </div>
    <input id="stack-frame6-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-2"><code>call</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-2.svg" height="150px" id="fig:stack-frame6-2">
    </div>
    <input id="stack-frame6-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-3"><code>pushq %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-3.svg" height="150px" id="fig:stack-frame6-3">
    </div>
    <input id="stack-frame6-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-4"><code>movq %rsp, %rbp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-4.svg" height="143px" id="fig:stack-frame6-4">
    </div>
    <input id="stack-frame6-5" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame6-5"><code>subq $32, %rsp</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame6-5.svg" height="220px" id="fig:stack-frame6-5">
    </div>
</form>
<ul>
<li>関数<code>foo</code>の最初の3行が「関数<code>foo</code>のスタックフレーム」を作ります．</li>
</ul>
<pre><code class="language-x86asmatt">    pushq %rbp
    movq %rsp, %rbp	
    subq $32, %rsp
</code></pre>
<ul>
<li><code>call</code>前: <code>%rsp</code>と<code>%rbp</code>は関数<code>main</code>のスタックフレームの上下を指しています．</li>
<li><code>call</code>後: <code>call</code>命令が戻り番地をプッシュしてから，
(図にはありませんが)関数<code>foo</code>にジャンプします．</li>
<li><code>pushq %rbp</code>後: スタックに<code>%rbpの値</code>(図中では古い<code>%rbp</code>の値)をプッシュします．
この値は<code>main</code>のスタックフレームの一番下を指しています．</li>
<li><code>movq %rsp, %rbp</code>後: <code>%rbp</code>の値をスタック上に退避した(保存した)ので，
<code>movq %rsp, %rbp</code>により，
<code>%rbp</code>が「関数<code>foo</code>のスタックフレームの一番下」を指すようにします．</li>
<li><code>subq $32, %rsp</code>により，<code>foo</code>のスタックフレームを確保しました．
これで<code>foo</code>のスタックフレームは完成です．
ここでは32バイト確保していますが，関数<code>foo</code>の中身によって適宜，増減します．</li>
</ul>
<form class="tab-wrap">
    <input id="stack-frame7-1" type="radio" name="TAB" class="tab-switch" checked="checked"/>
    <label class="tab-label" for="stack-frame7-1"><code>leave</code>前</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-1.svg" height="220px" id="fig:stack-frame7-1">
    </div>
    <input id="stack-frame7-2" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-2"><code>leave</code>前半(<code>movq %rbp, %rsp</code>)後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-2.svg" height="150px" id="fig:stack-frame7-2">
    </div>
    <input id="stack-frame7-3" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-3"><code>leave</code>後半(<code>popq %rbp</code>)後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-3.svg" height="150px" id="fig:stack-frame7-3">
    </div>
    <input id="stack-frame7-4" type="radio" name="TAB" class="tab-switch" />
    <label class="tab-label" for="stack-frame7-4"><code>ret</code>後</label>
    <div class="tab-content">
    	 <img src="figs/stack-frame7-4.svg" height="143px" id="fig:stack-frame7-4">
    </div>
</form>
<ul>
<li>関数<code>foo</code>の最後の2行(<code>leave</code>と<code>ret</code>)が
「関数<code>foo</code>のスタックフレーム」を破棄します．
<code>leave</code>命令は<code>movq %rbp, %rsp; popq %rbp</code>と同じ動作をします．</li>
</ul>
<pre><code class="language-x86asmatt">    leave
    ret
</code></pre>
<ul>
<li><code>leave</code>前: <code>%rsp</code>と<code>%rbp</code>が関数<code>foo</code>のスタックフレームの上下を指しています．</li>
<li><code>leave</code>前半(<code>movq %rbp, %rsp</code>)後:
<code>%rsp</code>が関数<code>foo</code>のスタックフレームの一番下を指します．</li>
<li><code>leave</code>後半(<code>popq %rbp</code>)後:
退避しておいた「古い<code>%rbp</code>」をポップして<code>%rbp</code>に格納することで，
<code>%rbp</code>は関数<code>main</code>のスタックフレームの一番下を指します．</li>
<li><code>ret</code>後:
スタックトップに戻り番地がある状態に戻ったので，
<code>ret</code>命令で関数<code>foo</code>から<code>main</code>にリターンします．
<code>ret</code>命令はスタックからポップして戻り番地を取り出すので，
スタック上から戻り番地が無くなります．
これでスタックは関数<code>foo</code>を呼び出す前と同じ状態に戻りました．
<code>%rsp</code>と<code>%rbp</code>は関数<code>main</code>のスタックフレームの上下を指しています．</li>
</ul>
<h3 id="caller-callee-save-regs"><a class="header" href="#caller-callee-save-regs">caller-saveレジスタとcallee-saveレジスタ</a></h3>
<ul>
<li>レジスタの数は限られているので，必要に応じて，
レジスタの値はスタック上に退避(保存)する必要があります．</li>
<li>その保存の仕方で，レジスタは <strong>caller-saveレジスタ</strong>と<strong>callee-saveレジスタ</strong>に分類されます．これを以下で説明します．</li>
</ul>
<h4 id="calleeとcaller"><a class="header" href="#calleeとcaller">calleeとcaller</a></h4>
<img src="figs/caller-callee.svg" height="100px" id="fig:caller-callee">
<p>関数Aが関数Bを呼び出す時，</p>
<ul>
<li>関数Aを<strong>caller</strong>(呼び出す側)，</li>
<li>関数Bを<strong>callee</strong>(呼び出される側)，といいます．</li>
</ul>
<p>雇用者を employer，被雇用者(雇われてる人)を employee って呼ぶのと同じ言い方ですね．
デバッグする側(debugger)，デバッグされる側(debuggee)，
テストする側(tester)，テストされる側(testee)という言い方もあります．</p>
<h4 id="レジスタ退避と回復"><a class="header" href="#レジスタ退避と回復">レジスタ退避と回復</a></h4>
<ul>
<li>関数呼び出しで，レジスタの退避と回復が必要になることが良くあります．
レジスタの数が有限でごく少ないからです．</li>
<li>レジスタの退避・回復のやり方は大きく2種類あります：
<ul>
<li>caller側で退避・回復: caller側でレジスタのプッシュとポップを行う</li>
<li>callee側で退避・回復: callee側でレジスタのプッシュとポップを行う</li>
</ul>
</li>
</ul>
<img src="figs/caller-callee-reg.svg" height="150px" id="fig:caller-callee-reg">
<h4 id="linuxのabiでの-caller-saveレジスタとcallee-saveレジスタ"><a class="header" href="#linuxのabiでの-caller-saveレジスタとcallee-saveレジスタ"><a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>での caller-saveレジスタとcallee-saveレジスタ</a></h4>
<p>レジスタの退避と回復は，caller側でもcallee側でもできますが，
レジスタごとにどちらでやるかを決めておくと便利です．</p>
<ul>
<li>caller側で退避・回復を行うレジスタを<strong>caller-saveレジスタ</strong>と呼びます</li>
<li>callee側で退避・回復を行うレジスタを<strong>callee-saveレジスタ</strong>と呼びます</li>
</ul>
<p><a href="https://wiki.osdev.org/System_V_ABI">LinuxのABI</a>では
以下のように，caller-saveレジスタとcallee-saveレジスタが決まっています．</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<p><code>%rsp</code>のcallee側での退避・回復には，
プッシュやポップを使いませんが，
「caller側にリターンする前に元に戻す，という約束をcallee側は守る(責任がある)」
という意味で，<code>%rsp</code>もcallee-saveレジスタになります．</p>
<h3 id="関数規約"><a class="header" href="#関数規約">関数呼び出し規約 (calling convention)</a></h3>
<p><strong>関数呼び出し規約</strong> (calling convention)は
ABIが定める「callerとcalle間のお約束」です．例えば，</p>
<ul>
<li>引数の渡し方 (スタック渡しかレジスタ渡しか)</li>
<li>スタックフレームのレイアウト (どこに何を置くか)</li>
<li>レジスタの役割</li>
<li><a href="./6-inst.html#caller-callee-save-regs">caller-saveレジスタとcallee-saveレジスタ</a></li>
<li>アラインメント</li>
</ul>
<h4 id="arg-reg"><a class="header" href="#arg-reg">引数の渡し方</a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<ul>
<li>第1引数〜第6引数は上記の通り，レジスタを介して渡します</li>
<li>第7引数以降はレジスタではなくスタックを介して渡します</li>
</ul>
<h4 id="スタックレイアウト"><a class="header" href="#スタックレイアウト">スタックレイアウト</a></h4>
<img src="figs/stack-layout2.svg" height="400px" id="fig:stack-layout2">
<ul>
<li>上図は典型的なスタックレイアウトです．</li>
<li>局所変数と第7以降の引数はスタック上に置きます．
スタック上の局所変数や引数は<code>%rbp</code>を使ってアクセスします．
例えば，上図ではメモリ参照<code>-16(%rbp)</code>は局所変数2，
メモリ参照<code>24(%rbp)</code>は第8引数への参照になります．
<code>%rbp</code>を使う理由は，
これらの絶対アドレスがコンパイル時に決まりませんが，
<code>%rbp</code>に対する相対アドレスはコンパイル時に決まるからです．
(<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>オプションが
指定された場合は，<code>%rbp</code>ではなく<code>%rsp</code>を使ってアクセスします)．</li>
<li>スタックに置く局所変数や引数が8バイト未満の場合は
<a href="4-data.html#alignment">アラインメント制約</a>を満たすために，
隙間(パディング)を入れる必要があることがあります．</li>
</ul>
<h4 id="register-role"><a class="header" href="#register-role">レジスタの役割</a></h4>
<ul>
<li><code>%rsp</code>と<code>%rbp</code>は一番上のスタックフレームの上下を指します
(<a href="./2-asm-intro.html#-fomit-frame-pointer"><code>-fomit-frame-pointer</code></a>オプションが
指定されていなければ)．</li>
<li>(8バイト以下の整数であれば)返り値は<code>%rax</code>に入れて返します．</li>
<li>可変長引数の関数(例えば <code>printf</code>)を呼び出す時は，
呼び出す前に
<code>%al</code>に「使用するベクタレジスタ(例えば<code>%xmm0</code>)の数」を入れます．</li>
</ul>
<h4 id="レッドゾーン-redzone"><a class="header" href="#レッドゾーン-redzone">レッドゾーン (redzone)</a></h4>
<img src="figs/redzone.svg" height="300px" id="fig:redzone">
<ul>
<li><a href="./2-asm-intro.html#redzone"><strong>レッドゾーン</strong></a>は
<code>%rsp</code>レジスタの上，128バイトの領域のことです．
この領域には好きに読み書きして良いことになっています．</li>
</ul>
<h4 id="alignment-rsp"><a class="header" href="#alignment-rsp">アラインメント制約</a></h4>
<ul>
<li><code>call</code>命令実行時に<code>%rsp</code>レジスタは16バイト境界を満たす，
つまり<code>%rsp</code>の値が16の倍数である必要があります．
これを守らないとプログラムが<strong>クラッシュすることがある</strong>ので要注意です</li>
</ul>
<h4 id="prologue"><a class="header" href="#prologue">関数プロローグとエピローグ</a></h4>
<img src="figs/func-prologue.svg" height="300px" id="fig:func-prologue">
<ul>
<li>関数本体実行前に準備を行うコードを<strong>関数プロローグ</strong>(function prologue)，
関数本体実行後に後片付けを行うコードを<strong>関数エピローグ</strong>(function epilogue)
といいます．</li>
<li>上図は典型的な関数プロローグとエピローグです．
<ul>
<li>関数プロローグでは，スタックフレームの作成，
callee-saveレジスタの退避(必要があれば)，
(局所変数や引数のために必要な)スタックフレーム上での領域の確保，
などを行います．</li>
<li>関数エピローグでは，概ね，関数プロローグの逆を行います．
callee-saveレジスタの回復の順番も，退避のときと逆になっている点に注意して下さい
(退避の時は<code>%rbx</code>→<code>%r12</code>，回復の時は逆順で<code>%r12</code>→<code>%rbx</code>)．</li>
</ul>
</li>
<li>コンパイラに<code>-O2</code>などの最適化オプションを指定すると，
不要な命令が削られたり移動するため，プロローグとエピローグの内容が
大きく変わることがあります．</li>
</ul>
<h3 id="cコードからアセンブリコードを呼び出す"><a class="header" href="#cコードからアセンブリコードを呼び出す">Cコードからアセンブリコードを呼び出す</a></h3>
<pre><code>// asm/mix1/main.c
#include &lt;stdio.h&gt;
int sub (int, int);
int main (void)
{
    printf (&quot;%d\n&quot;, sub (23, 7));
}

</code></pre>
<pre><code class="language-x86asmatt"># asm/mix1/sub.s
    .text
    .globl sub
    .type sub, @function
sub:
    pushq %rbp
    movq  %rsp, %rbp
    subq  %rsi, %rdi
    movq  %rdi, %rax
    leave
    ret
    .size sub, .-sub
</code></pre>
<pre><code>$ gcc -g main.c sub.s
$ ./a.out
16
</code></pre>
<ul>
<li><a href="./6-inst.html#%E9%96%A2%E6%95%B0%E8%A6%8F%E7%B4%84">関数規約</a>が守られていれば，
Cからアセンブリコードの関数を呼び出したり，
アセンブリコードからCの関数を呼び出すことができます．</li>
<li>上の例では関数<code>main</code>から，アセンブリコード中の関数<code>sub</code>を呼び出しています．</li>
</ul>
<h3 id="アセンブリコードからcコードを呼び出す"><a class="header" href="#アセンブリコードからcコードを呼び出す">アセンブリコードからCコードを呼び出す</a></h3>
<pre><code class="language-x86asmatt"># asm/mix2/main.s
    .text
    .globl main
    .type sub, @function
main:
    pushq %rbp
    movq %rsp, %rbp
    movq $23,  %rdi
    movq $7,   %rsi
    call sub
    leave
    ret
    .size main, .-main
</code></pre>
<pre><code>// asm/mix2/sub.c
int sub (int a, int b)
{
    return a - b;
}
</code></pre>
<pre><code>$ gcc -g main.s sub.c
$ ./a.out
$ echo $?
16
</code></pre>
<ul>
<li>上の例ではアセンブリコードからCの関数を呼び出しています．
関数<code>sub</code>の計算結果をここでは<strong>終了ステータス</strong>として表示しています．
関数<code>sub</code>が計算結果を<code>%rax</code>に入れて返した後，
関数<code>main</code>が<code>%rax</code>を壊さず終了したので，
引き算の結果がそのまま終了ステータスになっています．</li>
<li>終了ステータスの値は関数<code>main</code>が<code>return</code>した値，または<code>exit</code>の引数に渡した値です．
ただし，下位1バイトしか受け取れないので，終了ステータスの値は0から255までになります．</li>
</ul>
<h3 id="アセンブリコードからprintfを呼び出す"><a class="header" href="#アセンブリコードからprintfを呼び出す">アセンブリコードから<code>printf</code>を呼び出す</a></h3>
<pre><code class="language-x86asmatt"># asm/printf.s
    .section .rodata
L_fmt:
    .string &quot;%d\n&quot;

    .text
    .globl main
    .type sub, @function
main:
    pushq %rbp
    movq  %rsp, %rbp
    leaq  L_fmt(%rip), %rdi
    movq  $999,  %rsi
#    pushq $888   # ❶このコメントを外すと segmentation fault になることも
    movb  $0, %al # ❷
    call  printf
    leave
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g printf.s
$ ./a.out
999
</code></pre>
<ul>
<li>アセンブリコードから<code>printf</code>などのライブラリ関数を呼び出せます．</li>
<li><code>call</code>命令実行時には<code>%rsp</code>の値は16の倍数で無くてはいけません
(<a href="./6-inst.html#alignment-rsp"><code>%rsp</code>のアラインメント制約</a>)．
なので，❶の行のコメントを外して実行すると，segmentation fault
が起きることがあります(起きないこともありますが，それはたまたまです)．
❶の行のコメントを外さなければ，
「戻り番地の8バイトと古い<code>rbp</code>の値の8バイト」でちょうど16バイトが積まれて，
<code>%rsp</code>の値は16の倍数になります．</li>
<li><code>printf</code>は可変長引数を持つ関数なので，呼び出し前に
<code>%al</code>にベクトルレジスタ(例 <code>%xmm0</code>)の数を<a href="./6-inst.html#register-role">入れておく必要</a>があります
(ここではベクトルレジスタを使っていないのでゼロに設定)．</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 7; }
</style>
<h1 id="アセンブラ命令"><a class="header" href="#アセンブラ命令">アセンブラ命令</a></h1>
<h3 id="アセンブラとアセンブラ命令"><a class="header" href="#アセンブラとアセンブラ命令">アセンブラとアセンブラ命令</a></h3>
<ul>
<li><strong>アセンブラ</strong> (assembler)はアセンブリコード (<code>foo.s</code>)を
オブジェクトファイル (<code>foo.o</code>)に変換するプログラムです．
<ul>
<li>例えば，<code>gcc -c foo.s</code>とするとアセンブルできます．
<code>gcc -c</code>は内部で<code>as</code>コマンドを呼んでいて，これがアセンブラ本体です．
(<code>gcc</code>に<code>-v</code>オプションを付けると，<code>as</code>コマンドの実行が見えます)．</li>
</ul>
</li>
<li><strong>アセンブラ命令</strong> (assembler directive)はアセンブラへの指示です．
<ul>
<li>例えば，<code>.text</code>はアセンブラに「出力先を<code>.text</code>セクションに切り替えろ」と
指示しています．</li>
<li>GNUアセンブラのアセンブラ命令は<strong>すべてドット</strong><code>.</code>で始まります．</li>
</ul>
</li>
<li>アセンブラ命令はCPUが実行しない命令なので，
<strong>疑似命令</strong>(psuedo instruction)とも呼ばれます．
(が，分かりにくい用語なので本書では使いません)．</li>
</ul>
<h3 id="アセンブラ命令と機械語命令"><a class="header" href="#アセンブラ命令と機械語命令">アセンブラ命令と機械語命令</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>例</th><th>何が実行</th><th>いつ実行</th><th>バイナリファイル中に</th></tr></thead><tbody>
<tr><td>アセンブラ命令</td><td><code>.text</code></td><td>アセンブラ</td><td>アセンブル時</td><td>残らない</td></tr>
<tr><td>機械語命令</td><td><code>addl $5, %eax</code></td><td>CPU</td><td><code>a.out</code>実行時</td><td>残る</td></tr>
</tbody></table>
</div><img src="figs/add5-2.svg" height="200px" id="fig:add5-2">
<ul>
<li>アセンブラがアセンブリコード(<code>*.s</code>)からオブジェクトファイル(<code>*.o</code>)を作る際に，
<ul>
<li>アセンブラ命令(例: <code>.text</code>)に従って処理をします．例えば，<code>addl $5, %eax</code>を
バイト列に変換した結果 <code>0x83 0xC0 0x05</code>を<code>.text</code>セクションに出力します．</li>
<li>その結果，アセンブラ命令 <code>.text</code>はオブジェクトファイルには残りません．
(オブジェクトファイル中に<code>.text</code>セクションはありますが，
これはアセンブラ命令<code>.text</code>ではありません)．</li>
</ul>
</li>
<li>一方，機械語命令 <code>addl $5, %eax</code>はオブジェクトファイルに残っています
(バイト列 <code>0x83 0xC0 0x05</code>と見た目は変わっていますが)．
<code>a.out</code>を実行したときに，CPUがこの機械語命令を実行します．</li>
</ul>
<h2 id="アセンブラの主な仕事"><a class="header" href="#アセンブラの主な仕事">アセンブラの主な仕事</a></h2>
<h3 id="概要-1"><a class="header" href="#概要-1">概要</a></h3>
<p>アセンブラの主なお仕事は大きく次の4つです．</p>
<ul>
<li>
<p>機械語命令やデータを<a href="./4-data.html">2進数表現に変換</a>する</p>
<ul>
<li>例: <code>pushq %rax</code> を <code>0x50</code> に変換する</li>
<li>例: <code>.string &quot;%d\n&quot;</code> を <code>0x25 0x64 0x0A 0x00</code>に変換する
(<code>.string</code>は自動的に<strong>ヌル文字</strong> <code>0x00</code>を最後に付加します)</li>
<li>アセンブラにとって，機械語命令もデータも
「2進数にして出力する」という意味で，どちらも単なるデータです．</li>
</ul>
</li>
<li>
<p>変換した2進数を指定された<strong>セクション</strong>に出力する</p>
<ul>
<li>アセンブラは各セクションごとに<strong>ロケーションカウンタ</strong> (location counter)
を持っています．ロケーションカウンタは「機械語命令やデータを次に出力する際の
アドレス」です．
<code>.align 8</code>は「次に出力するアドレスを8の倍数にする(次の出力を8バイト境界にする)」というアセンブラ命令ですが，
ロケーションカウンタという言葉を使うと
「ロケーションカウンタを8の倍数になるように増やす」と言い換えられます．</li>
</ul>
</li>
<li>
<p><strong>記号表</strong> (symbol table)を作って，ラベルをアドレスに変換する</p>
</li>
<li>
<p>最後に変換したデータをバイナリ形式(LinuxではELF形式)にしてファイル出力する</p>
</li>
</ul>
<h3 id="セクションへの出力"><a class="header" href="#セクションへの出力">セクションへの出力</a></h3>
<h4 id="セクションとは"><a class="header" href="#セクションとは">セクションとは</a></h4>
<p>バイナリファイルの構造はざっくり以下の図のようになっています．</p>
<img src="figs/section.svg" height="250px" id="fig:text-binary">
<ul>
<li>基本的に，バイナリ (オブジェクトファイル<code>*.o</code>や実行可能ファイル<code>a.out</code>)は
<strong>セクション</strong> (section)という単位で区切られていて，それぞれ別の目的でデータが格納されます．</li>
<li><strong>ヘッダ</strong> (header)は目次の役割で「どこにどんなセクションがあるか」という情報を保持しています．</li>
</ul>
<h4 id="代表的なセクション"><a class="header" href="#代表的なセクション">代表的なセクション</a></h4>
<div class="table-wrapper"><table><thead><tr><th>セクション名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>.text</code></td><td>機械語命令(例：<code>pushq %rbp</code>)を置くセクション</td></tr>
<tr><td><code>.data</code></td><td>初期化済みの静的変数の値(例：<code>0x1234</code>)を置くセクション</td></tr>
<tr><td><code>.bss</code></td><td>未初期化(実行時に0で初期化する)の静的変数の値を置くセクション</td></tr>
<tr><td><code>.rodata</code></td><td>読み込みのみ(read only)の値(例：<code>&quot;hello\n&quot;</code>)を置くセクション</td></tr>
</tbody></table>
</div>
<h4 id="各セクションに出力する例"><a class="header" href="#各セクションに出力する例">各セクションに出力する例</a></h4>
<p>例えば，以下のアセンブリコード<code>foo.s</code>があるとします
(<code>.rodata</code>セクションを指定する際は，<code>.section</code>が必要です)．</p>
<pre><code class="language-x86asmatt"># foo.s
.text            # .textセクションに出力せよ
pushq %rbp
movq %rsp, %rbp
.data            # .dataセクションに出力せよ
.long 0x11223344
.section .rodata # .rodataセクションに出力せよ
.string &quot;hello\n&quot;
</code></pre>
<img src="figs/section2.svg" height="200px" id="fig:section2">
<p>この<code>foo.s</code>をアセンブラが処理すると以下になります．</p>
<ul>
<li><code>pushq %rbp</code>を2進数にすると <code>0x55</code>，
<code>movq %rsp, %rbp</code>を2進数にすると <code>0x48 0x89 0xe5</code> なので，
これら合計4バイトを<code>.text</code>セクションに出力します．</li>
<li><code>.data</code>は「<code>.data</code>セクションに出力せよ」
「<code>.long</code>は指定したデータを4バイトの2進数として出力せよ」という意味です．
<code>0x11223344</code>を2進数にすると <code>0x44 0x33 0x22 0x11</code>なので
これら4バイトを<code>.data</code>セクションに出力します．
(出力が逆順になっているように見えるのは
x86-64が<a href="./3-binary.html#%E3%83%AA%E3%83%88%E3%83%AB%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3">リトルエンディアン</a>だからです．)</li>
<li><code>.section .rodata</code>は「<code>.rodata</code>セクションに出力せよ」
「<code>.string</code>は指定した文字列をASCIIコードの2進数として出力せよ」という意味です．
<code>&quot;hello\n&quot;</code>を2進数にすると <code>0x68 0x65 0x6c 0x6c 0x64 0x0a 0x00</code>なので，
これら7バイトを<code>.rodata</code>セクションに出力します．
(最後の'\0'はヌル文字です．C言語では文字列定数の最後に自動的に
ヌル文字が追加されますが，アセンブリ言語では必ずしもそうではありません．
<code>.string</code>はヌル文字を自動的に追加します．
一方，(ここでは使っていませんが)<code>.ascii</code>はヌル文字を自動的に追加しません)．
ASCIIコードは<code>man ascii</code>で確認できます．</li>
</ul>
<h4 id="セクションを確認する"><a class="header" href="#セクションを確認する">セクションを確認する</a></h4>
<ul>
<li>
<p>セクションの内容は<code>objdump -h</code>や<code>readelf -S</code>コマンドで表示できます．</p>
</li>
<li>
<p><code>objdump -h</code> の例と読み方</p>
</li>
</ul>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ objdump -h add5.o
add5.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000013  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000053  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000053  2**0
                  ALLOC
<span class="boring">  3 .debug_info   00000066  0000000000000000  0000000000000000  00000053  2**0
</span><span class="boring">                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  4 .debug_abbrev 0000004d  0000000000000000  0000000000000000  000000b9  2**0
</span><span class="boring">                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  5 .debug_aranges 00000030  0000000000000000  0000000000000000  00000106  2**0
</span><span class="boring">                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  6 .debug_line   0000004f  0000000000000000  0000000000000000  00000136  2**0
</span><span class="boring">                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  7 .debug_str    00000093  0000000000000000  0000000000000000  00000185  2**0
</span><span class="boring">                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  8 .debug_line_str 00000089  0000000000000000  0000000000000000  00000218  2**0
</span><span class="boring">                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span><span class="boring">  9 .comment      0000002c  0000000000000000  0000000000000000  000002a1  2**0
</span><span class="boring">                  CONTENTS, READONLY
</span><span class="boring"> 10 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000002cd  2**0
</span><span class="boring">                  CONTENTS, READONLY
</span><span class="boring"> 11 .note.gnu.property 00000020  0000000000000000  0000000000000000  000002d0  2**3
</span><span class="boring">                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span class="boring"> 12 .eh_frame     00000038  0000000000000000  0000000000000000  000002f0  2**3
</span><span class="boring">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
</span></code></pre>
<div class="table-wrapper"><table><thead><tr><th>欄</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td>Idx</td><td>1</td><td>セクションの通し番号</td></tr>
<tr><td>Name</td><td><code>.text</code></td><td>セクションの名前</td></tr>
<tr><td>Size</td><td><code>00000013</code></td><td>セクションのサイズ (16進数，バイト)</td></tr>
<tr><td>VMA</td><td><code>00000000</code></td><td>実行時のセクションのアドレス (virtual memory address, 16進数)</td></tr>
<tr><td>LMA</td><td><code>00000000</code></td><td>ロード時のセクションのアドレス (load memory address, 16進数)</td></tr>
<tr><td>File Off</td><td><code>00000040</code></td><td>ファイルオフセット(16進数，バイト)</td></tr>
<tr><td>Algn</td><td><code>2**0</code></td><td>セクションのアラインメント制約(バイト), <code>2**n</code>は\(2^n\)を意味</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>説明</th></tr></thead><tbody>
<tr><td>CONTENTS</td><td>このセクションには中身がある(つまり中身が空のセクションもある)</td></tr>
<tr><td>ALLOC</td><td>ロード時にこのセクションのためにメモリを割り当てる必要がある</td></tr>
<tr><td>LOAD</td><td>このセクションは実行するためにメモリ上にロードする必要がある</td></tr>
<tr><td>READONLY</td><td>メモリ上では「読み込みのみ許可(書き込み禁止)」と設定する必要がある</td></tr>
<tr><td>CODE</td><td>このセクションは実行可能な機械語命令を含んでいる</td></tr>
<tr><td>RELOC</td><td>このセクションは再配置情報を含んでいる</td></tr>
</tbody></table>
</div>
<ul>
<li><code>readelf -S</code> の例と読み方</li>
</ul>
<pre><code class="language-bash">$ gcc -g -c add5.c
$ readelf -S add5.o
There are 21 section headers, starting at offset 0x640:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000013  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000053
       0000000000000000  0000000000000000  WA       0     0     1
<span class="boring">  [ 4] .debug_info       PROGBITS         0000000000000000  00000053
</span><span class="boring">       0000000000000066  0000000000000000           0     0     1
</span><span class="boring">  [ 5] .rela.debug_info  RELA             0000000000000000  00000410
</span><span class="boring">       00000000000000c0  0000000000000018   I      18     4     8
</span><span class="boring">  [ 6] .debug_abbrev     PROGBITS         0000000000000000  000000b9
</span><span class="boring">       000000000000004d  0000000000000000           0     0     1
</span><span class="boring">  [ 7] .debug_aranges    PROGBITS         0000000000000000  00000106
</span><span class="boring">       0000000000000030  0000000000000000           0     0     1
</span><span class="boring">  [ 8] .rela.debug_[...] RELA             0000000000000000  000004d0
</span><span class="boring">       0000000000000030  0000000000000018   I      18     7     8
</span><span class="boring">  [ 9] .debug_line       PROGBITS         0000000000000000  00000136
</span><span class="boring">       000000000000004f  0000000000000000           0     0     1
</span><span class="boring">  [10] .rela.debug_line  RELA             0000000000000000  00000500
</span><span class="boring">       0000000000000060  0000000000000018   I      18     9     8
</span><span class="boring">  [11] .debug_str        PROGBITS         0000000000000000  00000185
</span><span class="boring">       0000000000000093  0000000000000001  MS       0     0     1
</span><span class="boring">  [12] .debug_line_str   PROGBITS         0000000000000000  00000218
</span><span class="boring">       0000000000000089  0000000000000001  MS       0     0     1
</span><span class="boring">  [13] .comment          PROGBITS         0000000000000000  000002a1
</span><span class="boring">       000000000000002c  0000000000000001  MS       0     0     1
</span><span class="boring">  [14] .note.GNU-stack   PROGBITS         0000000000000000  000002cd
</span><span class="boring">       0000000000000000  0000000000000000           0     0     1
</span><span class="boring">  [15] .note.gnu.pr[...] NOTE             0000000000000000  000002d0
</span><span class="boring">       0000000000000020  0000000000000000   A       0     0     8
</span><span class="boring">  [16] .eh_frame         PROGBITS         0000000000000000  000002f0
</span><span class="boring">       0000000000000038  0000000000000000   A       0     0     8
</span><span class="boring">  [17] .rela.eh_frame    RELA             0000000000000000  00000560
</span><span class="boring">       0000000000000018  0000000000000018   I      18    16     8
</span><span class="boring">  [18] .symtab           SYMTAB           0000000000000000  00000328
</span><span class="boring">       00000000000000d8  0000000000000018          19     8     8
</span><span class="boring">  [19] .strtab           STRTAB           0000000000000000  00000400
</span><span class="boring">       000000000000000d  0000000000000000           0     0     1
</span><span class="boring">  [20] .shstrtab         STRTAB           0000000000000000  00000578
</span><span class="boring">       00000000000000c6  0000000000000000           0     0     1
</span><span class="boring">Key to Flags:
</span><span class="boring">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
</span><span class="boring">  L (link order), O (extra OS processing required), G (group), T (TLS),
</span><span class="boring">  C (compressed), x (unknown), o (OS specific), E (exclude),
</span><span class="boring">  D (mbind), l (large), p (processor specific)
</span></code></pre>
<div class="table-wrapper"><table><thead><tr><th>欄</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td>[Nr]</td><td>[1]</td><td>セクションの通し番号</td></tr>
<tr><td>Name</td><td><code>.text</code></td><td>セクションの名前</td></tr>
<tr><td>Type</td><td><code>PROGBITS</code></td><td>セクションのタイプ (以下参照)</td></tr>
<tr><td>Address</td><td><code>0000000000000000</code></td><td>セクションのアドレス</td></tr>
<tr><td>Offset</td><td><code>00000040</code></td><td>ファイルオフセット(16進数，バイト)</td></tr>
<tr><td>Size</td><td><code>0000000000000013</code></td><td>セクションのサイズ (16進数，バイト)</td></tr>
<tr><td>EntSize</td><td><code>0000000000000000</code></td><td>表中の固定長のエントリのサイズ (エントリがない場合は0)</td></tr>
<tr><td>Flags</td><td><code>AX</code></td><td>セクションのフラグ (以下参照)</td></tr>
<tr><td>Link</td><td><code>0</code></td><td>関連するセクションの通し番号([Nr]) (存在しない場合は0)</td></tr>
<tr><td>Info</td><td><code>0</code></td><td>関連情報 (ない場合は0)</td></tr>
<tr><td>Align</td><td><code>1</code></td><td>セクションのアラインメント制約(バイト)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>セクションのタイプ</th><th>説明</th></tr></thead><tbody>
<tr><td>NULL</td><td>このセクションは使われていない</td></tr>
<tr><td>PROGBITS</td><td>このセクションはプログラムがフォーマットと意味を決める情報を含む</td></tr>
<tr><td>NOBITS</td><td>未初期化の領域を含む (ファイル中ではサイズゼロ)</td></tr>
<tr><td>RELA</td><td>このセクションは再配置情報を含む (調整用の値(addend)を含む)</td></tr>
<tr><td>NOTE</td><td>言語処理系が定義・使用するメモ書き</td></tr>
<tr><td>SYMTAB</td><td>このセクションは記号表 (symbol table)</td></tr>
<tr><td>STRTAB</td><td>このセクションは文字列表 (string table)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>フラグ</th><th>説明</th></tr></thead><tbody>
<tr><td>W (write)</td><td>このセクションは実行時に書き込み可能にしておく必要がある</td></tr>
<tr><td>A (alloc)</td><td>ロード時にこのセクションのためにメモリを割り当てる必要がある</td></tr>
<tr><td>X (execute)</td><td>このセクションは実行可能な機械語命令を含む</td></tr>
<tr><td>M (merge)</td><td>このセクション中のデータは重複を避けるためにマージ可能</td></tr>
<tr><td>S (strings)</td><td>このセクションはヌル終端の文字列を含む</td></tr>
<tr><td>I (info)</td><td>このセクションはセクションのタイプに依存した付加情報を保持してる</td></tr>
<tr><td>L (link order)</td><td>このセクションはリンカに対して特別な順序を要求する</td></tr>
<tr><td>O (extra OS processing required)</td><td>このセクションはOS固有の特別な処理が必要である</td></tr>
<tr><td>G (group)</td><td>このセクションはセクショングループのメンバーである</td></tr>
<tr><td>T (TLS)</td><td>このセクションはスレッドローカルストレージを持つ</td></tr>
<tr><td>C (compressed)</td><td>このセクションの内容は圧縮されている (AやNOBITSとの併用はNG)</td></tr>
<tr><td>x (unknown)</td><td>このセクションは不明なセクションである</td></tr>
<tr><td>o (OS specific)</td><td>OS固有の意味を持つ</td></tr>
<tr><td>E (exclude)</td><td>このセクションは参照もメモリ割り当てもされなければ削除される</td></tr>
<tr><td>D (mbind)</td><td>このセクションは特別なメモリ領域に置く必要がある．Infoがそのメモリタイプを示す</td></tr>
<tr><td>l (large)</td><td>このセクションは(2GB以上の)largeコードモデルである</td></tr>
<tr><td>p (processor specific)</td><td>プロセッサ固有の意味を持つ</td></tr>
</tbody></table>
</div>
<ul>
<li><code>readelf -t</code> で，より詳細なセクション情報を表示可能</li>
<li><code>readelf -n</code>で<code>NOTE</code>セクションの内容を表示可能</li>
</ul>
<h3 id="記号表とアドレスへの変換"><a class="header" href="#記号表とアドレスへの変換">記号表とアドレスへの変換</a></h3>
<pre><code class="language-x86asmatt"># sym-main.s
	.text
	.globl	main
	.type	main, @function
main:
	movl	x(%rip), %eax # ラベル x の参照
	ret
	.size	main, .-main
</code></pre>
<pre><code class="language-x86asmatt"># sym-sub.s
	.globl	x
	.data
	.align 4
	.type	x, @object
	.size	x, 4
x:                     # ラベル x の定義
	.long	999
</code></pre>
<pre><code>$ gcc -c sym-main.s
$ gcc -c sym-sub.s
$ gcc sym-main.o sym-sub.o
$ nm sym-main.o
0000000000000000 T main
              ❶ U x
$ nm sym-sub.o
❷ 0000000000000000 D x 
$ nm a.out | egrep ' x'
❸ 0000000000004010 D x

$ objdump -D ./a.out
0000000000001129 &lt;main&gt;:
    1129: 8b 05 e1 2e 00 00    	mov  ❹ 0x2ee1(%rip),%eax  # 4010 &lt;x&gt;
 ❻ 112f: c3                   	ret    
(中略)
0000000000004010 &lt;x&gt;:
 ❺ 4010: e7 03                 out    %eax,$0x3
$ bc
obase=16
ibase=16
4010-112F
❼ 2EE1
</code></pre>
<ul>
<li><strong>アセンブラは記号表を作り</strong>，ラベルを見つけるたびに記号表に加えます．
記号表はリンク時にも使うので，アセンブラは記号表をオブジェクトファイルに埋め込みます．
最終的に，記号表の情報を使って，<strong>ラベルをアドレスに変換</strong>します．</li>
<li>例えば，上記の例ではラベル<code>x</code>を記号表で管理して，最終的にアドレス<code>0x4010</code>に変換しています．
<ul>
<li><code>sym-main.s</code>の <code>movl x(%rip), %eax</code> ではラベル<code>x</code>が登場するので，
記号表に加えられます．<code>sym-main.s</code>中には定義が無いので，
<code>nm</code>コマンドで記号表を見ると「<code>x</code>は未定義 (<code>❶ U x</code>)」となっています．</li>
<li>一方，<code>sym-sub.s</code>中にラベル<code>x</code>の定義があるので，
<code>nm</code>で調べると，「<code>x</code>の(仮の)アドレスは0番地 ❷」と表示されます．</li>
<li><code>sym-main.o</code>と<code>sym-sub.o</code>をリンクした<code>a.out</code>を調べると，
「<code>x</code>のアドレスは0x4010番地 ❸」となってます．</li>
<li><code>objdump -D</code>で(<code>.data</code>セクションも含めて)逆アセンブルすると，
<code>x</code>のアドレスは確かに❹<code>0x4010</code>番地となっていて，
<code>movl x(%rip), %eax</code>中のラベル<code>x</code>は相対アドレス❹<code>0x2EE1</code>に
なっています(❺ 0x4010 - ❻ 0x112F = ❼ 0x2EE1)．</li>
</ul>
</li>
</ul>
<h3 id="バイナリ形式として出力"><a class="header" href="#バイナリ形式として出力">バイナリ形式として出力</a></h3>
<ul>
<li>ここまでの処理で，アセンブラはセクション別に2進数のバイト列を生成しています．</li>
<li>アセンブラはこれらのバイト列を<strong>バイナリ形式</strong>のフォーマットに従って
ファイルに出力します．</li>
<li>本書の範囲ではバイナリ形式の詳細を知る必要はありませんが，
以下でELFバイナリ形式の全体の構造だけ説明します．
この知識がないと<code>readelf</code>コマンドを使う際に「ヘッダが3種類ある」と混乱するからです．</li>
</ul>
<h4 id="elfバイナリ形式の構造"><a class="header" href="#elfバイナリ形式の構造">ELFバイナリ形式の構造</a></h4>
<ul>
<li>ELFには3種類のヘッダがあります</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>ヘッダの種類</th><th>表示コマンド</th><th>説明</th></tr></thead><tbody>
<tr><td>ELFヘッダ</td><td><code>readelf -h</code></td><td>ELFファイル全体の目次とメタ情報．必ずファイル先頭に存在</td></tr>
<tr><td>セクションヘッダ</td><td><code>readelf -S</code></td><td>セクションの目次</td></tr>
<tr><td>プログラムヘッダ</td><td><code>readelf -l</code></td><td>セグメントの目次</td></tr>
</tbody></table>
</div><br/>
<img src="figs/elf-header.svg" height="400px" id="fig:elf-header">
<ul>
<li><strong>ELFのセクション</strong>はリンクのための処理の単位です．</li>
<li><strong>ELFのセグメント</strong>は複数のセクションが1つになったもので，
実行時にメモリにロードするための処理の単位です．
<ul>
<li>セクションと区別するために，「セグメント」という異なる名前が付いているがかえって紛らわしい．</li>
</ul>
</li>
<li>ELFヘッダ以外は，配置する場所や順番に決まりはないです．
(セクションヘッダは(ヘッダという名前なのに)ファイルの最後に配置されることが多いです)．
セクションヘッダとプログラムヘッダの位置(オフセット)は
ELFヘッダ中に書かれています．</li>
</ul>
<details>
<summary>
ELFとDWARF
</summary>
<p>バイナリ形式 ELF は executable linkage format の略です．
「北欧神話でおなじみのエルフ(ELF)と来ればドワーフ(DWARF)も欲しいでしょ」
というダジャレで，
(元々はELF形式のために)DWARFという名前のデバッグ情報形式が生まれたようです．</p>
</details>
<h2 id="gas-syntax"><a class="header" href="#gas-syntax">GNUアセンブラの文法</a></h2>
<h3 id="文"><a class="header" href="#文">文</a></h3>
<img src="figs/gas-stmt.svg" height="120px" id="fig:gas-stmt">
<ul>
<li>
<p>GNUアセンブラの<strong>文</strong>(statement)はアセンブリコードの構成要素であり，
上記の6つのいずれもが1つの文になります．</p>
</li>
<li>
<p>文は改行かセミコロン<code>;</code>で区切ります．</p>
<ul>
<li>
<p>セミコロンで区切れば，複数の文を1行に書いて良いです．
以下はどちらでもOKです</p>
<pre><code class="language-x86asmatt">pushq %rbp
movq %rsp, %rbp
</code></pre>
<pre><code class="language-x86asmatt">pushq %rbp; movq %rsp, %rbp
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="コメント"><a class="header" href="#コメント">コメント</a></h3>
<ul>
<li>
<p>GNUアセンブラのコメントは(C言語と同様に)プログラムのメモ書きです．
アセンブラは単に無視します．</p>
</li>
<li>
<p>行コメント: シャープ記号<code>#</code>から行末までがコメントになります</p>
<pre><code class="language-x86asmatt"># これは行コメントです
</code></pre>
<blockquote>
<p>注: 行コメントに使う記号はアーキテクチャ依存です．
例えば，x86-64は<code>#</code>ですが，ARMは<code>@</code>，H8は<code>;</code>，SPARCは<code>!</code>です．</p>
</blockquote>
</li>
<li>
<p>ブロックコメント: C言語と同じで<code>/*</code>から<code>*/</code>までがコメントです．
C言語と同様にブロックは入れ子禁止です(ブロックコメントの中にブロックコメントは書けません)</p>
<pre><code class="language-x86asmatt">/* これはブロックコメントです．
   複数行でもOKです           */
</code></pre>
</li>
<li>
<p>入れ子のコメントを書くには，C前処理命令 <code>#if 0</code>と<code>#endif</code>を使います．</p>
<ul>
<li>ただし，ファイル拡張子を(大文字の)<code>.S</code>にする必要があります．</li>
<li>拡張子を<code>.S</code>にするとC前処理が実行されるので，<code>#define</code>や<code>#include</code>も使えます．</li>
</ul>
<pre><code>#if 0
これはC前処理命令を使ったコメントです．
これは入れ子にできます．
#endif
</code></pre>
</li>
</ul>
<h3 id="定数"><a class="header" href="#定数">定数</a></h3>
<div class="table-wrapper"><table><thead><tr><th>種類</th><th>説明</th><th>例</th></tr></thead><tbody>
<tr><td>10進数定数</td><td><code>0</code>で始まらない</td><td><code>pushq $74</code></td></tr>
<tr><td>16進数定数</td><td><code>0x</code>か<code>0X</code>で始まる</td><td><code>pushq $0x4A</code></td></tr>
<tr><td>8進数定数</td><td><code>0</code>で始まる</td><td><code>pushq $0112</code></td></tr>
<tr><td>2進数定数</td><td><code>0b</code>か<code>0B</code>で始まる</td><td><code>pushq $0b01001010</code></td></tr>
<tr><td rowspan="3">文字定数</td><td><code>'</code>(クオート)で始まる</td><td><code>pushq $'J</code></td></tr>
<tr><td><code>'</code>(クオート)で囲む</td><td><code>pushq $'J'</code></td></tr>
<tr><td><code>\</code>バックスラッシュ<br/>でエスケープ可</td><td><code>pushq $'\n</code></td></tr>
<tr><td>文字列定数</td><td><code>"</code>(ダブルクオート)で囲む</td><td><code>.string "Hello\n"</code></td></tr>
</tbody></table>
</div>  
<ul>
<li>上の例の最初の4つの定数は全部，値が同じです</li>
<li>GNUアセンブラでは文字定数の値は<a href="./4-data.html#ASCII">ASCIIコード</a>です．
上の例では，文字<code>'J'</code>の値は<code>74</code>です．</li>
<li>バックスラッシュでエスケープできる文字は，
<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>,  <code>\&quot;</code>, <code>\\</code> です．
また<code>\123</code>は8進数，<code>\x4F</code>は16進数で指定した文字コードになります．</li>
<li>文字列定数では，<code>.string</code>と<code>.asciz</code>は自動的にヌル文字終端しますが，
<code>.ascii</code>はヌル文字終端しません(必要なら明示的に<code>\0</code>と書く必要があります)．
文字列定数は即値や変位には使えません．</li>
</ul>
<h3 id="式"><a class="header" href="#式">式</a></h3>
<pre><code class="language-x86asmatt">leaq main+10(%rip), %rax # 加算
movq $1&lt;&lt;12, %rax        # 左シフト
movq $1024*1024, %rax    # 乗算
</code></pre>
<ul>
<li>
<p>定数やラベルを書ける場所 (即値や変位)には<strong>式</strong>を書けます．</p>
</li>
<li>
<p>ただし，式には静的に(アセンブル時に)計算できるものだけが書けます．</p>
<ul>
<li>レジスタやメモリの値は参照できません．</li>
</ul>
</li>
<li>
<p>上の例では加算，左シフト，乗算を使った例です．</p>
</li>
<li>
<p>単項演算子</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>意味</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>2の補数による負数</td></tr>
<tr><td><code>~</code></td><td>ビットごとの反転 (1の補数)</td></tr>
</tbody></table>
</div>
<ul>
<li>2項演算子</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>意味</th></tr></thead><tbody>
<tr><td><code>*</code></td><td>乗算</td></tr>
<tr><td><code>/</code></td><td>除算</td></tr>
<tr><td><code>%</code></td><td>剰余</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>左シフト</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>右シフト</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>意味</th></tr></thead><tbody>
<tr><td><code>|</code></td><td>ビットOR</td></tr>
<tr><td><code>&amp;</code></td><td>ビットAND</td></tr>
<tr><td><code>^</code></td><td>ビットXOR</td></tr>
<tr><td><code>!</code></td><td>ビットOR NOT (a</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>意味</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>加算</td></tr>
<tr><td><code>-</code></td><td>減算</td></tr>
<tr><td><code>==</code></td><td>等しい</td></tr>
<tr><td><code>!=</code></td><td>等しくない</td></tr>
<tr><td><code>&lt;&gt;</code></td><td>等しくない</td></tr>
<tr><td><code>&lt;</code></td><td>小さい</td></tr>
<tr><td><code>&gt;</code></td><td>大きい</td></tr>
<tr><td><code>&lt;=</code></td><td>以下</td></tr>
<tr><td><code>&gt;=</code></td><td>以上</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>意味</th></tr></thead><tbody>
<tr><td><code>&amp;&amp;</code></td><td>論理AND</td></tr>
<tr><td><code>||</code></td><td>論理OR</td></tr>
</tbody></table>
</div>
<ul>
<li>一番上が最も優先度が高く，順番に下に行くほど優先度が下がります．</li>
<li>述語演算子は，真の時は<code>-1</code> (つまり全ビットが1)，負の時は<code>0</code> (つまり全ビットが0)を返します．</li>
<li>2023/9: <code>=</code>が入ってる演算子を使うと，
<code>foo.s:9: Error: invalid character '=' in operand 1</code>というエラーがでます．なぜなんだぜ</li>
</ul>
<h2 id="ラベルと識別子"><a class="header" href="#ラベルと識別子">ラベルと識別子</a></h2>
<!--
PICの場合，絶対アドレスを得る方法はないのか
(動的に LEA命令を使わず)

.quad main

とやればメモリには置ける．即値として得る方法は分からず．
GASで，ラベルの値を絶対・相対のどちらにするのか指定する方法はなさげ．
(文脈で，GASがどちらかにしてしまう)
-->
<h3 id="シンボル"><a class="header" href="#シンボル">シンボル</a></h3>
<ul>
<li><strong>シンボル</strong>はGNUアセンブラが使う<strong>一種の変数</strong>で，値を保持できます．</li>
<li>GNUアセンブラのシンボル名に使える文字は英語の大文字と小文字，数字，<code>_</code>，<code>$</code>，<code>.</code>です．
<ul>
<li>ただし，シンボル名は数字で始まってはいけません</li>
<li>大文字と小文字は区別します (case-sensitive)</li>
<li><code>$</code>と<code>.</code>は使わない方が良いでしょう (即値やアセンブラ命令と紛らわしいから)</li>
</ul>
</li>
<li>シンボルは主にラベルに使います．
<ul>
<li>ラベルはアセンブラが自動的にアドレスを割り当てます．つまり値がアドレスなシンボルがラベルです．</li>
</ul>
</li>
<li>アセンブラ命令 <code>.set</code> でシンボルの値をセットできます(あまり使いませんが)</li>
</ul>
<pre><code>.set x, 999  # シンボルxの値を999にする
</code></pre>
<h3 id="ラベル"><a class="header" href="#ラベル">ラベル</a></h3>
<ul>
<li>シンボルの直後にコロン<code>:</code>が来ると (例: <code>add5:</code>)，それはラベルの定義になります．</li>
<li>そのラベルの値は<code>add5:</code>を処理した時の<strong>ロケーションカウンタ</strong>
(次に出力するアドレス)になります．
つまり，アセンブラ  が自動的にラベルをアドレスに変換します．</li>
<li>変換するアドレスが絶対アドレスか相対アドレスかはGNUアセンブラが自動的に判断します (例: <code>leaq foo(%rip), %rax</code>の<code>foo</code>は相対アドレスになります)</li>
<li>ラベルは関数名や変数名などの<strong>識別子名</strong> (identifier)，ジャンプ先を表すために使います</li>
<li>アドレスを書ける場所 (即値や変位)にはラベルを書いて良い
(例: <code>movq %rax, foo (%rip)</code>)</li>
</ul>
<h3 id="ラベルのスコープ"><a class="header" href="#ラベルのスコープ">ラベルのスコープ</a></h3>
<ul>
<li>同じファイル中に同じラベル名があってはいけません(二重定義)．
グローバルではないラベルのスコープはそのファイル．</li>
</ul>
<pre><code class="language-x86asmatt">foo:
foo:  # 二重定義でNG
</code></pre>
<ul>
<li>グローバルなラベルは他のファイルに同じラベル名があってもいけません．
グローバルなラベルのスコープはリンクするファイルすべて．</li>
</ul>
<pre><code class="language-x86asmatt"># file1.s
.globl foo
foo:
</code></pre>
<pre><code class="language-x86asmatt"># file2.s
.globl foo
foo: # 二重定義でNG
</code></pre>
<ul>
<li>片方がweakなラベルなら二重定義でもOK
<ul>
<li>weakラベルと同名のラベルがあれば，(エラーなしで)weakではない方のラベルが使われる</li>
<li>weakラベルと同名のラベルがなければ，(エラーなしで)weakラベルが使われる</li>
<li>weakラベルは「他の定義に上書きされても良い，デフォルトの関数や変数」を定義するのに便利</li>
</ul>
</li>
</ul>
<pre><code class="language-x86asmatt"># file1.s
.globl foo
foo:
</code></pre>
<pre><code class="language-x86asmatt"># file3.s
.weak foo
.globl foo
foo: # OK (二重定義にならない)
</code></pre>
<ul>
<li>C言語でも変数や関数をweakにできる
<ul>
<li>GCC独自拡張機能である<code>__attribute__((weak))</code>を使う</li>
</ul>
</li>
</ul>
<pre><code>// weak-main.c
#include &lt;stdio.h&gt;
__attribute__((weak)) void foo ()
{
    printf (&quot;I am weak foo\n&quot;);
}
int main ()
{
    foo ();
}
</code></pre>
<pre><code>// weak-sub.c
#include &lt;stdio.h&gt;
void foo ()
{
    printf (&quot;I am non-weak foo\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g weak-main.c
$ ./a.out
I am weak foo
$ gcc -g weak-main.c weak-sub.c
$ ./a.out
I am non-weak foo
</code></pre>
<h3 id="記号表に含まれないラベル"><a class="header" href="#記号表に含まれないラベル">記号表に含まれないラベル</a></h3>
<pre><code>// label.s
.text
.global foo1
foo1:
foo2:
.Lfoo3:
</code></pre>
<pre><code>$ gcc -g -c label.s
$ nm label.o
0000000000000000 T foo1
0000000000000000 t foo2
</code></pre>
<ul>
<li>ELFバイナリの場合，<code>.L</code>で始まるラベルは記号表に含まれません．</li>
<li>コンパイラが出力するジャンプ先のラベルは<code>.L</code>で始まることが多いです
(例: <code>.LFB0</code>, <code>.LFE0</code>, <code>.L2</code>)．
ジャンプ先のラベルはデバッグ等に不要なことが多いからです．</li>
<li>上の例で<code>.Lfoo3</code>は記号表に含まれないため，<code>nm</code>コマンドで出力されませんでした．</li>
</ul>
<h3 id="dot-label"><a class="header" href="#dot-label">特別なドットラベル <code>.</code></a></h3>
<ul>
<li>
<p>ドット <code>.</code>は特別なラベルで，ロケーションカウンタ自身(つまり現在のアドレス)を指します．</p>
</li>
<li>
<p>例: <code>foo</code>の中身は<code>foo</code>のアドレスになります</p>
<pre><code class="language-x86asmatt">foo:
.quad .
</code></pre>
<pre><code class="language-x86asmatt">foo:
.quad foo  # こう書いても同じ
</code></pre>
</li>
<li>
<p>例: <code>.-add5</code>は現在のアドレスから<code>add5</code>のアドレスを引くので，
「関数<code>add5</code>の先頭から現在のアドレスまでの，機械語命令のバイト数」が計算できます</p>
<pre><code class="language-x86asmatt">.size   add5, .-add5
</code></pre>
</li>
</ul>
<h3 id="数値ラベル"><a class="header" href="#数値ラベル">数値ラベル</a></h3>
<img src="figs/numeric-label.svg" height="200px" id="fig:numeric-label">
<ul>
<li>数値ラベル = 正の整数にコロン<code>:</code>がついたもの</li>
<li>数値ラベルは再定義が可能 (2重定義にならない)</li>
<li>参照時には <code>f</code> か <code>b</code>を付ける
<ul>
<li><code>b</code> (backward)は<strong>後方で</strong>最初の同名のラベルを参照</li>
<li><code>f</code> (forward)は<strong>前方で</strong>最初の同名のラベルを参照</li>
</ul>
</li>
<li><a href="./8-inline.html">インラインアセンブリコード</a>で使うと
2重定義を気にせず使えるので便利．</li>
</ul>
<h3 id="変数名とラベル"><a class="header" href="#変数名とラベル">変数名とラベル</a></h3>
<pre><code>int x1 = 111;
int main ()
{
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x1
    .data
    .align 4
    .type   x1, @object
    .size   x1, 4
x1:
    .long   111
</code></pre>
<ul>
<li>静的な変数<code>x1</code>はそのままアセンブリコードのラベル<code>x1</code>になります．
ラベル<code>x1</code>の値は「変数<code>x1</code>の実体が置かれるメモリ領域の先頭番地」になります．</li>
</ul>
<pre><code>// var2.c
void foo ()
{
    static int x2 = 222;
}

int main ()
{
    static int x2 = 333;
}
</code></pre>
<pre><code class="language-x86asmatt">    .data
    .align 4
    .type   x2.1, @object
    .size   x2.1, 4
x2.1:
    .long   222

    .align 4
    .type   x2.0, @object
    .size   x2.0, 4
x2.0:
    .long   333
</code></pre>
<ul>
<li>関数内の静的変数<code>x2</code>は，同名の変数と区別するため，コンパイラが
<code>x2.0</code>，<code>x2.1</code>と数字を付け足しています．</li>
</ul>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
</code></pre>
<ul>
<li>
<p>関数<code>main</code>もそのままアセンブリコードでラベル<code>main</code>になります．
ラベル<code>main</code>の値は「関数<code>main</code>の実体が置かれるメモリ領域の先頭番地」になります．</p>
</li>
<li>
<p><code>static</code>ではない局所変数(自動変数)は記号表には含まれません．</p>
<ul>
<li>同じ関数が呼ばれるたびに，局所変数の実体がスタック上で確保されるため，
アドレスが1つに確定しないからです．</li>
<li>局所変数はコンパイル時にベースポインタ (<code>%rbp</code>)やスタックポインタ (<code>%rsp</code>)との
相対アドレスが確定します．局所変数はこの相対アドレスを使ってアクセスします．</li>
</ul>
</li>
</ul>
<h2 id="アセンブラ命令-1"><a class="header" href="#アセンブラ命令-1">アセンブラ命令</a></h2>
<h3 id="アセンブラ命令の種類"><a class="header" href="#アセンブラ命令の種類">アセンブラ命令の種類</a></h3>
<div class="table-wrapper"><table><thead><tr><th>種類</th><th>例</th><th>意味</th></tr></thead><tbody>
<tr><td>セクション指定</td><td><code>.text</code></td><td>出力先を<code>.text</code>セクションにせよ</td></tr>
<tr><td>データ出力</td><td><code>.long 0x12345678</code></td><td>4バイトの整数値<code>0x12345678</code>の<br/>2進数表現を出力せよ</td></tr>
<tr><td>出力アドレス調整</td><td><code>.align 4</code></td><td>4バイト境界にアラインメント調整せよ<br/>(4の倍数になるようにロケーションカウンタを増やせ)</td></tr>
<tr><td>シンボル情報</td><td><code>.globl main</code></td><td>シンボル<code>main</code>をグローバルとせよ</td></tr>
<tr><td>その他</td><td><code>.ident &quot;GCC..&quot;</code></td><td>(ELF形式の場合)文字列<code>&quot;GCC..&quot;</code>を<code>.comment</code>セクションに出力する</td></tr>
</tbody></table>
</div><div id="ident">
<pre><code>.ident	&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;
</code></pre>
<pre><code>$ objdump -s -j .comment ./a.out

./a.out:     file format elf64-x86-64

Contents of section .comment:
 0000 4743433a 20285562 756e7475 2031312e  GCC: (Ubuntu 11.
 0010 342e302d 31756275 6e747531 7e32322e  4.0-1ubuntu1~22.
 0020 30342920 31312e34 2e3000             04) 11.4.0.     
</code></pre>
<p>確かに<code>.comment</code>セクションに出力されていました．</p>
</div>
<h3 id="セクション指定"><a class="header" href="#セクション指定">セクション指定</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アセンブラ命令</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><code>.text</code></td><td><code>.text</code></td><td>出力先を<code>.text</code>セクションに変更</td></tr>
<tr><td><code>.data</code></td><td><code>.data</code></td><td>出力先を<code>.data</code>セクションに変更</td></tr>
<tr><td><code>.bss</code></td><td><code>.bss</code></td><td>出力先を<code>.bss</code>セクションに変更</td></tr>
<tr><td><code>.section</code> セクション名</td><td><code>.section .rodata</code></td><td>出力先を指定したセクション名に変更</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>セクション</th><th>役割</th></tr></thead><tbody>
<tr><td><code>.text</code></td><td>機械語命令列を保持</td></tr>
<tr><td><code>.data</code></td><td>初期化済みの静的変数を保持</td></tr>
<tr><td><code>.bss</code></td><td>未初期化の静的変数を保持</td></tr>
<tr><td><code>.rodata</code></td><td>読み込みのみ(書き込み禁止)データを保持 (例: Cの文字列定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>アセンブラ命令<code>.text</code>や<code>.data</code>などは何度でも指定できます</li>
</ul>
<h3 id="cの変数とセクションの対応"><a class="header" href="#cの変数とセクションの対応">Cの変数とセクションの対応</a></h3>
<pre><code>       int x1 = 10;     // コンパイル時に.dataセクションに確保
       int x2;          // コンパイル時に.bssセクションに確保
static int x3 = 10;     // コンパイル時に.dataセクションに確保
static int x4;          // コンパイル時に.bssセクションに確保
extern int x5;          // 何も確保しない

int main (void)
{
    int y1 = 10;        // 実行時にスタック上に確保
    int y2;             // 実行時にスタック上に確保
    static int y3 = 10; // コンパイル時に.dataセクションに確保
    static int y4;      // コンパイル時に.bssセクションに確保
    extern int y5;      // 何も確保しない
}
</code></pre>
<pre><code>$ gcc -g var3.c
$ nm ./a.out
0000000000001129 T main
0000000000004010 D x1
0000000000004020 B x2
0000000000004014 d x3
0000000000004024 b x4
0000000000004018 d y3.0
0000000000004028 b y4.1
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>シンボルタイプ</th><th>説明</th></tr></thead><tbody>
<tr><td>T</td><td><code>.text</code>セクション中のシンボル(関数名)</td></tr>
<tr><td>D</td><td><code>.data</code>セクション中のシンボル</td></tr>
<tr><td>B</td><td><code>.bss</code>セクション中のシンボル</td></tr>
<tr><td>U</td><td>参照されているが未定義のシンボル</td></tr>
</tbody></table>
</div>
<ul>
<li>初期化済みの静的変数は<code>.data</code>セクションに置かれます</li>
<li>未初期化の静的変数は<code>.bss</code>セクションに置かれます</li>
<li>大文字のシンボルタイプはグローバルスコープ，小文字はファイルスコープを表します</li>
<li><code>extern int x5;</code>は「<code>x5</code>の型は<code>int</code>だよ」とコンパイラに伝えるだけなので，実体は確保しません(念のため)</li>
</ul>
<h3 id="データ配置"><a class="header" href="#データ配置">データ配置</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アセンブラ命令</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><code>.byte</code> 式, ...</td><td><code>.byte 0x11, 0x22</code></td><td>1バイトデータを2つ (<code>0x11</code>と<code>0x22</code>)出力</td></tr>
<tr><td><code>.word</code> 式, ...</td><td><code>.word 0x11</code></td><td><code>0x11</code>を2バイトデータとして出力</td></tr>
<tr><td><code>.long</code> 式, ...</td><td><code>.long 0x11</code></td><td><code>0x11</code>を4バイトデータとして出力</td></tr>
<tr><td><code>.quad</code> 式, ...</td><td><code>.quad 0x11</code></td><td><code>0x11</code>を8バイトデータとして出力</td></tr>
<tr><td>`.string&quot; 文字列, ...</td><td><code>.string &quot;hello&quot;</code></td><td>文字列<code>&quot;hello&quot;</code>を出力(ヌル文字を付加する)</td></tr>
<tr><td>`.ascii&quot; 文字列, ...</td><td><code>.ascii &quot;hello\0&quot;</code></td><td>文字列<code>&quot;hello\0&quot;</code>を出力(ヌル文字を付加しない)</td></tr>
<tr><td>`.asciz&quot; 文字列, ...</td><td><code>.asciz &quot;hello&quot;</code></td><td>文字列<code>&quot;hello&quot;</code>を出力(ヌル文字を付加)</td></tr>
<tr><td>`.fill データ数,サイズ,値</td><td><code>.fill 10, 8, 0x1234</code></td><td><code>0x1234</code>を8バイトデータとして10個出力<br/>(サイズと値は省略可能．省略時はそれぞれ1と0になる)</td></tr>
</tbody></table>
</div>
<h3 id="出力アドレス調整-アラインメント"><a class="header" href="#出力アドレス調整-アラインメント">出力アドレス調整 (アラインメント)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アセンブラ命令</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><code>.align</code> 式</td><td><code>.align 8</code></td><td>出力先アドレスを8バイト境界にせよ<br/>(ロケーションカウンタを8の倍数に増やせ)</td></tr>
<tr><td><code>.p2align</code> 式</td><td><code>.p2align 3</code></td><td>出力先アドレスを\(2^3=8\)バイト境界にせよ</td></tr>
<tr><td><code>.space</code> 式</td><td><code>.space 3</code></td><td>ロケーションカウンタを3増やせ (<code>.skip</code>でも同じ)</td></tr>
<tr><td><code>.zero</code> 式</td><td><code>.zero 3</code></td><td>3バイトのゼロを出力せよ</td></tr>
<tr><td><code>.org</code> 式</td><td><code>.zero 510</code></td><td>ロケーションカウンタを510にせよ(増やす方向のみ)</td></tr>
</tbody></table>
</div>
<h3 id="シンボル情報"><a class="header" href="#シンボル情報">シンボル情報</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アセンブラ命令</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><code>.globl</code> シンボル</td><td><code>.globl foo</code></td><td>シンボル<code>foo</code>をグローバルにせよ</td></tr>
<tr><td><code>.type</code> シンボル, 型</td><td><code>.type main, @function</code></td><td>シンボル<code>main</code>の型は関数とせよ</td></tr>
<tr><td><code>.size</code> シンボル, サイズ</td><td><code>.size main, .-main</code></td><td>シンボル<code>main</code>のサイズを<code>.-main</code>の計算結果(単位はバイト)とせよ</td></tr>
<tr><td><code>.local</code> シンボル</td><td><code>.local foo</code></td><td>シンボル<code>foo</code>をローカルにせよ</td></tr>
<tr><td><code>.comm</code> シンボル, サイズ, アラインメント</td><td><code>.comm foo, 4, 4</code></td><td><code>.bss</code>セクションにシンボル<code>foo</code>を作成せよ<br/>(サイズは4バイト，アラインメントは4バイト境界で)</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p><code>.type</code>では型を <code>@function</code> (関数)か <code>@object</code> (普通のデータ)で指定します．
(<a href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.intro.html">ELFの仕様</a>によれば，
<code>@section</code>，<code>@file</code>，<code>@notype</code>なども使えます．これらは<code>readelf -s</code>の出力にシンボルの型として出てきます)．</p>
</li>
<li>
<p><code>.comm</code>について補足します．</p>
<pre><code>int x; // グローバル変数
</code></pre>
<p>に対して，<code>gcc -S</code>は</p>
<pre><code>    .globl  x
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .zero   4
</code></pre>
<p>というアセンブリコードを出力します．一方，</p>
<pre><code>static int y; 
</code></pre>
<p>に対して，<code>gcc -S</code>は</p>
<pre><code># ❶
    .align 4
    .type   y, @object
    .size   y, 4
y:
    .zero   4
</code></pre>
<p>ではなく</p>
<pre><code># ❷
    .local  y 
    .comm   y,4,4
</code></pre>
<p>を出力します(<code>.local</code>が必要なのは<code>.local</code>が無いと<code>.comm</code>で指定したシンボルがグローバルになってしまうからです)．
<code>.comm y,4,4</code>の最初の4は定義する<code>y</code>のサイズが4，次の4はアラインメント制約が4バイトであることを示しています．
実は❶と❷は全く同じ意味なのです(なので❶を出力してくれた方が分かりやすくて良いのですが…)．</p>
</li>
</ul>
<pre><code class="language-x86asmatt">	.data

	.bss
	.align 4
	.type	x, @object
	.size	x, 4
x:
	.zero	4

	.local	y
	.comm	y,4,4

	.text
	.globl	main
	.type	main, @function
main:
	endbr64
	ret
	.size	main, .-main
</code></pre>
<pre><code>$ gcc -g var4.s
$ readelf -s ./a.out
symbol table '.symtab' contains 37 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
(中略)
    12: 0000000000004014     4 OBJECT  LOCAL  DEFAULT   24 x ❸
    13: 0000000000004018     4 OBJECT  LOCAL  DEFAULT   24 y ❹

$ nm ./a.out
(中略)
0000000000004014 b x ❺
0000000000004018 b y ❻
</code></pre>
<p>念のため，<code>readelf -s</code>と<code>nm</code>で記号表の中身を比べると❸〜❻は全く同じになりました．</p>
<!--
### マクロ
-->
<h2 id="att形式とintel形式"><a class="header" href="#att形式とintel形式">AT&amp;T形式とIntel形式</a></h2>
<h3 id="コマンド等での選択"><a class="header" href="#コマンド等での選択">コマンド等での選択</a></h3>
<ul>
<li><code>gcc</code>では，<code>-masm=att</code> (デフォルト)，<code>-masm=intel</code>で出力するアセンブリコードの形式を選択可能です</li>
</ul>
<pre><code>$ gcc -S -masm=intel add5.c
$ cat add5.s
    .intel_syntax noprefix
    .text
    .globl  add5
    .type   add5, @function
add5:
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR -4[rbp], edi
    mov     eax, DWORD PTR -4[rbp]
    add     eax, 5
    pop     rbp
    ret
    .size   add5, .-add5
</code></pre>
<ul>
<li>
<p>アセンブリコード中では，アセンブラ命令 <code>.att_syntax</code> (デフォルト)と <code>.intel_syntax</code>で，どちらの記法を使うか選択可能です</p>
</li>
<li>
<p><code>objdump -d</code>で逆アセンブルする際は，<code>-M att</code>(デフォルト)と<code>-M intel</code>で選択可能です．</p>
</li>
</ul>
<pre><code>$ objdump -d -M intel add5.o

add5.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 &lt;add5&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   rbp
   5:	48 89 e5             	mov    rbp,rsp
   8:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
   b:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
   e:	83 c0 05             	add    eax,0x5
  11:	5d                   	pop    rbp
  12:	c3                   	ret    
</code></pre>
<h3 id="att-intel"><a class="header" href="#att-intel">AT&amp;T形式とIntel形式の主な違い</a></h3>
<ul>
<li>オペランドの順序，即値，レジスタの表記が異なります</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>AT&amp;T形式での例</th><th>Intel形式での例</th><th>説明</th></tr></thead><tbody>
<tr><td>オペランドの代入の順序</td><td><code>addq $4, %rax</code></td><td><code>add rax, 4</code></td><td>AT&amp;T形式では左→右<br/>Intel形式では右→左に代入</td></tr>
<tr><td>即値の表記</td><td><code>pushq $4</code></td><td><code>push 4</code></td><td>AT&amp;T形式では即値に<code>$</code>がつく</td></tr>
<tr><td>レジスタの表記</td><td><code>pushq %rbp</code></td><td><code>push rbp</code></td><td>AT&amp;T形式ではレジスタに<code>%</code>がつく</td></tr>
</tbody></table>
</div>
<ul>
<li>オペランドのサイズ指定方法が異なります
<ul>
<li>AT&amp;T形式では命令サフィックス(例えば，<code>movb</code>の<code>b</code>)で指定します</li>
<li>Intel形式では <code>BYTE PTR</code>などの記法を使います</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">AT&amp;T形式の<br/>サイズ指定</th><th>Intel形式の<br/>サイズ指定</th><th>メモリオペランドの<br/>サイズ</th><th>AT&amp;T形式での例</th><th>Intel形式での例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td><code>BYTE PTR</code></td><td>1バイト(8ビット)</td><td><code>movb $10, -8(%rbp)</code></td><td><code>mov BYTE PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>w</code></td><td><code>WORD PTR</code></td><td>2バイト(16ビット)</td><td><code>movw $10, -8(%rbp)</code></td><td><code>mov WORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>l</code></td><td><code>DWORD PTR</code></td><td>4バイト(32ビット)</td><td><code>movl $10, -8(%rbp)</code></td><td><code>mov DWORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>q</code></td><td><code>QWORD PTR</code></td><td>8バイト(64ビット)</td><td><code>movq $10, -8(%rbp)</code></td><td><code>mov QWORD PTR [rbp-8], 10</code></td></tr>
</tbody></table>
</div>
<ul>
<li>メモリ参照の記法が違います</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./7-asm.html#att-intel">AT&amp;T形式</a></th><th><a href="./7-asm.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>一部の機械語命令のニモニックが違います</p>
<ul>
<li>変換系の命令</li>
</ul>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>c␣t␣</code></strong></td><td><code>c␣␣␣</code></td><td>convert ␣ to ␣</td><td><code>%rax</code> (または<code>%eax</code>, <code>%ax</code>, <code>%al</code>)を符号拡張</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a><br/>(AT&amp;T形式)</th><th>詳しい記法<br/>(Intel形式)</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cbtw</code></strong></td><td><code>cbw</code></td><td><code>cbtw</code></td><td><code>%al</code>(byte)を<code>%ax</code>(word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtl</code></strong></td><td><code>cwde</code></td><td><code>cwtl</code></td><td><code>%ax</code>(word)を<code>%eax</code>(long)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtd</code></strong></td><td><code>cwd</code></td><td><code>cwtd</code></td><td><code>%ax</code>(word)を<code>%dx:%ax</code>(double word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltd</code></strong></td><td><code>cdq</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%edx:%eax</code>(doube long, quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltq</code></strong></td><td><code>cdqe</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%rax</code>(quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cqto</code></strong></td><td><code>cqo</code></td><td><code>cqto</code></td><td><code>%rax</code>(quad)を<code>%rdx:%rax</code>(octuple)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<ul>
<li>ゼロ拡張，符号拡張の命令</li>
</ul>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movsx</code> <em>op2</em>, <em>op1</em> </br> <code>movsxd</code> <em>op2</em>, <em>op1</em></td><td>move with sign-extention</td><td><em>op1</em>を符号拡張した値を<em>op2</em>に格納</td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movzx</code> <em>op2</em>, <em>op1</em></td><td>move with zero-extention</td><td><em>op1</em>をゼロ拡張した値を<em>op2</em>に格納</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例(AT&amp;T形式)</th><th>例(Intel形式)</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movslq %eax, %rbx</code></td><td><code>movsxd rbx,eax</code></td><td><code>%rbx</code> = <code>%eax</code>を8バイトに符号拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movzwq %ax, %rbx</code></td><td><code>movzx  rbx,ax</code></td><td><code>%rbx</code> = <code>%ax</code>を8バイトにゼロ拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><code>␣␣</code>に入るもの</th><th>何の略か</th><th>意味</th></tr></thead><tbody>
<tr><td><code>bw</code></td><td>byte to word</td><td>1バイト→2バイトの拡張</td></tr>
<tr><td><code>bl</code></td><td>byte to long</td><td>1バイト→4バイトの拡張</td></tr>
<tr><td><code>bq</code></td><td>byte to quad</td><td>1バイト→8バイトの拡張</td></tr>
<tr><td><code>wl</code></td><td>word to long</td><td>2バイト→4バイトの拡張</td></tr>
<tr><td><code>wq</code></td><td>word to quad</td><td>2バイト→8バイトの拡張</td></tr>
<tr><td><code>lq</code></td><td>long to quad</td><td>4バイト→8バイトの拡張</td></tr>
</tbody></table>
</div>
<hr />
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 8; }
</style>
<h1 id="インラインアセンブラ"><a class="header" href="#インラインアセンブラ">インラインアセンブラ</a></h1>
<h2 id="インラインアセンブラの概要"><a class="header" href="#インラインアセンブラの概要">インラインアセンブラの概要</a></h2>
<img src="figs/inline-asm.svg" height="150px" id="fig:inline-asm">
<ul>
<li>
<p><strong>インラインアセンブラ</strong> (inline assembler)はコンパイラの機能の一部であり，
高級言語(例えばC言語)中にアセンブリコードを記述する(埋め込む)ことを可能にします</p>
<ul>
<li>埋め込んだC言語中のアセンブリコードを<strong>インラインアセンブリコード</strong>といいます</li>
</ul>
</li>
<li>
<p>なるべく(アセンブリコードだけで記述するのではなく)<strong>，C言語中でインラインアセンブラを使うべき</strong>です</p>
<ul>
<li>アセンブリコードの生産性・保守性・移植性は非常に低いからです</li>
<li>インラインアセンブラを使えば「大半のコードはC言語で記述し，どうしてもアセンブリコードが必要な部分だけインラインアセンブラを使って書く」ことで，アセンブリコードの記述量を減らせます</li>
<li><a href="https://openhub.net/p/linux/analyses/latest/languages_summary">この資料</a>では，Linuxカーネルのアセンブリコードは <strong>0.8%</strong> で，ほとんどがC言語だそうです
(ただし，Cコード中のインラインアセンブリコードは正しくカウントされていないかも知れません)</li>
</ul>
</li>
<li>
<p>GCCでは<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html"><strong>asm構文</strong></a>を使ってインラインアセンブリコードを記述します</p>
<ul>
<li>
<p>例: <code>nop</code>命令を埋め込んだ例．実行しても何も起きないのであまり意味はないです．
これは<a href="./8-inline.html#%E5%9F%BA%E6%9C%ACasm%E6%A7%8B%E6%96%87"><strong>基本asm構文</strong></a>の例です．</p>
<pre><code>// inline-asm1.c (基本asm構文の例)
int main (void)
{
    asm (&quot;nop&quot;);
}

</code></pre>
<pre><code>$ gcc -g inline-asm1.c
$ ./a.out
(何も起きない)
</code></pre>
</li>
<li>
<p>例: スタックポインタ <code>%rsp</code>の値を変数<code>addr</code>に格納して表示する例．
これはC言語だけでは書けないので意味があります．
これは<a href="./8-inline.html#%E6%8B%A1%E5%BC%B5asm%E6%A7%8B%E6%96%87"><strong>拡張asm構文</strong></a>の例です．</p>
<pre><code>// inline-asm2.c (拡張asm構文の例)
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %0&quot;: &quot;=m&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<pre><code>$ gcc -g inline-asm2.c
$ gdb ./a.out
(gdb) b main
Breakpoint 2 at 0x555555555175: file foo.c, line 3.
(gdb) r
Breakpoint 2, main () at foo.c:3
3	{
(gdb) n
5	asm (&quot;movq %%rsp, %0&quot;: &quot;=m&quot;(addr));
(gdb) n
6	printf (&quot;rsp = %p\n&quot;, addr);
(gdb) p/x $rsp
$2 = 0x7fffffffdee0 ❶
(gdb) c
Continuing.
rsp = 0x7fffffffdee0 (printfの出力．❶の%rspの値と同じになっている)
(gdb) q
</code></pre>
</li>
</ul>
</li>
<li>
<p>インラインアセンブラの機能はC言語規格ではなく，コンパイラの<strong>独自拡張</strong>です．</p>
<ul>
<li>インラインアセンブラの記法は<strong>コンパイラごとに異なります</strong></li>
<li><code>gcc -std=c11 -pedantic</code>など，言語規格への遵守を強くするオプションを指定すると，コンパイルエラーになることがあります．
<code>asm</code>を<code>__asm__</code>にすればコンパイルできる場合もあります．</li>
</ul>
</li>
</ul>
<details>
<summary>
<code>__asm__</code>は予約識別子
</summary>
<p>「<code>_</code>と大文字」あるいは「<code>__</code>(下線2つ)と小文字」で始まる識別子(名前)は
<strong>予約識別子</strong> (予約語とは別のものです)と呼ばれ，
言語処理系が定義するための名前です．
<code>__asm__</code>も予約識別子なので，アプリケーションプログラムが定義することはできず，
二重定義を避けられるというわけです．
(二重定義を避けられても，asm構文がGCCの独自拡張であり，
C言語規格には違反であることは同じですが…)</p>
</details>
<ul>
<li>インラインアセンブラの使い方の注意(概要): コンパイラの最適化の影響をなるべく避けるため，以下に注意:
<ul>
<li>なるべく，基本asm構文ではなく拡張asm構文を使う</li>
<li>拡張asm構文には修飾子<code>volatile</code>を必ず付ける</li>
<li>なるべくまとめて，1つの拡張asm構文で記述する</li>
<li>必要なら<code>gcc -S</code>で出力したアセンブリコードを(意図通りにasm構文が展開されているかを)確認する</li>
<li>必要なら「人工的な変数の依存関係」を導入する</li>
<li>コンパイラの最適化により，拡張asm構文が移動させられたり，場合によっては
消去される可能性があります．<code>gcc -S</code>の出力を確認しましょう．</li>
</ul>
</li>
</ul>
<h2 id="基本asm構文"><a class="header" href="#基本asm構文">基本asm構文</a></h2>
<ul>
<li>
<p>基本asm構文は以下の形式です</p>
<pre><code>asm 修飾子 ( &quot;アセンブリコード&quot; );
</code></pre>
</li>
<li>
<p>以下は<code>nop</code>命令のみを基本asm構文で指定した例です．</p>
<pre><code>asm (&quot;nop&quot;);
</code></pre>
</li>
<li>
<p>基本asm構文では(拡張asm構文でも)機械語命令以外に，ラベル定義，アセンブラ命令，コメントも書けます．</p>
<pre><code>asm (&quot;foo: .text; nop # this is a comment&quot;);
</code></pre>
</li>
<li>
<p>修飾子は <code>volatile</code>と<code>inline</code>を指定可能です</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>修飾子</th><th>説明</th></tr></thead><tbody>
<tr><td><code>volatile</code></td><td>(ある程度)最適化を抑制する <br/>(基本asm構文では指定しなくても<code>volatile</code>とみなされる)</td></tr>
<tr><td><code>inline</code></td><td>この基本asm構文を含む関数がインライン化されやすい<br/>ようにasm構文中の機械語命令のバイト数を少なく見積もる</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>アセンブリコードを指定する文字列中では生の改行文字を入れてはいけません(<code>\n</code>なら良い)</p>
<ul>
<li>
<p>まず，最適化の影響を避けるため，なるべく1つのasm構文にまとめるべきです．
<a href="./8-inline.html#%E6%9C%80%E9%81%A9%E5%8C%96%E5%99%A8%E3%81%A8%E3%81%AE%E8%A9%B1">最適化がasm構文を移動したり削除したり</a>
するからです．</p>
<pre><code>// 良くない例 (1つのasm構文にまとめるべき)
asm (&quot;nop&quot;);
asm (&quot;nop&quot;);
asm (&quot;nop&quot;);
</code></pre>
</li>
<li>
<p>まとめる際は見やすさのため，各行ごとに文字列定数に分割した上で改行するの良いですし，これが最もお勧めです．</p>
<pre><code>// OK &amp; お勧め
asm (&quot;nop\n\t&quot;
     &quot;nop\n\t&quot;
     &quot;nop\n\t&quot;);
</code></pre>
<ul>
<li>カンマで区切られていない文字列定数の並び
(ここでは <code>&quot;nop\n\t&quot; &quot;nop\n\t&quot; &quot;nop\n\t&quot;</code>)
はコンパイルの初期段階で1つの文字列として連結され，
<code>&quot;nop\n\tnop\n\tnop\n\t&quot;</code> になります．</li>
<li><code>\t</code>は無くてもOKです．出力されたアセンブリコードのインデントのためにつけています．</li>
</ul>
</li>
<li>
<p>文字列定数の途中で改行してはいけません．
(文字列定数の途中で改行するとコンパイルエラーになります)</p>
<pre><code>// NG (コンパイルエラー)
asm (&quot;nop
      nop
      nop&quot;);
</code></pre>
</li>
</ul>
</li>
<li>
<p>基本asmコードはCのコードと協調(例: Cの変数へのアクセス)ができません．
→ 拡張asm構文を使え</p>
</li>
</ul>
<pre><code>// inline-bad.c
#include &lt;stdio.h&gt;
long x = 111;
long y = 222;   
int main ()
{
    asm (&quot;movq x(%rip), %rax; addq %rax, y(%rip)&quot;);
    printf (&quot;x = %ld, y = %ld\n&quot;, x, y);
}
</code></pre>
<pre><code>$ gcc -g inline-bad.c
$ ./a.out
x = 111, y = 333
</code></pre>
<p>上記のように基本asm構文でも無理やりCの変数<code>x</code>や<code>y</code>にアクセスできますが(これは<strong>悪い例</strong>)，
「コンパイラが変数<code>x</code>を<code>x(%rip)</code>として出力する」ことを大前提にしたコードです．つまり「たまたま動いている」だけです．
このため，多くの場合，<strong>基本asm構文ではなく<a href="./8-inline.html#%E6%8B%A1%E5%BC%B5asm%E6%A7%8B%E6%96%87">拡張asm構文</a>を使うべき</strong>です．
上記の例を拡張asm構文で書き直すと以下になります．
(<code>&quot;+rm&quot;</code>の<code>+</code>は指定した変数<code>y</code>(<code>%0</code>)が，読み書きの両方で使われていることを示し，
<code>&quot;rm&quot;</code>は「レジスタかメモリ参照として展開せよ」という指示(制約)です)．</p>
<pre><code>// inline-good.c
#include &lt;stdio.h&gt;
long x = 111;
long y = 222;   
int main ()
{
    asm volatile (&quot;movq %1, %%rax; addq %%rax, %0&quot;
                  : &quot;+rm&quot; (y) // 変数yのアセンブリコードを%0で展開
                  : &quot;rm&quot; (x)  // 変数xのアセンブリコードを%1で展開
                  : &quot;%rax&quot;    // レジスタ%raxの破壊の存在をコンパイラに伝達
        );
    printf (&quot;x = %ld, y = %ld\n&quot;, x, y);
}
</code></pre>
<ul>
<li>その他の注意点
<ul>
<li>基本asm構文は関数内と関数外の両方で使える(拡張asm構文は関数内のみ)が，
関数外で使う場合は<code>volatile</code>も<code>inline</code>も付けてはいけない．</li>
<li>asm構文から他のasm構文へのジャンプはしてはいけない．
(拡張asm構文ならCのラベルへのジャンプはしても良い)．</li>
<li>asm構文をGCCが複製する可能性があり(ループ展開とかで)，その結果，
シンボルの2重定義などが起こる可能性がある．これを避けるには <code>%=</code>を使う(ここでは詳細省略)</li>
<li>基本asm構文ではアセンブリコードをそのまま出力する．レジスタ名も<code>%rsp</code>をそのまま出力する．一方，拡張asm構文中は<code>%</code>を特別扱いするので，<code>%%rsp</code>と書く必要があるので注意 (<code>printf</code>のフォーマット中で<code>%</code>を出力するために<code>%%</code>と書くのと同じ)．</li>
<li>基本asm構文は<code>-masm</code>で指定された方言に従うので，
<code>asm (&quot;pushq $99&quot;);</code>は<code>gcc -masm=intel</code>とするとコンパイルエラーになる．</li>
</ul>
</li>
</ul>
<h2 id="拡張asm構文"><a class="header" href="#拡張asm構文">拡張asm構文</a></h2>
<h3 id="inline-asm2.c"><a class="header" href="#inline-asm2.c">拡張asm構文の例 (引数を<code>%順番</code>で指定)</a></h3>
<pre><code>// inline-asm2.c (拡張asm構文の例)
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %0&quot;: &quot;=m&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<img src="figs/extended-asm.svg" height="350px" id="fig:extended-asm">
<ul>
<li>
<p><strong>拡張asm構文</strong>はコロン<code>:</code>で区切られた<strong>引数</strong> (この場合は<code>&quot;=m&quot; (attr)</code>)を持ちます．
引数は対応するアセンブリコードに変換した上で，<code>%0</code>などの部分を展開します．</p>
<ul>
<li>引数が複数個ある場合は，先頭から順番に<code>%1</code>, <code>%2</code>, ... と参照します．</li>
</ul>
</li>
<li>
<p>上の例ではCの変数<code>addr</code>を対応するメモリ参照<code>-16(%rbp)</code>に変換して，
<code>%0</code>の場所に展開しています．</p>
<ul>
<li>拡張asm構文の第1引数(命令テンプレート)中の<code>%0</code>などは展開対象です．
つまり，<code>%</code>は特別扱いしています．
<code>%</code>文字自体を使うには<code>%%</code>とする必要があります．
このため，レジスタ<code>%rsp</code>は命令テンプレート中で<code>%%rsp</code>となっています．</li>
<li><code>&quot;=m&quot;</code>はアセンブリコードに変換する際の指示(<strong>制約</strong>)です．
<code>=</code>は出力，<code>m</code>はメモリ参照として展開せよという意味になります．</li>
</ul>
</li>
</ul>
<h3 id="拡張asm構文の例-引数を名前で指定"><a class="header" href="#拡張asm構文の例-引数を名前で指定">拡張asm構文の例 (引数を<code>%名前</code>で指定)</a></h3>
<pre><code>// inline-asm3.c
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %[addr]&quot;: [addr] &quot;=m&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<ul>
<li>展開する場所(例: <code>%0</code>)は順番だけでなく名前でも指定できます．</li>
<li>上の例では変数<code>addr</code>に，<code>[addr]</code>とすることで<code>addr</code>という名前をつけて，
命令テンプレート中で<code>%[addr]</code>と参照しています．
<ul>
<li>ここではたまたま変数名<code>addr</code>と名前<code>addr</code>を同じにしましたが，別にしてもOKです</li>
<li><code>&quot;=m (addr)&quot;</code>の<code>addr</code>の部分には変数だけでなくC言語の式を書けます</li>
</ul>
</li>
</ul>
<h3 id="拡張asm構文の例-グルーコードが生じる例"><a class="header" href="#拡張asm構文の例-グルーコードが生じる例">拡張asm構文の例 (グルーコードが生じる例)</a></h3>
<ul>
<li>グルーコードが生じる例 (単純な例)</li>
</ul>
<pre><code>// inline-asm4.c
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %0&quot;: &quot;=r&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<pre><code>$ gcc -S inline-asm4.c
$ cat inline-asm4.s
(中略)
#APP
# 6 &quot;inline-asm4.c&quot; 1
 ❶ movq  %rsp, %rax
# 0 &quot;&quot; 2
#NO_APP
 ❷ movq  %rax, -8(%rbp)
</code></pre>
<ul>
<li>
<p><a href="./8-inline.html#inline-asm2.c"><code>inline-asm2.c</code></a>の制約 <code>&quot;=m&quot;</code> (メモリ参照)を
<code>&quot;=r&quot;</code> (レジスタ)に変更してみます．すると，
制約の指定がレジスタなので，<code>%0</code>は❶ <code>%rax</code>に展開されました．
しかし，最終的な格納先である変数<code>addr</code>はメモリ (<code>-8(%rbp)</code>)だったので，
❷ <code>movq  %rax, -8(%rbp)</code>が追加され，変数<code>addr</code>に代入されるようになりました．</p>
</li>
<li>
<p>この追加された命令❷を<strong>グルーコード</strong>(glue code)といいます．
グルーは接着剤という意味です．
グルーコードはCのコードとインラインアセンブリコードの間の隙間を
接着する役割を担ってます．</p>
</li>
<li>
<p>この場合，制約を<code>=r</code>と指定した結果，
<a href="./8-inline.html#inline-asm2.c"><code>inline-asm2.c</code></a>では不要だった
グルーコードが増えてしまいました．制約はなるべく緩く指定して，
コンパイラに最適な出力を任せる方が良いことが多いでしょう．
この場合は，レジスタでもメモリでも良いので，<code>&quot;rm&quot;</code>と指定するのが最適だと思います．</p>
</li>
</ul>
<h3 id="グルーコードが生じる例-rdtscpの例"><a class="header" href="#グルーコードが生じる例-rdtscpの例">グルーコードが生じる例 (<code>rdtscp</code>の例)</a></h3>
<pre><code>// rdtscp.c
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

uint64_t rdtscp (void) {
    uint64_t hi, lo;
    uint32_t aux;
    asm volatile (&quot;rdtscp&quot;:&quot;=a&quot;(lo), &quot;=d&quot;(hi), &quot;=c&quot;(aux));
    printf (&quot;processor ID = %d\n&quot;, aux);
    return ((hi &lt;&lt; 32) | lo);
}

int main (void) {
    printf (&quot;%lu\n&quot;, rdtscp ());
}
</code></pre>
<img src="figs/extended-asm2.svg" height="250px" id="fig:extended-asm2">
<pre><code>$ gcc -S rdtscp.c
$ less rdtscp.s
(一部略)
#APP
# 8 &quot;rdtscp.c&quot; 1
    rdtscp
# 0 &quot;&quot; 2
#NO_APP
 ❶  movq    %rax, -16(%rbp)
 ❷  movq    %rdx, -8(%rbp)
 ❸  movl    %ecx, -20(%rbp)
</code></pre>
<ul>
<li><a href="./x86-list.html#rdtscp"><code>rdtscp</code>命令</a>には明示的なオペランドは無く，
64ビットのタイムスタンプカウンタの値を<code>%edx:%eax</code>に格納します．
(そしてプロセッサIDを<code>%ecx</code>に格納します)．</li>
<li><code>gcc -S</code>の出力を見ると，<code>rdtscp</code>命令に加えてグルーコード❶❷❸が追加されています．
<ul>
<li>❶❷❸は<code>rdtscp</code>命令がレジスタに格納した値を変数<code>hi</code>, <code>lo</code>, <code>aux</code>に
格納しています．</li>
</ul>
</li>
</ul>
<h3 id="拡張asm構文の形式"><a class="header" href="#拡張asm構文の形式">拡張asm構文の形式</a></h3>
<ul>
<li>
<p>拡張asm構文の形式は次の2種類があります．
以下ではコロン<code>:</code>の手前で改行していますが，これは見やすさのためだけで，
1行で書いても構いません．</p>
<pre><code>asm 修飾子 (命令テンプレート
         : 出力オペランド列
         : 入力オペランド列  # 省略可能
         : 破壊レジスタ列   # 省略可能
	   );
</code></pre>
<pre><code>asm 修飾子 (命令テンプレート
         : 出力オペランド列
         : 入力オペランド列
         : 破壊レジスタ列
         : gotoラベル列
	   );
</code></pre>
<ul>
<li>
<p>最初の形式の場合，出力オペランド列より後は(不要なら)省略可能です．
<code>: 入力オペランド列</code>を省略した場合は，<code>: 破壊レジスタ列</code>も省略しなければいけません．
途中に空の部分がある場合は <code>asm (&quot;nop&quot;:::&quot;%rax&quot;);</code> などとコロン<code>:</code>を並べます．
一方，2番目の形式ではコロン<code>:</code>は省略できません．</p>
</li>
<li>
<p>拡張asm構文は関数中でのみ使えます．関数の外では使えません．</p>
</li>
<li>
<p>修飾子は以下を指定可能です．</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>修飾子</th><th>説明</th></tr></thead><tbody>
<tr><td><code>volatile</code></td><td>(ある程度)最適化を抑制する (拡張asm構文には常に指定を推奨)</td></tr>
<tr><td><code>inline</code></td><td>この基本asm構文を含む関数がインライン化されやすい<br/>ようにasm構文中のasm命令(バイト数)を少なく見積もる</td></tr>
<tr><td><code>goto</code></td><td>命令オペランド中から「gotoラベル列」中のCラベルにジャンプする可能性を示す <br/> (<code>goto</code>を指定すると，<code>volatile</code>の指定なしでも<code>volatile</code>になる)</td></tr>
</tbody></table>
</div>
<ul>
<li>○○列の中身が複数ある場合はカンマ<code>,</code>で区切ります．</li>
</ul>
</li>
<li>
<p>拡張asm構文の例 (<code>goto</code>無し)</p>
</li>
</ul>
<pre><code>// inline-asm5.c
#include &lt;stdio.h&gt;
int main (void)
{
    int x = 111, y = 222, z;
    // z = x + y;
    asm volatile (&quot;movl %1, %%eax; addl %2, %%eax; movl %%eax, %0&quot;
                  : &quot;=rm&quot; (z)
                  : &quot;rm&quot; (x), &quot;rm&quot; (y)
                  : &quot;%eax&quot; );
    printf (&quot;x = %d, y = %d, z = %d\n&quot;, x, y, z);
}
</code></pre>
<img src="figs/extended-asm3.svg" height="200px" id="fig:extended-asm3">
<ul>
<li>命令テンプレート中の <code>%0</code>, <code>%1</code>, <code>%2</code> は出力オペランド列と入力オペランド列中の
<code>z</code>, <code>x</code>, <code>y</code>に対応します．
<ul>
<li>名前を使うと，順番ではなく，<code>%[z]</code>, <code>%[x]</code>, <code>%[y]</code>と名前での参照も可能です．</li>
</ul>
</li>
<li>例えば，出力オペランド列中の <code>&quot;=rm&quot; (z)</code>は1つの出力オペランドです．
<code>&quot;=rm&quot;</code>は制約を示していて，<code>&quot;=&quot;</code>はこのオペランドが出力であること，
<code>&quot;rm&quot;</code>はこのオペランドをレジスタかメモリ参照として<code>%0</code>を展開することを指示しています．</li>
<li>命令テンプレート中で値を破壊するレジスタは「破壊レジスタ列」で指定する．
<ul>
<li>この指定が無いとコンパイラは「命令テンプレート中でどのレジスタが破壊されるか」が分からないからです．コンパイラが気づかず同じレジスタを使うと，
命令テンプレート中のレジスタ書き込みにより，値が壊れてしまいます．</li>
<li>出力オペランド列で指定したレジスタは破壊レジスタ列で指定する必要はありません</li>
</ul>
</li>
</ul>
<!--
  - GCCは 「**出力オペランド列と破壊レジスタ列で指定したもの以外には，
    命令テンプレート中でレジスタを変更しない」と仮定して**コンパイルを行います．
-->
<ul>
<li>
<p>特別な記法として，メモリの値を壊す場合は &quot;memory&quot;, フラグレジスタの値を壊す場合は &quot;cc&quot; を「破壊レジスタ列」に指定する．</p>
</li>
<li>
<p>コンパイラは必要に応じて，命令テンプレートの前に「レジスタの値をメモリに退避(書き戻し)」，命令テンプレートの後に「メモリの値をレジスタに復帰させる」コードを追加します</p>
</li>
<li>
<p>拡張asm構文の例 (<code>goto</code>あり)</p>
</li>
</ul>
<pre><code>// inline-asm6.c
#include &lt;stdio.h&gt;
int add (unsigned char arg1, unsigned char arg2)
{
    asm goto (&quot;addb %1, %0; jc %l[overflow]&quot; // ❷ %l3 でも可
              : &quot;+rm&quot; (arg2)
              : &quot;rm&quot; (arg1)
              :
              : overflow ); // ❶
    return arg2;
overflow:
    printf (&quot;overflow: arg1 = %d, arg2 = %d\n&quot;, arg1, arg2);
    return arg2;
}

int main (void)
{
    printf (&quot;result = %d\n&quot;, add (254, 1));
    printf (&quot;result = %d\n&quot;, add (255, 1));
}
</code></pre>
<pre><code>$ gcc -S inline-asm6.c
$ cat inline-asm6.c
(中略)
    movl    %edi, %edx
    movl    %esi, %eax
    movb    %dl, -4(%rbp)
    movb    %al, -8(%rbp)
    movzbl  -8(%rbp), %eax
#APP
# 5 &quot;inline-asm6.c&quot; 1
    addb -4(%rbp), %al; jc .L2
# 0 &quot;&quot; 2
#NO_APP
(中略)
.L2:

$ gcc -g inline-asm6.c
$ ./a.out
result = 255
overflow: arg1 = 255, arg2 = 0
result = 0
</code></pre>
<ul>
<li>
<p>命令テンプレート中からCラベルにジャンプする可能性がある場合，
<code>goto</code>付きの拡張asm構文を使う必要があります．
その場合はジャンプする可能性があるCのラベルを「gotoラベル列」に列挙します(ダブルクオート<code>&quot;</code>では囲みません)． <!-- " --></p>
</li>
<li>
<p>上の例では，❶「gotoラベル列」に<code>overflow</code>を指定しています．
命令テンプレート中でラベルを参照するには次のどちらかを使います．</p>
<ul>
<li>引数の順番を使う: &quot;+&quot;は入出力で1回ずつ出現すると数えるので，
出力オペランドが1つ (<code>%0</code>)，入力オペランドが2つ(<code>%1</code>, <code>%2</code>)になるので，
ラベルoverflowは(0から数えて)3番目になります．頭に<code>%l</code>(%と小文字のエル)をつけて，<code>%l3</code>とします．</li>
<li>引数の名前を使う: <code>%l</code> とラベル名で，❷ <code>%l[overflow]</code>とします．</li>
</ul>
</li>
<li>
<p>ある実行パスで出力を設定しない場合，入力でも出力でも使われないことになり，
出力コードがおかしくなることがあるそうです
(<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">マニュアル</a>によると)．その場合は制約<code>+</code>を使って，必ず入力として使うと指定すれば大丈夫だそうです(試してません)．</p>
</li>
</ul>
<h2 id="出力オペランド列と入力オペランド列"><a class="header" href="#出力オペランド列と入力オペランド列">出力オペランド列と入力オペランド列</a></h2>
<ul>
<li>出力オペランド列と入力オペランド列はどちらも以下の形式になります</li>
</ul>
<pre><code>&quot;制約文字列&quot; (Cの式), &quot;制約文字列&quot; (Cの式), …
</code></pre>
<ul>
<li>「Cの式」は変数を指定することが多いですが，一般的なCの式でもOKです．
ただし，出力オペランドの場合は「Cの式」は左辺値(アドレスを持つ式)でなければいけません．</li>
<li>使用できる制約文字列は次の節で示します．</li>
</ul>
<h2 id="制約"><a class="header" href="#制約">制約</a></h2>
<h3 id="制約の一覧表"><a class="header" href="#制約の一覧表">制約の一覧表</a></h3>
<p>代表的な制約を以下に示します．
他の制約は<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">GCCインラインアセンブラ</a>を参照下さい．</p>
<ul>
<li>入出力を指定する制約</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody>
<tr><td><code>=</code></td><td>オペランドは出力専用(指定するなら必ず1文字目)</td></tr>
<tr><td><code>+</code></td><td>オペランドは入出力(指定するなら必ず1文字目)</td></tr>
<tr><td>(指定なし)</td><td>オペランドは入力専用</td></tr>
</tbody></table>
</div>
<ul>
<li>汎用の制約</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody>
<tr><td><code>r</code></td><td>オペランドはレジスタ</td></tr>
<tr><td><code>m</code></td><td>オペランドはメモリ</td></tr>
<tr><td><code>i</code></td><td>オペランドは整数即値</td></tr>
<tr><td><code>g</code></td><td>オペランドは制約無し (<code>&quot;rmi&quot;</code>と同じ)</td></tr>
<tr><td><code>&amp;</code></td><td>オペランドは早期破壊レジスタ</td></tr>
<tr><td><code>0</code></td><td>マッチング制約 (<code>1</code>〜<code>9</code>も同じ)</td></tr>
<tr><td><code>%</code></td><td>オペランドは交換可能(可換)<br/>書き込みオペランドには指定不可</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>x86用の制約 (レジスタ)</p>
<div class="table-wrapper"><table><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody>
<tr><td><code>a</code></td><td><code>%rax</code>, <code>%eax</code>, <code>%ax</code>, <code>%al</code>のいずれか</td></tr>
<tr><td><code>b</code></td><td><code>%rbx</code>, <code>%ebx</code>, <code>%bx</code>, <code>%bl</code>のいずれか</td></tr>
<tr><td><code>c</code></td><td><code>%rcx</code>, <code>%ecx</code>, <code>%cx</code>, <code>%cl</code>のいずれか</td></tr>
<tr><td><code>d</code></td><td><code>%rdx</code>, <code>%edx</code>, <code>%dx</code>, <code>%dl</code>のいずれか</td></tr>
<tr><td><code>D</code></td><td><code>%rdi</code>, <code>%edi</code>, <code>%di</code>, <code>%dil</code>のいずれか</td></tr>
<tr><td><code>S</code></td><td><code>%rsi</code>, <code>%esi</code>, <code>%si</code>, <code>%sil</code>のいずれか</td></tr>
<tr><td><code>A</code></td><td>制約 <code>a</code>, <code>d</code> のいずれか</td></tr>
<tr><td><code>Q</code></td><td>制約 <code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>のいずれか</td></tr>
<tr><td><code>q</code></td><td>任意の整数レジスタ (<code>%rsp</code>と<code>%rbp</code>は使わない)</td></tr>
<tr><td><code>U</code></td><td><a href="./6-inst.html#caller-callee-save-regs">caller-save</a>レジスタ</td></tr>
</tbody></table>
</div>
<ul>
<li><code>q</code>制約は，<code>-fomit-frame-pointer</code>オプションを<code>gcc</code>に付けると<code>%rbp</code>を使用する
(<code>%rbp</code>が汎用レジスタとして使えるようになるため)</li>
</ul>
</li>
</ul>
<!--
Rを指定しても%rbpや%rspは使ってくれない
|`R`|レガシー整数レジスタ，a, b, c, d, si, di, bp, sp|
-->
<ul>
<li>x86用の制約 (定数)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody>
<tr><td><code>I</code></td><td>範囲0〜31の整数 (32ビットシフト用)</td></tr>
<tr><td><code>J</code></td><td>範囲0〜63の整数 (64ビットシフト用)</td></tr>
<tr><td><code>K</code></td><td>範囲-128〜127の整数 (符号あり8ビット整数定数用)</td></tr>
<tr><td><code>L</code></td><td><code>0xFF</code>, <code>0xFFFF</code>, <code>0xFFFFFFFF</code> (マスク用)</td></tr>
<tr><td><code>M</code></td><td><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> (メモリ参照のスケール用)</td></tr>
<tr><td><code>N</code></td><td>範囲0〜255の整数 (<code>in</code>, <code>out</code>命令用))</td></tr>
</tbody></table>
</div>
<h3 id="制約mメモリと制約rレジスタの違い"><a class="header" href="#制約mメモリと制約rレジスタの違い">制約<code>m</code>(メモリ)と制約<code>r</code>(レジスタ)の違い</a></h3>
<pre><code>// inline-asm2.c
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %0&quot;: &quot;=m&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<pre><code>$ gcc -S inline-asm2.c
$ cat inline-asm2.s
(中略)
  movq  %rsp, -16(%rbp)
</code></pre>
<pre><code>// inline-asm4.c
#include &lt;stdio.h&gt;
int main (void)
{
    void *addr;
    asm volatile (&quot;movq %%rsp, %0&quot;: &quot;=r&quot;(addr));
    printf (&quot;rsp = %p\n&quot;, addr);
}
</code></pre>
<pre><code>$ gcc -S inline-asm4.c
$ cat inline-asm4.s
(中略)
  movq  %rsp, %rax
  movq  %rax, -16(%rbp)
</code></pre>
<ul>
<li>上のコードで制約<code>m</code>(メモリ)を使うと，<code>%0</code>はメモリ参照<code>-16(%rbp)</code>に展開されました．
<code>-16(%rbp)</code>は変数 <code>addr</code>なので，変数<code>addr</code>への代入はこれで終了です．</li>
<li>一方，  制約<code>r</code>(レジスタ)を使うと，<code>%0</code>はレジスタ<code>%rax</code>に展開されました．
また，<code>%rax</code>の値を<code>addr</code>に代入するために，
グルーコード <code>movq %rsp, -16(%rbp)</code>が追加されました．</li>
</ul>
<h3 id="読み書きするオペランドには制約を使う"><a class="header" href="#読み書きするオペランドには制約を使う">読み書きするオペランドには制約<code>+</code>を使う</a></h3>
<pre><code>// inline-asm7.c
#include &lt;stdio.h&gt;
int main (void)
{
    long in = 111, out = 222;
    asm volatile (&quot;movq %1, %0&quot;: &quot;=rm&quot;(out): &quot;rm&quot; (in)); // out = in;
    printf (&quot;in = %ld, out = %ld\n&quot;, in, out);
}
</code></pre>
<pre><code>// inline-asm8.c
#include &lt;stdio.h&gt;
int main (void)
{
    long in = 111, out = 222;
    asm volatile (&quot;addq %1, %0&quot;: &quot;+rm&quot;(out): &quot;rm&quot; (in)); // out += in;
    printf (&quot;in = %ld, out = %ld\n&quot;, in, out);
}
</code></pre>
<pre><code>// inline-asm9.c
#include &lt;stdio.h&gt;
int main (void)
{
    long in = 111, out = 222;
    asm volatile (&quot;addq %1, %0&quot;: &quot;=rm&quot;(out): &quot;rm&quot; (in), &quot;0&quot; (out)); // out += in;
    printf (&quot;in = %ld, out = %ld\n&quot;, in, out);
}
</code></pre>
<img src="figs/inline-asm2.svg" height="250px" id="fig:inline-asm2">
<ul>
<li><code>inline-asm7.c</code>の❶は<code>movq</code>命令なので，<code>out</code>は出力専用です．
このため，入出力の制約は<code>=</code>を指定しています．</li>
<li>一方，<code>inline-asm8.c</code>の❷は<code>addq</code>命令なので，<code>out</code>は入力と出力の両方になります．
このため，入出力の制約は<code>+</code>を指定しています．</li>
<li><code>addq</code>命令に対しては<strong>マッチング制約</strong> (ここでは<code>&quot;0&quot;</code>)を使う方法もあります．
<code>inline-asm9.c</code>の❸では，出力オペランド列では<code>out</code>に<code>=</code>を指定し，
入力オペランド列にも<code>out</code>を指定し，その制約に<code>&quot;0&quot;</code>を指定しています．
この<code>&quot;0&quot;</code>の指定で「このオペランド<code>out</code>は出力オペランドの<code>%0</code>と同じオペランドだ」と伝えているのです．
<ul>
<li>マッチング制約で「同じオペランドだ」と指定された場合，
コンパイラはそれらのオペランドに<strong>同じレジスタやメモリ参照</strong>を
割り当てようとします．</li>
</ul>
</li>
</ul>
<h3 id="早期破壊オペランド制約"><a class="header" href="#早期破壊オペランド制約">早期破壊オペランド制約 <code>&amp;</code></a></h3>
<p>要約:</p>
<ul>
<li>入力オペランドの参照よりも<strong>前に</strong>，出力オペランドへの代入がある場合は，
<strong>早期破壊オペランド制約</strong> <code>&amp;</code>を使う必要がある．</li>
<li>早期破壊オペランド制約 <code>&amp;</code> は「同じレジスタに割り当てるな」という指示
<ul>
<li>cf. マッチング制約は「同じレジスタに割り当てろ」という指示</li>
</ul>
</li>
</ul>
<pre><code>// early-clobber.c
#include &lt;stdio.h&gt;
int main (void)
{
    int a = 20, b;
    asm volatile (&quot;movl $10, %0; addl %1, %0&quot;
                  : &quot;=r&quot;(b) : &quot;r&quot;(a)); // b = 10; b += a;
    printf (&quot;b = %d\n&quot;, b);
}
</code></pre>
<pre><code>// early-clobber2.c
#include &lt;stdio.h&gt;
int main (void)
{
    int a = 20, b;
    asm volatile (&quot;movl $10, %0; addl %1, %0&quot;
                  : &quot;=&amp;r&quot;(b) : &quot;r&quot;(a)); // b = 10; b += a;
    printf (&quot;b = %d\n&quot;, b);
}
</code></pre>
<pre><code>$ gcc -g early-clobber.c
$ ./a.out
b = 20    結果が正しくない
$ gcc -g early-clobber2.c
$ ./a.out
b = 30    結果は正しい
</code></pre>
<img src="figs/early-clobber.svg" height="250px" id="fig:early-clobber">
<!--
-->
<ul>
<li>GCCは「命令テンプレートでは，入力オペランドを全て参照した<strong>後で</strong>，
出力オペランドへ代入している」という仮定をしています．</li>
<li>その理由は多くの場合，その仮定は成り立つし，成り立てば，入力オペランドと出力オペランドに<strong>同じレジスタ</strong>を割り当てられるからです．
<ul>
<li>OKな例: <code>y = x + 3;</code> は<code>x</code>を参照した後で，<code>y</code>に代入しています．ですので，
<code>x</code>と<code>y</code>に同じレジスタ<code>%eax</code>を割り当てて，<code>addl $3, %eax</code>としてもOKです．</li>
<li>NGな例: <code>b = 10; b += a;</code>は<code>b</code>への代入の後で，入力<code>a</code>を参照しています．
GCCの仮定に反しているのに，<code>a</code>と<code>b</code>に同じレジスタ<code>%eax</code>を割り当てて
<code>movl $10, %eax; addl %eax, %eax</code>としてしまうと，<code>a</code>の元の値が破壊されてしまいます．これが上の<code>early-clobber.c</code>の状況です．</li>
</ul>
</li>
<li><code>early-clobber.c</code>(上図の左)では，出力の制約を❶<code>=</code>としているだけなので，
<code>%0</code>と<code>%1</code>が同じレジスタ <code>%eax</code>になり❷，
意図通りの計算結果になりません(<code>a</code>の初期値<code>20</code>が失われています)．</li>
<li>これを防ぐには 早期破壊オペランド制約 <code>&amp;</code> (early-clobber operand constraint)を
制約に指定します❸．その結果，<code>%0</code>と<code>%1</code>には別のアドレスが割り当てられました．</li>
</ul>
<h3 id="破壊レジスタ列"><a class="header" href="#破壊レジスタ列">破壊レジスタ列</a></h3>
<ul>
<li>
<p>出力オペランド列に指定したレジスタやメモリ以外への書き込みがある場合は，
<strong>破壊レジスタ列に指定する必要</strong>があります．
コンパイラは指定されたレジスタやメモリへの読み書きが整合する範囲でのみ，
最適化のためのasm構文の移動を考えてくれます．</p>
</li>
<li>
<p>レジスタの破壊を指定して退避される例</p>
</li>
</ul>
<pre><code>int main ()
{
    asm (&quot;movl $999, %%ebx&quot; :::&quot;%ebx&quot;);
}

</code></pre>
<pre><code>❶ pushq  %rbx             # %rbxの退避
   movl   $999, %ebx       # %rbxの上位32ビットはクリアされる
❷ movq   -8(%rbp), %rbx   # %rbxの回復
</code></pre>
<p>破壊レジスタ列に<code>%rbx</code>を指定すると，コンパイラは前後に
<code>%rbx</code>の退避❶と回復❷のコードを付け足します．
<code>%rbx</code>はcallee-saveレジスタなので，<code>main</code>関数からリターンする前に，
<code>%rbx</code>の値を元の値に戻す必要があるからです．</p>
<ul>
<li>メモリの破壊を指定してコードが変化する例</li>
</ul>
<pre><code>// clobber-mem.c
#include &lt;stdio.h&gt;
int x = 111, y = 222;
int main ()
{
    y = x;
//    asm volatile (&quot;&quot;:::&quot;memory&quot;);
    return x;
}

</code></pre>
<pre><code>// clobber-mem2.c
#include &lt;stdio.h&gt;
int x = 111, y = 222;
int main ()
{
    y = x;
    asm volatile (&quot;&quot;:::&quot;memory&quot;); // ❶
    return x;
}

</code></pre>
<pre><code>$ gcc -S clobber-mem.c
$ cat clobber-mem.s
(一部省略)
main:
    movl  x(%rip), %eax
    movl  %eax, y(%rip)
    ret
</code></pre>
<pre><code>$ gcc -S clobber-mem2.c
$ cat clobber-mem2.s
(一部省略)
main:
 ❷ pushq  %rbp
 ❷ movq   %rsp, %rbp
 ❸ movl   x(%rip), %eax
    movl   %eax, y(%rip)
    # asm volatile (&quot;&quot;:::&quot;memory&quot;);
 ❹ movl   x(%rip), %eax
 ❷ popq   %rbp
    ret
</code></pre>
<ul>
<li>上のコードで<code>&quot;memory&quot;</code>を付けてメモリの破壊の存在をコンパイラに伝えた所，
以下の2つの変化がありました
<ul>
<li>スタックフレームが壊されないように，<code>main</code>用のスタックフレームを作りました❷</li>
<li>変数<code>x</code>の値が変化しているかも知れないので，❸で読んだ値は使わず，
メモリが変化したと言われた後の ❹で改めて読んでいます．</li>
</ul>
</li>
<li>なお，上の命令テンプレート❶は空ですが，コンパイラはメモリ破壊を信じてくれています</li>
</ul>
<h3 id="gccは以外の命令テンプレートの中身を見ない"><a class="header" href="#gccは以外の命令テンプレートの中身を見ない">GCCは<code>%</code>以外の命令テンプレートの中身を見ない</a></h3>
<pre><code>// inline-hoge.c
#include &lt;stdio.h&gt;
long x = 111;
long y = 222;   
int main ()
{
    asm volatile (&quot;hogehoge %1, %0&quot;: &quot;+rm&quot; (y): &quot;rm&quot; (x));
    printf (&quot;x = %ld, y = %ld\n&quot;, x, y);
}
</code></pre>
<pre><code class="language-x86asmatt">    movq    x(%rip), %rax
    movq    y(%rip), %rdx
    hogehoge %rax, %rdx
    movq    %rdx, y(%rip)
</code></pre>
<ul>
<li>GCCは(<code>%</code>を除いて)命令テンプレートの中身は見ません．
入出力オペランド列や破壊レジスタ列などの情報だけを使って，
<code>%0</code>などの部分を展開したり，グルーコードを出力します．</li>
<li>その証拠に，上の例では存在しない命令<code>hogehoge</code>に対して，上記の展開とグルーコード付加をGCCは行いました．</li>
</ul>
<h2 id="局所変数をレジスタ割当にする"><a class="header" href="#局所変数をレジスタ割当にする">局所変数をレジスタ割当にする</a></h2>
<pre><code>// local-reg.c
#include &lt;stdio.h&gt;
int main ()
{
    register long foo asm (&quot;%r15&quot;) = 999;
    printf (&quot;%ld\n&quot;, foo);
}
</code></pre>
<ul>
<li>非常に頻繁に使う局所変数を<strong>レジスタ名を指定してレジスタ割当にしたい場合</strong>があります．その場合は上記の記法で指定できます．</li>
<li>注意:
<ul>
<li><code>register</code>は必要です．<code>static</code>, <code>const</code>, <code>volatile</code>などはつけてはいけません．</li>
<li>この記法は指定したレジスタを<strong>予約</strong>するものではありません．
コンパイラは他の部分で指定したレジスタを上書きするので，それを前提として使う必要があります．</li>
</ul>
</li>
</ul>
<h2 id="multi-dialect"><a class="header" href="#multi-dialect">アセンブラ方言の扱い</a></h2>
<ul>
<li>GCCはアセンブリ記法の方言を出力できます．例えば，x86-64では<code>gcc -masm=att</code>でAT&amp;T記法を，<code>gcc -masm=intel</code>でIntel記法を出力できます．
(デフォルトはAT&amp;T記法です)</li>
<li><code>gcc</code>へのオプション (<code>-masm=att</code>, <code>-masm=intel</code>)でどちらの記法を出力するか切り替えられますが，<strong>インラインアセンブリコードの中身は自動的には切り替わりません</strong>．</li>
<li>どちらのオプションが指定されても大丈夫にする方法がGCCにはいろいろ用意されています．．例えば，以下の記法は</li>
</ul>
<pre><code>int main ()
{
    asm volatile (&quot;{movslq %%eax, %%rbx | movsxd rbx,eax}&quot;:);
}
</code></pre>
<p>AT&amp;T形式の際は <code>movslq %%eax, %%rbx</code>を出力し，Intel形式の時は
<code>movsxd rbx,eax</code>を出力します．
(このように命令テンプレート中で，<code>{</code>, <code>|</code>, <code>}</code>も, (そして <code>=</code>も)
特別な意味を持つので，これらの文字自身を出力したい場合は，
それぞれ，<code>%{</code>, <code>%|</code>, <code>%}</code>, <code>%=</code>と記述する必要があります)．
つまり，インラインアセンブリコードを書く人が
AT&amp;T形式とIntel形式の記述の両方を併記する必要があります．
さらに，</p>
<pre><code>int main ()
{
    int x = 111;
    asm volatile (&quot;inc %q0&quot;:&quot;+r&quot; (x));
}
</code></pre>
<p>と書くと，<code>%q0</code>の部分は，AT&amp;T形式に対しては例えば<code>%rax</code>，Intel形式に対しては<code>rax</code>などと展開します．詳細は<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">GCCインラインアセンブラ</a>の
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#x86Operandmodifiers">x86 Operand Modifiers</a>を御覧ください．</p>
<!--
## 最適化器との話
### 重要な注意点:

- asm構文の入力が変わらない場合，最適化は(入力が同じなら結果も同じ，副作用なんて知らんと判断して)asm構文を移動することがある(例えば，ループの外に)
- asm構文の出力が使われない場合，最適化はそのasm構文を消去することがある

### 入力が変わらないので，asm構文が移動する例

### 出力が使われないので，asm構文が消される例
-->
<!--
ここの説明がよくまとまっている
https://www.felixcloutier.com/documents/gcc-asm.html


"="ではなく"+"を指定する．なんでや?
Be careful when you set output operands inside asm goto only on some possible control flow paths. If you don’t set up the output on given path and never use it on this path, it is okay. Otherwise, you should use ‘+’ constraint modifier meaning that the operand is input and output one. With this modifier you will have the correct values on all possible paths from the asm goto.


- 拡張asm構文の修飾子
  - `volatile` 副作用を抑止する
    - `rdtsc`命令を使う場合，`volatile`が無いと「同じ値を返す」と判断して2回めを消す可能性がある
    - `volatile`を付けても最適化が拡張asmを移動させることがある．その場合は，変数間の人工的な依存関係を作れば良い
  - `inline` asm構文中の命令バイト数の見積もりを最小値にする (最適化がインライン化しやすくなる)
  - `goto`
    - 第5引数で指定したCラベルの一つにジャンプする可能性があることをコンパイラに伝える

- 特別なフォーマット文字列

|文字列| 説明|
|-|-|
|`%%`|`%`1つを出力する|
|`%=`|asm構文の各インスタンスにユニークな数を生成する<br/>最適化がasm構文を複製したときにシンボルの二重定義を防ぐのに使うと便利|
|`%{`| `{` を出力 (`%`無しだと[特別な意味]{./8-inline.md#multi-dialect}を持つ)|
|<code>%&#124;</code>| <code>&#124;</code> を出力 (`%`無しだと[特別な意味]{./8-inline.md#multi-dialect}を持つ)|
|`%}`| `}` を出力 (`%`無しだと[特別な意味]{./8-inline.md#multi-dialect}を持つ)|



"memory"を指定すると，そのasm構文を実行前にレジスタ中の値をメモリに戻して，
asm構文実行後に(必要なら)メモリからレジスタに読み込みなおす．


asm goto で，特定のパスだけ出力値をセットする場合は要注意．
設定しなかった値を参照するなら，`+`制約を付ける必要がある．

テンプレート中でラベルを参照するには，`%l6`などと指定する(lは小文字のエル)．
あるいは`%l[foo]`とすれば，Cのラベル名`foo`を指定できる．

|オペランド修飾子|例|説明|
|-|-|-|
|`c`|`%c0`|定数オペランドを要求する|
|`n`|`%n0`|`c`と同じだが，出力時に符号反転する|
|`a`|`%a0`|メモリ参照をアドレスに置換する (`lea`命令で便利)|
|`l`|`%l0`|ラベル名にする|

|x86オペランド修飾子|例|説明|
|-|-|-|
すごいいっぱいある．
-->
<!--
- 条件フラグの取得

```
asm("subq %3, %2"
    : "=@ccc"(*carry), "=@cco"(*overflow)
    : "g"(left), "g"(right));
```
-->
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 9; }
</style>
<h1 id="gccが生成したアセンブリコードを読む"><a class="header" href="#gccが生成したアセンブリコードを読む">GCCが生成したアセンブリコードを読む</a></h1>
<p>この章では単純なCのプログラムをGCCがどのようなアセンブリコードに変換するかを見ていきます．
これより以前の章で学んだ知識を使えば，C言語のコードが意外に簡単にアセンブリコードに変換できることが分かると思います．
(実際にコンパイラの授業で構文解析の手法を学び，
最適化器を実装しなければ，コンパイラは学部生でも十分簡単に作れます)．</p>
<h2 id="制御文"><a class="header" href="#制御文">制御文</a></h2>
<h3 id="if文"><a class="header" href="#if文">if文</a></h3>
<pre><code>// if.c
int x = 111;
int main ()
{
    if (x &gt; 100) {
        x++;
    }
}
</code></pre>
<img src="figs/if.svg" height="250px" id="fig:if">
<ul>
<li>ifの条件式<code>x &gt; 100</code>は反転して「<code>x &lt;= 100</code>なら，then部分をスキップして，thenの直後(ラベル<code>.L2</code>)にジャンプする」というコードを出力しています．
(反転する必然性はありません．<code>x &gt; 0</code>を評価してその結果が<code>0</code>に等しければ，<code>.L2</code>にジャンプするコードでも(実行速度を除けば)同じ動作になります)</li>
<li>then部分では「<code>x</code>に1を加える」コードを出力しています．</li>
</ul>
<details>
<summary>
なぜGCCはinc命令を使わないの?
</summary>
<p><code>incl x(%rip)</code>なら1命令で済みますよね．
もし<code>-O</code>や<code>-O2</code>などの最適化オプションを付ければ，
GCCは<code>inc</code>を使うかも知れませんが，
そうしてしまうと，(最適化が賢すぎて)元のif文の構造がガラリと変わってしまう可能性があるため避けています．
この章では全て「最適化オプションを付けていないので，GCCは無駄なコードを出力することがある」と考えて下さい．</p>
</details>
<h3 id="if-else文"><a class="header" href="#if-else文">if-else文</a></h3>
<pre><code>// if-else.c
int x = 111;
int main ()
{
    if (x &gt; 100) {
        x++;
    } else {
        x--;
    }
}
</code></pre>
<img src="figs/if-else.svg" height="330px" id="fig:if-else">
<ul>
<li>ifの条件式<code>x &gt; 100</code>は反転して「<code>x &lt;= 100</code>なら，then部分をスキップして，thenの直後(ラベル<code>.L2</code>)にジャンプする」というコードを出力しています．</li>
<li>then部分では「<code>x</code>に1を加える．次にelse部分をスキップするために<code>.L3</code>にジャンプする」コードを出力しています．</li>
<li>else部分では「<code>x</code>から1減らす」コードを出力しています．</li>
</ul>
<h3 id="while文"><a class="header" href="#while文">while文</a></h3>
<pre><code>// while.c
int x = 111;
int main ()
{
    while (x &gt; 100) {
        x--;
    }
}
</code></pre>
<img src="figs/while.svg" height="330px" id="fig:while">
<ul>
<li>while条件判定はwhileボディのコードの後に置かれています(これは必然ではありません)．
最初にwhileループに入る時，<code>.L2</code>にジャンプします．</li>
<li>whileの条件式<code>x &gt; 100</code>が成り立つ間は，<code>.L3</code>に繰り返しジャンプします．</li>
<li>「whileボディ」実行後に必ず「while条件判定」が必要になるので，これでうまくいきます．</li>
</ul>
<h3 id="for文"><a class="header" href="#for文">for文</a></h3>
<pre><code>// for.c
int x = 111;
int main ()
{
    for (int i = 0; i &lt; 10; i++) {
        x--;
    }
}
</code></pre>
<img src="figs/for.svg" height="330px" id="fig:for">
<ul>
<li>ほぼwhile文と同じです．違いは「for初期化」 (<code>int i = 0</code>)があることと，
「forボディ」の直後に「for更新」(<code>i++</code>)があることだけです．</li>
<li>GCCが条件判定のコードを，
<code>i &lt; 10</code> (<code>cmpl $10, -4(%rbp); jl .L3</code>)ではなく，
<code>i &lt;= 9</code> (<code>compl $9, -4(%rbp); jl .l3</code>)としています．
どちらも同じなのですが，なぜこうしたのか，GCCの気持ちは分かりません．</li>
</ul>
<h3 id="switch文-単純比較"><a class="header" href="#switch文-単純比較">switch文 (単純比較)</a></h3>
<pre><code>// switch.c
int x = 111;
int main ()
{
    switch (x) {
    case 1:
        x++;
        break;
    case 111:
        x--;
        break;
    default:
        x = 0;
        break;
    }
}
</code></pre>
<img src="figs/switch.svg" height="500px" id="fig:switch">
<ul>
<li>ジャンプテーブルを使わない，単純に比較するコード生成です．
例えば，<code>case 1:</code>は，<code>if (x == 1)</code>と同様のコード生成になっています．</li>
<li>この方法ではcaseが\(n\)個あると，\(n\)回比較する必要があるので，
\(O(n)\)の時間がかかってしまいます．</li>
</ul>
<h3 id="switch-jump-table"><a class="header" href="#switch-jump-table">switch文 (ジャンプテーブル)</a></h3>
<pre><code>// switch2.c
int x = 111;
int main ()
{
    switch (x) {
    case 1:  x++;   break;
    case 2:  x--;   break;
    case 3:  x = 3; break;
    case 4:  x = 4; break;
    case 5:  x = 5; break;
    default: x = 0; break;
    }
}
</code></pre>
<pre><code>// switch3.c
int x = 111;
int main ()
{
    void *jump_table [] = {&amp;&amp;L2, &amp;&amp;L8, &amp;&amp;L7, &amp;&amp;L6, &amp;&amp;L5, &amp;&amp;L3} ; // ❶
    goto *jump_table [x]; // ❷

L8: // case 1:
    x++;   goto L9;
L7: // case 2:
    x--;   goto L9;
L6: // case 3:
    x = 3; goto L9;
L5: // case 4:
    x = 4; goto L9;
L3: // case 5:
    x = 5; goto L9;
L2: // default:
    x = 0; goto L9;
L9:
}
</code></pre>
<img src="figs/switch2.svg" height="1000px" id="fig:switch2">
<ul>
<li><code>switch2.c</code>をジャンプテーブルを使って書き換えたのが<code>switch3.c</code>です．
❶と❷の部分はGCC拡張機能で「ラベルの値を配列変数に格納し❶」，
「<code>goto</code>で格納したラベルにジャンプ❷」することができます．</li>
<li>変数<code>x</code>の値をジャンプテーブル(配列)のインデックスとして，
ジャンプ先アドレスを取得し，間接ジャンプしています．
<ul>
<li><code>movl %eax, %eax</code>はレジスタ<code>%rax</code>の上位32ビットをゼロクリアしています．</li>
<li><code>notrack</code>はIntel CET (control-flow enforcement technology)による拡張命令です．
<code>notrack</code>付きの場合，間接ジャンプ先が<code>endbr64</code>ではなくても例外は発生しなくなります．</li>
</ul>
</li>
<li>ジャンプテーブルを使うと，\(O(1)\)でcase文を選択できます．
ただし，ジャンプテーブルが使えるのはcaseが指定する範囲がある程度，
密な場合に限ります(巨大な配列を使えば，疎な場合でも扱えますが…)．</li>
</ul>
<h2 id="定数-1"><a class="header" href="#定数-1">定数</a></h2>
<h3 id="整数定数"><a class="header" href="#整数定数">整数定数</a></h3>
<pre><code>// const-int.c
int main ()
{
    return 999;
}
</code></pre>
<pre><code class="language-x86asmatt">main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❶ $999, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>整数定数 <code>999</code> は❶即値 (<code>$999</code>)としてコード生成されています</li>
</ul>
<h3 id="文字定数"><a class="header" href="#文字定数">文字定数</a></h3>
<pre><code>// const-char.c
int main ()
{
    return 'A';
}
</code></pre>
<pre><code class="language-x86asmatt">main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❶ $65, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>文字定数は❶即値 (<code>$65</code>, 65は文字<code>A</code>のASCIIコード)としてコード生成されています</li>
</ul>
<h3 id="文字列定数"><a class="header" href="#文字列定数">文字列定数</a></h3>
<pre><code>// const-string.c
#include &lt;stdio.h&gt;
int main ()
{
    puts (&quot;hello\n&quot;);
}
</code></pre>
<pre><code class="language-x86asmatt">❶  .section  .rodata
❷ .LC0:
❸  .string &quot;hello\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    leaq ❹ .LC0(%rip), %rax
    movq    %rax, %rdi
    call    puts@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>文字列定数 <code>&quot;hello\n&quot;</code>の実体は❶<code>.rodata</code>セクションに置かれます．
❸<code>.string</code>命令で<code>&quot;hello\n&quot;</code>のバイナリ値を配置し，
その先頭アドレスを❷ラベル<code>.LC0:</code>と定義しています．</li>
<li>式中の<code>&quot;hello\n&quot;</code>の値は「その文字列の先頭アドレス」ですので，
❹ <code>.LC0(%rip)</code>と参照しています(ここでは文字列の先頭アドレスが<code>%rax</code>に格納されます)</li>
</ul>
<h3 id="配列"><a class="header" href="#配列">配列</a></h3>
<pre><code>// array3.c
int a [] = {111, 222, 333};
int main ()
{
    return a [2];
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  a
    .data
    .align 8
    .type   a, @object
    .size   a, 12
❶ a:
❷  .long   111
❷  .long   222
❷  .long   333

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❸ 8+a(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>配列はメモリ上で連続する領域に配置されます．
この場合は❷ <code>.long</code>命令で4バイトずつ，<code>111</code>, <code>222</code>, <code>333</code>の2進数を隙間なく配置しています．個人的には <code>.long 111, 222, 333</code>と１行で書いてくれる方が嬉しいのですが…
(なお，配列とは異なり，構造体の場合はメンバー間や最後にパディング(隙間)が入ることがあります)</li>
<li>配列の先頭アドレスを❶ラベル<code>a:</code>と定義しています．</li>
<li><code>a[2]</code>の参照は❸ <code>8+a(%rip)</code>という<code>%rip</code>相対のメモリ参照になっています．
指定したインデックスが定数(<code>2</code>)だったため，変位が <code>8+a</code>になっています．
(<code>a[i]</code>などとインデックスが変数の場合はアセンブラの足し算は使えません)．</li>
</ul>
<h3 id="構造体"><a class="header" href="#構造体">構造体</a></h3>
<pre><code>// struct5.c
struct foo {
    char x1;
    int x2;
};
struct foo f = {10, 20};
int main ()
{
    return f.x2;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8
    .type   f, @object
    .size   f, 8
❶ f:
❷  .byte   10 # x1
❸  .zero   3  # 3バイトのパディング
❹  .long   20 # x2

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❺ 4+f(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>構造体<code>foo</code>がメモリ上に配置される際，アラインメント制約を満たすために
<a href="./4-data.html#alignment-padding">パディング</a>が入ることがあります．</li>
<li>ここでは，メンバー❷<code>x1</code>と❹<code>x2</code>の間に❸3バイトのパディングが入っています．</li>
<li>構造体メンバーの参照 <code>foo.x2</code>は
❺<code>4+f(%rip)</code>という<code>%rip</code>相対のメモリ参照になっています．</li>
</ul>
<h3 id="共用体"><a class="header" href="#共用体">共用体</a></h3>
<pre><code>// union2.c
#include &lt;stdio.h&gt;
union foo {
    char x1 [5];
    int  x2;
};
union foo f = {.x1[0] = 'a'};

int main ()
{
    f.x2 = 999;
    return f.x2;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 8
    .type   f, @object
❶  .size   f, 8
❷ f:
❸  .byte   97
❹  .zero   4
❺  .zero   3

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❻ f(%rip)
    movl ❼ f(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>共用体は以下を除き，構造体と一緒です
<ul>
<li>同時に1つのメンバーにしか代入できない</li>
<li>全てのメンバーはオフセット0でアクセスする</li>
<li>共用体のサイズは最大サイズを持つメンバ＋パディングのサイズになる
<ul>
<li>上の例では最大サイズのメンバ <code>char x1 [5]</code>に3バイトのパディングがついて，
共用体 <code>f</code>のサイズは8バイトになってます</li>
</ul>
</li>
</ul>
</li>
<li>上の例では<strong>指示付き初期化子</strong>(designated initializer)の記法
(<code>union foo f = {.x1[0] = 'a'};</code>)を使って，メンバ<code>x1</code>を初期化しています．
❸<code>'a'</code>の値が<code>.byte</code>で配置され，残りの7バイトは❹❺<code>0</code>で初期化されています．</li>
<li>共用体<code>f</code>への代入や参照はメモリ参照❻❼<code>f(%rip)</code>でアクセスされています．</li>
</ul>
<h2 id="変数"><a class="header" href="#変数">変数</a></h2>
<h3 id="初期化済みの静的変数"><a class="header" href="#初期化済みの静的変数">初期化済みの静的変数</a></h3>
<pre><code>// var-init-static.c
int x = 999;
int main ()
{
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
❶  .data
    .align 4
    .type   x, @object
    .size   x, 4
❷ x:
❸  .long   999

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl ❹ x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>初期化済みの静的変数の実体は❶<code>.data</code>セクションに配置されます．
初期値 (<code>999</code>)を(この場合は<code>int</code>型なので)<code>.long</code>命令で
<code>999</code>のバイナリ値を配置し，その先頭アドレスをラベル<code>x:</code>と定義しています．</li>
<li>変数<code>x</code>の参照は❹<code>x(%rip)</code>という<code>%rip</code>相対のメモリ参照です．</li>
</ul>
<h3 id="未初期化の静的変数"><a class="header" href="#未初期化の静的変数">未初期化の静的変数</a></h3>
<pre><code>// var-uninit-static.c
int x;
int main ()
{
    x = 999;
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
❶  .bss
    .align 4
    .type   x, @object
    .size   x, 4
❷ x:
❸  .zero   4

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❹ x(%rip)
    movl    ❺ x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>未初期化の静的変数の実体は❶ <code>.bss</code>セクションに配置されます．
<code>.bss</code>セクション中の変数は❸ゼロで初期化されます．
初期化した4バイトの先頭アドレスをラベル❷ <code>x:</code>と定義しています．
<ul>
<li>ただし<code>.bss</code>セクションが実際にゼロで初期化されるのは実行直前です</li>
</ul>
</li>
<li>変数<code>x</code>の参照は，メモリ参照❹❺ <code>x(%rip)</code>でアクセスされています．</li>
</ul>
<h3 id="自動変数-static無しの局所変数"><a class="header" href="#自動変数-static無しの局所変数">自動変数 (<code>static</code>無しの局所変数)</a></h3>
<pre><code>// var-auto.c
int main ()
{
    int x;
    x = 999;
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $999, ❶ -4(%rbp)
    movl ❷ -4(%rbp), %eax
    popq    %rbp
    ret
</code></pre>
<img src="figs/stack-layout3.svg" height="300px" id="fig:stack-layout3">
<ul>
<li>自動変数は実行時にスタック上にその実体が配置されます．
上の例では変数<code>x</code>は❶❷<code>-4(%rbp)</code>から始まる4バイトに割り当てられ，
アクセスされています．
(この変数<code>x</code>は<a href="./2-asm-intro.html#redzone">レッドゾーン</a>に配置されています)</li>
</ul>
<h3 id="実引数"><a class="header" href="#実引数">実引数</a></h3>
<pre><code>// arg.c
void foo (long a1, long a2, long a3, long a4, long a5, long a6, long a7);
int main ()
{
    foo (10, 20, 30, 40, 50, 60, 70);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❹  subq    $8, %rsp    # パディング
❷  pushq   $70         # 第7引数
❶  movl    $60, %r9d   # 第6引数
❶  movl    $50, %r8d   # 第5引数
❶  movl    $40, %ecx   # 第4引数
❶  movl    $30, %edx   # 第3引数
❶  movl    $20, %esi   # 第2引数
❶  movl    $10, %edi   # 第1引数
❸  call    foo@PLT
❺  addq    $16, %rsp   # 第7引数とパディングを捨てる
    movl    $0, %eax
    leave
    ret
</code></pre>
<img src="figs/arg.svg" height="200px" id="fig:arg">
<ul>
<li>第6引数までは❶<a href="./6-inst.html#arg-reg">レジスタ渡し</a>になります．
第7引数以降は❷スタックに積んでから関数を呼び出します．</li>
<li><a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>
により
❸<code>call</code>命令実行時には<code>%rsp</code>の値は16の倍数である必要があります．
そのため，❹で8バイトのパディングをスタックに置いています．</li>
<li>関数からリターン後は❷でスタックに積んだ引数と❹パディングを❸スタック上から取り除きます．</li>
</ul>
<h3 id="仮引数"><a class="header" href="#仮引数">仮引数</a></h3>
<pre><code>// parameter.c
#include &lt;stdio.h&gt;
void
foo (long a1, long a2, long a3, long a4, long a5, long a6, long a7)
{
    printf (&quot;%ld\n&quot;, a1 + a7);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .section .rodata
.LC0:
    .string &quot;%ld\n&quot;
    .text
    .globl  foo
    .type   foo, @function
foo:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $48, %rsp
    movq ❶ %rdi, -8(%rbp)   # 第1引数
    movq ❶ %rsi, -16(%rbp)  # 第2引数
    movq ❶ %rdx, -24(%rbp)  # 第3引数
    movq ❶ %rcx, -32(%rbp)  # 第4引数
    movq ❶ %r8, -40(%rbp)   # 第5引数
    movq ❶ %r9, -48(%rbp)   # 第6引数
    movq    -8(%rbp), %rdx  
    movq ❷ 16(%rbp), %rax   # 第7引数
    addq    %rdx, %rax
    movq    %rax, %rsi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    nop
    leave
    ret
</code></pre>
<img src="figs/parameter.svg" height="400px" id="fig:parameter">
<ul>
<li>GCCはレジスタで受け取った第1〜第6引数をスタック上に❶置いています．
一方，第7引数はスタック渡しで，その場所は❻<code>16(%rbp)</code>でした．</li>
</ul>
<h2 id="式-expression"><a class="header" href="#式-expression">式 (expression)</a></h2>
<h3 id="単項演算子-unary-operator"><a class="header" href="#単項演算子-unary-operator">単項演算子 (unary operator)</a></h3>
<pre><code>// unary.c
int x = 111;
int main ()
{
    return -x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111
    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  negl    %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>単項演算は対応する命令，ここでは❶ <code>negl</code>を使うだけです．</li>
</ul>
<h3 id="二項演算子単純な加算"><a class="header" href="#二項演算子単純な加算">二項演算子(単純な加算)</a></h3>
<pre><code>// binop-add.c
int x = 111;
int main ()
{
    return x + 89;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  addl    $89, %eax
    popq    %rbp
        ret
</code></pre>
<ul>
<li>基本的に二項演算子も対応する命令 (ここでは❷<code>addl</code>)を使うだけです．</li>
</ul>
<h3 id="二項演算子割り算"><a class="header" href="#二項演算子割り算">二項演算子(割り算)</a></h3>
<pre><code>// binop-div.c
int x = 111, y = 9;
int main ()
{
    return x / y;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .globl  y
    .align 4
    .type   y, @object
    .size   y, 4
y:
    .long   9

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
    movl    y(%rip), %ecx
❷  cltd
❶  idivl   %ecx
    popq    %rbp
    ret
</code></pre>
<ul>
<li>割り算はちょっと注意が必要です．</li>
<li>例えば，32ビット符号ありの割り算を❶<code>idivl</code>命令で行う場合，
<code>%edx:%eax</code>を第1オペランドで割った商が<code>%eax</code> に入ります．</li>
<li>このため，<code>idivl</code>を使う前に❷<code>cltd</code>命令等を使って，
<code>%eax</code>を符号拡張した値を<code>%edx</code>に設定しておく必要があります
(<code>%edx</code>の値の設定を忘れるて<code>%idivl</code>を実行すると，割り算の結果がおかしくなります)</li>
</ul>
<h3 id="二項演算ポインタ演算"><a class="header" href="#二項演算ポインタ演算">二項演算(ポインタ演算)</a></h3>
<ul>
<li>復習: C言語のポインタ演算 (オペランドがポインタの場合の演算)は普通の加減算と意味が異なります．ポインタが指す先のサイズを使って計算する必要があります．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>演算</th><th>意味 (<code>int i, *p, *q</code>の場合)</th></tr></thead><tbody>
<tr><td><code>p + i</code></td><td><code>p + (i * sizeof (*p))</code></td></tr>
<tr><td><code>i + q</code></td><td><code>p + (i * sizeof (*p))</code></td></tr>
<tr><td><code>p + q</code></td><td>コンパイルエラー</td></tr>
<tr><td><code>p - i</code></td><td><code>p - (i * sizeof (*p))</code></td></tr>
<tr><td><code>i - q</code></td><td>コンパイルエラー</td></tr>
<tr><td><code>p - q</code></td><td><code>(p - q) / sizeof (*p)</code></td></tr>
</tbody></table>
</div>
<pre><code>// pointer-arith.c
#include &lt;stdio.h&gt;
int a [] = {0, 10, 20, 30};
int main ()
{
    printf (&quot;%p, %p\n&quot;, a, &amp;a[0]);     // 同じ
    printf (&quot;%p, %p, %p\n&quot;, &amp;a[2], a + 2, 2 + a); // 同じ
    printf (&quot;%p, %p\n&quot;, a, &amp;a[2] - 2); // 同じ
    printf (&quot;%ld\n&quot;, &amp;a[2] - &amp;a[0]);
    // printf (&quot;%p\n&quot;, &amp;a[2] + &amp;a[0]);    // コンパイルエラー
    // printf (&quot;%p\n&quot;, 2 - &amp;a[2]);        // コンパイルエラー
}
</code></pre>
<pre><code>$ gcc -g -no-pie pointer-arith.c
$ ./a.out
0x404030, 0x404030
0x404038, 0x404038, 0x404038
0x404030, 0x404030
2
</code></pre>
<img src="figs/array3.svg" height="400px" id="fig:array3">
<ul>
<li>復習: 式中で配列名(<code>a</code>)はその配列の先頭要素のアドレス(<code>&amp;a[0]</code>)を意味します．</li>
<li>復習: 式中で配列要素へのアクセス <code>a[i]</code>は，
<code>*(a+i)</code>や<code>*(i+a)</code>と書いても同じ意味です．</li>
<li>例えば，上の例で<code>a+2</code>は，配列の要素が<code>int</code>型で，<code>sizeof(int)</code>が4なので，
\(0x404030 + 2\times 4 = 0x404038\) という計算になります．
このため，<code>a+2</code>は<code>&amp;a[2]</code>と同じ値になります．</li>
</ul>
<pre><code>// pointer-arith2.c
int a [] = {0, 10, 20, 30};
int* foo ()
{
    return a + 2; // ❶
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  a
    .data
    .align 16
    .type   a, @object
    .size   a, 16
a:
    .long   0
    .long   10
    .long   20
    .long   30

    .text
    .globl  foo
    .type   foo, @function
foo:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    leaq ❷ 8+a(%rip), %rax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>上の例でCコード中の❶<code>a+2</code>は，アセンブリコード中では❷<code>8+a</code>になっています．
配列要素のサイズ4をかけ算して，\(a + 2\times 4\)という計算をするからです．</li>
</ul>
<h3 id="アドレス演算子と逆参照演算子"><a class="header" href="#アドレス演算子と逆参照演算子">アドレス演算子<code>&amp;</code>と逆参照演算子<code>*</code></a></h3>
<pre><code>// op-addr.c
int x = 111;
int *p;
int main ()
{
    p = &amp;x;
    return *p;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .globl  p
    .bss
    .align 8
    .type   p, @object
    .size   p, 8
p:
    .zero   8

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  leaq    x(%rip), %rax
    movq    %rax, p(%rip)
❷  movq    p(%rip), %rax
❸  movl    (%rax), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>アドレス演算子<code>&amp;x</code>には変数<code>x</code>のアドレスを計算すれば良いので，<code>leaq</code>命令を使います．
具体的には❶<code>leaq x(%rip), %rax</code>で，<code>x</code>の絶対アドレスを<code>%rax</code>に格納しています．</li>
<li>逆参照演算子<code>*p</code>にはメモリ参照を使います．
まず❷<code>movq p(%rip), %rax</code>で変数<code>p</code>の中身を<code>%rax</code>に格納し，
❸<code>movl (%rax), %eax</code>とすれば，メモリ参照<code>(%rax)</code>で<code>p</code>が指す先の値を得られます．</li>
</ul>
<h3 id="比較演算子"><a class="header" href="#比較演算子">比較演算子</a></h3>
<pre><code>// pred.c
int x = 111;
int main ()
{
    return x &gt; 100;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
❶  cmpl    $100, %eax
❷  setg    %al
❸  movzbl  %al, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li><code>&gt;</code>などの比較演算子には<a href="./x86-list.html#set"><code>set␣</code></a>命令を使います．</li>
<li>例えば，<code>x &gt; 100</code>の場合，
<ul>
<li>❶<code>cmpl</code>命令で比較を行い，</li>
<li>❷<code>setg</code>を使って「より大きい」という条件が成り立っているかどうかを<code>%al</code>に格納し</li>
<li>❸<code>movzbl</code>を使って，必要なサイズ(ここでは4バイト)にゼロ拡張しています</li>
</ul>
</li>
</ul>
<h3 id="論理andと論理or左から右への評価"><a class="header" href="#論理andと論理or左から右への評価">論理ANDと論理OR，「左から右への評価」</a></h3>
<pre><code>// land.c
int x = 111;
int main ()
{
    return 50 &lt; x &amp;&amp; x &lt; 200;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    x(%rip), %eax
    cmpl    $50, %eax
❶  jle     .L2             # if x &lt;= 50 goto .L2
    movl    x(%rip), %eax
    cmpl    $199, %eax
❷  jg      .L2             # if x &gt; 199 goto .L2
    movl    $1, %eax        # 結果に1をセット
    jmp     .L4
.L2:
    movl    $0, %eax        # 結果に0をセット
.L4:
    popq    %rbp
    ret
</code></pre>
<ul>
<li>
<p>多くの二項演算子では「両方のオペランドを計算してから，その二項演算子 (例えば加算)を行う」というコードを生成すればOKです．</p>
</li>
<li>
<p>しかし，論理AND (<code>&amp;&amp;</code>) や論理OR (<code>||</code>)ではそのやり方ではNGです．
論理ANDと論理ORは<strong>左から右への評価</strong> (left-to-right evaluation)を
行う必要があるからです．</p>
<ul>
<li>
<p>論理ANDでは，まず左オペランドを計算し，その結果が真の時だけ，
右オペランドを計算します．(左オペランドが偽ならば，右オペランドを計算せず，全体の結果を偽とする)</p>
</li>
<li>
<p>論理OR では，まず左オペランドを計算し，その結果が偽の時だけ，
右オペランドを計算します．(左オペランドが真ならば，右オペランドを計算せず，全体の結果を真とする)</p>
</li>
<li>
<p>要するに左オペランドだけで結果が決まる時は，右オペランドを計算してはいけないのです．
このおかげで，以下のようなコードが記述可能になります．
(右オペランド <code>*p &gt; 100</code>が評価されるのは<code>p</code>が<code>NULL</code>ではない場合のみになります)</p>
<pre><code>int *p;
if (p != NULL &amp;&amp; *p &gt; 100) { ...
</code></pre>
</li>
</ul>
</li>
<li>
<p>このため，上のコード例でも❶左オペランドが真の場合だけ，
❷右オペランドが計算されています．</p>
</li>
</ul>
<h3 id="assignment"><a class="header" href="#assignment">代入</a></h3>
<pre><code>// assign.c
int x = 111;
int main ()
{
    return x = 100;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $100, x(%rip)
❷  movl    x(%rip), %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>代入式は単純に❶<code>mov</code>命令を使えばOKです．</li>
<li>代入式には(代入するという副作用以外に)「代入した値そのものを
その代入式の評価結果とする」という役割もあります．
　そのため❷で，<code>return</code>で返す値を<code>%eax</code>に格納しています．</li>
</ul>
<h2 id="文-statement"><a class="header" href="#文-statement">文 (statement)</a></h2>
<h3 id="式文"><a class="header" href="#式文">式文</a></h3>
<pre><code>// exp-stmt.c
int x = 111;
int main ()
{
    x = 222;
    333;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $222, x(%rip)
    movl    $0, %eax
    popq    %rbp
    ret

</code></pre>
<ul>
<li>復習: 式にセミコロン<code>;</code>を付けたものが<strong>式文</strong>です．</li>
<li><code>x = 222;</code>という式文(代入文)は，<a href="./9-code.html#assignment">代入式</a>の
❶ <code>mov</code>命令をそのまま出力すればOKです．
<ul>
<li>式文中の式の計算にスタックを使った場合は，スタック上の値を捨てる必要があることがあります</li>
</ul>
</li>
<li><code>333;</code>は文法的に正しい式文なのですが，意味がないのでGCCはこの式文を無視しました</li>
</ul>
<h3 id="ブロック文"><a class="header" href="#ブロック文">ブロック文</a></h3>
<pre><code>// block-stmt.c
int x = 111;
int main ()
{
    {
        x = 222;
        x = 333;
        x = 444;
    }
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $222, x(%rip)  # 文1
❷  movl    $333, x(%rip)  # 文2
❸  movl    $444, x(%rip)  # 文3
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>復習: <strong>ブロック文</strong> (あるいは<strong>複合文</strong> (compound statement))は，
複数の文が並んだ文です．</li>
<li>ブロック文のコード出力は簡単で，文の並びの順番に，それぞれの
アセンブリコード❶❷❸を出力するだけです．</li>
</ul>
<h3 id="goto文とラベル文"><a class="header" href="#goto文とラベル文">goto文とラベル文</a></h3>
<pre><code>// goto.c
int x = 111;
int main ()
{
foo:
    x = 222;
    goto foo;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
.L2:
    movl    $222, x(%rip)
    jmp     .L2
</code></pre>
<ul>
<li>C言語のラベル<code>foo</code>はアセンブリコードでは<code>.L2</code>になっていますが，
(名前の重複に気をつければ)ラベルとして出力すればOKです</li>
<li><code>goto</code>文もそのまま無条件ジャンプ<code>jmp</code>にすればOKです</li>
</ul>
<h3 id="return文-intを返す"><a class="header" href="#return文-intを返す">return文 (<code>int</code>を返す)</a></h3>
<pre><code>// return.c
int x = 111;
int main ()
{
    return x;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  x
    .data
    .align 4
    .type   x, @object
    .size   x, 4
x:
    .long   111

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    x(%rip), %eax
❷  popq    %rbp
❸  ret
</code></pre>
<ul>
<li><code>int</code>などの整数型を返す<code>return</code>文は簡単です．
❶返す値を<code>%rax</code>レジスタに格納し，❷スタックフレームの後始末をしてから，
❸<code>ret</code>命令で，リターンアドレスに制御を移せばOKです．</li>
</ul>
<h3 id="return文-構造体を返す"><a class="header" href="#return文-構造体を返す">return文 (構造体を返す)</a></h3>
<pre><code>// return2.c
struct foo {
    char x1;
    long x2;
};
struct foo f = {'A', 0x1122334455667788};
struct foo func ()
{
    return f;
}
</code></pre>
<pre><code class="language-x86asmatt">    .globl  f
    .data
    .align 16
    .type   f, @object
    .size   f, 16
f:
    .byte   65
    .zero   7
    .quad   1234605616436508552

    .text
    .p2align 4
    .globl  func
    .type   func, @function
func:
    endbr64
❶  movq    8+f(%rip), %rdx
❷  movq    f(%rip), %rax
    ret
</code></pre>
<ul>
<li>
<p>復習: C言語では，配列や関数を，関数の引数に渡したり，関数から返すことはできません (配列へのポインタや，関数へのポインタなら可能ですが)．
一方，構造体や共用体は，関数の引数に渡したり，関数から返すことができます．</p>
</li>
<li>
<p>8バイトより大きい構造体や共用体を関数引数や返り値にする場合，
通常のレジスタ以外のレジスタやスタックを使ってやりとりをします．
具体的な方法は
<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>
が定めています．</p>
</li>
<li>
<p>上の例では<code>%rax</code>と<code>%rdx</code>を使って，構造体<code>f</code>を関数からリターンしています．
(コードが簡単になるように，ここでは<code>gcc -O2 -S</code>の出力を載せています)</p>
</li>
</ul>
<h2 id="関数"><a class="header" href="#関数">関数</a></h2>
<h3 id="関数定義"><a class="header" href="#関数定義">関数定義</a></h3>
<pre><code>// add5.c
int add5 (int n)
{
    return n + 5;
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  add5
    .type   add5, @function
❷ add5:                      # 関数名のラベル定義
    endbr64
    pushq   %rbp              # スタックフレーム作成
    movq    %rsp, %rbp        # スタックフレーム作成
❶  movl    %edi, -4(%rbp)    # 関数本体
❶  movl    -4(%rbp), %eax    # 関数本体
❶  addl    $5, %eax          # 関数本体
    popq    %rbp              # スタックフレーム破棄
    ret                       # リターン
    .size   add5, .-add5
</code></pre>
<ul>
<li>関数を定義するには関数本体のアセンブリコード❶の前に<strong>関数プロローグ</strong>，
後に<strong>関数エピローグ</strong>のコードを出力します．
また，関数の先頭で❷関数名のラベル(<code>add5;</code>)を定義します．</li>
<li>関数プロローグはスタックフレームの作成や，callee-saveレジスタの退避などを行います．</li>
<li>関数エピローグはcallee-saveレジスタの回復や，スタックフレームの破棄などを行い，<code>ret</code>でリターンします．</li>
</ul>
<h3 id="関数コール"><a class="header" href="#関数コール">関数コール</a></h3>
<pre><code>// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main ()
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
❶  movl    $10, %edi
❷  call    add5@PLT
❸  movl    %eax, %esi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>関数コールをするには，<code>call</code>命令の前に引数をレジスタやスタック上に格納してから，
<code>call</code>命令を実行します．その後，<code>%rax</code>に入っている返り値を引き取ります．</li>
<li>上の例では，
<ul>
<li>❶で <code>10</code>を第1引数として<code>%edi</code>レジスタにセットしてから，</li>
<li>❷で <code>call</code>を実行して，制御を<code>add5</code>関数に移します</li>
<li>❸で<code>add5</code>の返り値 (<code>%eax</code>)を引き取っています</li>
</ul>
</li>
<li>デフォルトの動的リンクを前提としたコンパイルなので，
関数名が<code>add5</code>ではなく❷<code>add5@PLT</code>となっています
(<a href="./3-binary.html#GOT-PLT">PLTについてはこちら</a>を参照)</li>
</ul>
<h3 id="関数コール関数ポインタ"><a class="header" href="#関数コール関数ポインタ">関数コール(関数ポインタ)</a></h3>
<pre><code></code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp
❶  movq    add5@GOTPCREL(%rip), %rax # GOT領域のadd5のエントリ(中身はadd5の絶対アドレス)
    movq    %rax, -8(%rbp)
    movq    -8(%rbp), %rax
❷  movl    $10, %edi
❸  call    *%rax
    movl    %eax, %esi
    leaq    .LC0(%rip), %rax
    movq    %rax, %rdi
    movl    $0, %eax
    call    printf@PLT
    movl    $0, %eax
    leave
    ret
</code></pre>
<ul>
<li>上のコード例では<code>add5</code>を変数<code>fp</code>に代入して，
<code>fp</code>中の関数ポインタを使って，<code>add5</code>を呼び出しています．</li>
<li>これをアセンブリコードにすると❶ <code>movq add5@GOTPCREL(%rip), %rax</code>になります．
<code>add5@GOTPCREL</code>はGOT領域の<code>add5</code>のエントリなので，
メモリ参照<code>add5@GOTPCREL(%rip)</code>で，<code>add5</code>の絶対アドレスを取得できます
(<a href="./3-binary.html#GOT-PLT">GOT領域についてはこちら</a>を参照)</li>
<li>❷で第1引数(<code>10</code>)を<code>%edi</code>に渡して</li>
<li>❸<code>call *%rax</code>で<code>%rax</code>中の関数ポインタを間接コールしています</li>
</ul>
<h3 id="ライブラリ関数コール"><a class="header" href="#ライブラリ関数コール">ライブラリ関数コール</a></h3>
<pre><code>// main.c
#include &lt;stdio.h&gt;
int add5 (int n);
int main ()
{
    printf (&quot;%d\n&quot;, add5 (10));
}
</code></pre>
<pre><code class="language-x86asmatt">    .section        .rodata
.LC0:
    .string &quot;%d\n&quot;

    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $10, %edi
    call    add5@PLT
❷  movl    %eax, %esi
❶  leaq    .LC0(%rip), %rax
❶  movq    %rax, %rdi
❸  movl    $0, %eax
❹  call    printf@PLT
    movl    $0, %eax
    popq    %rbp
    ret
</code></pre>
<ul>
<li>ここではライブラリ関数代表として，<code>printf</code>を呼び出すコードを見てみます．
<ul>
<li>❶で<code>printf</code>の第1引数である文字列<code>&quot;%d\n&quot;</code>の先頭アドレス
(<code>.LC0(%rip)</code>)を第1引数のレジスタ<code>%rdi</code>に格納します</li>
<li>❷は<code>add5</code>が返した値を，第2引数のレジスタ<code>%esi</code>に格納します</li>
<li>❸で<code>%eax</code>に<code>0</code>を格納しています．
<ul>
<li><code>%al</code>は<code>printf</code>などの可変長引数を持つ関数の<strong>隠し引数</strong>です</li>
<li><code>%al</code>にはベクタレジスタを使って渡す浮動小数点数の引数の数をセットします</li>
<li>これは<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a>が定めています</li>
</ul>
</li>
<li>❹で<code>printf</code>をコールしています</li>
</ul>
</li>
</ul>
<h3 id="システムコール-1"><a class="header" href="#システムコール-1">システムコール</a></h3>
<pre><code>// syscall-exit.c
#include &lt;unistd.h&gt;
int main ()
{
    _exit (0);
}
</code></pre>
<pre><code class="language-x86asmatt">    .text
    .globl  main
    .type   main, @function
main:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $0, %edi
❶  call    _exit@PLT
</code></pre>
<ul>
<li><code>exit</code>はライブラリ関数なので，ここではシステムコールである<code>_exit</code>を呼び出しています．</li>
<li>が，<code>_exit</code>もただの<strong>ラッパ関数</strong>で，
<code>_exit</code>の中で実際のシステムコールを呼び出します．
このため，❶を見れば分かる通り，<code>_exit</code>の呼び出しは
ライブラリ関数の呼び出し方と同じになります．</li>
</ul>
<pre><code class="language-bash">$ objdump -d /lib/x86_64-linux-gnu/libc.so.6 | less
(中略)
00000000000eac70 &lt;_exit&gt;:
   eac70:       f3 0f 1e fa             endbr64 
   eac74:       4c 8b 05 95 e1 12 00    mov    0x12e195(%rip),%r8        # 218e10 &lt;_DYNAMIC+0x250&gt;
   eac7b:       be e7 00 00 00          mov    $0xe7,%esi
   eac80:       ba 3c 00 00 00          mov    $0x3c,%edx
   eac85:       eb 16                   jmp    eac9d &lt;_exit+0x2d&gt;
   eac87:       66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
   eac8e:       00 00 
   eac90:       89 d0                   mov    %edx,%eax
   eac92:       0f 05                ❶ syscall 
   eac94:       48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
   eac9a:       77 1c                   ja     eacb8 &lt;_exit+0x48&gt;
   eac9c:       f4                      hlt    
   eac9d:       89 f0                   mov    %esi,%eax
   eac9f:       0f 05                ❶ syscall 
<span class="boring">   eaca1:       48 3d 00 f0 ff ff       cmp    $0xfffffffffffff000,%rax
</span><span class="boring">   eaca7:       76 e7                   jbe    eac90 &lt;_exit+0x20&gt;
</span><span class="boring">   eaca9:       f7 d8                   neg    %eax
</span><span class="boring">   eacab:       64 41 89 00             mov    %eax,%fs:(%r8)
</span><span class="boring">   eacaf:       eb df                   jmp    eac90 &lt;_exit+0x20&gt;
</span><span class="boring">   eacb1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
</span><span class="boring">   eacb8:       f7 d8                   neg    %eax
</span><span class="boring">   eacba:       64 41 89 00             mov    %eax,%fs:(%r8)
</span><span class="boring">   eacbe:       eb dc                   jmp    eac9c &lt;_exit+0x2c&gt;
</span></code></pre>
<ul>
<li><code>_exit</code>関数の中身を逆アセンブルしてみると，
❶<code>syscall</code>命令を使ってシステムコールを呼び出している部分を見つけられます．
(お作法を正しく守れば，<code>_exit</code>を使わず，直接，<code>syscall</code>でシステムコールを呼び出すこともできます)</li>
</ul>
<h3 id="memcpyと最適化"><a class="header" href="#memcpyと最適化"><code>memcpy</code>と最適化</a></h3>
<ul>
<li>
<p>ライブラリ関数<code>memcpy</code>の呼び出しは，最適化の有無により例えば次の3パターンになります:</p>
<ul>
<li><code>call memcpy</code>  (通常の関数コール)</li>
<li><code>movdqa src(%rip), %xmm0; movaps  %xmm0, dst(%rip)</code> (SSE/AVX命令)</li>
<li><code>rep movsq</code> (ストリング命令)</li>
</ul>
</li>
<li>
<p>最適化無しの場合</p>
</li>
</ul>
<pre><code>// memcpy.c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
char src [4096], dst [4096];
int main ()
{
    memcpy (dst, src, 64);
}
</code></pre>
<pre><code>$ gcc -S memcpy.c
$ cat memcpy.s
main:
    pushq   %rbp
    movq    %rsp, %rbp
    movl    $64, %edx
    leaq    src(%rip), %rax
    movq    %rax, %rsi
    leaq    dst(%rip), %rax
    movq    %rax, %rdi
    call    memcpy@PLT    # 普通の call命令でライブラリ関数memcpyを呼ぶ
</code></pre>
<ul>
<li>
<p>最適化した場合</p>
<pre><code>$ gcc -S -O2 memcpy.c
$ cat memcpy.s
main:
    movdqa  src(%rip), %xmm0     # 16バイト長の%xmm0レジスタに16バイトコピー
    movdqa  16+src(%rip), %xmm1
    xorl    %eax, %eax
    movdqa  32+src(%rip), %xmm2
    movdqa  48+src(%rip), %xmm3
    movaps  %xmm0, dst(%rip)     # %xmm0レジスタからメモリに16バイトコピー
    movaps  %xmm1, 16+dst(%rip)
    movaps  %xmm2, 32+dst(%rip)
    movaps  %xmm3, 48+dst(%rip)
</code></pre>
<ul>
<li><code>memcpy.c</code>を<code>-O2</code>でコンパイルすると，<code>movdqa</code>と<code>movaps</code>命令を使うコードを出力しました．アラインメントなどの条件が合うと，こうなります．</li>
<li><code>%xmm0</code>〜<code>%xmm3</code>はSSE拡張で導入された16バイト長のレジスタです．</li>
</ul>
</li>
<li>
<p>サイズを増やして最適化した場合</p>
</li>
</ul>
<pre><code>// memcpy2.c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
char src [4096], dst [4096];
int main ()
{
    memcpy (dst, src, 1024);
}
</code></pre>
<pre><code>$ gcc -S -O2 memcpy2.c
$ cat memcpy.s
main:
    leaq    dst(%rip), %rax
    leaq    src(%rip), %rsi
    movl    $128, %ecx
    movq    %rax, %rdi
    xorl    %eax, %eax
    rep movsq
</code></pre>
<ul>
<li>サイズを増やすと，<code>rep movsq</code>という<a href="./x86-list.html#string-insn">ストリング命令</a>を出力しました．</li>
<li><code>rep movsq</code>は，<code>%ecx</code>回の繰り返しを行います．
各繰り返しでは，メモリ<code>(%rsi)</code>の値を<code>(%rdi)</code>に8バイトコピーし，
<code>%rsi</code>と<code>%rdi</code>の値を8増やします．
(DFフラグが1の場合は8減らしますが，ABIが「関数の出入り口で(DF=1にしていたら)DF=0に戻せ」と定めているので，ここではDF=0です)</li>
</ul>
<details>
<summary>
%rsiと%rdiの名前の由来
</summary>
<p><code>%rsi</code>は source index，<code>%rdi</code>は destination index が名前の由来です．</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 10; }
</style>
<h1 id="デバッガgdbの使い方"><a class="header" href="#デバッガgdbの使い方">デバッガ<code>gdb</code>の使い方</a></h1>
<h2 id="デバッガの概要"><a class="header" href="#デバッガの概要">デバッガの概要</a></h2>
<h3 id="なぜデバッガ"><a class="header" href="#なぜデバッガ">なぜデバッガ?</a></h3>
<img src="figs/debugger-why.svg" height="200px" id="fig:debugger-why">
<ul>
<li><code>gdb</code>などのデバッガの使用をお薦めする理由は「プログラムのデバッグ」を<strong>とても楽にしてくれる</strong>からです！！</li>
<li>デバッグが難しいのは実行中のプログラムの中身（実行状態）が外からでは見えにくいからです．
<code>printf</code>を埋め込むことでも変数の値や実行パスを調べられますが，
デバッガを使うともっと効率的に調べることができます．</li>
<li>デバッガは「簡単に習得できて，効果も高いお得な開発ツール」です．
慣れることが大事です．</li>
<li>デバッガはつまみ食いOKです．
最初は「自分が使いたい機能，使える機能」だけを使えばいいのです．
デバッガを使うために「デバッガの全て」を学ぶ必要はありません．</li>
</ul>
<h3 id="デバッガとは"><a class="header" href="#デバッガとは">デバッガとは</a></h3>
<img src="figs/debugger-what.svg" height="200px" id="fig:debugger-what">
<p>デバッガは主に以下の機能を組み合わせて，プログラムの実行状態を調べることで，
バグの原因を探します．</p>
<ul>
<li>① プログラム実行の一時停止:
「実行を止めたい場所(<strong>ブレークポイント</strong>)」や止めたい条件を設定できます．
ブレークポイントには関数名や行番号やアドレスなどを指定できます．</li>
<li>② <strong>ステップ実行</strong>:
①でプログラムの実行を一時停止した後，
ステップ実行の機能を使って，ちょっとずつ実行を進めます．</li>
<li>③ 実行状態の表示:
変数の値，現在の行番号，スタックトレース(バックトレース)などを表示できます．</li>
<li>④ 実行状態の変更:
変数に別の値を代入したり，関数を呼び出したりして，
「ここでこう実行したら」を試せます．</li>
</ul>
<h3 id="gdbとは"><a class="header" href="#gdbとは"><code>gdb</code>とは</a></h3>
<ul>
<li><strong>Linux</strong>上で使える代表的で高性能なデバッガです．</li>
<li>C/C++/<strong>アセンブリ言語</strong>/Objective-C/Rustなど，多くの言語をサポートしています．</li>
<li><strong>Linux/x86-64</strong>を含む，多くのOSやプロセッサに対応しています．</li>
<li>オープンソースで無料で使えます (GNU GPLライセンス)．</li>
<li>一次情報: <a href="https://www.sourceware.org/gdb/">GDB: The GNU Project Debugger</a></li>
</ul>
<h2 id="gdbの実行例-c言語編"><a class="header" href="#gdbの実行例-c言語編"><code>gdb</code>の実行例 (C言語編)</a></h2>
<h3 id="起動-run-と終了-quit"><a class="header" href="#起動-run-と終了-quit">起動 <code>run</code> と終了 <code>quit</code></a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc ❶ -g hello.c
$ ./a.out
hello
$ ❷ gdb ./a.out
❸(gdb) ❹ run
hello
(gdb) ❺ quit
A debugging session is active.
	Inferior 1 [process 20186] will be killed.
Quit anyway? (y or n)  ❻ y
$
</code></pre>
<ul>
<li><code>gdb</code>でデバッグする前に，<code>gcc</code>のコンパイルに❶<code>-g</code>オプションを付けます．
<code>-g</code>は<code>a.out</code>に<a href="./3-binary.html#%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%83%85%E5%A0%B1">デバッグ情報</a>を付加します．
デバッグ情報がなくてもデバッグは可能ですが，
ファイル名や行番号などの情報が表示されなくなり不便です．</li>
</ul>
<details>
<summary>
gcc -g -Og オプションがベスト
</summary>
<p><code>gdb</code>のマニュアルに以下の記述があります．</p>
<ul>
<li><code>-O2</code>などの最適化オプションを付けてコンパイルしたプログラムでも<code>gdb</code>で
デバッグできるが，行番号がずれたりする．なので可能なら
最適化オプションを付けない方が良い．</li>
<li><code>gdb</code>でデバッグするベストな最適化オプションは<code>-Og</code>であり，
<code>-Og</code>は<code>-O0</code>よりも良い．</li>
</ul>
<p>ですので，デバッグ時には <code>gcc -g -Og</code>オプションがベストなようです．</p>
</details>
<details>
<summary>
Inferior はデバッグ対象のプログラムのこと
</summary>
<p>上の実行例中の<code>Inferior 1 [process 20186] will be killed.</code>は
「<code>gdb</code>の終了に伴って，デバッグ対象のプログラムも実行終了させます」という
ことを意味しています．
inferiorは「下位の」「劣った」という意味ですね
(劣等感は英語で inferiority complex)．
<code>gdb</code>のマニュアルでもデバッグ対象のプログラムを一貫してinferiorと呼んでいます．
なお他の文献ではデバッグ対象のプログラムのことをデバッギ (debuggee)と呼ぶことがあります．</p>
</details>
<ul>
<li>❷ <code>gdb ./a.out</code> と，引数にデバッグ対象のバイナリ(ここでは<code>./a.out</code>)を指定して<code>gdb</code>を起動します．</li>
</ul>
<details>
<summary>
gdb起動メッセージの抑制
</summary>
<p>デフォルトで<code>gdb</code>を起動すると以下のような長い起動メッセージが出ます．</p>
<pre><code class="language-bash">$ gdb ./a.out 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
<span class="boring">There is NO WARRANTY, to the extent permitted by law.
</span><span class="boring">Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
</span><span class="boring">This GDB was configured as &quot;x86_64-linux-gnu&quot;.
</span><span class="boring">Type &quot;show configuration&quot; for configuration details.
</span><span class="boring">For bug reporting instructions, please see:
</span><span class="boring">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
</span><span class="boring">Find the GDB manual and other documentation resources online at:
</span><span class="boring">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
</span><span class="boring">
</span><span class="boring">For help, type &quot;help&quot;.
</span><span class="boring">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
</span><span class="boring">Reading symbols from ./a.out...
</span><span class="boring">(gdb) 
</span></code></pre>
<p>これを抑制するには，<code>gdb -q</code>オプションを付けるか，
<code>~/.gdbearlyinit</code>ファイルに以下を指定します．</p>
<pre><code>set startup-quietly on
</code></pre>
</details>
<ul>
<li>❸ <code>(gdb)</code> は<code>gdb</code>のプロンプトです．<code>gdb</code>のコマンドが入力可能なことを示します．</li>
<li>❹ <code>run</code>は<code>gdb</code>上で<strong>プログラムの実行を開始</strong>します．
ここではブレークポイントを指定していないため，そのまま<code>hello</code>を出力して
プログラムは終了しました．</li>
<li>❺ <code>quit</code>は<code>gdb</code>を終了させます．
(ここではすでにデバッグ対象のプログラムの実行は終了していますが)
デバッグ対象のプログラムが終了しておらず，
「本当に終了して良いか?」と聞かれたら，❻ <code>y</code>と答えて終了させます．</li>
</ul>
<details>
<summary>
コマンドの省略名
</summary>
<p><code>gdb</code>のコマンドは(区別できる範囲で)短く省略できます．
例えば，<code>run</code>は<code>r</code>，<code>quit</code>は<code>q</code>，それぞれ1文字でコマンドを指定できます．
慣れてきたらコマンドの省略名を使いましょう．</p>
</details>
<h3 id="コマンドライン引数argvを指定して実行"><a class="header" href="#コマンドライン引数argvを指定して実行">コマンドライン引数<code>argv</code>を指定して実行</a></h3>
<pre><code>// argv.c
#include &lt;stdio.h&gt;
int main (int argc, char *argv[])
{
    for (int i = 0; i &lt; argc; i++) {
        printf (&quot;argv[%d]=%s\n&quot;, i, argv [i]);
    }
}
</code></pre>
<pre><code>$ gcc -g argv.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ run a b c d
argv[0]=/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
argv[1]=a
argv[2]=b
argv[3]=c
argv[4]=d
[Inferior 1 (process 20303) exited normally]
(gdb) 
</code></pre>
<ul>
<li>コマンドライン引数を与えてデバッグしたい場合は，
<code>run</code>コマンドに続けて引数を与えます(ここでは<code>a b c d</code>)．</li>
</ul>
<h3 id="標準入出力を切り替えて実行"><a class="header" href="#標準入出力を切り替えて実行">標準入出力を切り替えて実行</a></h3>
<pre><code>// cat.c
#include &lt;stdio.h&gt;
int main ()
{
    int c;
    while ((c = getchar ()) != EOF) {
        putchar (c);
    }
}
</code></pre>
<pre><code>$ gcc -g cat.c
$ cat foo.txt
hello
byebye
$ gdb ./a.out
(gdb) run ❶ &lt; foo.txt ❷ &gt; out.txt
(gdb) quit
$ cat out.txt
hello
byebye
</code></pre>
<ul>
<li>標準入出力をリダイレクトして(切り替えて)実行したい場合は，
通常のシェルのときと同様に<code>run</code>コマンドの後で，
❶ <code>&lt;</code> や❷ <code>&gt;</code>を使って行います．</li>
</ul>
<h3 id="segmentation-fault-あるいは-bus-errorの原因を探る"><a class="header" href="#segmentation-fault-あるいは-bus-errorの原因を探る">segmentation fault (あるいは bus error)の原因を探る</a></h3>
<pre><code>// segv.c
#include &lt;stdio.h&gt;
int main ()
{
    int *p = (int *)0xDEADBEEF; // アクセスNGそうなアドレスを代入
    printf (&quot;%d\n&quot;, *p); 
}
</code></pre>
<pre><code>$ gcc -g segv.c
$ ./a.out
❶ Segmentation fault (core dumped)
$ gdb ./a.out
(gdb) r
Program received signal SIGSEGV, ❷ Segmentation fault.
0x0000555555555162 in ❸ main () at ❹ segv.c:6
6	 ❺ printf (&quot;%d\n&quot;, *p); 
(gdb) ❻ print/x p
$1 = ❼ 0xdeadbeef
(gdb) ❽ print/x *p
❾ Cannot access memory at address 0xdeadbeef
(gdb) quit
</code></pre>
<ul>
<li><code>segv.c</code>をコンパイルして実行すると❶ segmentation fault が起きました．
segumentation fault や bus error は正しくないポインタを使用して
メモリにアクセスすると発生します．</li>
<li><code>gdb</code>上で<code>a.out</code>を実行すると，<code>gdb</code>上でも ❷ segmentation fault が起きました．
発生場所は ❹ ファイル<code>segv.c</code>の<code>6行目</code>，❸ <code>main</code>関数内と表示されています．
また，6行目のソースコード ❺ <code>printf (&quot;%d\n&quot;, *p);</code>も表示されています．</li>
<li>変数<code>p</code>が怪しいので，❻ <code>print/x p</code>コマンドで変数<code>p</code>の値を表示させます．
<code>/x</code>は「16進数で表示」を指示するオプションです．
怪しそうな<code>0xDEADBEEF</code>という値が表示されました．
(<code>print</code>コマンドは<code>p</code>と省略可能です)．</li>
</ul>
<details>
<summary>
怪しいアドレスとは
</summary>
<p>まず，8の倍数ではないアドレスは怪しいです(正しいアドレスのこともあります)．
特に奇数のアドレスは怪しいです(正しいこともありますが)．
<a href="./4-data.html#alignment">アラインメント制約</a>を守るため，
多くのデータが4の倍数や8の倍数のアドレスに配置されるからです．</p>
<p>また慣れてくると，例えば「<code>0x7ffde9a98000</code>はスタックのアドレスっぽい」と
感じるようになります．
「これ，どこのメモリだろう」と思ったら
<a href="./3-binary.html#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%9E%E3%83%83%E3%83%97%E3%82%92%E8%A6%8B%E3%82%8B">メモリマップ</a>
や<code>gdb</code>上で<code>info proc map</code>の結果を見て調べるのが良いです．</p>
</details>
<ul>
<li>念のため，<code>print</code>コマンドで<code>*p</code>を表示させると
(❽ <code>print/x *p</code>)，
この番地にはアクセスできないことが確認できました
(❾ <code>Cannot access memory at address 0xdeadbeef</code>)．</li>
</ul>
<h3 id="変数の値を表示-print"><a class="header" href="#変数の値を表示-print">変数の値を表示 (<code>print</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) ❶ b main
Breakpoint 1 at 0x1131: file calcx.c, line 3.
(gdb) ❷ r
❸ Breakpoint 1, main () at calcx.c:3
3	 ❹ int x = 10;
(gdb) ❺ s
❻ 4	    x += 3;
(gdb) ❼ p x
❽ $1 = 10
(gdb) s
5	    x += 4;
(gdb) p x
$2 = 13
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>s</code>(<code>step</code>), <code>p</code>(<code>print</code>), <code>q</code>(<code>quit</code>)</li>
<li>❶ <code>b main</code>で，<code>main</code>関数にブレークポイントを設定し，
❷ <code>r</code>で実行を開始すると，❸<code>main関数で実行が一時停止しました． ❹ </code>int x = 10;`は次に実行する文です(まだ<strong>実行していません</strong>)．</li>
</ul>
<details>
<summary>
breakで設定できる場所
</summary>
<p>ここでは<code>b main</code>と関数名を指定しました．
他にも以下のように行番号やファイル名も使えます．</p>
<div class="table-wrapper"><table><thead><tr><th>場所の指定</th><th>説明</th></tr></thead><tbody>
<tr><td><code>b 10</code></td><td>(今実行中のファイルの)10行目</td></tr>
<tr><td><code>b +5</code></td><td>今の実行地点から5行後</td></tr>
<tr><td><code>b -5</code></td><td>今の実行地点から5行前</td></tr>
<tr><td><code>b main</code></td><td>(今実行中のファイルの)関数<code>main</code></td></tr>
<tr><td><code>b main.c:main</code></td><td>ファイル<code>main.c</code>中の<code>main</code>関数</td></tr>
<tr><td><code>b main.c:10</code></td><td>ファイル<code>main.c</code>の10行目</td></tr>
</tbody></table>
</div></details>
<ul>
<li>❺ <code>s</code>で，1行だけ実行を進めます．
4行目 (❻ <code>4  x += 3;</code>)を実行する手前で実行が止まります．</li>
<li>ここで <code>❼ p x</code>として <code>x</code>の値を表示させます．
<code>❽ $1 = 10</code>と表示され，<code>x</code>の値は<code>10</code>と分かりました．
(<code>$1</code>は<code>gdb</code>中で使える変数ですが，ここでは使っていません)．</li>
</ul>
<h3 id="変数の値を自動表示-display"><a class="header" href="#変数の値を自動表示-display">変数の値を自動表示 (<code>display</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) ❶ disp x
❷ 1: x = 21845
(gdb) s
5	    x += 3;
❸ 1: x = 10
(gdb) s
6	    x += 4;
❹ 1: x = 13
(gdb) s
7	    return x;
❺ 1: x = 17
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>s</code>(<code>step</code>), <code>disp</code>(<code>display</code>), <code>q</code>(<code>quit</code>)</li>
<li>「何度も<code>p x</code>と入力するのが面倒」という人は<code>display</code>を使って，
変数の値を自動表示させましょう．<code>display</code>は実行が停止するたびに，
指定した変数の値を表示します．</li>
<li>ここでは❶ <code>disp x</code>として，変数<code>x</code>の値を自動表示させます．
(❷ <code>1: x = 21845</code>と出てるのは，変数<code>x</code>が未初期化のため，ゴミの値が表示されたからです)．</li>
<li><code>s</code>で1行ずつ実行を進めるたびに，
変数<code>x</code>の値が，❸ <code>1: x = 10</code>→ ❹ <code>1: x = 13</code>→ ❺ <code>1: x = 17</code> と変化するのが分かります．</li>
</ul>
<h3 id="条件付きブレークポイントの設定とバックトレース表示-break-if-backtrace"><a class="header" href="#条件付きブレークポイントの設定とバックトレース表示-break-if-backtrace">条件付きブレークポイントの設定とバックトレース表示 (<code>break if</code>, <code>backtrace</code>)</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
(gdb) ❶ b fact if n==0
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❷ r
❸ Breakpoint 1, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❹ bt
#0  fact (n=0) at fact.c:5
#1  0x0000555555555172 in fact (n=1) at fact.c:8
#2  0x0000555555555172 in fact (n=2) at fact.c:8
#3  0x0000555555555172 in fact (n=3) at fact.c:8
#4  0x0000555555555172 in fact (n=4) at fact.c:8
#5  0x0000555555555172 in fact (n=5) at fact.c:8
❺#6  0x000055555555518a in main () at fact.c:13
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>bt</code>(<code>backtrace</code>), <code>q</code>(<code>quit</code>)</li>
<li>❶ <code>b fact if n==0</code>で，引数<code>n</code>が<code>0</code>の時だけ<code>fact</code>の実行を停止する設定をして，
❷ <code>r</code>で実行を開始すると，意図通り ❸ <code>fact (n=0)</code>で実行停止できました．</li>
<li>ここで，❹<code>bt</code>として<strong>バックトレース</strong>を表示させます．
バックトレースとは「今，実行中の関数から遡って<code>main</code>関数に至るまでの
関数呼び出し系列」のことです．
❺<code>main</code>関数から，<code>fact(n=5)</code>→<code>fact(n=4)</code>→(中略)
→<code>fact(n=0)</code>と呼び出されたことが分かります．</li>
<li>なお，<code>backtrace full</code>とすると，
バックトレースに加えて，局所変数の値も表示されます．</li>
</ul>
<blockquote>
<p>注: Ubuntu 20.04 LTSなど，少し古いLinuxを使っている人は
バックトレース中の引数の値が間違った表示
になることがあります(私はなりました)．
これは<a href="https://stackoverflow.com/questions/64697087/gdb-shows-incorrect-arguments-of-functions-for-stack-frames">古い<code>gdb</code>が<code>endbr64</code>命令に非対応だったから</a>です．
Ubuntu 22.04 LTSなど最新のLinuxにすることをお勧めします (2023年8月現在)．</p>
</blockquote>
<h3 id="変数や式の変更監視-watch"><a class="header" href="#変数や式の変更監視-watch">変数や式の変更監視 (<code>watch</code>)</a></h3>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) ❶ wa x
Hardware watchpoint 2: x
(gdb) ❷ c
Continuing.

Hardware watchpoint 2: x
❸ Old value = 21845
❹ New value = 10
main () at calcx.c:5
5	    x += 3;
(gdb) c
Continuing.

Hardware watchpoint 2: x
Old value = 10
New value = 13
main () at calcx.c:6
6	    x += 4;
(gdb) c
Continuing.

Hardware watchpoint 2: x
Old value = 13
New value = 17
main () at calcx.c:7
7	    return x;
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>wa</code>(<code>watch</code>), <code>c</code>(<code>continue</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>watch</code>は指定した変数や式の変化(書き込み)を監視します．
「どこで値が変わるのかわからない」という場合に便利です．
ここでは ❶ <code>wa x</code>として変数<code>x</code>を監視する設定を行い，
実行を再開します (❷ <code>c</code>)．
変更箇所で自動的にブレークされて，
変更前後の値が表示されました(❸ <code>Old value = 21845</code>，❹ <code>New value = 10</code>)．</p>
</li>
<li>
<p><code>break</code>と同様に，<code>watch</code>にも<code>if</code>で条件を指定できます．
例えば，<code>wa x if x==13</code>とすると，変数の値が<code>13</code>になった時点でブレークできます．</p>
</li>
<li>
<p><code>watch</code>はハードウェア機能を使うため，
高速ですが指定できる個数に限りがあります．</p>
</li>
<li>
<p><code>watch</code>には<code>-l</code>というオプションを指定可能です．
このオプションを指定すると，指定した変数や式を評価して，
その結果のアドレスへの書き込みを(変数のスコープを無視して)監視します．
評価結果がアドレスでなかった場合(つまり左辺値を持たない式だった場合)は<code>gdb</code>はエラーを表示します．</p>
</li>
<li>
<p><code>watch</code>は「書き込み」を監視します．
「読み込み」を監視したい時は<code>rwatch</code>，
「読み書き」の両方を監視したい時は<code>awatch</code>を使って下さい．</p>
</li>
</ul>
<h3 id="set-var-x"><a class="header" href="#set-var-x">実行中断と，実行途中での変数の値の変更</a></h3>
<pre><code>// inf-loop.c
#include &lt;stdio.h&gt;
int main ()
{
    int x = 1, n = 0;
    while (x != 0) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g inf-loop.c
$ gdb ./a.out
(gdb) r

❶ ^C
❷ Program received signal SIGINT, Interrupt.
main () at inf-loop.c:7
7	    while (x != 0) {
(gdb) ❸ p x=0
$1 = 0
(gdb) ❹ c
Continuing.
❺ hello, world
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>r</code>(<code>run</code>), <code>p</code>(<code>print</code>), <code>c</code>(<code>continue</code>), <code>q</code>(<code>quit</code>)</li>
<li>このプログラムは無限ループがあるため，実行を開始すると
<code>gdb</code>に制御が戻ってきません．そこで，<code>ctrl-c</code> (❶ <code>^C</code>)を入力して
プログラムを一時停止します．</li>
<li>変数<code>x</code>の値をゼロにすれば無限ループを抜けるので，
<code>print</code>コマンドで ❸ <code>p x=0</code>とすることで，変数<code>x</code>にゼロを代入します．
このように<code>print</code>コマンドは変数を変更したり，
副作用のある関数を呼び出すことができます(例えば，<code>p printf(&quot;hello\n&quot;)</code>として)．</li>
<li>実行を再開すると (❹<code>c</code>)，❺ <code>hello, world</code>が表示され，
無事に無限ループを抜けることができました．</li>
</ul>
<h3 id="再開場所の変更-jump"><a class="header" href="#再開場所の変更-jump">再開場所の変更 (<code>jump</code>)</a></h3>
<pre><code>// inf-loop2.c
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main ()
{
    int n = 0;
    while (time (NULL)) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g inf-loop2.c
$ gdb ./a.out
(gdb) r

^C
Program received signal SIGINT, Interrupt.
main () at inf-loop2.c:8
8	        n++;
(gdb) ❶ l
3	#include &lt;time.h&gt;
4	int main ()
5	{
6	    int n = 0;
7	    while (time (NULL)) {
8	        n++;
9	    }
❷ 10	    printf (&quot;hello, world\n&quot;);
11	}
(gdb) ❸ j 10
Continuing at 0x555555555191.
❹ hello, world
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>r</code>(<code>run</code>), <code>l</code>(<code>list</code>), <code>j</code>(<code>jump</code>), <code>q</code>(<code>quit</code>)</li>
<li><a href="10-gdb.html#set-var-x">先程</a>と異なり，今回，無限ループを抜けるのに，
単純に変数の値を変える方法は使えません．
(システムコール<code>time</code>は1970/1/1からの経過秒数を返します)．
そこで，ここでは<code>jump</code>コマンドを使います．
<code>jump</code>は「指定した場所から実行を再開」します．
(一方，<code>continue</code>は「実行を一時停止した場所から実行を再開」します)．</li>
</ul>
<details>
<summary>
別の方法
</summary>
<p>別の方法として，<code>time</code>が返した戻り値は<code>%rax</code>レジスタに入っているので，
<code>time</code>からのリターン直後に<code>p $rax=0</code>とする方法もあります
(レジスタ<code>%rax</code>の値が<code>0</code>になります)．
また <code>p $rip=0x0000555555555191</code>として，直接 <code>%rip</code>レジスタの値を
変更する方法もあります(<code>jump</code>コマンドの中身はまさにこれでしょう)．</p>
</details>
<ul>
<li>何行目から実行を再開すればよいかを調べるために，
<code>list</code>コマンドを使ってソースコードの一部を表示します．
(<code>list</code>に表示する行番号や関数名を指定することもできます)．
10行目から再開すれば良さそうと分かります．</li>
<li>10行目から実行を再開すると(❷ <code>j 10</code>)，
無事に無限ループを抜けられました (❸ <code>hello, world</code>)．</li>
</ul>
<img src="figs/gdb-layout-src.png" height="300px" id="fig:gdb-layout-src">
<p>なお，<code>layout src</code>とすると，ソースコードを表示するウインドウが現れます．
ソースコードと現在の実行位置を見ながらデバッグできるので便利です．
(時々画面が乱れるので，その時は<code>ctrl-l</code>(コントロールL)を押して，
画面を再描画して下さい)．
このモードから抜けるには，<code>tui disable</code>あるいは<code>ctrl-x a</code>を入力します．</p>
<h3 id="型の表示-whatis-ptype"><a class="header" href="#型の表示-whatis-ptype">型の表示 (<code>whatis</code>, <code>ptype</code>)</a></h3>
<pre><code>// struct2.c
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt; // for size_t

struct foo {
   int a1;
   char a2;
   size_t a3;
};

int main ()
{
    struct foo f = {10, 'a', 20};
    printf (&quot;%d\n&quot;, f.a1);
}
</code></pre>
<pre><code>$ gcc -g struct2.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1155: file struct2.c, line 12.
(gdb) r
Breakpoint 1, main () at struct2.c:12
12	    struct foo f = {10, 'a', 20};
(gdb) ❶ whatis f
type = struct foo
(gdb) ❷ ptype f
type = struct foo {
    int a1;
    char a2;
    size_t a3;
}
(gdb) ❸ ptype/o f
/* offset      |    size */  type = struct foo {
/*      0      |       4 */    int a1;
/*      4      |       1 */    char a2;
/* XXX  3-byte hole      */
/*      8      |       8 */    size_t a3;

                               /* total size (bytes):   16 */
                             }
(gdb) ❹ ptype struct foo
type = struct foo {
    int a1;
    char a2;
    size_t a3;
}
(gdb) ❺ whatis f.a3
type = size_t
(gdb) ❻ ptype f.a3
type = unsigned long
(gdb) ptype size_t
type = unsigned long
(gdb) ❼ info types foo
All types matching regular expression &quot;foo&quot;:

File struct2.c:
4:	struct foo;
(gdb) q
</code></pre>
<ul>
<li>
<p><code>whatis</code>や<code>ptype</code>は式や型名の型情報を表示します．</p>
</li>
<li>
<p><code>whatis</code>は構造体の中身を表示しませんが (❶ <code>whatis f</code>)，
<code>ptype</code>は表示します (❷ <code>ptype f</code>)．
<code>/o</code>オプションを付けると，構造体のフィールドのオフセットとサイズ，
構造体中のパディング(ホール，穴)も表示してくれます
(❸ <code>ptype/o f</code>)．</p>
</li>
<li>
<p><code>whatis</code>や<code>ptype</code>には型名も指定できます (❹ <code>ptype struct foo</code>)．</p>
</li>
<li>
<p><code>whatis</code>は<code>typedef</code>を1レベルまでしか展開しませんが (❺ <code>whatis f.a3</code>)，
<code>ptype</code>は全て展開します (❻ <code>ptype f.a3</code>)．</p>
</li>
<li>
<p><code>info types</code>を使うと，正規表現にマッチする型名一覧を表示します
(❼ <code>info types foo</code>)．</p>
</li>
</ul>
<h2 id="gdbの実行例-アセンブリ言語編"><a class="header" href="#gdbの実行例-アセンブリ言語編"><code>gdb</code>の実行例 (アセンブリ言語編)</a></h2>
<h3 id="アドレス指定でブレイクレジスタの値を表示"><a class="header" href="#アドレス指定でブレイクレジスタの値を表示">アドレス指定でブレイク，レジスタの値を表示</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g hello.c
$ gdb ./a.out
(gdb) ❶ b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❷ disas
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
❸ =&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❹ b *0x0000555555555149
Breakpoint 2 at 0x555555555149: file hello.c, line 4.
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Breakpoint 2, main () at hello.c:4
4	{
(gdb) ❺ disp/i $rip
1: x/i $rip
❻ =&gt; 0x555555555149 &lt;main&gt;:	endbr64 
(gdb) ❼ si
0x000055555555514d	4	{
❽ 1: x/i $rip
❾ =&gt; 0x55555555514d &lt;main+4&gt;:	push   %rbp
(gdb) si
0x000055555555514e	4	{
1: x/i $rip
=&gt; 0x55555555514e &lt;main+5&gt;:	mov    %rsp,%rbp
(gdb) ❿ p/x $rbp
$1 = 0x1
(gdb) ⓫ i r
rax            0x555555555149      93824992235849
rbx            0x0                 0
rcx            0x555555557dc0      93824992247232
rdx            0x7fffffffdfb8      140737488347064
rsi            0x7fffffffdfa8      140737488347048
rdi            0x1                 1
rbp            0x1                 0x1
rsp            0x7fffffffde90      0x7fffffffde90
(長いので中略)
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disas</code>(<code>disassemble</code>), <code>si</code>(<code>stepi</code>), <code>p</code>(<code>print</code>), <code>i r</code>(<code>info registers</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p>まず，<code>main</code>関数にブレークポイントを設定して(❶ <code>b main</code>)，
実行を開始すると実行が一時停止するのですが，
逆アセンブル (❷ <code>disas</code>)して確かめると，
機械語命令レベルでは<code>main</code>関数の先頭で実行を一時停止していません．</p>
<ul>
<li>❸ <code>=&gt; 0x0000555555555151 &lt;+8&gt;:</code>　の <code>&lt;+8&gt;</code>が
「<code>main</code>関数の先頭から8バイト目」であることを示しています．
<code>gdb</code>は関数名を指定してブレークした場合，
<a href="./6-inst.html#prologue">関数プロローグ</a>が終わった場所でブレークします．</li>
<li><code>disassemble</code>は逆アセンブル結果を表示します．
何も指定しないと実行中の場所付近の逆アセンブル結果を表示します．
関数名やアドレスを指定することも可能です．
また，<code>disassemble</code>には以下のオプションを指定可能です．</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">オプション</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>/s</code></td><td>ソースコードも表示 (表示順は機械語命令の順番)</td></tr>
<tr><td style="text-align: center"><code>/m</code></td><td>ソースコードも表示 (表示順はソースコードの順番)</td></tr>
<tr><td style="text-align: center"><code>/r</code></td><td>機械語命令の16進ダンプも表示</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>ここでは<code>main</code>関数の先頭番地を指定してブレークポイントを設定してみます
(❹ <code>b *0x0000555555555149</code>)．行番号と区別するため <code>*</code>が必要です．
実行を開始するとブレークしました．</p>
</li>
<li>
<p>ブレークした番地と，その番地の機械語命令を表示すると便利です．
そのため，❺ <code>disp/i $rip</code>としました．
これはプログラムカウンタ<code>%rip</code>の値を命令として(<code>i</code>, instruction)自動表示せよ，
という意味です．(<code>gdb</code>ではレジスタを指定するのに<code>%rip</code>ではなく，
<code>$rip</code>のようにドルマーク<code>$</code>を使います)．
これにより，❻ <code>=&gt; 0x555555555149 &lt;main&gt;: endbr64</code>が表示されました．</p>
<ul>
<li>次に実行する番地は <code>0x555555555149</code>番地</li>
<li>その番地の命令は <code>endbr64</code>命令</li>
</ul>
</li>
<li>
<p><code>stepi</code> (❼ <code>si</code>)を使うと，1行ではなく，機械語命令を1つ実行する
ステップ実行になります．
❺<code>disp/i $rip</code>の効果で，
次に実行される命令の番地とニモニックが表示されました
(❾ <code>=&gt; 0x55555555514d &lt;main+4&gt;: push   %rbp</code>)．
なお，❽ <code>1: x/i $rip</code>とあるのは，
❺<code>disp/i $rip</code>は<code>print</code>ではなく，
<code>x/i $rip</code>コマンドで機械語命令を出力するからです
(<code>x</code>はメモリ中の値を表示するコマンドです．
<code>/i</code>はフォーマット指定で「機械語命令」(instruction)を意味します)．</p>
</li>
<li>
<p>レジスタの値を表示するには<code>print</code>を使います (❿ <code>p/x $rbp</code>)
<code>/x</code>はフォーマット指定で「16進数」(hexadecimal)を意味します．
値は1でした (<code>$1 = 0x1</code>)．</p>
</li>
<li>
<p>なお，<code>info registers</code> (⓫ <code>i r</code>)で，全ての汎用レジスタの値を
一括表示できます．</p>
</li>
</ul>
<h3 id="メモリ中の値機械語命令を表示する-x"><a class="header" href="#メモリ中の値機械語命令を表示する-x">メモリ中の値(機械語命令)を表示する (<code>x</code>)</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) disp/x $rip
1: /x $rip = &lt;error: No registers.&gt;
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
1: /x $rip = 0x555555555151
(gdb) ❶ disas/r
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	f3 0f 1e fa	endbr64 
   0x000055555555514d &lt;+4&gt;:	55	push   %rbp
   0x000055555555514e &lt;+5&gt;:	48 89 e5	mov    %rsp,%rbp
❷ =&gt; 0x0000555555555151 &lt;+8&gt;:	48 8d 05 ac 0e 00 00	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	48 89 c7	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	e8 f0 fe ff ff	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	b8 00 00 00 00	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	5d	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	c3	ret    
End of assembler dump.
(gdb) ❸ x/7xb 0x0000555555555151
❹ 0x555555555151 &lt;main+8&gt;:	0x48	0x8d	0x05	0xac	0x0e	0x00	0x00
(gdb) ❺ x/7xb $rip
0x555555555151 &lt;main+8&gt;:	0x48	0x8d	0x05	0xac	0x0e	0x00	0x00
(gdb) ❻ x/7xb $rip+7
0x555555555158 &lt;main+15&gt;:	0x48	0x89	0xc7	0xe8	0xf0	0xfe	0xff
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disp</code> (<code>display)</code>, <code>disas</code>(<code>disassemble</code>), <code>x</code>(<code>x</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p>16進ダンプ付き(<code>/r</code>)で逆アセンブルすると (❶ <code>disas/r</code>)，</p>
</li>
</ul>
<pre><code>❷ =&gt; 0x0000555555555151 &lt;+8&gt;:	48 8d 05 ac 0e 00 00	lea    0xeac(%rip),%rax        # 0x555555556004
</code></pre>
<p>と表示されました．
<code>0x0000555555555151</code>番地には <code>lea 0xeac(%rip),%rax</code>という命令があり，
機械語バイト列としては <code>48 8d 05 ac 0e 00 00</code>だと分かりました．</p>
<ul>
<li>
<p><code>x</code>コマンドでメモリ中の値を表示できます．
例えば，❸ <code>x/7xb 0x0000555555555151</code>は，
「<code>0x0000555555555151</code>番地のメモリの値を表示せよ．
表示は1バイト単位(<code>b</code>)，16進表記(<code>x</code>)のものを7個，表示せよ」という意味です．
その結果，逆アセンブル結果と同じ値が表示されました
(❹ <code>0x555555555151 &lt;main+8&gt;: 0x48 0x8d 0x05 0xac 0x0e 0x00 0x00</code>)．</p>
</li>
<li>
<p>なお，<code>x</code>コマンドに与える指定は <em>NFT</em> という形式です．<br />
<em>N</em> は表示個数(デフォルト1)，<em>F</em>はフォーマット，<em>U</em>は単位サイズの指定です．
<em>F</em>と<em>U</em>の順番は逆でもOKです． 
(例: <code>4gx</code> は「8バイトデータを16進数表記で4個表示」を意味する)．
<em>F</em>と<em>U</em>で指定できるものは以下の通りです．</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォーマット <em>F</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td>16進数 (hexadecimal)</td></tr>
<tr><td style="text-align: center"><code>d</code></td><td>符号あり10進数 (decimal)</td></tr>
<tr><td style="text-align: center"><code>u</code></td><td>符号なし10進数 (unsigned)</td></tr>
<tr><td style="text-align: center"><code>t</code></td><td>2進数 (two)</td></tr>
<tr><td style="text-align: center"><code>c</code></td><td>文字 (char)</td></tr>
<tr><td style="text-align: center"><code>s</code></td><td>文字列 (string)</td></tr>
<tr><td style="text-align: center"><code>i</code></td><td>機械語命令 (instruction)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">単位サイズ <em>U</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td>1バイト (byte)</td></tr>
<tr><td style="text-align: center"><code>h</code></td><td>2バイト (half-word)</td></tr>
<tr><td style="text-align: center"><code>w</code></td><td>4バイト (word)</td></tr>
<tr><td style="text-align: center"><code>g</code></td><td>8バイト (giant)</td></tr>
</tbody></table>
</div>
<ul>
<li><code>x</code>へのアドレス指定にレジスタの値 (❺ <code>x/7xb $rip</code>)や
レジスタ値を使った足し算 (❻ <code>x/7xb $rip+7</code>)も指定できます．</li>
</ul>
<h3 id="メモリ中の値スタックを表示する-x"><a class="header" href="#メモリ中の値スタックを表示する-x">メモリ中の値(スタック)を表示する (<code>x</code>)</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x1180: file fact.c, line 13.
(gdb) b fact
Breakpoint 2 at 0x1158: file fact.c, line 5.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❶ p/x $rbp
$1 = ❷ 0x7fffffffde90
(gdb) c
Continuing.

Breakpoint 2, fact (n=5) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❸ x/1xg $rbp + 8
0x7fffffffde88:	❹ 0x000055555555518a
(gdb) disas main
Dump of assembler code for function main:
   0x0000555555555178 &lt;+0&gt;:	endbr64 
   0x000055555555517c &lt;+4&gt;:	push   %rbp
   0x000055555555517d &lt;+5&gt;:	mov    %rsp,%rbp
   0x0000555555555180 &lt;+8&gt;:	mov    $0x5,%edi
   0x0000555555555185 &lt;+13&gt;:	call   0x555555555149 &lt;fact&gt;
❺ 0x000055555555518a &lt;+18&gt;:	mov    %eax,%esi
   0x000055555555518c &lt;+20&gt;:	lea    0xe71(%rip),%rax        # 0x555555556004
   0x0000555555555193 &lt;+27&gt;:	mov    %rax,%rdi
   0x0000555555555196 &lt;+30&gt;:	mov    $0x0,%eax
   0x000055555555519b &lt;+35&gt;:	call   0x555555555050 &lt;printf@plt&gt;
   0x00005555555551a0 &lt;+40&gt;:	mov    $0x0,%eax
   0x00005555555551a5 &lt;+45&gt;:	pop    %rbp
   0x00005555555551a6 &lt;+46&gt;:	ret    
End of assembler dump.
(gdb) ❻ x/1gx $rbp
0x7fffffffde80:	❼ 0x00007fffffffde90
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>p</code> (<code>print)</code>, <code>c</code>(<code>continue</code>), <code>x</code>(<code>x</code>), <code>disas</code>(<code>disassemble</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>main</code>と<code>fact</code>にブレークポイントを設定し，
<code>main</code>関数でブレークした時点で，<code>%rbp</code>の値を調べると (❶ <code>p/x $rbp</code>)，
❷ <code>0x7fffffffde90</code>と分かりました．
これは<code>main</code>関数のスタックフレームの一番下のアドレスです．</p>
</li>
</ul>
<img src="figs/stack-fact.svg" height="200px" id="fig:stack-fact">
<ul>
<li>
<p><code>fact</code>でブレークした時点で，スタックフレームは上図になっているはずです．
まずメモリ参照<code>8(%rbp)</code>に正しく戻り番地が入っているか調べます．
<code>$rbp+8</code>番地のメモリの値を調べると (❸ <code>x/1xg $rbp+8</code>)，
❹ <code>0x000055555555518a</code>が入っていました．
(<code>1xg</code>は，8バイトデータを16進数で1個分出力する，を意味します)．</p>
<p><code>main</code>関数を逆アセンブルすると，</p>
</li>
</ul>
<pre><code>   0x0000555555555185 &lt;+13&gt;:	call   0x555555555149 &lt;fact&gt;
❺ 0x000055555555518a &lt;+18&gt;:	mov    %eax,%esi
</code></pre>
<p>この番地(❹ <code>0x000055555555518a</code>)は<code>call fact</code>の次の命令なので，
戻り番地として正しいことを確認できました．</p>
<ul>
<li>次に<code>fact(5)</code>のスタックフレーム中の「古い<code>%rbp</code>」の値が正しいかを調べます．
<code>%rbp</code>が指すメモリの値を調べると(❻ <code>x/1gx $rbp</code>)，
❼ <code>0x00007fffffffde90</code>が入っていました．
これは ❷ <code>0x7fffffffde90</code>と一致するので，
「古い<code>%rbp</code>」が正しいことを確認できました．</li>
</ul>
<h3 id="シンボルテーブル-info-address-info-symbol"><a class="header" href="#シンボルテーブル-info-address-info-symbol">シンボルテーブル (<code>info address</code>, <code>info symbol</code>)</a></h3>
<pre><code>// hello.c
#include &lt;stdio.h&gt;
int main ()
{
    printf (&quot;hello\n&quot;);
}
</code></pre>
<pre><code>$ gcc -g hello.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ info address main
Symbol &quot;main&quot; is a function at address ❷ 0x1149.
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❸ info address main
Symbol &quot;main&quot; is a function at address ❹ 0x555555555149.
(gdb) info address printf
Symbol &quot;printf&quot; is at 0x7ffff7c60770 in a file ❺ compiled without debugging.
(gdb) disas main
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❻ info symbol 0x0000555555555149
main in section .text of /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
(gdb) ❼ info symbol 0x0000555555555166
main + 29 in section .text of /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out
(gdb) q
</code></pre>
<ul>
<li>
<p>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>r</code>(<code>run</code>), <code>disas</code>(<code>disassemble</code>), <code>q</code>(<code>quit</code>)</p>
</li>
<li>
<p><code>info address</code>は指定したシンボルのアドレスを表示します．
プログラム実行前の場合(❶ <code>info address main</code>)，
ファイル<code>a.out</code>中のアドレスを表示します(❷ <code>0x1149</code>)．
これは<code>nm</code>コマンドや<code>objdump -d</code>で得られるアドレスと同じです．</p>
</li>
</ul>
<pre><code>$ nm ./a.out | egrep main
                 U __libc_start_main@GLIBC_2.34
0000000000001149 T main
</code></pre>
<ul>
<li>
<p>一方，実行後では (❸ <code>info address main</code>)，
<code>main</code>関数のメモリ上でのアドレスが得られます (❹ <code>0x555555555149</code>)．
なお，<code>printf</code>のアドレスを調べると，
デバッグ情報無しでコンパイルされた旨のメッセージも表示されました
(❺ <code>compiled without debugging</code>)．</p>
</li>
<li>
<p><code>info symbol</code>は指定したアドレスを持つシンボルを返します．
例えば，<code>main</code>関数の先頭アドレスを指定すると
( ❻ <code>info symbol 0x0000555555555149</code>)，<code>main</code>を表示しました．
アドレスは<code>main</code>関数の途中のアドレスでも大丈夫です
( ❼ <code>info symbol 0x0000555555555166</code>)．</p>
</li>
</ul>
<h2 id="お便利機能"><a class="header" href="#お便利機能">お便利機能</a></h2>
<h3 id="helpコマンド"><a class="header" href="#helpコマンド"><code>help</code>コマンド</a></h3>
<p><code>help</code> (<code>h</code>)はコマンドのヘルプ(説明)を表示します．</p>
<pre><code>(gdb) help step
step, s
Step program until it reaches a different source line.
Usage: step ❶ [N]
Argument N means step N times (or till program stops for another reason).
</code></pre>
<p>例えば，<code>help step</code>とすると，<code>step</code>に回数を指定できる❶ことが分かりました．
<code>[N]</code>のカギカッコは省略可能な引数を意味します．</p>
<h3 id="aproposコマンド"><a class="header" href="#aproposコマンド"><code>apropos</code>コマンド</a></h3>
<p><code>apropos</code>(<code>apr</code>)は指定した正規表現をヘルプに含むコマンドを表示します．</p>
<pre><code>(gdb) apropos break
advance -- Continue the program up to the given location (same form as args for break command).
break, brea, bre, br, b -- Set breakpoint at specified location.
break, brea, bre, br, b -- Set breakpoint at specified location.
break-range -- Set a breakpoint for an address range.
breakpoints -- Making program stop at certain points.
clear, cl -- Clear breakpoint at specified location.
commands -- Set commands to be executed when the given breakpoints are hit.
(以下略)
</code></pre>
<p>例えば，<code>apropos break</code>とすると，<code>break</code>をヘルプに含むコマンド一覧を表示します．
<code>break</code>に関係するコマンドを知りたい場合に便利です．</p>
<h3 id="補完とヒストリ機能"><a class="header" href="#補完とヒストリ機能">補完とヒストリ機能</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>ctrl-p</code></td><td></td><td>1つ前のコマンドを表示</td></tr>
<tr><td><code>ctrl-n</code></td><td></td><td>1つ後のコマンドを表示</td></tr>
<tr><td><code>show commands</code></td><td></td><td>自分が入力したコマンド履歴を表示</td></tr>
<tr><td><code>ctrl-i</code></td><td></td><td>コマンド等を補完 (TABキーでも同じ)<br/>2回押すと候補一覧を表示</td></tr>
<tr><td><code>ctrl-l</code></td><td></td><td>画面をクリア・リフレッシュ</td></tr>
</tbody></table>
</div>
<pre><code>(gdb) br TAB  (br とTABの間にはスペースを入れない)
(gdb) break  (breakまで補完)
(gdb) break TAB (ここで2回TABを押すと)
break        break-range     (breakで始まるコマンドの一覧を表示)
</code></pre>
<pre><code>(gdb) b main
(gdb) r
(gdb) step
(gdb) ctrl-p  (ctrl-p を押すと)
(gdb) step    (1つ前のコマンド step が表示された)
</code></pre>
<h3 id="tui-テキストユーザインタフェース"><a class="header" href="#tui-テキストユーザインタフェース">TUI (テキストユーザインタフェース)</a></h3>
<p><code>layout</code>コマンドで，TUIの表示モードを使えます．
<code>src</code> (ソースコード)，<code>asm</code> (アセンブリコード)，
<code>regs</code> (レジスタ表示)を選べます．</p>
<!--
<img src="figs/gdb-layout-src.png" height="300px" id="fig:gdb-layout-src">
<img src="figs/gdb-layout-asm.png" height="300px" id="fig:gdb-layout-asm">
<img src="figs/gdb-layout-split.png" height="300px" id="fig:gdb-layout-split">
<img src="figs/gdb-layout-regs.png" height="300px" id="fig:gdb-layout-regs">
-->
<img src="figs/gdb-layout-asm-regs.png" height="350px" id="fig:gdb-layout-asm-regs">
<p>上図は<code>layout asm</code>後に<code>layout regs</code>とした時の画面です．
元の表示方法に戻るには<code>ctrl-x a</code>として下さい．</p>
<h2 id="ブレークポイントの設定"><a class="header" href="#ブレークポイントの設定">ブレークポイントの設定</a></h2>
<h3 id="場所の指定"><a class="header" href="#場所の指定">場所の指定</a></h3>
<div class="table-wrapper"><table><thead><tr><th>場所の指定</th><th>説明</th></tr></thead><tbody>
<tr><td><code>b 10</code></td><td>(今実行中のファイルの)10行目</td></tr>
<tr><td><code>b +5</code></td><td>今の実行地点から5行後</td></tr>
<tr><td><code>b -5</code></td><td>今の実行地点から5行前</td></tr>
<tr><td><code>b main</code></td><td>(今実行中のファイルの)関数<code>main</code></td></tr>
<tr><td><code>b main.c:main</code></td><td>ファイル<code>main.c</code>中の<code>main</code>関数</td></tr>
<tr><td><code>b main.c:10</code></td><td>ファイル<code>main.c</code>の10行目</td></tr>
</tbody></table>
</div>
<h3 id="条件付きブレークポイント"><a class="header" href="#条件付きブレークポイント">条件付きブレークポイント</a></h3>
<pre><code>// fact.c
#include &lt;stdio.h&gt;
int fact (int n)
{
    if (n &lt;= 0)
         return 1;
     else
        return n * fact (n - 1);
}

int main ()
{
    printf (&quot;%d\n&quot;, fact (5));
}
</code></pre>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ b fact if n==0
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❷ i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
	stop only if ❸ n==0
(gdb) ❹ cond 1 n==1
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
	stop only if n==1
(gdb) ❺ cond 1
Breakpoint 1 now unconditional.
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001158 in fact at fact.c:5
(gdb) q
</code></pre>
<ul>
<li>使った<a href="./10-gdb.html#gdb-commands">短縮コマンド</a>:
<code>b</code>(<code>break</code>), <code>i b</code>(<code>info breakpoints</code>), <code>cond</code>(<code>condition</code>), <code>q</code>(<code>quit</code>)</li>
<li>条件付きブレークポイントは<code>if</code>を使って指定します
(❶ <code>b fact if n==0</code>)．</li>
<li><code>i b</code>で，現在のブレークポイントの状況を確認できます (❷ <code>i b</code>)．
番号1のブレークポイントとして，❸ <code>n==0</code>という条件が設定されています．</li>
<li><code>cond</code>で，指定した番号のブレークポイントの条件を変更できます．
ここでは ❹ <code>cond 1 n==1</code>として，条件を<code>n==1</code>に変更しました．</li>
<li><code>cond</code>で新しい条件を指定しないと，条件が外れます(❺ <code>cond 1</code>)．</li>
</ul>
<h3 id="break-with-commands"><a class="header" href="#break-with-commands">コマンド付きブレークポイント</a></h3>
<p><code>commands</code>で「ブレークした時に実行するコマンド列」を指定できます．</p>
<pre><code>$ gcc -g fact.c
$ gdb ./a.out
(gdb) b fact 
Breakpoint 1 at 0x1158: file fact.c, line 5.
(gdb) ❶ commands
Type commands for breakpoint(s) 1, one per line.
End with a line saying just &quot;end&quot;.
&gt;print n
&gt;c
❷&gt;end
(gdb) ❸ r

Breakpoint 1, fact (n=5) at fact.c:5
5	    if (n &lt;= 0)
$1 = 5

Breakpoint 1, fact (n=4) at fact.c:5
5	    if (n &lt;= 0)
$2 = 4

Breakpoint 1, fact (n=3) at fact.c:5
5	    if (n &lt;= 0)
$3 = 3

Breakpoint 1, fact (n=2) at fact.c:5
5	    if (n &lt;= 0)
$4 = 2

Breakpoint 1, fact (n=1) at fact.c:5
5	    if (n &lt;= 0)
$5 = 1

Breakpoint 1, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
$6 = 0
120
(gdb) 
</code></pre>
<ul>
<li>引数無しで❶<code>commands</code>とすると，最後に設定したブレークポイントに対して
コマンドを設定します．
<code>commands 2</code>や<code>commands 5-7</code>などブレークポイントの番号や範囲の指定もできます．</li>
<li><code>commands</code>に続けて，実行したいコマンドを入力します．
最後に❷<code>end</code>を指定します．</li>
<li>❸実行すると，全ての<code>fact</code>の呼び出しが一気に表示できました．
指定したコマンド中に<code>continue</code>を指定できるのがとても便利です．</li>
<li>ここでは不使用ですが，コマンド列の最初に<code>silent</code>を使用すると，
ブレーク時のメッセージを非表示にできます．</li>
</ul>
<h2 id="ステップ実行"><a class="header" href="#ステップ実行">ステップ実行</a></h2>
<h3 id="ステップ実行の種類"><a class="header" href="#ステップ実行の種類">ステップ実行の種類</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ステップ実行の種類</th><th><code>gdb</code>コマンド</th><th>短縮形</th><th>説明</th></tr></thead><tbody>
<tr><td>ステップイン</td><td><code>step</code></td><td><code>s</code></td><td>1行実行を進める(関数呼び出しは中に入って1行を数える)</td></tr>
<tr><td>ステップオーバー</td><td><code>next</code></td><td><code>n</code></td><td>1行実行を進める(関数呼び出しはまたいで1行を数える)</td></tr>
<tr><td>ステップアウト</td><td><code>finish</code></td><td><code>fin</code></td><td>今の関数がリターンするまで実行を進める</td></tr>
<tr><td>実行再開</td><td><code>continue</code></td><td><code>c</code></td><td>ブレークされるまで実行を進める</td></tr>
</tbody></table>
</div><br/>
<img src="figs/step.svg" height="200px" id="fig:step">
<ul>
<li>上図で，今，<code>B();</code>を実行する直前でブレークしているとします．</li>
<li><code>step</code>すると，関数<code>B</code>の<code>printf(&quot;B\n&quot;);</code>まで実行を進めます．</li>
<li><code>next</code>すると，関数<code>A</code>の<code>printf(&quot;A\n&quot;);</code>まで実行を進めます．</li>
<li><code>finish</code>すると，関数<code>main</code>の<code>printf(&quot;main\n&quot;);</code>まで実行を進めます．</li>
</ul>
<h3 id="ステップインの実行例-step"><a class="header" href="#ステップインの実行例-step">ステップインの実行例 (<code>step</code>)</a></h3>
<pre><code>#include &lt;stdio.h&gt;
void B ()
{
    printf (&quot;B\n&quot;);
}
void A ()
{
    B ();
    printf (&quot;A\n&quot;);
}
int main ()
{
    A ();
    printf (&quot;main\n&quot;);
}

</code></pre>
<pre><code>$ gcc -g step.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❶ s
B () at step.c:4
4	❷    printf (&quot;B\n&quot;);
</code></pre>
<p><code>step</code>(❶ <code>s</code>)すると，❷ <code>printf (&quot;B\n&quot;);</code>まで実行しました．</p>
<h3 id="ステップオーバーの実行例-next"><a class="header" href="#ステップオーバーの実行例-next">ステップオーバーの実行例 (<code>next</code>)</a></h3>
<pre><code>$ gcc -g step.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❸ n
B
9	❹    printf (&quot;A\n&quot;);
</code></pre>
<p><code>next</code>(❸ <code>n</code>)すると，❹ <code>printf (&quot;A\n&quot;);</code>まで実行しました．</p>
<h3 id="ステップオーバーの実行例-finish"><a class="header" href="#ステップオーバーの実行例-finish">ステップオーバーの実行例 (<code>finish</code>)</a></h3>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out 
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❺ fin
Run till exit from #0  A () at step.c:8
B
A
main () at step.c:14
14	❻    printf (&quot;main\n&quot;);
</code></pre>
<p><code>finish</code>(❺ <code>fin</code>)すると，❻ <code>printf (&quot;main\n&quot;);</code>まで実行しました．</p>
<h3 id="実行再開の実行例-continue"><a class="header" href="#実行再開の実行例-continue">実行再開の実行例 (<code>continue</code>)</a></h3>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b A
Breakpoint 1 at 0x116b: file step.c, line 8.
(gdb) r
Breakpoint 1, A () at step.c:8
8	    B ();
(gdb) ❼ c
Continuing.
B
A
main
</code></pre>
<p><code>continue</code>(❼ <code>c</code>)すると，ブレークポイントがなかったので，
最後まで実行して実行終了しました．</p>
<h2 id="変数の値の表示"><a class="header" href="#変数の値の表示">変数の値の表示</a></h2>
<h3 id="配列-"><a class="header" href="#配列-">配列 (<code>@</code>)</a></h3>
<pre><code>// array2.c
#include &lt;stdlib.h&gt;
int main (int argc, char **argv)
{
   int arr [4] = {0, 10, 20, 30};
   int *p = malloc (sizeof (int) * 4);
   p [0] = 40;
   p [1] = 50;
   p [2] = 60;
   p [3] = 70;
}
</code></pre>
<pre><code>$ gcc -g array2.c
(gdb) b 11
Breakpoint 1 at 0x5555555551ee: file array2.c, line 11.
(gdb) r aa bb cc dd
Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out aa bb cc dd

Breakpoint 1, main (argc=5, argv=0x7fffffffdf78) at array2.c:11
11	}
(gdb) ❶ p arr
❷ $1 = {0, 10, 20, 30}
(gdb) ❸ p *p
❹ $2 = 40
(gdb) ❺ p *p@4
❻ $3 = {40, 50, 60, 70}
(gdb) ❼ p *argv@5
❽ $4 = {
  0x7fffffffe2f7 &quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out&quot;, 0x7fffffffe337 &quot;aa&quot;, 0x7fffffffe33a &quot;bb&quot;, 0x7fffffffe33d &quot;cc&quot;, 
  0x7fffffffe340 &quot;dd&quot;}
</code></pre>
<ul>
<li>普通の配列は<code>print</code>でそのまま表示できます．
例えば ❶ <code>p arr</code>とすると，❷ <code>$1 = {0, 10, 20, 30}</code>と表示されます．</li>
<li><code>malloc</code>で配列を確保した場合，
単純に ❸ <code>p *p</code>とすると，<code>p</code>の型は<code>int *</code>なので，
❹ <code>$2 = 40</code>しか表示されません．
この場合は<code>@</code>を使って ❺ <code>p *p@4</code>とすると，
4要素の配列としてうまく表示できます(❻ <code>$3 = {40, 50, 60, 70}</code>)．</li>
<li>同様に<code>argv</code>も ❼ <code>p *argv@5</code>とすると，うまく表示できます(❽)．</li>
</ul>
<h3 id="スコープの指定-"><a class="header" href="#スコープの指定-">スコープの指定 ('::')</a></h3>
<pre><code>#include &lt;stdio.h&gt;
int x = 111;
int main ()
{
    static int x = 222;
    {
        int x = 333;
        printf (&quot;hello\n&quot;);
    }
}
</code></pre>
<pre><code>$ gcc -g scope.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b 8
Breakpoint 1 at 0x115c: file scope.c, line 8.
(gdb) r
Breakpoint 1, main () at scope.c:8
8		printf (&quot;hello\n&quot;);
(gdb) p x
$1 = 333
(gdb) ❶ p 'scope.c'::x
$2 = 111
(gdb) ❷ p main::x
$3 =  222
</code></pre>
<p>'::'を使うと，特定のファイルや関数中の変数の値を表示できます．</p>
<ul>
<li>❶ <code>p 'scope.c'::x</code> は<code>scope.c</code>のグローバル変数<code>x</code>の値を表示します．
(ファイル名をクオート文字 <code>'</code> で囲む必要があります)．</li>
<li>❷ <code>p main::x</code> は関数<code>main</code>の静的変数<code>x</code>の値を表示します．</li>
</ul>
<h3 id="構造体-リスト構造"><a class="header" href="#構造体-リスト構造">構造体 (リスト構造)</a></h3>
<pre><code>// list.c
#include &lt;stdio.h&gt;
struct list {
    int data;
    struct list *next;
};

int main ()
{
    struct list n1 = {10, NULL};
    struct list n2 = {20, &amp;n1};
    struct list n3 = {30, &amp;n2};
    struct list *p = &amp;n3;
}
</code></pre>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b 14
Breakpoint 1 at 0x119e: file list.c, line 14.
(gdb) r
Breakpoint 1, main () at list.c:14
14	}
(gdb) p p
$1 = (struct list *) 0x7fffffffde70
(gdb) ❶ p *p
❷ $2 = {data = 30, next = 0x7fffffffde60}
(gdb) ❸ p *p-&gt;next
$3 = {data = 20, next = 0x7fffffffde50}
(gdb) ❹ p *p-&gt;next-&gt;next
$4 = {data = 10, next = 0x0}
</code></pre>
<img src="figs/list.svg" height="80px" id="fig:list">
<ul>
<li><code>p</code>が指すリスト構造は上図のようになっています．</li>
<li><code>print</code>を使って(❶ <code>p *p</code>)，
構造体の中身を普通に表示できます(❷ <code>{data = 30, next = 0x7fffffffde60}</code>)．</li>
<li><code>*p-&gt;next</code>などのC言語の式と(ほぼ)同じ記法で，
リスト構造をたどって中身を表示できます
(❸ <code>p *p-&gt;next</code>，❹ <code>p *p-&gt;next-&gt;next</code>)．</li>
</ul>
<h3 id="共用体-1"><a class="header" href="#共用体-1">共用体</a></h3>
<pre><code>// union.c
#include &lt;stdio.h&gt;

union foo {
    int  u1;
    float u2;
};

int main ()
{
    union foo f;
    f.u1 = 999;
    f.u2 = 123.456;
}
</code></pre>
<pre><code>(gdb) b 13
Breakpoint 3 at 0x555555555138: file union.c, line 13.
(gdb) r
Breakpoint 3, main () at union.c:13
13	    f.u2 = 123.456;
(gdb) ❶ p f
❷ $1 = {u1 = 999, u2 = 1.39989717e-42}
(gdb) ❸ p f.u1
❹ $2 = 999
(gdb) s
14	}
(gdb) p f
$3 = {u1 = 1123477881, u2 = 123.456001}
(gdb) p f.u2
$4 = 123.456001
</code></pre>
<ul>
<li>共用体を<code>print</code>すると (❶ <code>p f</code>)，
<code>u1</code>と<code>u2</code>のどちらのメンバが使われているか<code>gdb</code>は分からないので，
両方の可能性を表示します (❷ <code>{u1 = 999, u2 = 1.39989717e-42}</code>)．</li>
<li>メンバ名を<code>u1</code>と指定すると (❸ <code>p f.u1</code>)，
そのメンバに対する値を表示します (❹ <code>$2 = 999</code>)．</li>
</ul>
<h3 id="特定の値をメモリ中から探す-find"><a class="header" href="#特定の値をメモリ中から探す-find">特定の値をメモリ中から探す (<code>find</code>)</a></h3>
<pre><code>// find.c
#include &lt;stdio.h&gt;
int arr [1000];

int main ()
{
    arr [500] = 0xDEADBEEF;
    printf (&quot;%p\n&quot;, &amp;arr [500]);
}
</code></pre>
<pre><code>(gdb) b 8
Breakpoint 1 at 0x115b: file find.c, line 8.
(gdb) r
Breakpoint 1, main () at find.c:8
8	    printf (&quot;%p\n&quot;, &amp;arr [500]);
(gdb) ❶ p/x &amp;arr[500]
❷ $1 = 0x555555558810
(gdb) ❸ find /w arr, arr+4000, 0xDEADBEEF
❹ 0x555555558810 &lt;arr+2000&gt;
1 pattern found.
</code></pre>
<ul>
<li>上のプログラムでは<code>arr[500]</code>に<code>0xDEADBEEF</code>という値が入っています．
この値が格納されている場所のアドレスは<code>print</code>で(❶ <code>p/x &amp;arr[500]</code>)，
❷ <code>0x555555558810</code>番地と分かります．</li>
<li>ここで仮に，配列のどこに<code>0xDEADBEEF</code>が入っているか分からず，
この配列に入っているか調べたいとします．
<code>find</code>コマンドで調べられます．
❸ <code>find /w arr, arr+4000, 0xDEADBEEF</code>は，
指定したアドレス範囲 (<code>arr</code>番地から<code>arr+4000</code>番地まで)，
4バイト (<code>/w</code>)の値 <code>0xDEADBEEF</code>を探せ，という意味になります．
正しく結果が表示されました (❹ <code>0x555555558810 &lt;arr+2000&gt;</code>)．</li>
</ul>
<h2 id="変数レジスタメモリに値をセット-set"><a class="header" href="#変数レジスタメモリに値をセット-set">変数，レジスタ，メモリに値をセット (<code>set</code>)</a></h2>
<p><code>set</code>を使うと，変数，レジスタ，メモリに値をセットできます．</p>
<pre><code>// calcx.c
int main ()
{
    int x = 10;
    x += 3;
    x += 4;
    return x;
}
</code></pre>
<pre><code>$ gcc -g calcx.c
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1131: file calcx.c, line 4.
(gdb) r
Breakpoint 1, main () at calcx.c:4
4	    int x = 10;
(gdb) s
5	    x += 3;
(gdb) ❶ set x = 20
(gdb) p x
$1 = 20
(gdb) ❷ p x = 30
$2 = 30
(gdb) p x
$3 = 30
(gdb) ❸ p/x &amp;x
$4 = 0x7fffffffde8c
(gdb) ❹ set {int}0x7fffffffde8c = 40
(gdb) p x
❺ $5 = 40
(gdb) p/x $rax
$6 = 0x555555555129
(gdb) ❻ set $rax = 0xDEADBEEF
(gdb) p/x $rax
$7 = 0xdeadbeef
</code></pre>
<ul>
<li>❶ <code>set x = 20</code> で，変数<code>x</code>に20を代入しています．</li>
<li>❸ <code>p/x &amp;x</code>で変数<code>x</code>のアドレスを調べて，
そのアドレスに代入してみます(❹ <code>set {int}0x7fffffffde8c = 40</code>)．
変数<code>x</code>の値が<code>40</code>に変わりました (❺ <code>$5 = 40</code>)．</li>
<li>❺ <code>set $rax = 0xDEADBEEF</code>で，レジスタ<code>%rax</code>の値を変更しました．</li>
<li>なお，変数，メモリ，レジスタのどの場合でも，
<code>print</code>コマンドを使っても代入できます (❷ <code>p x = 30</code>)．</li>
</ul>
<h2 id="gdb-commands"><a class="header" href="#gdb-commands"><code>gdb</code> の主なコマンドの一覧</a></h2>
<h3 id="起動終了"><a class="header" href="#起動終了">起動・終了</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>gdb ./a.out</code></td><td></td><td><code>gdb</code>の起動</td></tr>
<tr><td><code>run</code></td><td><code>r</code></td><td>実行開始</td></tr>
<tr><td><code>quit</code></td><td><code>q</code></td><td><code>gdb</code>の終了</td></tr>
<tr><td><code>ctrl-c</code></td><td></td><td>実行中のプログラムを一時停止<br/> (シグナル<code>SIGINT</code>を使用)</td></tr>
<tr><td><code>ctrl-z</code></td><td></td><td>実行中のプログラムを一時停止<br/> (シグナル<code>SIGTSTP</code>を使用)</td></tr>
<tr><td>⏎ (改行)</td><td></td><td>前と同じコマンドを再実行</td></tr>
</tbody></table>
</div>
<ul>
<li><code>ctrl-c</code>で<code>SIGINT</code>を<code>gdb</code>ではなく実行中のプログラムに渡すには，
<code>handle SIGINT nostop pass</code>とします．
<code>gdb</code>のシグナル処理状態は<code>info signals</code>で見られます．</li>
<li><code>gdb</code>のプロンプト<code>(gdb)</code>が出ている状態で，<code>ctrl-z</code>を入力すると，
<code>gdb</code>自体の実行を一時停止します．再開するには<code>fg</code>コマンドなどを使います．</li>
</ul>
<h3 id="ヘルプ"><a class="header" href="#ヘルプ">ヘルプ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>help</code> コマンド</td><td><code>h</code></td><td>コマンドのヘルプ(説明)を表示</td></tr>
<tr><td><code>apropos</code> [<code>-v</code>] 正規表現</td><td><code>apr</code></td><td>正規表現をヘルプに含むコマンドを表示(<code>-v</code>は詳細表示)</td></tr>
</tbody></table>
</div>
<h3 id="ヒストリコマンド履歴と補完コンプリーションなど"><a class="header" href="#ヒストリコマンド履歴と補完コンプリーションなど">ヒストリ(コマンド履歴)と補完(コンプリーション)など</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>ctrl-p</code></td><td></td><td>1つ前のコマンドを表示</td></tr>
<tr><td><code>ctrl-n</code></td><td></td><td>1つ後のコマンドを表示</td></tr>
<tr><td><code>show commands</code></td><td></td><td>自分が入力したコマンド履歴を表示</td></tr>
<tr><td><code>ctrl-i</code></td><td></td><td>コマンド等を補完 (TABキーでも同じ)<br/>2回押すと候補一覧を表示</td></tr>
<tr><td><code>ctrl-l</code></td><td></td><td>画面をクリア・リフレッシュ</td></tr>
</tbody></table>
</div>
<h3 id="ブレークポイントウォッチポイント"><a class="header" href="#ブレークポイントウォッチポイント">ブレークポイント・ウォッチポイント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>break</code> 場所</td><td><code>b</code></td><td>ブレークポイントの設定</td></tr>
<tr><td><code>rbreak</code> 正規表現</td><td><code>rb</code></td><td>正規表現にマッチする全関数にブレークポイントの設定</td></tr>
<tr><td><code>watch</code> 場所</td><td><code>wa</code></td><td>ウォッチポイント(書き込み)の設定</td></tr>
<tr><td><code>rwatch</code> 場所</td><td><code>rw</code></td><td>ウォッチポイント(読み込み)の設定</td></tr>
<tr><td><code>awatch</code> 場所</td><td><code>aw</code></td><td>ウォッチポイント(読み書き)の設定</td></tr>
<tr><td><code>info break</code></td><td><code>i b</code></td><td>ブレークポイント・ウォッチポイント一覧表示</td></tr>
<tr><td><code>break</code> 場所 <code>if</code> 条件</td><td><code>b</code></td><td>条件付きブレークポイントの設定</td></tr>
<tr><td><code>condition</code> 番号 条件</td><td><code>cond</code></td><td>ブレークポイントに条件を設定</td></tr>
<tr><td><code>commands</code> [番号]</td><td><code>comm</code></td><td>ブレークした時に実行するコマンド列を設定(<code>end</code>で終了)</td></tr>
<tr><td><code>delete</code> 番号</td><td><code>d</code></td><td>ブレークポイントの削除</td></tr>
<tr><td><code>delete</code></td><td><code>d</code></td><td>全ブレークポイントの解除 (<code>clear</code>でも同じ)</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th>場所の指定方法</th><th>例</th></tr></thead><tbody>
<tr><td>関数名</td><td><code>main</code></td></tr>
<tr><td>行番号</td><td><code>6</code></td></tr>
<tr><td>ファイル名:行番号</td><td><code>main.c:6</code></td></tr>
<tr><td>ファイル名:関数名</td><td><code>main.c:main</code></td></tr>
<tr><td><code>*</code>アドレス</td><td><code>*0x55551290</code></td></tr>
</tbody></table>
</div>
<h3 id="ステップ実行-1"><a class="header" href="#ステップ実行-1">ステップ実行</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>step</code></td><td><code>s</code></td><td>次の行までステップ実行(関数コールに入って1行を数える)</td></tr>
<tr><td><code>next</code></td><td><code>n</code></td><td>次の行までステップ実行(関数コールはまたいで1行を数える)</td></tr>
<tr><td><code>finish</code></td><td><code>fin</code></td><td>今の関数を終了するまで実行</td></tr>
<tr><td><code>continue</code></td><td><code>c</code></td><td>ブレークポイントに当たるまで実行</td></tr>
<tr><td><code>until</code> 場所</td><td><code>u</code></td><td>指定した場所まで実行(ループを抜けたい時に便利)</td></tr>
<tr><td><code>jump</code> 場所</td><td><code>j</code></td><td>指定した場所から実行を再開(<code>%rip</code>を書き換えて再開に相当)</td></tr>
<tr><td><code>stepi</code></td><td><code>si</code></td><td>次の機械語命令を1つだけ実行して停止(関数コールに入って1命令を数える)</td></tr>
<tr><td><code>nexti</code></td><td><code>ni</code></td><td>次の機械語命令を1つだけ実行して停止(関数コールはまたいで1命令を数える)</td></tr>
</tbody></table>
</div>
<h3 id="式変数レジスタメモリの表示"><a class="header" href="#式変数レジスタメモリの表示">式，変数，レジスタ，メモリの表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>print</code>/フォーマット   式</td><td><code>p</code></td><td>式を実行して値を表示</td></tr>
<tr><td><code>display</code>/フォーマット   式</td><td><code>disp</code></td><td>実行停止毎に<code>print</code>する</td></tr>
<tr><td><code>info display</code></td><td><code>i di</code></td><td><code>display</code>の設定一覧表示</td></tr>
<tr><td><code>undisplay</code>    番号</td><td><code>und</code></td><td><code>display</code>の設定解除</td></tr>
<tr><td><code>x</code>/<em>NFU</em>    アドレス</td><td><code>x</code></td><td>メモリの内容を表示 (examine)</td></tr>
<tr><td><code>info registers</code></td><td><code>i r</code></td><td>全汎用レジスタの内容を表示</td></tr>
<tr><td><code>info all-registers</code></td><td><code>i al</code></td><td>全汎用レジスタの内容を表示</td></tr>
</tbody></table>
</div>
<ul>
<li>表示する「式」は副作用があっても良い．
代入式でも良いし，副作用のある関数呼び出しやライブラリ関数呼び出しでも良い．
(例: <code>p x = 999</code>，<code>p printf (&quot;hello\n&quot;)</code>)．
このため<code>printf</code>コマンドは単なる「実行状態の表示コマンド」ではなく
「実行状態の変更」も可能 (このために<code>gdb</code>は裏で結構すごいことやってる)．</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>式</th><th>説明</th></tr></thead><tbody>
<tr><td><code>$</code>レジスタ名</td><td>レジスタ参照</td></tr>
<tr><td>アドレス<code>@</code>要素数</td><td>配列「アドレス[要素数]」として処理</td></tr>
</tbody></table>
</div>
<ul>
<li><em>N</em> は表示個数(デフォルト1)，<em>F</em>はフォーマット，<em>U</em>は単位サイズを指定する．
<em>F</em>と<em>U</em>の順番は逆でも良い． 
(例: <code>4gx</code> は「8バイトデータを16進数表記で4個表示」を意味する)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">フォーマット <em>F</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>x</code></td><td>16進数 (hexadecimal)</td></tr>
<tr><td style="text-align: center"><code>d</code></td><td>符号あり10進数 (decimal)</td></tr>
<tr><td style="text-align: center"><code>u</code></td><td>符号なし10進数 (unsigned)</td></tr>
<tr><td style="text-align: center"><code>t</code></td><td>2進数 (two)</td></tr>
<tr><td style="text-align: center"><code>c</code></td><td>文字 (char)</td></tr>
<tr><td style="text-align: center"><code>s</code></td><td>文字列 (string)</td></tr>
<tr><td style="text-align: center"><code>i</code></td><td>機械語命令 (instruction)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">単位サイズ <em>U</em></th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td>1バイト (byte)</td></tr>
<tr><td style="text-align: center"><code>h</code></td><td>2バイト (half-word)</td></tr>
<tr><td style="text-align: center"><code>w</code></td><td>4バイト (word)</td></tr>
<tr><td style="text-align: center"><code>g</code></td><td>8バイト (giant)</td></tr>
</tbody></table>
</div>
<h3 id="変数レジスタメモリの変更"><a class="header" href="#変数レジスタメモリの変更">変数，レジスタ，メモリの変更</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>set 変数 = 式</code></td><td><code>set</code></td><td>変数に式の値を代入する</td></tr>
</tbody></table>
</div>
<ul>
<li>変数には通常の変数(<code>x</code>)，レジスタ(<code>$rax</code>)，
メモリ (<code>{int}0x0x1200</code>)，
　デバッガ変数 (<code>$foo</code>)が指定できます．</li>
</ul>
<h3 id="スタック表示"><a class="header" href="#スタック表示">スタック表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>backtrace</code></td><td><code>bt</code>, <code>ba</code></td><td>コールスタックを表示 <br/> <code>where</code>, <code>info stack</code>でも同じ</td></tr>
<tr><td><code>backtrace full</code></td><td><code>bt f</code>, <code>ba f</code></td><td>コールスタックと全局所変数を表示</td></tr>
</tbody></table>
</div>
<h3 id="プログラム表示"><a class="header" href="#プログラム表示">プログラム表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>list</code> 場所</td><td><code>l</code></td><td>ソースコードを表示</td></tr>
<tr><td><code>disassemble</code> 場所</td><td><code>disas</code></td><td>逆アセンブル結果を表示</td></tr>
</tbody></table>
</div>
<ul>
<li><code>disassemble</code>へのオプション</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">オプション</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>/s</code></td><td>ソースコードも表示 (表示順は機械語命令の順番)</td></tr>
<tr><td style="text-align: center"><code>/m</code></td><td>ソースコードも表示 (表示順はソースコードの順番)</td></tr>
<tr><td style="text-align: center"><code>/r</code></td><td>機械語命令の16進ダンプも表示</td></tr>
</tbody></table>
</div>
<h3 id="tui-テキストユーザインタフェース-1"><a class="header" href="#tui-テキストユーザインタフェース-1">TUI (テキストユーザインタフェース)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>layout</code> レイアウト</td><td><code>la</code></td><td>TUIレイアウトを変更</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">レイアウト</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>asm</code></td><td>アセンブリコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>regs</code></td><td>レジスタのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>src</code></td><td>ソースコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>split</code></td><td>ソースとアセンブリコードのウインドウを表示</td></tr>
<tr><td style="text-align: center"><code>next</code></td><td>次のレイアウトを表示</td></tr>
<tr><td style="text-align: center"><code>prev</code></td><td>前のレイアウトを表示</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">キーバインド</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>ctrl-x a</code></td><td>TUIモードのオン・オフ</td></tr>
<tr><td style="text-align: center"><code>ctrl-x 1</code></td><td>ウインドウを1つにする</td></tr>
<tr><td style="text-align: center"><code>ctrl-x 2</code></td><td>ウインドウを2つにする</td></tr>
<tr><td style="text-align: center"><code>ctrl-x o</code></td><td>選択ウインドウを変更</td></tr>
<tr><td style="text-align: center"><code>ctrl-x s</code></td><td>シングルキーモードのオン・オフ</td></tr>
<tr><td style="text-align: center"><code>ctrl-l</code></td><td>ウインドウをリフレッシュ(再表示)</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">シングルキーモードの<br/>キーバインド</th><th>説明</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>c</code></td><td><code>continue</code></td></tr>
<tr><td style="text-align: center"><code>d</code></td><td><code>down</code></td></tr>
<tr><td style="text-align: center"><code>f</code></td><td><code>finish</code></td></tr>
<tr><td style="text-align: center"><code>n</code></td><td><code>next</code></td></tr>
<tr><td style="text-align: center"><code>o</code></td><td><code>nexti</code></td></tr>
<tr><td style="text-align: center"><code>q</code></td><td>シングルキーモードの終了</td></tr>
<tr><td style="text-align: center"><code>r</code></td><td><code>run</code></td></tr>
<tr><td style="text-align: center"><code>s</code></td><td><code>step</code></td></tr>
<tr><td style="text-align: center"><code>i</code></td><td><code>stepi</code></td></tr>
<tr><td style="text-align: center"><code>v</code></td><td><code>info locals</code></td></tr>
<tr><td style="text-align: center"><code>v</code></td><td><code>where</code></td></tr>
</tbody></table>
</div>
<h3 id="シンボルテーブル"><a class="header" href="#シンボルテーブル">シンボルテーブル</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>info address</code> シンボル</td><td><code>i ad</code></td><td>シンボルのアドレスを表示</td></tr>
<tr><td><code>info symbol</code> アドレス</td><td><code>i s</code></td><td>そのアドレスを持つシンボルを表示</td></tr>
</tbody></table>
</div>
<h3 id="型の表示"><a class="header" href="#型の表示">型の表示</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コマンド</th><th>省略名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>whatis</code> 式または型名</td><td><code>wha</code></td><td>その式や型名の型情報を表示</td></tr>
<tr><td><code>ptype</code> 式または型名</td><td><code>pt</code></td><td>その式や型名の型情報を詳しく表示</td></tr>
<tr><td><code>info types</code> 正規表現</td><td><code>i types</code></td><td>正規表現にマッチする型を表示</td></tr>
</tbody></table>
</div>
<ul>
<li><code>whatis</code>は<code>typedef</code>を1レベルだけ展開します．
<code>ptype</code>は<code>typedef</code>を全て展開します．</li>
<li><code>ptype</code>に<code>/o</code>オプションを付けると，構造体のフィールドの
オフセットとサイズも表示します．</li>
</ul>
<h2 id="その他の使い方"><a class="header" href="#その他の使い方">その他の使い方</a></h2>
<p>どんなものがあるか，ごく簡単に説明します(詳しくは説明しません)．
詳しくは<a href="https://www.sourceware.org/gdb/documentation/">GDBマニュアル</a>を参照下さい．</p>
<h3 id="初期化ファイル"><a class="header" href="#初期化ファイル">初期化ファイル</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ファイル名</th><th>説明</th></tr></thead><tbody>
<tr><td><code>~/.gdbearlyinit</code></td><td><code>gdb</code>の初期化前に読み込まれる初期化ファイル</td></tr>
<tr><td><code>~/.gdbinit</code></td><td><code>gdb</code>の初期化後に読み込まれる初期化ファイル</td></tr>
<tr><td><code>./.gdbinit</code></td><td>最後に読み込まれる初期化ファイル</td></tr>
</tbody></table>
</div>
<ul>
<li>よく使う<code>gdb</code>の設定，<a href="./10-gdb.html#%E3%83%A6%E3%83%BC%E3%82%B6%E5%AE%9A%E7%BE%A9%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89">ユーザ定義コマンド</a>や
<a href="./10-gdb.html#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9">コマンドエイリアス</a>は
　初期化ファイルに記述しておくと便利です．</li>
<li><code>gdb</code>の起動メッセージを抑制する <code>set startup-quietly on</code> は
<code>~/.gdbearlyinit</code> に指定する必要があります．</li>
<li><code>./.gdbinit</code>は個別の設定の記述に便利です．
ただしデフォルトでは許可されていないので，
<code>add-auto-load-safe-path パス</code> や
<code>set auto-load safe-path /</code> を<code>~/.gdbinit</code>に書く必要があります．</li>
</ul>
<h3 id="ユーザ定義コマンド"><a class="header" href="#ユーザ定義コマンド">ユーザ定義コマンド</a></h3>
<p><code>define</code>と<code>end</code>でユーザ定義コマンドを定義できます．</p>
<pre><code>$ cat ~/.gdbinit
define hello
    echo hello, ❶ $arg0\n
end
❷ define start
    b main
    r
end
define ❸ hook-print
    echo size: b (1 byte), h (2 byte), w (4 byte), g (8 byte)\n
end
define ❹ hook-stop
    x/i $rip
end
$ gdb ./a.out
(gdb) hello gdb
hello, gdb
(gdb) start
=&gt; 0x555555555151 &lt;main+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) p main
size: b (1 byte), h (2 byte), w (4 byte), g (8 byte)
$1 = {int ()} 0x555555555149 &lt;main&gt;
(gdb) ❺ help user-defined
User-defined commands.
The commands in this class are those defined by the user.
Use the &quot;define&quot; command to define a command.

List of commands:

hello -- User-defined.
hook-print -- User-defined.
hook-stop -- User-defined.
start -- User-defined.
(gdb) 
</code></pre>
<ul>
<li>ユーザ定義コマンドの引数は，❶ <code>$arg0</code>, <code>$arg1</code>... と参照します．</li>
<li>例えば「毎回 <code>b main</code>と<code>r</code>を2回打つのは面倒だ」
という場合はユーザ定義コマンド❷ <code>start</code>を定義すると便利かも知れません．
(ここでは使っていませんが) <code>if</code>，<code>while</code>，<code>set</code>を組み合わせて
スクリプト的なユーザ定義コマンドも定義可能です．</li>
<li><code>hook-</code>で始まるコマンド名は特別な意味を持ちます．
例えば，❸<code>hook-print</code>は<code>print</code>を実行するたびに実行されるユーザ定義コマンドになります．(ここでは試しにサイズ指定 <code>bhwg</code> の意味を表示しています)．</li>
<li><code>hook-stop</code>はプログラムが一時停止するたびに実行されるユーザ定義コマンドです．</li>
<li><code>help user-defined</code>で，ユーザ定義コマンドの一覧を表示できます．</li>
</ul>
<h3 id="コマンドエイリアス"><a class="header" href="#コマンドエイリアス">コマンドエイリアス</a></h3>
<pre><code>$ cat ~/.gdbinit
❶ alias di = disassemble
$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1151: file hello.c, line 5.
(gdb) r
Breakpoint 1, main () at hello.c:5
5	    printf (&quot;hello\n&quot;);
(gdb) ❷ di
Dump of assembler code for function main:
   0x0000555555555149 &lt;+0&gt;:	endbr64 
   0x000055555555514d &lt;+4&gt;:	push   %rbp
   0x000055555555514e &lt;+5&gt;:	mov    %rsp,%rbp
=&gt; 0x0000555555555151 &lt;+8&gt;:	lea    0xeac(%rip),%rax        # 0x555555556004
   0x0000555555555158 &lt;+15&gt;:	mov    %rax,%rdi
   0x000055555555515b &lt;+18&gt;:	call   0x555555555050 &lt;puts@plt&gt;
   0x0000555555555160 &lt;+23&gt;:	mov    $0x0,%eax
   0x0000555555555165 &lt;+28&gt;:	pop    %rbp
   0x0000555555555166 &lt;+29&gt;:	ret    
End of assembler dump.
(gdb) ❸ help di
disassemble, di
Disassemble a specified section of memory.
Usage: disassemble[/m|/r|/s] START [, END]
(以下略)
(gdb) ❹ help aliases
User-defined aliases of other commands.

List of commands:

di -- Disassemble a specified section of memory.
</code></pre>
<ul>
<li><code>alias</code>コマンドでコマンドの別名を定義できます．
ここでは<code>alias di = disassemble</code>として，❷<code>di</code>で逆アセンブルができるようにしました．</li>
<li>素晴らしいことに，❸ <code>help</code> がユーザ定義のエイリアスに対応していて，
<code>help di</code>でヘルプを表示できます．</li>
<li>また，❹ <code>help aliases</code>でエイリアスの一覧を表示できます．
(<code>-a</code>オプションで定義したエイリアスは，補完の対象にならず，
エイリアス一覧にも表示されません)．</li>
</ul>
<h3 id="gdb-attach"><a class="header" href="#gdb-attach">プロセスのアタッチとデタッチ (<code>attach</code>, <code>detach</code>)</a></h3>
<p><code>gdb -p</code>オプションや<code>attach</code>を使うと，すでに実行中のプログラムを
<code>gdb</code>の支配下に置けます(これを<strong>プロセスにアタッチする</strong>といいます)．</p>
<pre><code>// inf-loop.c
#include &lt;stdio.h&gt;
int main ()
{
    int x = 1, n = 0;
    while (x != 0) {
        n++;
    }
    printf (&quot;hello, world\n&quot;);
}
</code></pre>
<pre><code>$ ❶ sudo sysctl -w kernel.yama.ptrace_scope=0
$ gcc -g inf-loop.c
$ ./a.out
 ❷^Z
[1]+  Stopped                 ./a.out
$ ❸ bg
[1]+ ./a.out &amp;
$ ps | egrep a.out
❹ 27373 pts/0    00:00:10 a.out
$ ❺ gdb -p 27373
Attaching to process 27373
main () at inf-loop.c:6
6	    while (x != 0) {
(gdb) bt
#0  main () at inf-loop.c:6
(gdb) ❻ kill
Kill the program being debugged? (y or n) y
[Inferior 1 (process 27373) killed]
(gdb) q
</code></pre>
<ul>
<li>まず ❶ <code>sudo sysctl -w kernel.yama.ptrace_scope=0</code>として，
プロセスへのアタッチを許可します．デフォルトでは以下のメッセージが出て
アタッチができません．❶の操作はLinuxを再起動するまで有効です．</li>
</ul>
<pre><code>$ gdb -p 27373
Attaching to process 27373
Could not attach to process.  If your uid matches the uid of the target
process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try
again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf
ptrace: Operation not permitted.
</code></pre>
<ul>
<li>ここでは無限ループする<code>inf-loop.c</code>をコンパイルして実行します．
❷<code>ctrl-z</code>で実行をサスペンド(一時中断)して，❸<code>bg</code>で
バックグラウンド実行にします．
(別の端末から<code>gdb</code>を起動するなら，❷❸の作業は不要です)</li>
<li><code>ps</code>コマンドで<code>a.out</code>のプロセス番号を調べると❹<code>27373</code>と分かりました．
❺<code>gdb -p 27373</code>とすると，プロセス番号27373のプロセスを
<code>gdb</code>が支配下に置きます(これを<strong>プロセスにアタッチする</strong>と言います)．</li>
<li>ここでは単に <code>kill</code>コマンドで<code>a.out</code>を終了させました．
終了させたくない場合は，調査後に <code>detach</code>するか<code>gdb</code>を終了すれば，
<code>a.out</code>はそのまま実行を継続できます．</li>
<li><code>gdb</code>起動後に，<code>attach</code>コマンドを使ってもアタッチできます．</li>
</ul>
<h3 id="core-file"><a class="header" href="#core-file">コアファイルによる事後デバッグ</a></h3>
<h4 id="コアファイルとは"><a class="header" href="#コアファイルとは">コアファイルとは</a></h4>
<p><strong>コアファイル</strong>(core file)あるいは<strong>コアダンプ</strong>(core dump)とは，
実行中のプロセスのメモリやレジスタの値を記録したファイルのことです．
再現性がないバグに対してコアファイルがあると，
後から何度でもそのコアファイルを使ってデバッグできるので便利です．</p>
<details>
<summary>
コアファイルのコアはメモリを意味する
</summary>
<p>コアファイルのコア (core)はメモリを意味します．
これはかつて(大昔)のメモリが<strong>磁気コア</strong>だったことに由来します．</p>
</details>
<h4 id="コアファイルを生成する設定"><a class="header" href="#コアファイルを生成する設定">コアファイルを生成する設定</a></h4>
<p>セキュリティ等の理由で，デフォルトの設定ではコアファイルが生成されません．
以下でコアファイルを生成する設定にできます．</p>
<pre><code>$ ❶ ulimit -c unlimited
$ ❷ sudo sysctl -w kernel.core_pattern=core
</code></pre>
<p>❶でコアファイルのサイズを無制限に設定します．
　❷で，コアファイル名のパターンを<code>core</code>にします
(生成されるファイル名は <code>core.&lt;pid&gt;</code> となります．<code>&lt;pid&gt;</code>はそのプロセスのプロセス番号です)．
❶の設定はそのシェル内のみ，❷の設定はLinuxを再起動するまで有効です．</p>
<h4 id="コアファイルで事後解析してみる"><a class="header" href="#コアファイルで事後解析してみる">コアファイルで事後解析してみる</a></h4>
<p>segmentation faultでクラッシュしたプログラムの事後解析をしてみます．</p>
<pre><code>$ gcc -g segv.c
$ ./a.out
❶ Segmentation fault (core dumped)
$ ls -l core*
❷ -rw------- 1 gondow gondow 307200  8月 25 10:54 core.2224
$ ❸ gdb ./a.out core.2224
Reading symbols from ./a.out...
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000559ad81bb162 in main () at segv.c:6
6	    printf (&quot;%d\n&quot;, *p); 
(gdb) p p
❹ $1 = (int *) 0xdeadbeef
(gdb) bt
#0  0x0000559ad81bb162 in main () at segv.c:6
</code></pre>
<p><code>segv.c</code>をコンパルして実行すると，segmentation fault を起こし，
コアファイルが作成されました(❷)．
<code>gdb</code>にコアファイル名も指定して起動すると(❸)，
segmentation faultが起きた状態でデバッグが可能になりました．
例えば，変数<code>p</code>の値を表示できています
(❹ <code>$1 = (int *) 0xdeadbeef</code>)．</p>
<blockquote>
<p>注: 著者の環境(仮想マシンVMWare Fusion 上のUbuntu 22.04LTS，ホストマシン macOS 13.4)の共有フォルダ上で上記を行った場合，
作られたコアファイルのサイズが0になってしまいました．
共有フォルダではなく<code>/tmp</code>などでは問題なくコアファイルが作られました．</p>
</blockquote>
<h4 id="動作中のプロセスのコアファイルを生成する"><a class="header" href="#動作中のプロセスのコアファイルを生成する">動作中のプロセスのコアファイルを生成する</a></h4>
<p><code>gcore</code>コマンドや，<code>gdb</code>の<code>gcore</code>コマンドで，
動作中のプロセスのコアファイルを生成できます．</p>
<pre><code>$ gcc -g inf-loop.c 
$ ./a.out &amp;
[1] 2325
$ ❶ sudo sysctl -w kernel.yama.ptrace_scope=0
kernel.yama.ptrace_scope = 0
$ ❷ gcore 2325
0x0000561775b05169 in main ()
Saved corefile core.2325
$ ❸ gdb ./a.out core.2325 
Reading symbols from ./a.out...
Core was generated by `./a.out'.
#0  main () at inf-loop.c:6
6	    while (x != 0) {
</code></pre>
<p>❶で<a href="./10-gdb.html#gdb-attach">アタッチを可能にする設定</a>が必要です．
<code>gcore</code>コマンドが対象プログラムにアタッチするからです．
<code>gcore</code>コマンドでコアファイルを生成し(❷)，<code>gdb</code>でコアファイルを指定すると(❸)，
無事にデバッグ可能になりました．</p>
<pre><code>$ gcc -g inf-loop.c 
$ gdb ./a.out
(gdb) r
Starting program: /tmp/a.out 
❶ ^C
Program received signal SIGINT, Interrupt.
main () at inf-loop.c:6
6	    while (x != 0) {
(gdb) ❷ gcore
Saved corefile core.2369
</code></pre>
<p><code>gdb</code>上でもコアファイルを生成できます．
<code>gdb</code>上で<code>a.out</code>を実行後，このプログラムは無限ループしてるので，
<code>ctrl-c</code> (❶)で実行を中断してから，
<code>gcore</code>コマンドを使うと，コアファイルを生成できました．</p>
<h3 id="キャッチポイント-catch"><a class="header" href="#キャッチポイント-catch">キャッチポイント (<code>catch</code>)</a></h3>
<p>キャッチポイントは様々なイベント発生時にブレークする仕組みです．
キャッチポイントが扱えるイベントには，
例外，<code>exec</code>，<code>fork</code>，<code>vfork</code>，
システムコール(<code>syscall</code>)，
ライブラリのロード・アンロード(<code>load</code>, <code>unload</code>)，
シグナル (<code>signal</code>)などがあります．</p>
<h4 id="システムコールをキャッチしてみる"><a class="header" href="#システムコールをキャッチしてみる">システムコールをキャッチしてみる</a></h4>
<pre><code class="language-bash">$ gcc -g hello.c
$ gdb ./a.out
(gdb) ❶ catch syscall write
Catchpoint 1 (syscall 'write' [1])
(gdb) r

❷ Catchpoint 1 (call to syscall write), 0x00007ffff7d14a37 in __GI___libc_write (fd=1, buf=0x5555555592a0, nbytes=6) at ../sysdeps/unix/sysv/linux/write.c:26
26	../sysdeps/unix/sysv/linux/write.c: No such file or directory.
(gdb) ❸ bt
#0  0x00007ffff7d14a37 in __GI___libc_write (fd=1, buf=0x5555555592a0, 
    nbytes=6) at ../sysdeps/unix/sysv/linux/write.c:26
#1  0x00007ffff7c8af6d in _IO_new_file_write (
    f=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, data=0x5555555592a0, n=6)
    at ./libio/fileops.c:1180
<span class="boring">#2  0x00007ffff7c8ca61 in new_do_write (to_do=6, 
</span><span class="boring">    data=0x5555555592a0 &quot;hello\n&quot;, fp=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;)
</span><span class="boring">    at ./libio/libioP.h:947
</span><span class="boring">#3  _IO_new_do_write (to_do=6, data=0x5555555592a0 &quot;hello\n&quot;, 
</span><span class="boring">    fp=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;) at ./libio/fileops.c:425
</span><span class="boring">#4  _IO_new_do_write (fp=fp@entry=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, 
</span><span class="boring">    data=0x5555555592a0 &quot;hello\n&quot;, to_do=6) at ./libio/fileops.c:422
</span><span class="boring">#5  0x00007ffff7c8cf43 in _IO_new_file_overflow (
</span><span class="boring">    f=0x7ffff7e1a780 &lt;_IO_2_1_stdout_&gt;, ch=10) at ./libio/fileops.c:783
</span><span class="boring">#6  0x00007ffff7c8102a in __GI__IO_puts (str=0x555555556004 &quot;hello&quot;)
</span><span class="boring">    at ./libio/ioputs.c:41
</span><span class="boring">#7  0x0000555555555160 in main () at hello.c:5
</span><span class="boring">(gdb) 
</span></code></pre>
<p>❶ <code>catch syscall write</code>で，<code>write</code>システムコールをキャッチしてみます．
<code>printf</code>が最終的には<code>write</code>システムコールを呼ぶはずです．
やってみたら，無事にキャッチできました(❷)．
バックトレースを見ると(❸)，<code>main</code>関数から<code>write</code>が呼ばれるまでの
　関数呼び出しを表示できました．</p>
<h4 id="シグナルをキャッチしてみる-handle-catch-signal"><a class="header" href="#シグナルをキャッチしてみる-handle-catch-signal">シグナルをキャッチしてみる (<code>handle</code>, <code>catch signal</code>)</a></h4>
<h5 id="handleを使う"><a class="header" href="#handleを使う"><code>handle</code>を使う</a></h5>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

void handler (int n)
{
    fprintf (stderr, &quot;I am handler\n&quot;);
}

int main (void)
{
    signal (SIGUSR1, handler);
    while (1) {
        fprintf (stderr, &quot;.&quot;);
        sleep (1);
    }
}
</code></pre>
<pre><code>$ gcc -g sigusr1.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ handle SIGUSR1 
Signal        Stop	Print	Pass to program	Description
SIGUSR1       Yes	Yes	Yes		User defined signal 1
(gdb) r
❷ ........... 
❸ Program received signal SIGUSR1, User defined signal 1.
0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb) ❹ handle SIGUSR1 nostop noprint pass
Signal        Stop	Print	Pass to program	Description
SIGUSR1       No	No	Yes		User defined signal 1
(gdb) ❺ c
Continuing.
❻ I am handler
......I am handler
.....❼ ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	in ../sysdeps/unix/sysv/linux/clock_nanosleep.c
(gdb)
</code></pre>
<ul>
<li>
<p>❶ <code>handle SIGUSR1</code>とすると，
<code>gdb</code>がシグナル<code>SIGUSR1</code>を受け取った時の処理設定が表示されます．</p>
<ul>
<li>Stop Yes: <code>gdb</code>は<code>a.out</code>の実行を一時停止します．</li>
<li>Print Yes: <code>gdb</code>は<code>SIGUSR1</code>を受け取ったことを表示します．</li>
<li>Pass Yes: <code>gdb</code>は<code>a.out</code>に<code>SIGUSR1</code>を渡します．</li>
</ul>
</li>
<li>
<p>❷ 実行を開始すると，<code>a.out</code>は1秒ごとに<code>.</code>を出力しながら<code>SIGUSR1</code>を待ちます．</p>
</li>
<li>
<p>別端末から<code>a.out</code>のプロセス番号を調べて(ここでは2696)，
<code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信しました．
その結果，<code>a.out</code>の実行が一時停止し(❸)，<code>gdb</code>に制御が戻りました．</p>
</li>
<li>
<p>今度は<code>SIGUSR1</code>の設定を変えてやってみます
❹ <code>handle SIGUSR1 nostop noprint pass</code>は，
「<code>SIGUSR1</code>で一時停止しない，表示もしない，<code>a.out</code>に<code>SIGUSR1</code>を渡す」
という設定を意味します
(<code>stop</code>, <code>nostop</code>, <code>print</code>, <code>noprint</code>, <code>pass</code>, <code>nopass</code>を指定可能です)．
<code>gdb</code>が<code>SIGUSR1</code>を受け取った時，
<code>gdb</code>は<code>a.out</code>を一時停止させず，<code>SIGUSR1</code>を<code>a.out</code>に渡すはずです．</p>
</li>
<li>
<p>実行を再開すると (❺ <code>c</code>)，
❻ <code>I am handler</code>が表示されています．
これは先程送った<code>SIGUSR1</code>に対して<code>a.out</code>のシグナルハンドラが出力した表示です．
ここでもう一度， 
<code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信すると，
(<code>gdb</code>は<code>a.out</code>を一時停止させること無く)
再度<code>I am handler</code>が表示されました．期待した通りの動作です．</p>
</li>
<li>
<p><code>ctrl-C</code> (❼ <code>^C</code>)を押して，<code>a.out</code>の動作を一時停止しました．</p>
</li>
</ul>
<h5 id="catch-signalを使う"><a class="header" href="#catch-signalを使う"><code>catch signal</code>を使う</a></h5>
<pre><code>$ gcc -g sigusr1.c
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❶ catch signal SIGUSR1
Catchpoint 1 (signal SIGUSR1)
(gdb) r
..........
❷ Catchpoint 1 (signal SIGUSR1), 0x00007ffff7ce57fa in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7fffffffde50, rem=rem@entry=0x7fffffffde50) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78	../sysdeps/unix/sysv/linux/clock_nanosleep.c: No such file or directory.
(gdb)
</code></pre>
<ul>
<li>❶ <code>catch signal SIGUSR1</code> で，<code>SIGUSR1</code>をキャッチする設定をします．</li>
<li>別端末から <code>kill -USR1 2696</code>として，<code>a.out</code>に<code>SIGUSR1</code>を送信すると，
期待通り，<code>SIGUSR1</code>をキャッチして<code>a.out</code>の実行が一時停止されました
(❷ <code>Catchpoint 1 (signal SIGUSR1)</code>)．</li>
<li><code>handle</code>も<code>catch</code>もシグナルをキャッチできるのですが，
<code>catch</code>が<code>handle</code>より嬉しいのは，<code>catch</code>を使うと
停止する<a href="./10-gdb.html#%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%83%96%E3%83%AC%E3%83%BC%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">条件</a>や
停止時に実行する
<a href="./10-gdb.html#break-with-commands">コマンドを設定</a>できることです．</li>
<li>なお <code>catch</code> を設定すると，<code>handle</code>の<code>nostop</code>設定は無視されます．</li>
</ul>
<h3 id="gdbのpythonプラグイン"><a class="header" href="#gdbのpythonプラグイン">GDBのPythonプラグイン</a></h3>
<p>PythonでGDBのユーザ定義コマンドを定義できます．</p>
<pre><code># gdb-script.py
class python_test (❶ gdb.Command):
    &quot;&quot;&quot;Python Script Test&quot;&quot;&quot;

    def __init__ (self):
        super (python_test, self).__init__ (
            &quot;python_test&quot;, gdb.COMMAND_USER
        )

    def invoke (self, args, from_tty):
        val = ❷ gdb.parse_and_eval (args)
        print (&quot;args = &quot; + args)
        print (&quot;val  = &quot; + str (val))
        ❸ gdb.execute (&quot;p/x&quot; + str (val) + &quot;\n&quot;);

python_test ()        
</code></pre>
<ul>
<li>例えば上の<code>gdb-script.py</code>は<code>python_test</code>というユーザ定義コマンドを定義します．
<code>~/.gdbinit</code>などでこのファイルを<code>source gdb-script.py</code>として読み込む必要があります．</li>
<li>定義するコマンドは❶<code>gdb.Command</code>のサブクラスとして定義します．
❷ <code>gdb.parse_and_eval</code>を使えば与えられた引数を<code>gdb</code>の下で評価できます．
❸ <code>gdb.execute</code>を使えば，<code>gdb</code>のコマンドとして実行できます．</li>
</ul>
<pre><code>$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1180: file fact.c, line 13.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❹ python_test $rsp
args = $rsp
val  = 0x7fffffffde60
$1 = 0x7fffffffde60
(gdb) help user-defined
User-defined commands.
The commands in this class are those defined by the user.
Use the &quot;define&quot; command to define a command.

List of commands:

❺ python_test -- Python Script Test
(gdb) 
</code></pre>
<ul>
<li><code>gdb</code>上で定義した<code>python_test</code>というコマンドを実行すると(❹)
意図通り実行できました(<code>%rsp</code>の値が評価されて<code>0x7fffffffde60</code>になっています)．</li>
<li><code>help user-defined</code>すると，ちゃんと登録されていました(❺)．</li>
</ul>
<h3 id="gdbmi-machine-interface"><a class="header" href="#gdbmi-machine-interface">GDB/MI machine interface</a></h3>
<p><code>gdb</code>のMI(マシンインタフェース)とは
<code>gdb</code>とのやり取りをプログラムで処理しやすくするためのモードです．</p>
<pre><code>$ gdb --interpreter=mi ./a.out
=thread-group-added,id=&quot;i1&quot;
=cmd-param-changed,param=&quot;auto-load safe-path&quot;,value=&quot;/&quot;
~&quot;Reading symbols from ./a.out...\n&quot;
(gdb) 
❶ b main
❷ &amp;&quot;b main\n&quot;
❸ ~&quot;Breakpoint 1 at 0x1180: file fact.c, line 13.\n&quot;
❹ =breakpoint-created,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000000000001180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}
^done
(gdb) 
r
&amp;&quot;r\n&quot;
~&quot;Starting program: /mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/a.out \n&quot;
=thread-group-started,id=&quot;i1&quot;,pid=&quot;5171&quot;
=thread-created,id=&quot;1&quot;,group-id=&quot;i1&quot;
=breakpoint-modified,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}
=library-loaded,id=&quot;/lib64/ld-linux-x86-64.so.2&quot;,target-name=&quot;/lib64/ld-linux-x86-64.so.2&quot;,host-name=&quot;/lib64/ld-linux-x86-64.so.2&quot;,symbols-loaded=&quot;0&quot;,thread-group=&quot;i1&quot;,ranges=[{from=&quot;0x00007ffff7fc5090&quot;,to=&quot;0x00007ffff7fee335&quot;}]
^running
*running,thread-id=&quot;all&quot;
(gdb) 
=library-loaded,id=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,target-name=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,host-name=&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;,symbols-loaded=&quot;0&quot;,thread-group=&quot;i1&quot;,ranges=[{from=&quot;0x00007ffff7c28700&quot;,to=&quot;0x00007ffff7dbaabd&quot;}]
~&quot;[Thread debugging using libthread_db enabled]\n&quot;
~&quot;Using host libthread_db library \&quot;/lib/x86_64-linux-gnu/libthread_db.so.1\&quot;.\n&quot;
=breakpoint-modified,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;1&quot;,original-location=&quot;main&quot;}
~&quot;\n&quot;
~&quot;Breakpoint 1, main () at fact.c:13\n&quot;
~&quot;13\t    printf (\&quot;%d\\n\&quot;, fact (5));\n&quot;
*stopped,reason=&quot;breakpoint-hit&quot;,disp=&quot;keep&quot;,bkptno=&quot;1&quot;,frame={addr=&quot;0x0000555555555180&quot;,func=&quot;main&quot;,args=[],file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,arch=&quot;i386:x86-64&quot;},thread-id=&quot;1&quot;,stopped-threads=&quot;all&quot;,core=&quot;1&quot;
(gdb) 
quit
&amp;&quot;quit\n&quot;
=thread-exited,id=&quot;1&quot;,group-id=&quot;i1&quot;
</code></pre>
<ul>
<li><code>gdb</code>のMIは「CSVのようなもの」です．</li>
<li>❶ <code>b main</code>とブレークポイントの設定をすると，
❷ <code>&amp;&quot;b main\n&quot;</code>と入力したコマンドが返り，
その結果 ❸ <code>~&quot;Breakpoint 1 at 0x1180: file fact.c, line 13.\n&quot;</code>と
付属情報が表示されます ❹ <code>=breakpoint-created,bkpt={number=&quot;1&quot;,type=&quot;breakpoint&quot;,disp=&quot;keep&quot;,enabled=&quot;y&quot;,addr=&quot;0x0000000000001180&quot;,func=&quot;main&quot;,file=&quot;fact.c&quot;,fullname=&quot;/mnt/hgfs/gondow/project/linux-x86-64-programming/src/asm/fact.c&quot;,line=&quot;13&quot;,thread-groups=[&quot;i1&quot;],times=&quot;0&quot;,original-location=&quot;main&quot;}</code>
各行は1行で，カンマ <code>,</code>などの区切り子(デリミタ)で区切られており，
プログラムで処理しやすい出力になっています．</li>
<li>JSONで出力してくればいいのにと思ったり．
<code>gdb</code>のMI出力をJSONに変換するツール<a href="https://github.com/cs01/pygdbmi">pygdbmi</a>
はあるようです(試していません)．</li>
</ul>
<h3 id="gdb-remote"><a class="header" href="#gdb-remote">遠隔デバッグ (<code>gdbserver</code>, <code>target remote</code>)</a></h3>
<p><code>gdb</code>は遠隔デバッグが可能です．
遠隔デバッグとは，デバッグ対象のプログラムが動作しているマシンとは
異なるマシン上でデバッグすることです．
リソースが貧弱な組み込みシステムなどで，遠隔デバッグは有用です．</p>
<p>ここでは(簡単のため)ローカルホスト，つまり同じマシン上で遠隔デバッグをしてみます</p>
<p>まず予め <code>gdbserver</code>をインストールしておく必要があります．</p>
<pre><code>$ sudo apt install gdbserver
</code></pre>
<p><code>gdbserver</code>を使ってデバッグしたいプログラム<code>a.out</code>を起動します．</p>
<pre><code>$ gdbserver :1234 ./a.out
Process ./a.out created; pid = 5195
Listening on port 1234
</code></pre>
<p><code>:1234</code>は遠隔でバッグに使用するポート番号です．</p>
<pre><code>$ ❶ gdb ./a.out
Reading symbols from ./a.out...
(gdb) ❷ target remote localhost:1234
Remote debugging using localhost:1234
Reading /lib64/ld-linux-x86-64.so.2 from remote target...
(gdb) ❸ c
Continuing.
Reading /lib/x86_64-linux-gnu/libc.so.6 from remote target...
[Inferior 1 (process 5195) exited normally]
(gdb) 
</code></pre>
<ul>
<li><code>gdb</code>を起動して(❶)，デバッグ対象を
遠隔で対象は<code>localhost:1234</code>と指定します(❷)．
(<code>localhost</code>を省略して <code>:1234</code>だけ指定してもOKです)．</li>
<li>デバッグ対象のプログラムはすでに実行を開始しているので，
❸<code>c</code>で実行を再開します．その後は通常の<code>gdb</code>と同様の操作が可能です．</li>
</ul>
<h3 id="トレースポイント-trace-actions-collect-tstart-tstop-tfind-tdump-tstatus"><a class="header" href="#トレースポイント-trace-actions-collect-tstart-tstop-tfind-tdump-tstatus">トレースポイント (<code>trace</code>, <code>actions</code>, <code>collect</code>, <code>tstart</code>, <code>tstop</code>, <code>tfind</code>, <code>tdump</code>, <code>tstatus</code>)</a></h3>
<p>通常，<code>gdb</code>を使う時はブレークポイントを使ってプログラムを一時的に停止させて，
対話的にデバッグ作業を行います．
一方，トレースポイントを使うと<strong>プログラムを一時停止させずに</strong>，
プログラムの動作を観察できます．
手順は以下の通りです．</p>
<ol>
<li><a href="./10-gdb.html#gdb-remote">遠隔デバッグ</a>でプログラムを
<code>gdb</code>の監視下に置きます．
(現在，トレースポイントは遠隔デバッグでのみ有効です)．</li>
<li><code>trace</code>と<code>collect</code>を使って，観察したい場所とデータを事前に設定します．</li>
<li><code>tstart</code>と<code>tstop</code>を使って，プログラムのデータ収集の開始と停止を指示します．</li>
<li>事後に<code>tfind</code>, <code>tdump</code>, <code>tstatus</code>で収集したデータを調査します．</li>
</ol>
<pre><code>$ gcc -g -static fact.c
$ gdbserver :1234 ./a.out
Process ./a.out created; pid = 5696
Listening on port 1234
</code></pre>
<p>ここでは簡単のため静的リンクでコンパイルした<code>a.out</code>を使って
遠隔でバッグの準備をします．</p>
<pre><code>$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) target remote :1234
Remote debugging using :1234
0x0000000000401620 in _start ()
(gdb) ❶ trace fact
Tracepoint 1 at 0x401754: file fact.c, line 5.
(gdb) ❷ actions
Enter actions for tracepoint 1, one per line.
End with a line saying just &quot;end&quot;.
&gt;❸ collect n
&gt;end
(gdb) b 14
Breakpoint 2 at 0x4017a1: file fact.c, line 14.
(gdb) ❹ tstart
(gdb) c
Continuing.

Breakpoint 2, main () at fact.c:14
14	}
(gdb) ❺ tstop
(gdb) ❻ tstatus
Trace stopped by a tstop command ().
Collected 6 trace frames.
Trace buffer has 5237852 bytes of 5242880 bytes free (0% full).
Trace will stop if GDB disconnects.
Not looking at any trace frame.
Trace started at 135843.311816 secs, stopped 5.701432 secs later.
(gdb) ❼ tfind start
Found trace frame 0, tracepoint 1
#0  fact (n=5, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) ❽ tdump
Data collected at tracepoint 1, trace frame 0:
n = 5
(gdb) ❾ tfind
Found trace frame 1, tracepoint 1
#0  fact (n=4, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 2, tracepoint 1
#0  fact (n=3, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 3, tracepoint 1
#0  fact (n=2, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 4, tracepoint 1
#0  fact (n=1, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) tfind
Found trace frame 5, tracepoint 1
#0  fact (n=0, n@entry=&lt;error reading variable: PC not available&gt;) at fact.c:5
5	    if (n &lt;= 0)
(gdb) quit
</code></pre>
<ul>
<li>
<p>事前準備をします．
関数<code>fact</code>にトレースポイントを設定します(❶ <code>trace fact</code>)．
<a href="./10-gdb.html#break-with-commands">コマンド付きブレークポイント</a>の
<code>comands</code>と同じ要領で，
❷ <code>actions</code>を使って，トレースポイントで収集するデータや動作を指定します．
ここでは単に引数$n$の値を収集します (❸ <code>collect n</code>)．</p>
</li>
<li>
<p>❹ <code>tstart</code>でデータの収集を開始します．
<code>continue</code>でプログラムの実行を再開すると，
トレースポイントにヒットした情報が集められます．
❺ <code>tstop</code>で収集を終了します．</p>
</li>
<li>
<p>事後の調査をします．
❻ <code>tstatus</code>で収集状況を調べると，
6回トレースポイントにヒットしてデータを収集していました
(<code>Collected 6 trace frames</code>)．
❼ <code>tfind start</code>で最初の収集データを見ます．
❽ <code>tdump</code>とするとその収集データの内容を全て表示します
(が，ここでは引数<code>n</code>の値しか表示されません)．
引数無しで ❾ <code>tfind</code>とすると，次の収集データを表示します．
引数<code>n</code>の値が，6から0まで変化したことが分かりました．</p>
</li>
</ul>
<p>トレースポイントに関する付記:</p>
<ul>
<li><code>trace</code>には<code>if</code>を使って
ヒットする<a href="./10-gdb.html#%E6%9D%A1%E4%BB%B6%E4%BB%98%E3%81%8D%E3%83%96%E3%83%AC%E3%83%BC%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">条件</a>を指定可能です．</li>
<li><code>trace</code>は<code>int3</code>などのトラップ命令を使って<strong>計装</strong>(instrumentation)するので遅いです．<code>ftrace</code>を使うと5バイト長のジャンプ命令を使って計装するので高速になります
(が，計装位置の命令長が5バイト以上必要です)．
(試していませんが)静的計装を行う<code>strace</code>もあります．</li>
</ul>
<h3 id="実行の記録とリプレイ逆実行-record-full-reverse-step"><a class="header" href="#実行の記録とリプレイ逆実行-record-full-reverse-step">実行の記録とリプレイ，逆実行 (<code>record full</code>, <code>reverse-step</code>)</a></h3>
<p><code>gdb</code>では実行状態の記録とリプレイが可能です．
またリプレイ機能を使って逆実行も可能です．
リプレイでは実際には機械語命令の実行を行わず，
実行ログの内容を使って，メモリやレジスタの値を変化させます．</p>
<pre><code>$ gcc -g fact.s
$ gdb ./a.out
Reading symbols from ./a.out...
(gdb) b main
Breakpoint 1 at 0x40177c: file fact.c, line 13.
(gdb) r
Breakpoint 1, main () at fact.c:13
13	    printf (&quot;%d\n&quot;, fact (5));
(gdb) ❶ record full
(gdb) b fact if n==0
Breakpoint 2 at 0x401754: file fact.c, line 5.
(gdb) c
Continuing.

Breakpoint 2, fact (n=0) at fact.c:5
5	    if (n &lt;= 0)
(gdb) reverse-TABTAB
reverse-continue  reverse-next      reverse-search    reverse-stepi
reverse-finish    reverse-nexti     reverse-step      
(gdb) ❷ reverse-next
8	        return n * fact (n - 1);
(gdb) (改行のみ入力，以下も同様)
5	    if (n &lt;= 0)
(gdb) 
8	        return n * fact (n - 1);
(gdb) 
5	    if (n &lt;= 0)
(gdb) 
8	        return n * fact (n - 1);
(gdb) ❸ print n
$1 = 3
(gdb) quit
</code></pre>
<ul>
<li>
<p>❶ <code>record full</code>で実行状態の記録を開始します．
ソフトウェア的に全実行状態を保存します．
(当然，メモリを激しく消費します)．</p>
</li>
<li>
<p>❷ <code>reverse-next</code>など逆実行用のステップ実行を行うと，
逆実行できます(実際には実行はせず，元の状態に戻すだけですが)．
❸ <code>n</code>の値が3の状態まで戻りました．</p>
</li>
</ul>
<p>実行の記録とリプレの付記:</p>
<ul>
<li><code>record full</code>ではなく，<code>record btrace pt</code>などとすると，
ハードウェア機能(例えば，Intel PT)を使った高速な記録になりますが，
リングバッファを使うため，バッファがあふれると古いデータは捨てられます．</li>
<li><code>record stop</code>とすると実行の記録を止めて実行ログは破棄されます．
実行ログは <code>record save ファイル名</code>，<code>record restore ファイル名</code>で
保存や回復が可能です．上の例だとファイルサイズは約700KBでした．</li>
<li>x86-64ではAVX命令などが非対応のようです．
例えば，AVX512の<code>vmovdqu</code>命令を試すと，以下のエラーとなりました(2023/8/27現在)．</li>
</ul>
<pre><code>main () at movdqu.s:23
23	vmovdqu (%rsp), %ymm0
(gdb) 
Process record does not support instruction 0xc5 at address 0x555555555171.
Process record: failed to record execution log.
(gdb) 
</code></pre>
<p>glibcなどのライブラリは<code>-O2</code>などでコンパイルされているため，
AVX命令が使われることが多くあります．
試しに<code>hello.c</code>で試した所，同じエラーとなりました．</p>
<pre><code>(gdb) n
5	    printf (&quot;hello\n&quot;);
(gdb) n
Process record does not support instruction 0xc5 at address 0x7ffff7d9d969.
Process record: failed to record execution log.
</code></pre>
<!--
- 最適化されたコードのデバッグ p.193
  - インライン関数，末尾コール最適化，
## 悩みどころ
- 簡単なドリル問題があったほうが良い
- コマンドの短縮形と長い名前(なれるまでは長い名前が理解しやすい)
-->
<!--
⓿ ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴
-->
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 12; }
</style>
<h1 id="x86-64-命令一覧"><a class="header" href="#x86-64-命令一覧">x86-64 命令一覧</a></h1>
<h2 id="概要と記号"><a class="header" href="#概要と記号">概要と記号</a></h2>
<p><a href="./asm/add5.c"><code>add5.c</code></a>を<code>gcc -S add5.c</code>でコンパイルした結果
<a href="./asm/add5.s"><code>add5.s</code></a>(余計なものの削除後)を用いて，
x86-64アセンブリ言語の概要と記号を説明します．</p>
<img src="figs/add5.svg" height="300px" id="fig:add5">
<ul>
<li><code>$ gcc -S add5.c</code>を実行(コンパイル)すると，アセンブリコード<code>add5.s</code>が生成されます．(結果は環境依存なので，<code>add5.s</code>の中身が違ってても気にしなくてOK)</li>
<li>ドット記号 <code>.</code> で始まるのは<strong>アセンブラ命令</strong>(assembler directive)です．</li>
<li>コロン記号 <code>:</code> で終わるのは<strong>ラベル定義</strong>です．</li>
<li>シャープ記号 <code>#</code> から行末までと，<code>/*</code>と<code>*/</code>で囲まれた範囲(複数行可)は<strong>コメント</strong>です．</li>
<li><code>movq %rsp, %rbp</code> は<strong>機械語命令</strong>(2進数)の記号表現(<strong>ニモニック</strong>(mnemonic))です．<code>movq</code>が命令で<strong>オペコード</strong>(opcode)，<code>%rsp</code>と<code>%rbp</code>は引数で<strong>オペランド</strong>(operand)と呼ばれます．</li>
<li>ドル記号 <code>$</code> で始まるのは<strong>即値</strong>(immediate value，定数)です．</li>
<li>パーセント記号 <code>%</code>で始まるのは<strong>レジスタ</strong>です．</li>
<li><code>-4(%rbp)</code>は<a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a>です．この場合は「<code>%rbp-4</code>の計算結果」をアドレスとするメモリの内容にアクセスすることを意味します．</li>
</ul>
<h2 id="命令サフィックス"><a class="header" href="#命令サフィックス">命令サフィックス</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">AT&amp;T形式の<br/>サイズ指定</th><th>Intel形式の<br/>サイズ指定</th><th>メモリオペランドの<br/>サイズ</th><th>AT&amp;T形式での例</th><th>Intel形式での例</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>b</code></td><td><code>BYTE PTR</code></td><td>1バイト(8ビット)</td><td><code>movb $10, -8(%rbp)</code></td><td><code>mov BYTE PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>w</code></td><td><code>WORD PTR</code></td><td>2バイト(16ビット)</td><td><code>movw $10, -8(%rbp)</code></td><td><code>mov WORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>l</code></td><td><code>DWORD PTR</code></td><td>4バイト(32ビット)</td><td><code>movl $10, -8(%rbp)</code></td><td><code>mov DWORD PTR [rbp-8], 10</code></td></tr>
<tr><td style="text-align: center"><code>q</code></td><td><code>QWORD PTR</code></td><td>8バイト(64ビット)</td><td><code>movq $10, -8(%rbp)</code></td><td><code>mov QWORD PTR [rbp-8], 10</code></td></tr>
</tbody></table>
</div>
<ul>
<li><a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a>ではサイズ指定が必要です
(「何バイト読み書きするのか」が決まらないから)</li>
<li>AT&amp;T形式では<strong>命令サフィックス</strong>(instruction suffix)でサイズを指定します．
例えば<code>movq $10, -8(%rbp)</code>の<code>q</code>は，
「メモリ参照<code>-8(%rbp)</code>への書き込みサイズが8バイト」であることを意味します．</li>
</ul>
<details>
<summary>
サフィックスとプリフィックス
</summary>
<p>サフィックス(suffix)は<strong>接尾語</strong>(後ろに付けるもの)，
プリフィックス(prefix)は<strong>接頭語</strong>(前に付けるもの)という意味です．</p>
</details>
<ul>
<li>Intel形式ではメモリ参照の前に，<code>BYTE PTR</code>などと指定します．</li>
<li>他のオペランドからサイズが決まる場合は命令サフィックスを省略可能です．
例えば，<code>movq %rax, -8(%rsp)</code>は<code>mov %rax, -8(%rsp)</code>にできます．
<code>mov</code>命令の2つのオペランドはサイズが同じで
<code>%rax</code>レジスタのサイズが8バイトだからです．</li>
</ul>
<h2 id="即値定数"><a class="header" href="#即値定数">即値(定数)</a></h2>
<!--
| 種類 | 説明 | 例 |
|-|-|-|
|10進数定数|`0`で始まらない| `pushq $74`|
|16進数定数|`0x`か`0X`で始まる|`pushq $0x4A`|
|8進数定数|`0`で始まる|`pushq $0112`|
|2進数定数|`0b`か`0B`で始まる|`pushq $0b01001010`|
|文字定数|`'`(クオート)で始まる| `pushq $'J`|
|文字定数|`'`(クオート)で囲む| `pushq $'J'`|
|文字定数|`\`バックスラッシュ<br/>でエスケープ可|`pushq $'\n`|
-->
<div class="table-wrapper"><table><thead><tr><th>種類</th><th>説明</th><th>例</th></tr></thead><tbody>
<tr><td>10進数定数</td><td><code>0</code>で始まらない</td><td><code>pushq $74</code></td></tr>
<tr><td>16進数定数</td><td><code>0x</code>か<code>0X</code>で始まる</td><td><code>pushq $0x4A</code></td></tr>
<tr><td>8進数定数</td><td><code>0</code>で始まる</td><td><code>pushq $0112</code></td></tr>
<tr><td>2進数定数</td><td><code>0b</code>か<code>0B</code>で始まる</td><td><code>pushq $0b01001010</code></td></tr>
<tr><td rowspan="3">文字定数</td><td><code>'</code>(クオート)で始まる</td><td><code>pushq $'J</code></td></tr>
<tr><td><code>'</code>(クオート)で囲む</td><td><code>pushq $'J'</code></td></tr>
<tr><td><code>\</code>バックスラッシュ<br/>でエスケープ可</td
><td><code>pushq $'\n</code></td></tr>
</tbody></table>
</div>  
<ul>
<li><strong>即値</strong>(immediate value，定数)には<code>$</code>をつけます</li>
<li>上の例の定数は最後以外は全部，値が同じです</li>
<li>GNUアセンブラでは文字定数の値は<a href="./4-data.html#ASCII">ASCIIコード</a>です．
上の例では，文字<code>'J'</code>の値は<code>74</code>です．</li>
<li>バックスラッシュでエスケープできる文字は，
<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>,  <code>\&quot;</code>, <code>\\</code> です．
また<code>\123</code>は8進数，<code>\x4F</code>は16進数で指定した文字コードになります．</li>
<li>多くの場合，即値は32ビットまでで，
オペランドのサイズが64ビットの場合，
32ビットの即値は，64ビットの演算前に
<strong>64ビットに<a href="./4-data.html#%E7%AC%A6%E5%8F%B7%E6%8B%A1%E5%BC%B5">符号拡張</a></strong> されます
(<a href="./4-data.html#%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a>だと
負の値が大きな正の値になって困るから)</li>
</ul>
<details>
<summary>
64ビットに符号拡張される例(1)
</summary>
<div id="imm-64bit-signed-extended">
<pre><code class="language-x86asmatt"># asm/add-imm2.s
    .text
    .globl main
    .type main, @function
main:
    movq $0, %rax
    addq $-1, %rax
    ret
    .size main, .-main
</code></pre>
<p>上の<code>addq $-1, %rax</code>命令の即値<code>$-1</code>は
32ビット(以下の場合もあります)の符号あり整数<code>$0xFFFFFFFF</code>として
機械語命令に埋め込まれます．
<code>addq</code>命令が実行される時は，
この<code>$0xFFFFFFFF</code>が64ビットに符号拡張されて<code>$0xFFFFFFFFFFFFFFFF</code>となります．
以下の実行例でもこれが確認できました．</p>
<pre><code>0 + 0xFFFFFFFFFFFFFFFF = 0xFFFFFFFFFFFFFFFF
</code></pre>
<pre><code>$ gcc -g add-imm2.s
$ gdb ./a.out -x add-imm2.txt
Breakpoint 1, main () at add-imm2.s:8
8	    ret
7	    addq $-1, %rax
$1 = 0xffffffffffffffff
# 0xffffffffffffffff が表示されていれば成功
</code></pre>
</div>
</details>
<details>
<summary>
64ビットに符号拡張される例(2)
</summary>
<p>32ビットの即値が，64ビットの演算前に64ビットに符号拡張されることを見てみます．
32ビット符号あり整数が表現できる範囲は<code>-0x80000000</code>から<code>0x7FFFFFFF</code>です．</p>
<pre><code class="language-x86asmatt"># asm/add-imm.s
    .text
    .globl main
    .type main, @function
main:
    movq $0, %rax
    addl $0xFFFFFFFF, %eax          # OK (0xFFFFFFFF = -1)
#    addq $0xFFFFFFFF, %rax         # NG (0x7FFFFFFFを超えている)
    addq $0xFFFFFFFFFFFFFFFF, %rax  # OK (0xFFFFFFFFFFFFFFFF = -1)
    addq $0x7FFFFFFF, %rax          # OK
    addq $-0x80000000, %rax         # OK
    addq $0xFFFFFFFF80000000, %rax  # OK (0xFFFFFFFF80000000 = -0x80000000)
    ret
    .size main, .-main
</code></pre>
<ul>
<li>
<p>7行目の<code>$0xFFFFFFFF</code>は32ビット符号あり整数として<code>-1</code>，
つまり32ビット符号あり整数が表現できる範囲内なのでOKです．</p>
</li>
<li>
<p>一方，8行目の<code>$0xFFFFFFFF</code>は
64ビット符号あり整数として<code>$0x7FFFFFFF</code>を超えてるのでNGです．
(アセンブルするとエラーになります)</p>
</li>
<li>
<p>9行目の<code>$0xFFFFFFFFFFFFFFFF</code>は一見NGですが，
64ビット符号あり整数としての値は<code>-1</code>なので，
GNUアセンブラはこの即値を<code>-1</code>として機械語命令に埋め込みます．</p>
</li>
<li>
<p>いちばん大事なのは最後の2つの<code>addq</code>命令です．
<code>addq $-0x80000000, %rax</code>の
即値<code>$-0x80000000</code>は(機械語命令中では32ビットで埋め込まれますが)
足し算を実行する前に64ビットに符号拡張されるので，
<code>$0xFFFFFFFF80000000</code>という値で足し算されます．
(つまり，<code>$0x80000000</code>を引きます)．
以下の実行例を見ると，その通りの実行結果になっています．</p>
<ul>
<li><code>❶ 0x17ffffffd - $0x80000000 = ❷ 0xfffffffd</code></li>
<li><code>❷ 0xfffffffd - $0x80000000 = ❸ 0x7ffffffd</code></li>
</ul>
<p>一方，もし <code>$-0x80000000</code>を(符号拡張ではなく)
<strong><a href="4-data.html#%E3%82%BC%E3%83%AD%E6%8B%A1%E5%BC%B5">ゼロ拡張</a></strong> すると，
<code>$0x0000000080000000</code>となるので，
<code>$0x80000000</code>を(引くのではなく)足すことになってしまいます．</p>
</li>
</ul>
<pre><code>$ gcc -g add-imm.s
$ gdb ./a.out -x add-imm.txt
Breakpoint 1, main () at add-imm.s:7
7	    addl $0xFFFFFFFF, %eax          # OK (0xFFFFFFFF = -0x1)
9	    addq $0xFFFFFFFFFFFFFFFF, %rax  # OK (0xFFFFFFFFFFFFFFFF = -0x1)
1: /x $rax = 0xffffffff
10	    addq $0x7FFFFFFF, %rax          # OK
1: /x $rax = 0xfffffffe
11	    addq $-0x80000000, %rax         # OK
1: /x $rax = ❶ 0x17ffffffd
12	    addq $0xFFFFFFFF80000000, %rax  # OK (0xFFFFFFFF80000000 = -0x80000000)
1: /x $rax = ❷ 0xfffffffd
main () at add-imm.s:13
13	    ret
1: /x $rax = ❸ 0x7ffffffd
#以下が表示されていれば成功
#1: /x $rax = 0xffffffff
#1: /x $rax = 0xfffffffe
#1: /x $rax = 0x17ffffffd
#1: /x $rax = 0xfffffffd
#1: /x $rax = 0x7ffffffd
</code></pre>
<p>以下の通り，逆アセンブルすると，
32ビット以下の即値として機械語命令中に埋め込まれていることが分かります．</p>
<pre><code>$ gcc -g add-imm.s
$ objdump -d ./a.out
0000000000001129 &lt;main&gt;:
    1129:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    1130:	83 c0 ff             	add    $0xffffffff,%eax
    1133:	48 83 c0 ff          	add    $0xffffffffffffffff,%rax
    1137:	48 05 ff ff ff 7f    	add    $0x7fffffff,%rax
    113d:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
    1143:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
    1149:	c3                   	ret    
</code></pre>
</details>
<ul>
<li><code>mov</code>命令は例外で64ビットの即値を扱えます</li>
</ul>
<details>
<summary>
64ビットの即値を扱う例
</summary>
<div id="mov-64bit-imm">
<pre><code class="language-x86asmatt"># asm/movqabs-1.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movabsq $0x99AABBCCDDEEFF00, %rax
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g movqabs-1.s
$ gdb ./a.out -x movqabs-1.txt
Breakpoint 1, main () at movqabs-1.s:6
6	    movq $0x1122334455667788, %rax
7	    movabsq $0x99AABBCCDDEEFF00, %rax
1: /x $rax = 0x1122334455667788
main () at movqabs-1.s:8
8	    ret
1: /x $rax = 0x99aabbccddeeff00
# 以下が表示されれば成功
# 1: /x $rax = 0x1122334455667788
# 1: /x $rax = 0x99aabbccddeeff00
</code></pre>
</div>
</details>
<ul>
<li>ジャンプでは64ビットの相対ジャンプができないので，
間接ジャンプを使う必要がある</li>
</ul>
<details>
<summary>
64ビットの相対ジャンプの代わりに間接ジャンプを使う例
</summary>
<pre><code class="language-x86asmatt"># asm/jmp-64bit.s
    .text
    .globl main
    .type main, @function
main:
#    jmp 0x1122334455667788           # NG
    movq $0x1122334455667788, %rax
    jmp *%rax
    ret
    .size main, .-main
</code></pre>
<p><code>0x1122334455667788</code>はいい加減なアドレスなので，
コンパイルは可能ですが，実行すると segmentation fault になります．</p>
</details>
<h2 id="レジスタ"><a class="header" href="#レジスタ">レジスタ</a></h2>
<h3 id="汎用レジスタ-2"><a class="header" href="#汎用レジスタ-2">汎用レジスタ</a></h3>
<img src="figs/gp-regs.svg" height="350px" id="fig:gp-regs">
<ul>
<li>上記16個のレジスタが<strong>汎用レジスタ</strong>(general-purpose register)です．
原則として，プログラマが自由に使えます．</li>
<li>ただし，<code>%rsp</code>は<strong>スタックポインタ</strong>，<code>%rbp</code>は<strong>ベースポインタ</strong>と呼び，
<a href="./2-asm-intro.html#stack-rsp-rbp">一番上のスタックフレームの上下を指す</a>
という役割があります．
(ただし，<a href="./2-asm-intro.html#-fomit-frame-pointer">-fomit-frame-pointer</a>
オプションでコンパイルされた<code>a.out</code>中では，<code>%rbp</code>はベースポインタとしてではなく，
汎用レジスタとして使われています)．</li>
</ul>
<h4 id="caller-savecallee-saveレジスタ-1"><a class="header" href="#caller-savecallee-saveレジスタ-1"><a href="./6-inst.html#caller-callee-save-regs">caller-save/callee-saveレジスタ</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th></th><th>汎用レジスタ</th></tr></thead><tbody>
<tr><td>caller-saveレジスタ</td><td><code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>〜<code>%r11</code></td></tr>
<tr><td>callee-saveレジスタ</td><td><code>%rbx</code>, <code>%rbp</code>, <code>%rsp</code>, <code>%r12</code>〜<code>%r15</code></td></tr>
</tbody></table>
</div>
<h4 id="引数-1"><a class="header" href="#引数-1"><a href="./6-inst.html#arg-reg">引数</a></a></h4>
<div class="table-wrapper"><table><thead><tr><th>引数</th><th>レジスタ</th></tr></thead><tbody>
<tr><td>第1引数</td><td><code>%rdi</code></td></tr>
<tr><td>第2引数</td><td><code>%rsi</code></td></tr>
<tr><td>第3引数</td><td><code>%rdx</code></td></tr>
<tr><td>第4引数</td><td><code>%rcx</code></td></tr>
<tr><td>第5引数</td><td><code>%r8</code></td></tr>
<tr><td>第6引数</td><td><code>%r9</code></td></tr>
</tbody></table>
</div>
<ul>
<li>第7引数以降はレジスタではなくスタックを介して渡します</li>
</ul>
<h3 id="プログラムカウンタ命令ポインタ-1"><a class="header" href="#プログラムカウンタ命令ポインタ-1">プログラムカウンタ（命令ポインタ）</a></h3>
<img src="figs/rip.svg" height="100px" id="fig:rip">
<h3 id="ステータスレジスタフラグレジスタ-1"><a class="header" href="#ステータスレジスタフラグレジスタ-1"><a href="./6-inst.html#status-reg">ステータスレジスタ（フラグレジスタ）</a></a></h3>
<img src="figs/rflags.svg" height="100px" id="fig:rflags">
<h4 id="本書で扱うフラグ-1"><a class="header" href="#本書で扱うフラグ-1">本書で扱うフラグ</a></h4>
<p>ステータスレジスタのうち，本書は以下の6つのフラグを扱います．</p>
<div class="table-wrapper"><table><thead><tr><th>フラグ</th><th>名前</th><th>説明</th></tr></thead><tbody>
<tr><td><code>CF</code></td><td>キャリーフラグ</td><td>算術演算で結果の最上位ビットにキャリーかボローが生じるとセット．それ以外はクリア．符号<strong>なし</strong>整数演算でのオーバーフロー状態を表す．</td></tr>
<tr><td><code>OF</code></td><td>オーバーフローフラグ</td><td>符号ビット(MSB)を除いて，整数の演算結果が大きすぎるか小さすぎるかするとセット．それ以外はクリア．2の補数表現での符号<strong>あり</strong>整数演算のオーバーフロー状態を表す．</td></tr>
<tr><td><code>ZF</code></td><td>ゼロフラグ</td><td>結果がゼロの時にセット．それ以外はクリア．</td></tr>
<tr><td><code>SF</code></td><td>符号フラグ</td><td>符号あり整数の符号ビット(MSB)と同じ値をセット．(0は正の数，1は負の数であることを表す)</td></tr>
<tr><td><code>PF</code></td><td>パリティフラグ</td><td>結果の最下位バイトの値1のビットが偶数個あればセット，奇数個であればクリア．</td></tr>
<tr><td><code>AF</code></td><td>調整フラグ</td><td>算術演算で，結果のビット3にキャリーかボローが生じるとセット．それ以外はクリア．BCD演算で使用する(本書ではほとんど使いません)．</td></tr>
</tbody></table>
</div>
<h4 id="ステータスフラグの変化の記法"><a class="header" href="#ステータスフラグの変化の記法">ステータスフラグの変化の記法</a></h4>
<p>x86-64命令を実行すると，ステータスフラグが変化する命令と
変化しない命令があります．
ステータスフラグの変化は以下の記法で表します．</p>
<div class="table-wrapper"><table><thead><tr><th><a href="x86-list.html#status-reg">CF</a></th><th><a href="x86-list.html#status-reg">OF</a></th><th><a href="x86-list.html#status-reg">SF</a></th><th><a href="x86-list.html#status-reg">ZF</a></th><th><a href="x86-list.html#status-reg">PF</a></th><th><a href="x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td>!</td><td>?</td><td>0</td><td>1</td><td></td></tr>
</tbody></table>
</div>
<p>記法の意味は以下の通りです．</p>
<div id="status-reg">
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>意味</th></tr></thead><tbody>
<tr><td>空白</td><td>フラグ値に変化なし</td></tr>
<tr><td>!</td><td>フラグ値に変化あり</td></tr>
<tr><td>?</td><td>フラグ値は未定義(参照禁止)</td></tr>
<tr><td>0</td><td>フラグ値はクリア(0になる)</td></tr>
<tr><td>1</td><td>フラグ値はセット(1になる)</td></tr>
</tbody></table>
</div></div>
<!--
### セグメントレジスタ
-->
<h3 id="レジスタの別名-1"><a class="header" href="#レジスタの別名-1">レジスタの別名</a></h3>
<h4 id="raxレジスタの別名-rbx-rcx-rdxも同様-1"><a class="header" href="#raxレジスタの別名-rbx-rcx-rdxも同様-1"><code>%rax</code>レジスタの別名 (<code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>も同様)</a></h4>
<img src="figs/reg-alias1.svg" height="150px" id="fig:reg-alias1">
<ul>
<li><code>%rax</code>の下位32ビットは<code>%eax</code>としてアクセス可能</li>
<li><code>%eax</code>の下位16ビットは<code>%ax</code>としてアクセス可能</li>
<li><code>%ax</code>の上位8ビットは<code>%ah</code>としてアクセス可能</li>
<li><code>%ax</code>の下位8ビットは<code>%al</code>としてアクセス可能</li>
</ul>
<h4 id="rbpレジスタの別名-rsp-rdi-rsiも同様-1"><a class="header" href="#rbpレジスタの別名-rsp-rdi-rsiも同様-1"><code>%rbp</code>レジスタの別名 (<code>%rsp</code>, <code>%rdi</code>, <code>%rsi</code>も同様)</a></h4>
<img src="figs/reg-alias2.svg" height="150px" id="fig:reg-alias2">
<ul>
<li><code>%rbp</code>の下位32ビットは<code>%ebp</code>としてアクセス可能</li>
<li><code>%ebp</code>の下位16ビットは<code>%bp</code>としてアクセス可能</li>
<li><code>%bp</code>の下位8ビットは<code>%bpl</code>としてアクセス可能</li>
</ul>
<h4 id="r8レジスタの別名-r9r15も同様-1"><a class="header" href="#r8レジスタの別名-r9r15も同様-1"><code>%r8</code>レジスタの別名 (<code>%r9</code>〜<code>%r15</code>も同様)</a></h4>
<img src="figs/reg-alias3.svg" height="150px" id="fig:reg-alias3">
<ul>
<li><code>%r8</code>の下位32ビットは<code>%r8d</code>としてアクセス可能</li>
<li><code>%r8d</code>の下位16ビットは<code>%r8w</code>としてアクセス可能</li>
<li><code>%r8w</code>の下位8ビットは<code>%r8b</code>としてアクセス可能</li>
</ul>
<h4 id="同時に使えない制限-1"><a class="header" href="#同時に使えない制限-1">同時に使えない制限</a></h4>
<ul>
<li>一部のレジスタは<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>と一緒には使えない．</li>
<li>例：<code>movb %ah, (%r8)</code> や <code>movb %ah, %bpl</code>はエラーになる．</li>
<li>正確には<a href="./4-data.html#REX-prefix"><code>REX</code>プリフィクス</a>付きの命令では，<code>%ah</code>, <code>%bh</code>, <code>%ch</code>, <code>%dh</code>を使えない．</li>
</ul>
<h3 id="zero-upper32"><a class="header" href="#zero-upper32">32ビットレジスタ上の演算は64ビットレジスタの上位32ビットをゼロにする</a></h3>
<ul>
<li>例:<code>movl $0xAABBCCDD, %eax</code>を実行すると<code>%rax</code>の上位32ビットが全てゼロになる</li>
<li>例: <code>movw $0x1122, %ax</code>や<code>movb $0x11, %al</code>では上位をゼロにすることはない</li>
</ul>
<details>
<summary>
上位32ビットをゼロにする実行例
</summary>
<img src="figs/zero-upper32.svg" height="250px" id="fig:zero-upper32">
<pre><code class="language-x86asmatt"># asm/zero-upper32.s
    .text
    .globl main
    .type main, @function
main:
    movq $0x1122334455667788, %rax
    movl $0xAABBCCDD, %eax
    movq $0x1122334455667788, %rax
    movw $0x1122, %ax
    movq $0x1122334455667788, %rax
    movb $0x11, %al
    ret
    .size main, .-main
</code></pre>
<pre><code>$ gcc -g zero-upper32.s
$ gdb ./a.out -x zero-upper32.txt
Breakpoint 1, main () at zero-upper32.s:7
7	    movl $0xAABBCCDD, %eax
6	    movq $0x1122334455667788, %rax
7	    movl $0xAABBCCDD, %eax
$1 = 0x1122334455667788
8	    movq $0x1122334455667788, %rax
$2 = 0x00000000aabbccdd
# 以下が出力されれば成功
# $1 = 0x1122334455667788 (%raxは8バイトの値を保持)
# $2 = 0x00000000aabbccdd (%raxの上位4バイトがゼロになった)
</code></pre>
</details>
<h2 id="アドレッシングモードオペランドの記法"><a class="header" href="#アドレッシングモードオペランドの記法">アドレッシングモード(オペランドの記法)</a></h2>
<h3 id="アドレッシングモードの種類"><a class="header" href="#アドレッシングモードの種類">アドレッシングモードの種類</a></h3>
<div class="table-wrapper"><table><thead><tr><th>アドレッシング<br/>モードの種類</th><th>オペランドの値</th><th>例</th><th>計算するアドレス</th></tr></thead>
<tbody>
<tr><td rowspan="2">
<p><a href="./6-inst.html#addr-mode-imm">即値(定数)</a></p>
</td><td rowspan="2">定数の値</td><td><code>movq $0x100, %rax</code></td></tr>
<tr><td><code>movq $foo, %rax</code></td></tr>
<tr><td>
<p><a href="./6-inst.html#addr-mode-reg">レジスタ参照</a>
<br/></td><td>レジスタの値</td><td><code>movq %rbx, %rax</code></td></tr></p>
<tr><td rowspan="2">
<p><a href="./6-inst.html#addr-mode-direct">直接メモリ参照</a></p>
</td><td rowspan="2">定数で指定した<br/>アドレスのメモリ値</td><td><code>movq 0x100, %rax</code></td><td><code>0x100</code></td></tr>
<tr><td><code>movq foo, %rax</code></td><td><code>foo</code></td></tr>
<tr><td rowspan="3">
<p><a href="./6-inst.html#addr-mode-indirect">間接メモリ参照</a></p>
</td><td rowspan="3">レジスタ等で計算した<br/>アドレスのメモリ値</td><td><code>movq (%rsp), %rax</code></td><td><code>%rsp</code></td></tr>
<tr><td><code>movq 8(%rsp), %rax</code></td><td><code>%rsp+8</code></td></tr>
<tr><td><code>movq foo(%rip), %rax</code></td><td><code>%rip+foo</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>foo</code>はラベルであり，定数と同じ扱い．(定数を書ける場所にはラベルも書ける)．</li>
<li>メモリ参照では例えば<code>-8(%rbp, %rax, 8)</code>など複雑なオペランドも指定可能．
参照するメモリのアドレスは<code>-8+%rbp+%rax*8</code>になる．
(<a href="x86-list.html#%E3%83%A1%E3%83%A2%E3%83%AA%E5%8F%82%E7%85%A7">以下</a>を参照)．</li>
</ul>
<h3 id="メモリ参照の形式"><a class="header" href="#メモリ参照の形式">メモリ参照の形式</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th><a href="./7-asm.html#att-intel">AT&amp;T形式</a></th><th><a href="./7-asm.html#att-intel">Intel形式</a></th><th>計算されるアドレス</th></tr></thead><tbody>
<tr><td>通常のメモリ参照</td><td>disp (base, index, scale)</td><td>[base + index * scale + disp]</td><td>base + index * scale + disp</td></tr>
<tr><td><code>%rip</code>相対参照</td><td>disp (<code>%rip</code>)</td><td>[rip + disp]</td><td><code>%rip</code> + disp</td></tr>
</tbody></table>
</div>
<blockquote>
<p>注：
Intelのマニュアルには「segment: メモリ参照」という形式もあるとありますが，
segment: はほとんど使わないので，省いて説明します．</p>
</blockquote>
<details>
<summary>
segmentは使わないの?(いえ，ちょっと使います)
</summary>
<div id="segment-override">
segment(正確にはsegment-override)はx86-64ではほとんど使いません．
が，segmentを使ったメモリ参照をする場合があります．
例えば，`%fs:0xfffffffffffffffc`がその例です．
<p><code>%fs</code>は<strong>セグメントレジスタ</strong>と呼ばれる16ビット長のレジスタで，
他には<code>%cs</code>，<code>%ds</code>，<code>%ss</code>，<code>%es</code>，<code>%gs</code>があります．
x86-64では<code>%cs</code>，<code>%ds</code>，<code>%ss</code>，<code>%es</code>は常にベースアドレスが0と扱われます．
<code>%fs:</code>という記法が使われた時は，
「<code>%fs</code>レジスタが示す<strong>ベースアドレス</strong>をアクセスするアドレスに加える」
ことを意味します．</p>
<p><code>%fs</code>のベースレジスタの値を得るには次の方法があります．</p>
<ul>
<li><code>arch_prctl()</code>システムコールを使う (ここでは説明しません)．</li>
<li><code>gdb</code>で<code>p/x $fs_base</code>を実行する．
(なお，<code>p/x $fs</code>を実行すると<code>0</code>が返りますがこの値は嘘です)</li>
<li><code>rdfsbase</code>命令を使う．</li>
</ul>
<details>
<summary>
rdfsbase命令はCPUとOSの設定に依存
</summary>
<p><code>rdfsbase</code>命令が使えるかどうかは，CPUとOSの設定に依存します．
<code>/proc/cpuinfo</code>の<code>flags</code>の表示に<code>fsgsbase</code>があれば，<code>rdfsbase</code>命令は使えます．
(以下の出力例では<code>fsgsbase</code>が入っています)．</p>
<pre><code>$ less /proc/cpuinfo
processor       : 0
cpu family      : 6
model name      : Intel(R) Core(TM) i9-9880H CPU @ 2.30GHz
(一部略)
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities
</code></pre>
</details>
<p>Linuxでは<code>%fs:</code>や<code>%gs:</code>を使って
<strong>スレッドローカルストレージ</strong>(TLS)を実現しています．
スレッドローカルストレージとは「スレッドごとの(一種の)グローバル変数」です．
マルチスレッドはスレッド同士がメモリ空間を共有しているので，
普通にグローバル変数を使うと，他のスレッドに内容が破壊される可能性があります．
スレッドローカルストレージを使えば，他のスレッドに破壊される心配がなくなります．
スレッドごとに<code>%fs</code>レジスタの値を変えて，
（プログラム上では同じ変数に見えても）スレッドごとに別のアドレスを
参照させて実現しているのでしょう．
(CPUがスレッドの実行を停止・再開するたびに，
スレッドが使用しているレジスタの値も退避・回復するので，
見た目上，「スレッドはそれぞれ独自のレジスタセットを持っている」ように動作します)．</p>
<p>C11からは<code>_Thread_local</code>，<code>gcc</code>では<code>__thread</code>というキーワードで，
スレッドローカルな変数を宣言できます．</p>
<pre><code>// tls.c
#include &lt;stdio.h&gt;
❶ __thread int x = 0xdeadbeef;
int main ()
{
    printf (&quot;x=%x\n&quot;, x);
}
</code></pre>
<pre><code>$ gcc -g tls.c
$ ./a.out
x=deadbeef
$ objdump -d ./a.out | less
0000000000001149 &lt;main&gt;:
    1149:  f3 0f 1e fa             endbr64 
    114d:  55                      push   %rbp
    114e:  48 89 e5                mov    %rsp,%rbp
    1151:  64 8b 04 25 fc ff ff    mov  ❷ %fs:0xfffffffffffffffc,%eax
    1158:  ff 
    1159:  89 c6                   mov    %eax,%esi
</code></pre>
<pre><code>$ gdb ./a.out
(gdb) b main
Breakpoint 1 at 0x1151: file tls.c, line 5.
(gdb) r
Breakpoint 1, main () at tls.c:5
5	    printf (&quot;x=%x\n&quot;, x);
(gdb) p/x x
$1 = 0xdeadbeef
(gdb) ❸ p/x $fs_base
$2 = ❹ 0x7ffff7fa9740
(gdb) x/1wx $fs_base - 4
0x7ffff7fa973c:	❺ 0xdeadbeef
</code></pre>
<ul>
<li>❶ <code>__thread</code>キーワードを使って，変数<code>x</code>をスレッドローカルにします．</li>
<li>コンパイルした<code>a.out</code>を逆アセンブルすると，
❷ <code>%fs:0xfffffffffffffffc</code>というメモリ参照があります．
これがスレッドローカルな変数<code>x</code>の実体の場所で，
「<code>%fsのベースレジスタ - 4</code>」が<code>x</code>のアドレスになります．</li>
<li>❸ <code>p/x $fs_base</code>を使って，<code>%fsのベースレジスタ</code>の値を調べると
❹  <code>0x7ffff7fa9740</code>と分かりました．</li>
<li>アドレス<code>$fs_base - 4</code>のメモリの中身(4バイト)を調べると，
変数<code>x</code>の値である❺ <code>0xDEADBEEF</code>が入っていました．</li>
</ul>
<!--
leaq $fs:-4, %rax とすると，アセンブラに怒られる．
gccは  movq %fs:0, %rax で，アドレスを入手している．
つまり，%fs:0番地に%fsのベースレジスタの値が書き込まれていることが前提になっている．
-->
<details>
<summary>
0xDEADBEEFとは
</summary>
<p>バイナリ上でデバッグする際，「ありそうもない値」を使うと便利なことがあります．
<code>1</code>や<code>2</code>だと偶然の一致がありますが，「ありそうもない値」を使うと
「高い確率でこれは私が書き込んだ値だよね」と分かるからです．
<code>0xDEADBEEF</code>は正しい16進数でありながら，英単語としても読めるので，
「ありそうもない値」として便利です．
他には<code>CAFEBABE</code>もよく使われます．
<code>0xDEADBEEF</code>や<code>0xCAFEBABE</code>はバイナリを識別するマジックナンバーとしても使われます．</p>
</details>
<details>
<summary>
%fs:はスタック保護でも使われる
</summary>
<pre><code>$ gcc -S -fstack-protector-all add5.c
</code></pre>
<p><a href="./asm/add5.c"><code>add5.c</code></a>を<code>-fstack-protector-all</code>オプションで
スタック保護機能をオンにしてコンパイルします．
(最近のLinuxの<code>gcc</code>のデフォルトでは，<code>-fstack-protector-strong</code>が有効に
なっています．これはバッファを使用する関数のみにスタック保護機能を加えます．
ここでは<code>-fstack-protector-all</code>を使って全関数にスタック保護機能を加えました)．</p>
<pre><code class="language-x86asmatt">    .text
    .globl  add5
    .type   add5, @function
add5:
    endbr64
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $32, %rsp
    movl    %edi, -20(%rbp)
    movq ❶ %fs:40, %rax
    movq ❷ %rax, -8(%rbp)
    xorl    %eax, %eax
    movl    -20(%rbp), %eax
    addl    $5, %eax
    movq ❸ -8(%rbp), %rdx
    subq ❹ %fs:40, %rdx
    je      .L3
    call ❺ __stack_chk_fail@PLT
.L3:
    leave   
    ret     
    .size   add5, .-add5
</code></pre>
<ul>
<li>関数の最初の方で，スレッドローカルストレージの❶ <code>%fs:40</code>の値を，
(<code>%rax</code>経由で)スタック上の<code>-8(%rbp)</code>に書き込みます．</li>
<li>関数の終わりの方で，❸<code>-8(%rbp)</code>の値を<code>%rdx</code>レジスタにコピーし，
❹ <code>%fs:40</code>の値を引き算しています．</li>
<li>もし，引き算の結果がゼロでなければ(つまり❸と❹の値が異なれば)，
「バッファオーバーフローが起きた」と判断して，
❺ <code>__stack_chk_fail@PLT</code>を呼び出して
プロセスを強制終了させます(つまりバッファオーバーフロー攻撃を防げたことになります)．</li>
</ul>
<!--
> 注:「`-8(%rbp)`を飛び越してバッファオーバーフローを起こせたら，
> あるいは偶然，❸と❹の値が同じになってしまったら，
> バッファオーバーフローを検知できないのでは?」と思った方，正解です．
-->
</details>
<!--
TLSの話はここが詳しい．
https://fasterthanli.me/series/making-our-own-executable-packer/part-13
https://www.kernel.org/doc/html/v5.9/x86/x86_64/fsgs.html

C11から，_Thread_local
GCC拡張 __thread
-->
</div>
</details>
<h3 id="メモリ参照で可能な組み合わせ64ビットモードの場合-1"><a class="header" href="#メモリ参照で可能な組み合わせ64ビットモードの場合-1">メモリ参照で可能な組み合わせ(64ビットモードの場合)</a></h3>
<h4 id="通常のメモリ参照-1"><a class="header" href="#通常のメモリ参照-1">通常のメモリ参照</a></h4>
<img src="figs/memory-ref.svg" height="250px" id="fig:memory-ref">
<ul>
<li>disp には符号あり定数を指定する．ただし「64ビット定数」は無いことに注意．
アドレス計算時に64ビット長に符号拡張される．
dispは変位(displacement)を意味する．</li>
<li>base には上記のいずれかのレジスタを指定可能．省略も可．</li>
<li>index には上記のいずれかのレジスタを指定可能．省略も可．
<code>%rsp</code>を指定できないことに注意．</li>
<li>scale を省略すると <code>1</code> と同じ</li>
</ul>
<blockquote>
<p>注: dispの例外．
<code>mov␣</code>命令のみ，64ビットのdispを指定可能．
この場合，<code>movabs␣</code>というニモニックを使用可能．
メモリ参照はdispのみで，base，index，scaleは指定不可．
他方のオペランドは<code>%rax</code>のみ指定可能．</p>
<pre><code>movq     0x1122334455667788, %rax
movabsq  0x1122334455667788, %rax
movq     %rax, 0x1122334455667788
movabsq  %rax, 0x1122334455667788
</code></pre>
</blockquote>
<h4 id="rip相対参照-1"><a class="header" href="#rip相対参照-1"><code>%rip</code>相対参照</a></h4>
<img src="figs/rip-relative.svg" height="120px" id="fig:rip-relative">
<p><code>%rip</code>相対参照では32ビットのdispと<code>%rip</code>レジスタのみが指定可能です．</p>
<h3 id="メモリ参照の例-1"><a class="header" href="#メモリ参照の例-1">メモリ参照の例</a></h3>
<div class="table-wrapper"><table><thead><tr><th><a href="./7-asm.html#att-intel">AT&amp;T形式</a></th><th><a href="./7-asm.html#att-intel">Intel形式</a></th><th>指定したもの</th><th>計算するアドレス</th></tr></thead><tbody>
<tr><td><code>8</code></td><td><code>[8]</code></td><td>disp</td><td><code>8</code></td></tr>
<tr><td><code>foo</code></td><td><code>[foo]</code></td><td>disp</td><td><code>foo</code></td></tr>
<tr><td><code>(%rbp)</code></td><td><code>[rbp]</code></td><td>base</td><td><code>%rbp</code></td></tr>
<tr><td><code>8(%rbp)</code></td><td><code>[rbp+8]</code></td><td>dispとbase</td><td><code>%rbp + 8</code></td></tr>
<tr><td><code>foo(%rbp)</code></td><td><code>[rbp+foo]</code></td><td>dispとbase</td><td><code>%rbp + foo</code></td></tr>
<tr><td><code>8(%rbp,%rax)</code></td><td><code>[rbp+rax+8]</code></td><td>dispとbaseとindex</td><td><code>%rbp + %rax + 8</code></td></tr>
<tr><td><code>8(%rbp,%rax, 2)</code></td><td><code>[rbp+rax*2+8]</code></td><td>dispとbaseとindexとscale</td><td><code>%rbp + %rax*2 + 8</code></td></tr>
<tr><td><code>(%rip)</code></td><td><code>[rip]</code></td><td>base</td><td><code>%rip</code></td></tr>
<tr><td><code>8(%rip)</code></td><td><code>[rip+8]</code></td><td>dispとbase</td><td><code>%rip + 8</code></td></tr>
<tr><td><code>foo(%rip)</code></td><td><code>[rip+foo]</code></td><td>dispとbase</td><td><code>%rip + foo</code></td></tr>
<tr><td><code>%fs:-4</code></td><td><code>fs:[-4]</code></td><td><a href="x86-list.html#segment-override">segment</a>とdisp</td><td><code>%fsのベースレジスタ - 4</code></td></tr>
</tbody></table>
</div>
<ul>
<li>メモリに読み書きするサイズの指定方法 (先頭アドレスだけだと，何バイト読み書きすればいいのか不明):
<ul>
<li>
<p>AT&amp;T形式では<a href="x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a> (<code>q</code>, <code>l</code>, <code>w</code>, <code>b</code>)で指定する．例: <code>movq $4, 8(%rbp)</code></p>
</li>
<li>
<p>Intel形式では，メモリ参照の前に
<code>QWORD PTR</code>, <code>DWORD PTR</code>, <code>WORD PTR</code>, <code>BYTE PTR</code>を付加する
(順番に，8バイト，4バイト，2バイト，1バイトを意味する)．
例: `mov QWORD PTR [rbp+8], 4</p>
</li>
</ul>
</li>
</ul>
<h2 id="詳しい記法"><a class="header" href="#詳しい記法">「記法」「詳しい記法」欄で用いるオペランドの記法と注意</a></h2>
<p>以下の機械語命令の説明で使う記法を説明します．
この記法はその命令に許されるオペランドの形式を表します．</p>
<h3 id="オペランド即値定数-1"><a class="header" href="#オペランド即値定数-1">オペランド，即値(定数)</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*op1*|  | 第1オペランド |
|*op2*|  | 第2オペランド |
|*imm*| `$100` |  *imm8*, *imm16*, *imm32*のどれか |
|*imm8*| `$100` | 8ビットの即値(定数) |
|*imm16*| `$100` | 16ビットの即値(定数) |
|*imm32*| `$100` | 32ビットの即値(定数) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>op1</em></td><td></td><td>第1オペランド</td></tr>
<tr><td><em>op2</em></td><td></td><td>第2オペランド</td></tr>
<tr><td rowspan="2"><em>imm</em></td><td><code>$100</code></td><td rowspan="2"><em>imm8</em>, <em>imm16</em>, <em>imm32</em>のどれか</td></tr>
<tr><td><code>$foo</code></td></tr>
<tr><td><em>imm8</em></td><td><code>$100</code></td><td>8ビットの即値(定数)</td></tr> 
<tr><td><em>imm16</em></td><td><code>$100</code></td><td>16ビットの即値(定数)</td></tr>
<tr><td><em>imm32</em></td><td><code>$100</code></td><td>32ビットの即値(定数)</td></tr>
</tbody></table>
</div>
<ul>
<li>多くの場合，サイズを省略して単に<em>imm</em>と書きます．
特にサイズに注意が必要な時だけ，<em>imm32</em>などとサイズを明記します．</li>
<li><a href="./x86-list.html#mov-64bit-imm">一部例外を除き</a>，
x86-64では64ビットの即値を書けません(32ビットまでです)．</li>
</ul>
<h3 id="汎用レジスタ-3"><a class="header" href="#汎用レジスタ-3">汎用レジスタ</a></h3>
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td><em>r</em></td><td><code>%rax</code></td><td><em>r8</em>, <em>r16</em>, <em>r32</em>, <em>r64</em>のどれか</td></tr>
<tr><td><em>r8</em></td><td><code>%al</code></td><td>8ビットの汎用レジスタ</td></tr>
<tr><td><em>r16</em></td><td><code>%ax</code></td><td>16ビットの汎用レジスタ</td></tr>
<tr><td><em>r32</em></td><td><code>%eax</code></td><td>32ビットの汎用レジスタ</td></tr>
<tr><td><em>r64</em></td><td><code>%rax</code></td><td>64ビットの汎用レジスタ</td></tr>
</tbody></table>
</div>
<h3 id="メモリ参照-2"><a class="header" href="#メモリ参照-2">メモリ参照</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*r/m*  | `-8(%rbp)` |  *r/m8*, *r/m16*, *r/m32*, *r/m64*のどれか |
|*r/m8* | `-8(%rbp)` | *r8*  または 8ビットのメモリ参照 |
|*r/m16*| `-8(%rbp)` | *r16* または16ビットのメモリ参照 |
|*r/m32*| `-8(%rbp)` | *r32* または32ビットのメモリ参照 |
|*r/m64*| `-8(%rbp)` | *r64* または64ビットのメモリ参照 |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="4"><em>r/m</em></td><td><code>%rbp</code></td><td rowspan="4"><em>r/m8</em>, <em>r/m16</em>, <em>r/m32</em>, <em>r/m32</em>, <em>r/m64</em>のどれか</td></tr>
<tr><td><code>100</code></td></tr>
<tr><td><code>-8(%rbp)</code></td></tr>
<tr><td><code>foo(%rbp)</code></td></tr>
<tr><td><em>r/m8</em></td><td><code>-8(%rbp)</code></td><td><em>r8</em>  または 8ビットのメモリ参照</td></tr>
<tr><td><em>r/m16</em></td><td><code>-8(%rbp)</code></td><td><em>r16</em> また
は16ビットのメモリ参照</td></tr>
<tr><td><em>r/m32</em></td><td><code>-8(%rbp)</code></td><td><em>r32</em> また
は32ビットのメモリ参照</td></tr>
<tr><td><em>r/m64</em></td><td><code>-8(%rbp)</code></td><td><em>r64</em> また
は64ビットのメモリ参照</td></tr>
<tr><td><em>m</em></td><td><code>-8(%rbp)</code></td><td> メモリ参照</td></tr>
</tbody></table>
</div>
<h3 id="ジャンプコール用のオペランド"><a class="header" href="#ジャンプコール用のオペランド">ジャンプ・コール用のオペランド</a></h3>
<!--
| 記法 | 例 | 説明 |
|-|-|-|
|*rel*  | `0x100` |  *rel8*, *rel32*のどちらか |
|*rel8* | `0x100` |  8ビット相対アドレス(直接ジャンプ，定数だが$は不要)|
|*rel32*| `0x1000` |  32ビット相対アドレス(直接ジャンプ，定数だが$は不要)|
|*\*r/m64*| `*-8(%rbp)` | *r64* または64ビットのメモリ参照による<br/>絶対・間接ジャンプ (`*`を前につける) |
-->
<div class="table-wrapper"><table><thead><tr><th>記法</th><th>例</th><th>説明</th></tr></thead><tbody>
<tr><td rowspan="2"><em>rel</em></td><td><code>0x100</code></td><td rowspan="2"><em>rel8</em>, <em>rel32</em>のどちらか</td></tr>
<tr><td><code>foo</code></td></tr>
<tr><td><em>rel8</em></td><td><code>0x100</code></td><td>8ビット相対アドレス(直接ジャンプ，定数だが<code>$</code>は不要)</td></tr>
<tr><td><em>rel32</em></td><td><code>0x1000</code></td><td>32ビット相対アドレス(直接ジャンプ，定数だが<code>$</code>は不要)</td></tr>
<tr><td rowspan="3"><em>*r/m64</em></td><td><code>*%rax</code></td><td rowspan="3"><em>r64</em> または64ビットのメモリ参照による絶対アドレス<br/>(間接ジャンプ，<code>*</code>が前に必要)</td></tr>
<tr><td><code>*(%rax)</code></td></tr>
<tr><td><code>*-8(%rax)</code></td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>GNUアセンブラの記法のおかしな点</p>
<ul>
<li>直接ジャンプ先の指定<em>rel</em>は，定数なのに<code>$</code>をつけてはいけない</li>
<li>間接ジャンプ先の指定**r/m64<em>は，
(他の</em>r/m*オペランドでは不要だったのに) <code>*</code>をつけなくてはいけない</li>
<li>相対アドレスで<code>rel8</code>か<code>rel32</code>をプログラマは選べない
(<code>jmp</code>命令に命令サフィックス<code>b</code>や<code>l</code>をつけると怒られる．アセンブラにお任せするしか無い)</li>
</ul>
</li>
<li>
<p><code>*%rax</code>と<code>*(%rax)</code>の違いに注意(以下の図を参照)</p>
</li>
</ul>
<img src="figs/indirect-jmp.svg" height="200px" id="fig:indirect-jmp">
<h2 id="データ転送コピー系の命令"><a class="header" href="#データ転送コピー系の命令">データ転送(コピー)系の命令</a></h2>
<h3 id="mov命令-データの転送コピー-1"><a class="header" href="#mov命令-データの転送コピー-1"><code>mov</code>命令: データの転送（コピー）</a></h3>
<div id="mov-plain">
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mov␣</code></strong> <em>op1</em>, <em>op2</em></td><td>move</td><td><em>op1</em>の値を<em>op2</em>にデータ転送(コピー)</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`mov␣`** *r*, *r/m*| `movq %rax, %rbx` | `%rbx = %rax` |[movq-1.s](./asm/movq-1.s) [movq-1.txt](./asm/movq-1.txt)|
|| `movq %rax, -8(%rsp)` | `*(%rsp - 8) = %rax` |[movq-2.s](./asm/movq-2.s) [movq-2.txt](./asm/movq-2.txt)|
|**`mov␣`** *r/m*, *r*| `movq -8(%rsp), %rax` | `%rax = *(%rsp - 8)` |[movq-3.s](./asm/movq-3.s) [movq-3.txt](./asm/movq-3.txt)|
|**`mov␣`** *imm*, *r*| `movq $999, %rax` | `%rax = 999` | [movq-4.s](./asm/movq-4.s) [movq-4.txt](./asm/movq-4.txt)|
|**`mov␣`** *imm*, *r/m*| `movq $999, -8(%rsp)` | `*(%rsp - 8) = 999` |[movq-5.s](./asm/movq-5.s) [movq-5.txt](./asm/movq-5.txt)||
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#詳しい記法">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>mov␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>movq %rax, %rbx</code></td><td><code>%rbx = %rax</code></td><td><a href="./asm/movq-1.s">movq-1.s</a> <a href="./asm/movq-1.txt">movq-1.txt</a></td></tr>
<tr><td><code>movq %rax, -8(%rsp)</code></td><td><code>*(%rsp - 8) = %rax</code></td><td><a href="./asm/movq-2.s">movq-2.s</a> <a href="./asm/movq-2.txt">movq-2.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movq -8(%rsp), %rax</code></td><td><code>%rax = *(%rsp - 8)</code></td><td><a href="./asm/movq-3.s">movq-3.s</a> <a href="./asm/movq-3.txt">movq-3.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>movq $999, %rax</code></td><td><code>%rax = 999</code></td><td><a href="./asm/movq-4.s">movq-4.s</a> <a href="./asm/movq-4.txt">movq-4.txt</a></td></tr>
<tr><td><strong><code>mov␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>movq $999, -8(%rsp)</code></td><td><code>*(%rsp - 8) = 999</code></td><td><a href="./asm/movq-5.s">movq-5.s</a> <a href="./asm/movq-5.txt">movq-5.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<hr />
</div>
<ul>
<li><code>␣</code>は<a href="x86-list.html#%E5%91%BD%E4%BB%A4%E3%82%B5%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9">命令サフィックス</a></li>
<li><code>mov</code>命令(および他のほとんどのデータ転送命令)はステータスフラグの値を変更しない</li>
<li><code>mov</code>命令はメモリからメモリへの直接データ転送はできない</li>
</ul>
<h3 id="xchg命令-オペランドの値を交換-1"><a class="header" href="#xchg命令-オペランドの値を交換-1"><code>xchg</code>命令: オペランドの値を交換</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>op1</em>, <em>op2</em></td><td>exchange</td><td><em>op1</em> と <em>op2</em> の値を交換する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>xchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xchg %rax, (%rsp)</code></td><td><code>%rax</code>と<code>(%rsp)</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
<tr><td><strong><code>xchg</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xchg (%rsp), %rax</code></td><td><code>(%rsp)</code>と<code>%rax</code>の値を交換する</td><td><a href="./asm/xchg.s">xchg.s</a> <a href="./asm/xchg.txt">xchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>xchg</code>命令は<strong>アトミックに</strong>2つのオペランドの値を交換します．(LOCKプリフィクスをつけなくてもアトミックになります)</li>
<li>この<strong>アトミック</strong>な動作はロックなどの<strong>同期機構</strong>を作るために使えます．</li>
</ul>
<h3 id="lea命令-実効アドレスを計算-1"><a class="header" href="#lea命令-実効アドレスを計算-1"><code>lea</code>命令: 実効アドレスを計算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>op1</em>, <em>op2</em></td><td>load effective address</td><td><em>op1</em> の実効アドレスを <em>op2</em> に代入する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>lea␣</code></strong> <em>m</em>, <em>r</em></td><td><code>leaq -8(%rsp, %rsi, 4), %rax</code></td><td><code>%rax=%rsp+%rsi*4-8</code></td><td><a href="./asm/lea.s">lea.s</a> <a href="./asm/lea.txt">lea.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="pushとpop命令-スタックとデータ転送-1"><a class="header" href="#pushとpop命令-スタックとデータ転送-1"><code>push</code>と<code>pop</code>命令: スタックとデータ転送</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>op1</em></td><td>push</td><td><em>op1</em> をスタックにプッシュ</td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>op1</em></td><td>pop</td><td>スタックから <em>op1</em> にポップ</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>push␣</code></strong> <em>imm</em></td><td><code>pushq $999</code></td><td><code>%rsp-=8; *(%rsp)=999</code></td><td><a href="./asm/push1.s">push1.s</a> <a href="./asm/push1.txt">push1.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m16</em></td><td><code>pushw %ax</code></td><td><code>%rsp-=2; *(%rsp)=%ax</code></td><td><a href="./asm/push2.s">push2.s</a> <a href="./asm/push2.txt">push2.txt</a></td></tr>
<tr><td><strong><code>push␣</code></strong> <em>r/m64</em></td><td><code>pushq %rax</code></td><td><code>%rsp-=8; *(%rsp)=%rax</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m16</em></td><td><code>popw %ax</code></td><td><code>*(%rsp)=%ax; %rsp += 2</code></td><td><a href="./asm/pop2.s">pop2.s</a> <a href="./asm/pop2.txt">pop2.txt</a></td></tr>
<tr><td><strong><code>pop␣</code></strong> <em>r/m64</em></td><td><code>popq %rbx</code></td><td><code>%rbx=*(%rsp); %rsp += 8</code></td><td><a href="./asm/push-pop.s">push-pop.s</a> <a href="./asm/push-pop.txt">push-pop.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h2 id="四則演算論理演算の命令"><a class="header" href="#四則演算論理演算の命令">四則演算・論理演算の命令</a></h2>
<h3 id="add-adc命令-足し算"><a class="header" href="#add-adc命令-足し算"><code>add</code>, <code>adc</code>命令: 足し算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add</td><td><em>op1</em> を <em>op2</em> に加える</td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>op1</em>, <em>op2</em></td><td>add with carry</td><td><em>op1</em> と CF を <em>op2</em> に加える</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>add␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>addq $999, %rax</code></td><td><code>%rax += 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>addq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>add␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>addq (%rsp), %rax</code></td><td><code>%rax += *(%rsp)</code></td><td><a href="./asm/add-2.s">add-2.s</a> <a href="./asm/add-2.txt">add-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>adcq $999, %rax</code></td><td><code>%rax += 999 + CF</code></td><td><a href="./asm/adc-1.s">adc-1.s</a> <a href="./asm/adc-1.txt">adc-1.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>adcq %rax, (%rsp)</code></td><td><code>*(%rsp) += %rax + CF</code></td><td><a href="./asm/adc-2.s">adc-2.s</a> <a href="./asm/adc-2.txt">adc-2.txt</a></td></tr>
<tr><td><strong><code>adc␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>adcq (%rsp), %rax</code></td><td><code>%rax += *(%rsp) + CF</code></td><td><a href="./asm/adc-3.s">adc-3.s</a> <a href="./asm/adc-3.txt">adc-3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と<code>adc</code>はオペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算する．</li>
</ul>
<h3 id="sub-sbb命令-引き算-1"><a class="header" href="#sub-sbb命令-引き算-1"><code>sub</code>, <code>sbb</code>命令: 引き算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract</td><td><em>op1</em> を <em>op2</em> から引く</td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>op1</em>, <em>op2</em></td><td>subtract with borrow</td><td><em>op1</em> と CF を <em>op2</em> から引く</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sub␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>subq $999, %rax</code></td><td><code>%rax -= 999</code></td><td><a href="./asm/sub-1.s">sub-1.s</a> <a href="./asm/sub-1.txt">sub-1.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>subq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sub␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>subq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp)</code></td><td><a href="./asm/sub-2.s">sub-2.s</a> <a href="./asm/sub-2.txt">sub-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>sbbq $999, %rax</code></td><td><code>%rax -= 999 + CF</code></td><td><a href="./asm/sbb-1.s">sbb-1.s</a> <a href="./asm/sbb-1.txt">sbb-1.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>sbbq %rax, (%rsp)</code></td><td><code>*(%rsp) -= %rax + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
<tr><td><strong><code>sbb␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>sbbq (%rsp), %rax</code></td><td><code>%rax -= *(%rsp) + CF</code></td><td><a href="./asm/sbb-2.s">sbb-2.s</a> <a href="./asm/sbb-2.txt">sbb-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>add</code>と同様に，<code>sub</code>と<code>sbb</code>は
オペランドが符号<strong>あり</strong>整数か符号<strong>なし</strong>整数かを区別せず，
両方の結果を正しく計算する．</li>
</ul>
<h3 id="mul-imul命令-かけ算-1"><a class="header" href="#mul-imul命令-かけ算-1"><code>mul</code>, <code>imul</code>命令: かけ算</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>op1</em></td><td>unsigned multiply</td><td>符号なし乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em></td><td>signed multiply</td><td>符号あり乗算．<code>(%rdx:%rax) = %rax</code> * <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em></td><td>signed multiply</td><td>符号あり乗算．<em>op2</em> *= <em>op1</em></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>op1</em>, <em>op2</em>, <em>op3</em></td><td>signed multiply</td><td>符号あり乗算．<em>op3</em> = <em>op1</em> * <em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>mul␣</code></strong> <em>r/m</em></td><td><code>mulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/mul-1.s">mul-1.s</a> <a href="./asm/mul-1.txt">mul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em></td><td><code>imulq %rbx</code></td><td><code>(%rdx:%rax) = %rax * %rbx</code></td><td><a href="./asm/imul-1.s">imul-1.s</a> <a href="./asm/imul-1.txt">imul-1.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r</em></td><td><code>imulq $4, %rax</code></td><td><code>%rax *= 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>imulq %rbx, %rax</code></td><td><code>%rax *= %rbx</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
<tr><td><strong><code>imul␣</code></strong> <em>imm</em>, <em>r/m</em>, <em>r</em></td><td><code>imulq $4, %rbx, %rax</code></td><td><code>%rax = %rbx * 4</code></td><td><a href="./asm/imul-2.s">imul-2.s</a> <a href="./asm/imul-2.txt">imul-2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>オペランドが1つの形式では，<code>%rax</code>が隠しオペランドになる．
このため，乗算の前に<code>%rax</code>に値をセットしておく必要がある．
また，8バイト同士の乗算結果は最大で16バイトになるので，
乗算結果を<code>%rdx</code>と<code>%rax</code>に分割して格納する
(16バイトの乗算結果の上位8バイトを<code>%rdx</code>に，下位8バイトを<code>%rax</code>に格納する)．
これをここでは<code>(%rdx:%rax)</code>という記法で表現している．</li>
<li><code>imul</code>だけ例外的に，オペランドが2つの形式と3つの形式がある．
2つか3つの形式では乗算結果が64ビットを超えた場合，
越えた分は破棄される(乗算結果は8バイトのみ)．</li>
</ul>
<h3 id="div-idiv命令-割り算余り-1"><a class="header" href="#div-idiv命令-割り算余り-1"><code>div</code>, <code>idiv</code>命令: 割り算，余り</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>op1</em></td><td>unsigned divide</td><td>符号なし除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>op1</em></td><td>signed divide</td><td>符号あり除算と余り<br/> <code>%rax = (%rdx:%rax)</code> / <em>op1</em>  <br/> <code>%rdx = (%rdx:%rax)</code> % <em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>div␣</code></strong> <em>r/m</em></td><td><code>divq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/div-1.s">div-1.s</a> <a href="./asm/div-1.txt">div-1.txt</a></td></tr>
<tr><td><strong><code>idiv␣</code></strong> <em>r/m</em></td><td><code>idivq %rbx</code></td><td><code>%rax = (%rdx:%rax) / %rbx</code> <br/> <code>%rdx = (%rdx:%rax) % %rbx</code></td><td><a href="./asm/idiv-1.s">idiv-1.s</a> <a href="./asm/idiv-1.txt">idiv-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li>16バイトの値 <code>%rdx:%rax</code> を第1オペランドで割った商が<code>%rax</code>に入り，
余りが<code>%rdx</code>に入る．</li>
<li>隠しオペランドとして<code>%rdx</code>と<code>%rax</code>が使われるので，事前に値を設定しておく必要がある．
<code>idiv</code>を使う場合，もし<code>%rdx</code>を使わないのであれば，
<code>cqto</code>命令で<code>%rax</code>を<code>%rdx:%rax</code>に符号拡張しておくと良い．</li>
</ul>
<h3 id="inc-dec命令-インクリメントデクリメント-1"><a class="header" href="#inc-dec命令-インクリメントデクリメント-1"><code>inc</code>, <code>dec</code>命令: インクリメント，デクリメント</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>op1</em></td><td>increment</td><td><em>op1</em>の値を1つ増加</td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>op1</em></td><td>decrement</td><td><em>op1</em>の値を1つ減少</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>inc␣</code></strong> <em>r/m</em></td><td><code>inc %rax</code></td><td><code>%rax</code>++</td><td><a href="./asm/inc-1.s">inc-1.s</a> <a href="./asm/inc-1.txt">inc-1.txt</a></td></tr>
<tr><td><strong><code>dec␣</code></strong> <em>r/m</em></td><td><code>dec %rax</code></td><td><code>%rax</code>--</td><td><a href="./asm/dec-1.s">dec-1.s</a> <a href="./asm/dec-1.txt">dec-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>inc</code>や<code>dec</code>はオーバーフローしてもCFが変化しないところがポイント．</li>
</ul>
<h3 id="neg命令-符号反転-1"><a class="header" href="#neg命令-符号反転-1"><code>neg</code>命令: 符号反転</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>op1</em></td><td>negation</td><td>2の補数による<em>op1</em>の符号反転</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>neg␣</code></strong> <em>r/m</em></td><td><code>neg %rax</code></td><td><code>%rax = -%rax</code></td><td><a href="./asm/neg-1.s">neg-1.s</a> <a href="./asm/neg-1.txt">neg-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<h3 id="not命令-ビット論理演算-1-1"><a class="header" href="#not命令-ビット論理演算-1-1"><code>not</code>命令: ビット論理演算 (1)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>op1</em></td><td>bitwise not</td><td><em>op1</em>の各ビットの反転 (NOT)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>not␣</code></strong> <em>r/m</em></td><td><code>notq %rax</code></td><td><code>%rax = ~%rax</code></td><td><a href="./asm/not-1.s">not-1.s</a> <a href="./asm/not-1.txt">not-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="and-or-xor命令-ビット論理演算-2-1"><a class="header" href="#and-or-xor命令-ビット論理演算-2-1"><code>and</code>, <code>or</code>, <code>xor</code>命令: ビット論理演算 (2)</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise and</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理積(AND)</td></tr>
<tr><td><strong><code>or␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise or</td><td><em>op1</em>と<em>op2</em>の各ビットごとの論理和(OR)</td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>op1</em>, <em>op2</em></td><td>bitwise xor</td><td><em>op1</em>と<em>op2</em>の各ビットごとの排他的論理和(XOR)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>and␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>andq $0x0FFF, %rax</code></td><td><code>%rax &amp;= 0x0FFF</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>andq %rax, (%rsp)</code></td><td><code>*(%rsp) &amp;= %rax</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>and␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>andq (%rsp), %rax</code></td><td><code>%rax &amp;= *(%rsp)</code></td><td><a href="./asm/and-1.s">and-1.s</a> <a href="./asm/and-1.txt">and-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>orq $0x0FFF, %rax</code></td><td><code>%rax |= 0x0FFF </code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>orq %rax, (%rsp)</code></td><td><code>*(%rsp) |= %rax</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>or␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>orq (%rsp), %rax</code></td><td><code>%rax |= *(%rsp)</code></td><td><a href="./asm/or-1.s">or-1.s</a> <a href="./asm/or-1.txt">or-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>xorq $0x0FFF, %rax</code></td><td><code>%rax ^= 0x0FFF</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>xorq %rax, (%rsp)</code></td><td><code>*(%rsp) ^= %rax</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
<tr><td><strong><code>xor␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>xorq (%rsp), %rax</code></td><td><code>%rax ^= *(%rsp)</code></td><td><a href="./asm/xor-1.s">xor-1.s</a> <a href="./asm/xor-1.txt">xor-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></br>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><em>x</em></th><th style="text-align: center"><em>y</em></th><th style="text-align: center"><em>x</em> &amp; <em>y</em></th><th style="text-align: center"><em>x</em> | <em>y</em></th><th style="text-align: center"><em>x</em> ^ <em>y</em></th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>&amp;</code>, <code>|</code>, <code>^</code>はC言語で，それぞれ，ビットごとの論理積，論理和，排他的論理積です
(忘れた人はC言語を復習しましょう)．</li>
</ul>
<h3 id="sal-sar-shl-shr命令-シフト"><a class="header" href="#sal-sar-shl-shr命令-シフト"><code>sal</code>, <code>sar</code>, <code>shl</code>, <code>shr</code>命令: シフト</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic left</td><td>算術左シフト</td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical left</td><td>論理左シフト</td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift arithmetic right</td><td>算術右シフト</td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>shift logical right</td><td>論理右シフト</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>sal␣</code></strong> <em>r/m</em></td><td><code>salq %rax</code></td><td><code>%rax</code>を1ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>salq $2, %rax</code></td><td><code>%rax</code>を2ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>sal␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>salq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術左シフト</td><td><a href="./asm/sal-1.s">sal-1.s</a> <a href="./asm/sal-1.txt">sal-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>r/m</em></td><td><code>shlq %rax</code></td><td><code>%rax</code>を1ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shlq $2, %rax</code></td><td><code>%rax</code>を2ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>shl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shlq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理左シフト</td><td><a href="./asm/shl-1.s">shl-1.s</a> <a href="./asm/shl-1.txt">shl-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>r/m</em></td><td><code>sarq %rax</code></td><td><code>%rax</code>を1ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>sarq $2, %rax</code></td><td><code>%rax</code>を2ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>sar␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>sarq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット算術右シフト</td><td><a href="./asm/sar-1.s">sar-1.s</a> <a href="./asm/sar-1.txt">sar-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>r/m</em></td><td><code>shrq %rax</code></td><td><code>%rax</code>を1ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>shrq $2, %rax</code></td><td><code>%rax</code>を2ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
<tr><td><strong><code>shr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>shrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット論理右シフト</td><td><a href="./asm/shr-1.s">shr-1.s</a> <a href="./asm/shr-1.txt">shr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<img src="figs/shift.svg" height="300px" id="fig:shift">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li><strong>シフト</strong>とは(指定したビット数だけ)右か左にビット列をずらすことを意味します．
<em>op2</em>がなければ「1ビットシフト」を意味します．</li>
<li><strong>論理シフト</strong>とは「空いた場所に<strong>0を入れる</strong>」，
<strong>算術シフト</strong>とは「空いた場所に<strong>符号ビットを入れる</strong>」ことを意味します．</li>
<li>左シフトの場合は(符号ビットを入れても意味がないので)，論理シフトでも算術シフトでも，0を入れます．その結果，算術左シフト<code>sal</code>と論理左シフト<code>shl</code>は全く同じ動作になります．</li>
<li>C言語の符号あり整数に対する右シフト(&gt;&gt;)は算術シフトか論理シフトかは
決まっていません(実装依存です)．
C言語で，ビット演算は符号なし整数に対してのみ行うようにしましょう．</li>
</ul>
<h3 id="rol-ror-rcl-rcr命令-ローテート"><a class="header" href="#rol-ror-rcl-rcr命令-ローテート"><code>rol</code>, <code>ror</code>, <code>rcl</code>, <code>rcr</code>命令: ローテート</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left</td><td>左ローテート</td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate left through carry</td><td>CFを含めて左ローテート</td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right</td><td>右ローテート</td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>rotate right through carry</td><td>CFを含めて右ローテート</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rol␣</code></strong> <em>r/m</em></td><td><code>rolq %rax</code></td><td><code>%rax</code>を1ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rolq $2, %rax</code></td><td><code>%rax</code>を2ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rol␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rolq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット左ローテート</td><td><a href="./asm/rol-1.s">rol-1.s</a> <a href="./asm/rol-1.txt">rol-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>r/m</em></td><td><code>rclq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rclq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>rcl␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rclq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて左ローテート</td><td><a href="./asm/rcl-1.s">rcl-1.s</a> <a href="./asm/rcl-1.txt">rcl-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>r/m</em></td><td><code>rorq %rax</code></td><td><code>%rax</code>を1ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rorq $2, %rax</code></td><td><code>%rax</code>を2ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>ror␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rorq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビット右ローテート</td><td><a href="./asm/ror-1.s">ror-1.s</a> <a href="./asm/ror-1.txt">ror-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>r/m</em></td><td><code>rcrq %rax</code></td><td><code>%rax</code>を1ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <em>imm8</em>, <em>r/m</em></td><td><code>rcrq $2, %rax</code></td><td><code>%rax</code>を2ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
<tr><td><strong><code>rcr␣</code></strong> <code>%cl</code>, <em>r/m</em></td><td><code>rcrq %cl, %rax</code></td><td><code>%rax</code>を<code>%cl</code>ビットCFを含めて右ローテート</td><td><a href="./asm/rcr-1.s">rcr-1.s</a> <a href="./asm/rcr-1.txt">rcr-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<img src="figs/rotate.svg" height="330px" id="fig:rotate">
<ul>
<li><em>op1</em>[, <em>op2</em>] という記法は「<em>op2</em>は指定してもしなくても良い」という意味です．</li>
<li>ローテートは，シフトではみ出したビットを空いた場所に入れます．</li>
<li>ローテートする方向(右か左)，CFを含めるか否かで，4パターンの命令が存在します．</li>
</ul>
<h3 id="cmp-test命令-比較"><a class="header" href="#cmp-test命令-比較"><code>cmp</code>, <code>test</code>命令: 比較</a></h3>
<h4 id="cmp命令-1"><a class="header" href="#cmp命令-1"><code>cmp</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>sub</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmp␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>cmpq $999, %rax</code></td><td><code>subq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpq %rax, (%rsp)</code></td><td><code>subq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
<tr><td><strong><code>cmp␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>cmpq (%rsp), %rax</code></td><td><code>subq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/cmp-1.s">cmp-1.s</a> <a href="./asm/cmp-1.txt">cmp-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<h4 id="test命令-1"><a class="header" href="#test命令-1"><code>test</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>op1</em>[, <em>op2</em>]</td><td>logical compare</td><td><em>op1</em>と<em>op2</em>の比較結果をフラグに格納(比較は<code>and</code>命令を使用)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>test␣</code></strong> <em>imm</em>, <em>r/m</em></td><td><code>testq $999, %rax</code></td><td><code>andq $999, %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r</em>, <em>r/m</em></td><td><code>testq %rax, (%rsp)</code></td><td><code>andq %rax, (%rsp)</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
<tr><td><strong><code>test␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>testq (%rsp), %rax</code></td><td><code>andq (%rsp), %rax</code>のフラグ変化のみ計算．オペランドは変更なし</td><td><a href="./asm/test-1.s">test-1.s</a> <a href="./asm/test-1.txt">test-1.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>!</td><td>!</td><td>!</td><td>?</td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmp</code>命令と同様に，<code>test</code>命令はフラグ計算だけを行います．
(レジスタやメモリは変化しません)．</li>
<li><code>cmp</code>命令と同様に，<code>test</code>命令は<a href="x86-list.html#%E3%82%B8%E3%83%A3%E3%83%B3%E3%83%97%E5%91%BD%E4%BB%A4">条件付きジャンプ命令</a>と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が0ならジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">testq %rax, %rax
jz L2
</code></pre>
<ul>
<li>例えば<code>%rax</code>が0かどうかを知りたい場合，
<code>cmpq $0, %rax</code>と<code>testq %rax, %rax</code>のどちらでも調べることができます．
どちらの場合も，ZF==1なら，<code>%rax</code>が0と分かります
(<code>testq %rax, %rax</code>はビットごとのANDのフラグ変化を計算するので，
<code>%rax</code>がゼロの時だけ，ZF==1となります)．
コンパイラは<code>testq %rax, %rax</code>を使うことが多いです．
<code>testq %rax, %rax</code>の方が命令長が短くなるからです．</li>
</ul>
<h3 id="movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張-1"><a class="header" href="#movs-movz-cbtw-cqto命令-符号拡張とゼロ拡張-1"><code>movs</code>, <code>movz</code>, <code>cbtw</code>, <code>cqto</code>命令: 符号拡張とゼロ拡張</a></h3>
<h4 id="movs-movz命令"><a class="header" href="#movs-movz命令"><code>movs</code>, <code>movz</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movsx</code> <em>op2</em>, <em>op1</em> </br> <code>movsxd</code> <em>op2</em>, <em>op1</em></td><td>move with sign-extention</td><td><em>op1</em>を符号拡張した値を<em>op2</em>に格納</td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>op1</em>, <em>op2</em></td><td><code>movzx</code> <em>op2</em>, <em>op1</em></td><td>move with zero-extention</td><td><em>op1</em>をゼロ拡張した値を<em>op2</em>に格納</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>movs␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movslq %eax, %rbx</code></td><td><code>%rbx</code> = <code>%eax</code>を8バイトに符号拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
<tr><td><strong><code>movz␣␣</code></strong> <em>r/m</em>, <em>r</em></td><td><code>movzwq %ax, %rbx</code></td><td><code>%rbx</code> = <code>%ax</code>を8バイトにゼロ拡張した値</td><td><a href="./asm/movs-movz.s">movs-movz.s</a> <a href="./asm/movs-movz.txt">movs-movz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><code>␣␣</code>に入るもの</th><th>何の略か</th><th>意味</th></tr></thead><tbody>
<tr><td><code>bw</code></td><td>byte to word</td><td>1バイト→2バイトの拡張</td></tr>
<tr><td><code>bl</code></td><td>byte to long</td><td>1バイト→4バイトの拡張</td></tr>
<tr><td><code>bq</code></td><td>byte to quad</td><td>1バイト→8バイトの拡張</td></tr>
<tr><td><code>wl</code></td><td>word to long</td><td>2バイト→4バイトの拡張</td></tr>
<tr><td><code>wq</code></td><td>word to quad</td><td>2バイト→8バイトの拡張</td></tr>
<tr><td><code>lq</code></td><td>long to quad</td><td>4バイト→8バイトの拡張</td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>movs</code>, <code>movz</code>命令はAT&amp;T形式とIntel形式でニモニックが異なるので注意です．</li>
<li>GNUアセンブラではAT&amp;T形式でも実は<code>movsx</code>, <code>movzx</code>のニモニックが使用できます．
ただし逆アセンブルすると，<code>movslq</code>, <code>movzwq</code>などのニモニックが表示されるので，
<code>movslq</code>, <code>movzwq</code>などを使う方が良いでしょう．</li>
<li><code>movzlq</code> (Intel形式では<code>movzxd</code>)はありません．例えば，<code>%eax</code>に値を入れると，
<code>%rax</code>の上位32ビットは<a href="./x86-list.html#zero-upper32">クリア</a>されるので，
<code>movzlq</code>は不要だからです．</li>
<li>Intel形式では，4バイト→8バイトの拡張の時だけ，
(<code>movsx</code>ではなく)<code>movsxd</code>を使います．</li>
</ul>
<h4 id="cbtw-cqto命令-1"><a class="header" href="#cbtw-cqto命令-1"><code>cbtw</code>, <code>cqto</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法(AT&amp;T形式)</a></th><th>記法(Intel形式)</th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td>**<code>c␣t␣</code></td><td><code>c␣␣␣</code></td><td>convert ␣ to ␣</td><td><code>%rax</code> (または<code>%eax</code>, <code>%ax</code>, <code>%al</code>)を符号拡張</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a><br/>(AT&amp;T形式)</th><th>詳しい記法<br/>(Intel形式)</th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cbtw</code></strong></td><td><code>cbw</code></td><td><code>cbtw</code></td><td><code>%al</code>(byte)を<code>%ax</code>(word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtl</code></strong></td><td><code>cwde</code></td><td><code>cwtl</code></td><td><code>%ax</code>(word)を<code>%eax</code>(long)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cwtd</code></strong></td><td><code>cwd</code></td><td><code>cwtd</code></td><td><code>%ax</code>(word)を<code>%dx:%ax</code>(double word)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltd</code></strong></td><td><code>cdq</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%edx:%eax</code>(doube long, quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cltq</code></strong></td><td><code>cdqe</code></td><td><code>cltd</code></td><td><code>%eax</code>(long)を<code>%rax</code>(quad)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
<tr><td><strong><code>cqto</code></strong></td><td><code>cqo</code></td><td><code>cqto</code></td><td><code>%rax</code>(quad)を<code>%rdx:%rax</code>(octuple)に符号拡張</td><td><a href="./asm/cbtw.s">cbtw.s</a> <a href="./asm/cbtw.txt">cbtw.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cqto</code>などは<code>idiv</code>で割り算する前に使うと便利(<code>%rdx:%rax</code>が<code>idiv</code>の隠しオペランドなので)．</li>
<li>GNUアセンブラはIntel形式のニモニックも受け付ける．</li>
</ul>
<h2 id="ジャンプ命令-1"><a class="header" href="#ジャンプ命令-1">ジャンプ命令</a></h2>
<h3 id="jmp-無条件ジャンプ-1"><a class="header" href="#jmp-無条件ジャンプ-1"><code>jmp</code>: 無条件ジャンプ</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>jmp</code></strong> <em>op1</em></td><td>jump</td><td><em>op1</em>にジャンプ</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`jmp`** *rel8*| `jmp 0x1000` | `0x1000`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ (`%rip += 0x1000`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *rel32*| `jmp foo` | `foo`番地に[相対](6-inst.md#abs-rel-jump)・[直接](6-inst.md#dir-indir-jump)ジャンプ (`%rip += foo`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *%rax` | `*%rax`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ (`%rip = *rax`)|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
|**`jmp`** *r/m*| `jmp *(%rax)` | `*(%rax)`番地に[絶対](6-inst.md#abs-rel-jump)・[間接](6-inst.md#dir-indir-jump)ジャンプ (`%rip = *(%rax)`|[jmp.s](./asm/jmp.s) [jmp.txt](./asm/jmp.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>jmp</code></strong> <em>rel</em></td><td><code>jmp 0x1000</code></td><td><code>0x1000</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += 0x1000</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><code>jmp foo</code></td><td><code>foo</code>番地に<a href="6-inst.html#abs-rel-jump">相対</a>・<a href="6-inst.html#dir-indir-jump">直接</a>ジャンプ (<code>%rip += foo</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *%rax</code></td><td><code>*%rax</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
<tr><td><strong><code>jmp</code></strong> <em>r/m</em></td><td><code>jmp *(%rax)</code></td><td><code>*(%rax)</code>番地に<a href="6-inst.html#abs-rel-jump">絶対</a>・<a href="6-inst.html#dir-indir-jump">間接</a>ジャンプ (<code>%rip = *(%rax)</code>)</td><td><a href="./asm/jmp.s">jmp.s</a> <a href="./asm/jmp.txt">jmp.txt</a></td></tr>
</tbody></table>
</div>
---
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64では，相対・直接と絶対・間接の組み合わせしかありません．
(つまり，相対・間接ジャンプや絶対・直接ジャンプはありません．
なお，ここで紹介していないfarジャンプでは絶対・直接もあります)．</li>
<li>相対・直接ジャンプでは符号ありの8ビット(<em>rel8</em>)か
32ビット(<em>rel32</em>)の整数定数で相対アドレスを指定します．
(64ビットの相対アドレスは指定できません．64ビットのジャンプをしたい時は
絶対・間接ジャンプ命令を使います)．</li>
<li><em>rel8</em>か<em>rel32</em>かはアセンブラが勝手に選んでくれます．
逆に<code>jmpb</code>や<code>jmpl</code>などとサフィックスをつけて指定することはできません．</li>
<li>なぜか，定数なのに<em>rel8</em>や<em>rel32</em>にはドルマーク<code>$</code>をつけません．
逆に<em>r/m</em>の前にはアスタリスク<code>*</code>が必要です．
GNUアセンブラのこの部分は一貫性がないので要注意です．</li>
</ul>
<h3 id="条件付きジャンプの概要-1"><a class="header" href="#条件付きジャンプの概要-1">条件付きジャンプの概要</a></h3>
<ul>
<li>条件付きジャンプ命令 <code>j␣</code>は
　ステータスフラグ (CF, OF, PF, SF, ZF)をチェックして，
条件が成り立てばジャンプします．</li>
<li>条件付きジャンプは比較命令と一緒に使うことが多いです．
例えば以下の2命令で「<code>%rax</code>が(符号あり整数として)1より大きければジャンプする」という意味になります．</li>
</ul>
<pre><code class="language-x86asmatt">cmpq $1, %rax
jg L2
</code></pre>
<ul>
<li>条件付きジャンプ命令のニモニックでは次の用語を使い分けます
<ul>
<li>符号あり整数の大小には less/greater を使う</li>
<li>符号なし整数の大小には above/below を使う</li>
</ul>
</li>
</ul>
<h3 id="条件付きジャンプ-符号あり整数用-1"><a class="header" href="#条件付きジャンプ-符号あり整数用-1">条件付きジャンプ: 符号あり整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em><br/> <strong><code>jnle</code></strong> <em>rel</em></td><td>jump if greater <br/> jump if not less nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==0&amp;&amp;SF==OF</code></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em><br/> <strong><code>jnl</code></strong> <em>rel</em></td><td>jump if greater or equal <br/> jump if not less</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF==OF</code></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em><br/> <strong><code>jng</code></strong> <em>rel</em></td><td>jump if less or equal <br/> jump if not greater</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>ZF==1||SF!=OF</code></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em><br/> <strong><code>jnge</code></strong> <em>rel</em></td><td>jump if less <br/> jump if not greater nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>SF!=OF</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jg</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jg foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jnle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnle foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/jg.s">jg.s</a> <a href="./asm/jg.txt">jg.txt</a></td></tr>
<tr><td><strong><code>jge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jge foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jnl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnl foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jge.s">jge.s</a> <a href="./asm/jge.txt">jge.txt</a></td></tr>
<tr><td><strong><code>jle</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jle foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jng</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jng foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jle.s">jle.s</a> <a href="./asm/jle.txt">jle.txt</a></td></tr>
<tr><td><strong><code>jl</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jl foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
<tr><td><strong><code>jnge</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnge foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jl.s">jl.s</a> <a href="./asm/jl.txt">jl.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jg</code>と<code>jnle</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==0&amp;&amp;SF==OF</code>と共通です．
他の3つのペア，<code>jge</code>と<code>jnl</code>，<code>jle</code>と<code>jng</code>，<code>jl</code>と<code>jnge</code>も同様です．</li>
</ul>
<h3 id="条件付きジャンプ-符号なし整数用-1"><a class="header" href="#条件付きジャンプ-符号なし整数用-1">条件付きジャンプ: 符号なし整数用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em><br/> <strong><code>jnbe</code></strong> <em>rel</em></td><td>jump if above <br/> jump if not below nor equal</td><td><em>op2</em>&gt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0&amp;ZF==0</code></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em><br/> <strong><code>jnb</code></strong> <em>rel</em></td><td>jump if above or equal <br/> jump if not below</td><td><em>op2</em>&gt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&lt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em><br/> <strong><code>jna</code></strong> <em>rel</em></td><td>jump if below or equal <br/> jump if not above</td><td><em>op2</em>&lt;=<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1&amp;&amp;ZF==1</code></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em><br/> <strong><code>jnae</code></strong> <em>rel</em></td><td>jump if below <br/> jump if not above nor equal</td><td><em>op2</em>&lt;<em>op1</em>なら<em>rel</em>にジャンプ <br/> !(<em>op2</em>&gt;=<em>op1</em>)なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ja</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>ja foo</code></td><td>if (<code>%rax</code>&gt;0) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jnbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnbe foo</code></td><td>if (!(<code>%rax</code>&lt;=0)) goto foo</td><td><a href="./asm/ja.s">ja.s</a> <a href="./asm/ja.txt">ja.txt</a></td></tr>
<tr><td><strong><code>jae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jae foo</code></td><td>if (<code>%rax</code>&gt;=0) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jnb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnb foo</code></td><td>if (!(<code>%rax</code>&lt;0)) goto foo</td><td><a href="./asm/jae.s">jae.s</a> <a href="./asm/jae.txt">jae.txt</a></td></tr>
<tr><td><strong><code>jbe</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jbe foo</code></td><td>if (<code>%rax</code>&lt;=0) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jna</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jna foo</code></td><td>if (!(<code>%rax</code>&gt;0)) goto foo</td><td><a href="./asm/jbe.s">jbe.s</a> <a href="./asm/jbe.txt">jbe.txt</a></td></tr>
<tr><td><strong><code>jb</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jb foo</code></td><td>if (<code>%rax</code>&lt;0) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
<tr><td><strong><code>jnae</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jnae foo</code></td><td>if (!(<code>%rax</code>&gt;=0)) goto foo</td><td><a href="./asm/jb.s">jb.s</a> <a href="./asm/jb.txt">jb.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>ja</code>と<code>jnbe</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>CF==0&amp;&amp;ZF==0</code>と共通です．
他の3つのペア，<code>jae</code>と<code>jnb</code>，<code>jbe</code>と<code>jna</code>，<code>jb</code>と<code>jnae</code>も同様です．</li>
</ul>
<h3 id="条件付きジャンプ-フラグ用-1"><a class="header" href="#条件付きジャンプ-フラグ用-1">条件付きジャンプ: フラグ用</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th><th>ジャンプ条件</th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td>jump if carry</td><td><code>CF==1</code>なら<em>rel</em>にジャンプ</td><td><code>CF==1</code></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td>jump if not carry</td><td><code>CF==0</code>なら<em>rel</em>にジャンプ</td><td><code>CF==0</code></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td>jump if overflow</td><td><code>OF==1</code>なら<em>rel</em>にジャンプ</td><td><code>OF==1</code></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td>jump if not overflow</td><td><code>OF==0</code>なら<em>rel</em>にジャンプ</td><td><code>OF==0</code></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td>jump if sign</td><td><code>SF==1</code>なら<em>rel</em>にジャンプ</td><td><code>SF==1</code></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td>jump if not sign</td><td><code>SF==0</code>なら<em>rel</em>にジャンプ</td><td><code>SF==0</code></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em> <br/> <strong><code>je</code></strong> <em>rel</em></td><td>jump if zero <br/> jump if equal</td><td><code>ZF==1</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>==<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==1</code></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em> <br/> <strong><code>jne</code></strong> <em>rel</em></td><td>jump if not zero <br/> jump if not equal</td><td><code>ZF==0</code>なら<em>rel</em>にジャンプ <br/> <em>op2</em>!=<em>op1</em>なら<em>rel</em>にジャンプ</td><td><code>ZF==0</code></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em> <br/> <strong><code>jpe</code></strong> <em>rel</em></td><td>jump if parity <br/> jump if parity even</td><td><code>PF==1</code>なら<em>rel</em>にジャンプ</td><td><code>PF==1</code></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em> <br/> <strong><code>jpo</code></strong> <em>rel</em></td><td>jump if not parity <br/> jump if parity odd</td><td><code>PF==0</code>なら<em>rel</em>にジャンプ</td><td><code>PF==0</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>jc</code></strong> <em>rel</em></td><td><code>jc foo</code></td><td>if (<code>CF==1</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jnc</code></strong> <em>rel</em></td><td><code>jnc foo</code></td><td>if (<code>CF==0</code>) goto foo</td><td><a href="./asm/jc.s">jc.s</a> <a href="./asm/jc.txt">jc.txt</a></td></tr>
<tr><td><strong><code>jo</code></strong> <em>rel</em></td><td><code>jo foo</code></td><td>if (<code>OF==1</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>jno</code></strong> <em>rel</em></td><td><code>jno foo</code></td><td>if (<code>OF==0</code>) goto foo</td><td><a href="./asm/jo.s">jo.s</a> <a href="./asm/jo.txt">jo.txt</a></td></tr>
<tr><td><strong><code>js</code></strong> <em>rel</em></td><td><code>js foo</code></td><td>if (<code>SF==1</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jns</code></strong> <em>rel</em></td><td><code>jns foo</code></td><td>if (<code>SF==0</code>) goto foo</td><td><a href="./asm/js.s">js.s</a> <a href="./asm/js.txt">js.txt</a></td></tr>
<tr><td><strong><code>jz</code></strong> <em>rel</em></td><td><code>jz foo</code></td><td>if (<code>ZF==1</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>je</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>je foo</code></td><td>if (<code>%rax==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jnz</code></strong> <em>rel</em></td><td><code>jnz foo</code></td><td>if (<code>ZF==0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jne</code></strong> <em>rel</em></td><td><code>cmpq $0, %rax</code><br/><code>jne foo</code></td><td>if (<code>%rax!=0</code>) goto foo</td><td><a href="./asm/jz.s">jz.s</a> <a href="./asm/jz.txt">jz.txt</a></td></tr>
<tr><td><strong><code>jp</code></strong> <em>rel</em></td><td><code>jp foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpe</code></strong> <em>rel</em></td><td><code>jpe foo</code></td><td>if (<code>PF==1</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jnp</code></strong> <em>rel</em></td><td><code>jnp foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
<tr><td><strong><code>jpo</code></strong> <em>rel</em></td><td><code>jpo foo</code></td><td>if (<code>PF==0</code>) goto foo</td><td><a href="./asm/jp.s">jp.s</a> <a href="./asm/jp.txt">jp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><em>op1</em> と <em>op2</em> は条件付きジャンプ命令の直前で使用した<code>cmp</code>命令のオペランドを表します．</li>
<li><code>jz</code>と<code>je</code>は異なるニモニックですが動作は同じです．
その証拠にジャンプ条件は<code>ZF==1</code>と共通です．
他の3つのペア，<code>jnz</code>と<code>jne</code>，<code>jp</code>と<code>jpe</code>，<code>jnp</code>と<code>jpo</code>も同様です．</li>
<li>AFフラグのための条件付きジャンプ命令は存在しません．</li>
</ul>
<h2 id="関数呼び出しコール命令"><a class="header" href="#関数呼び出しコール命令">関数呼び出し(コール命令)</a></h2>
<h3 id="call-ret命令-関数を呼び出すリターンする"><a class="header" href="#call-ret命令-関数を呼び出すリターンする"><code>call</code>, <code>ret</code>命令: 関数を呼び出す，リターンする</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>op1</em></td><td>call procedure</td><td><code>%rip</code>をスタックにプッシュしてから <em>op1</em>にジャンプする<br/> (<code>pushq %rip; %rip</code> = <em>op1</em>)</td></tr>
<tr><td><strong><code>ret</code></strong></td><td>return from procedure</td><td>スタックからポップしたアドレスにジャンプする <br/> (<code>popq %rip</code>)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>call</code></strong> <em>rel</em></td><td><code>call foo</code></td><td>相対・直接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>call</code></strong> <em>r/m</em></td><td><code>call *%rax</code></td><td>絶対・間接の関数コール</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
<tr><td><strong><code>ret</code></strong></td><td><code>ret</code></td><td>関数からリターン</td><td><a href="./asm/call.s">call.s</a> <a href="./asm/call.txt">call.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<h3 id="enter-leave命令-スタックフレームを作成する破棄する"><a class="header" href="#enter-leave命令-スタックフレームを作成する破棄する"><code>enter</code>, <code>leave</code>命令: スタックフレームを作成する，破棄する</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>op1</em>, <em>op2</em></td><td>make stack frame</td><td>サイズ<em>op1</em>のスタックフレームを作成する</td></tr>
<tr><td><strong><code>leave</code></strong></td><td>discard stack frame</td><td>今のスタックフレームを破棄する</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>enter</code></strong> <em>imm16</em>, <em>imm8</em></td><td><code>enter $0x20, $0</code></td><td><code>pushq %rbp</code><br/><code>movq %rsp, %rbp</code><br/><code>subq $0x20, %rsp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
<tr><td><strong><code>leave</code></strong></td><td><code>leave</code></td><td><code>movq %rbp, %rsp</code><br/><code>popq %rbp</code></td><td><a href="./asm/enter.s">enter.s</a> <a href="./asm/enter.txt">enter.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>enter</code>命令の<em>op2</em>には関数のネストレベルを指定するのですが，
C言語では入れ子の関数がない(つまりネストレベルは常にゼロ)なので
常にゼロを指定します．</li>
<li>ただし，<code>enter</code>は遅いので通常は使いません．
代わりに同等の動作をする<code>pushq %rbp; movq %rsp, %rbp; subq $</code><em>n</em><code>, %rsp</code>を使います．</li>
</ul>
<!--
### calleeとcaller
### レジスタ退避と回復
### caller-saveレジスタとcallee-saveレジスタ
### スタックフレーム
    図
### スタックレイアウト
### 関数呼び出し規約 (calling convention)
### 引数の渡し方
### 関数プロローグとエピローグ
### レッドゾーン (redzone)
### Cコードからアセンブリコードを呼び出す
### アセンブリコードからCコードを呼び出す
### アセンブリコードから`printf`を呼び出す
-->
<h2 id="その他"><a class="header" href="#その他">その他</a></h2>
<h3 id="insn-nop"><a class="header" href="#insn-nop"><code>nop</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
<tr><td><strong><code>nop</code></strong> <em>op1</em></td><td>no operation</td><td>何もしない(プログラムカウンタのみ増加)</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>nop</code></strong></td><td><code>nop</code></td><td>何もしない</td><td><a href="./asm/nop.s">nop.s</a> <a href="./asm/nop.txt">nop.txt</a></td></tr>
<tr><td><strong><code>nop</code></strong> <em>r/m</em></td><td><code>nopl (%rax)</code></td><td>何もしない</td><td><a href="./asm/nop2.s">nop2.s</a> <a href="./asm/nop2.txt">nop2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>nop</code>は何もしない命令です(ただしプログラムカウンタ<code>%rip</code>は増加します)．</li>
<li>機械語命令列の間を(何もせずに)埋めるために使います．</li>
<li><code>nop</code>の機械語命令は1バイト長です．</li>
<li><code>nop</code> <em>r/m</em> という形式の命令は2〜9バイト長の<code>nop</code>命令になります．
1バイト長の<code>nop</code>を9個並べるより，
9バイト長の<code>nop</code>を1個並べた方が，実行が早くなります．</li>
<li>「複数バイトの<code>nop</code>命令がある」という知識は，
逆アセンブル時に<code>nopl (%rax)</code>などを見てビックリしないために必要です．</li>
</ul>
<h3 id="cmpxchg-cmpxchg8b-cmpxchg16b命令-cas-compare-and-swap命令"><a class="header" href="#cmpxchg-cmpxchg8b-cmpxchg16b命令-cas-compare-and-swap命令"><code>cmpxchg</code>, <code>cmpxchg8b</code>, <code>cmpxchg16b</code>命令: CAS (compare-and-swap)命令</a></h3>
<h4 id="cmpxchg命令"><a class="header" href="#cmpxchg命令"><code>cmpxchg</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg</code></strong> <em>op1</em>, <em>op2</em></td><td>compare and exchange</td><td><code>%rax</code>と<em>op2</em>を比較し，同じなら<em>op2</em>=<em>op1</em>，異なれば <code>%rax</code>=<em>op2</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg</code></strong> <em>r</em>, <em>r/m</em></td><td><code>cmpxchg %rbx, (%rsp)</code></td><td>if (<code>*(%rsp)==%rax</code>) <code>*(%rsp)=%rbx</code>;<br/> else <code>%rax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg.s">cmpxchg.s</a> <a href="./asm/cmpxchg.txt">cmpxchg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td><td>!</td></tr>
</tbody></table>
</div></div>
<!--
特定のメモリの値が指定した値と等しい時だけ，別に指定した値で書き換える．
-->
<ul>
<li><code>cmpxchg</code>命令などのCAS命令は，lock-free，つまりロックを使わず
同期機構を実現するために使われます．
アトミックに実行する必要があるため，通常，LOCKプリフィックスをつけて使います．</li>
<li>気持ち:
<ul>
<li>あるメモリにある<em>op2</em>を新しい値<em>op1</em>で書き換えたい．</li>
<li>ただし，代入前の<em>op2</em>の値は<code>%rax</code>と同じはずで，
もし(割り込まれて)知らない間に別の値になっていたら，この代入は失敗させる．</li>
<li>代入が失敗したことを知るために，
(他の誰かが更新した最新の)<em>op2</em>の値を<code>%rax</code>に入れる．
<code>cmpxchg</code>実行後に<code>%rax</code>の値を調べれば，無事に<em>op1</em>への代入ができたかどうかが分かる．</li>
</ul>
</li>
</ul>
<h4 id="cmpxchg8b-cmpxchg16b命令"><a class="header" href="#cmpxchg8b-cmpxchg16b命令"><code>cmpxchg8b</code>, <code>cmpxchg16b</code>命令</a></h4>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg8b</code></strong> <em>op1</em></td><td>compare and exchange bytes</td><td><code>%edx:%eax</code>と<em>op1</em>を比較し，同じなら<em>op1</em>=<code>%ecx:%ebx</code>，異なれば <code>%edx:%eax</code>=<em>op1</em></td></tr>
<tr><td><strong><code>cmpxchg16b</code></strong> <em>op1</em></td><td>compare and exchange bytes</td><td><code>%rdx:%rax</code>と<em>op1</em>を比較し，同じなら<em>op1</em>=<code>%rcx:%rbx</code>，異なれば <code>%rdx:%rax</code>=<em>op1</em></td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>cmpxchg8b</code></strong> <em>m64</em></td><td><code>cmpxchg8b (%rsp)</code></td><td>if (<code>*(%rsp)==%edx:%eax</code>) <code>*(%rsp)=%ecx:%ebx</code>;<br/> else <code>%edx:%eax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg8.s">cmpxchg8b.s</a> <a href="./asm/cmpxchg8.txt">cmpxchg8.txt</a></td></tr>
<tr><td><strong><code>cmpxchg16b</code></strong> <em>m128</em></td><td><code>cmpxchg16b (%rsp)</code></td><td>if (<code>*(%rsp)==%rdx:%rax</code>) <code>*(%rsp)=%rcx:%rbx</code>;<br/> else <code>%rdx:%rax=*(%rsp)</code>;</td><td><a href="./asm/cmpxchg16.s">cmpxchg16b.s</a> <a href="./asm/cmpxchg16.txt">cmpxchg16.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td>!</td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>cmpxchg8b</code>, <code>cmpxchg16b</code>もCAS命令の一種ですが，
<code>cmpxchg</code>とステータスフラグの変化が異なるので，分けて書いています．</li>
<li><code>cmpxchg16b</code>命令が参照するメモリは16バイト境界のアラインメントが必要です．
(つまりメモリアドレスが16の倍数である必要があります)．</li>
</ul>
<h3 id="rdtscp"><a class="header" href="#rdtscp"><code>rdtsc</code>, <code>rdtscp</code>命令: タイムスタンプを読む</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rdtsc</code></strong></td><td>read time-stamp counter</td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ</td></tr>
<tr><td><strong><code>rdtscp</code></strong></td><td>read time-stamp counter and processor ID</td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ <br/> <code>%ecx</code> = 32ビットプロセッサID</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rdtsc</code></strong></td><td><code>rdtsc</code></td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ</td><td><a href="./asm/rdtsc.s">rdtsc.s</a> <a href="./asm/rdtsc.txt">rdtsc.txt</a></td></tr>
<tr><td><strong><code>rdtscp</code></strong></td><td><code>rdtscp</code></td><td><code>%edx:%eax</code> = 64ビットタイムスタンプカウンタ <br/> <code>%ecx</code> = 32ビットプロセッサID</td><td><a href="./asm/rdtscp.s">rdtscp.s</a> <a href="./asm/rdtscp.txt">rdtscp.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>x86-64は64ビットの<strong>タイムスタンプカウンタ</strong>
(TSC: time stamp counter)を備えており，
リセット後のCPUのサイクル数を数えています．
原理的には「サイクル数の差分をCPUのクロック周波数で割れば実行時間が得られる」
はずですが，実際にはout-of-order実行や，
内部クロックの変化などを考慮する必要があります．
詳しくは<a href="https://github.com/tpn/pdfs/blob/master/How%20to%20Benchmark%20Code%20Execution%20Times%20on%20Intel%20IA-32%20and%20IA-64%20Instruction%20Set%20Architectures%20-%20September%2C%202010%20(324264-001).pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a>
を参照して下さい．</li>
<li><code>rdtscp</code>命令を使うと，プロセッサIDも取得できます．
<code>rdtsc</code>と<code>rdtscp</code>ではシリアライズ処理が異なるため，得られるサイクル数も異なります．
詳しくは
<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">x86-64のマニュアルSDM</a>
を参照して下さい．</li>
</ul>
<h3 id="int3命令"><a class="header" href="#int3命令"><code>int3</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>int3</code></strong></td><td>call to interrupt procedure</td><td>ブレークポイントトラップを発生</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>int3</code></strong></td><td><code>int3</code></td><td>ブレークポイントトラップを発生</td><td><a href="./asm/int3.s">int3.s</a> <a href="./asm/int3.txt">int3.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>int3</code>命令はブレークポイントトラップ(ソフトウェア割り込みの一種)を発生させます．
通常実行では<code>int3</code>を実行した時点でプロセスは強制終了となりますが，
デバッガ上ではその時点でブレークします．continueコマンドでその後の実行も継続できます．ブレークしたい場所が分かっている場合は，
Cコード中に<code>asm (&quot;int3&quot;);</code>と書くことでデバッガ上でブレークさせることができます．</li>
</ul>
<h3 id="ud2命令"><a class="header" href="#ud2命令"><code>ud2</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>ud2</code></strong></td><td>undefined instruction</td><td>無効オペコード例外を発生させる</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>ud2</code></strong></td><td><code>ud2</code></td><td>無効オペコード例外を発生させる</td><td><a href="./asm/ud2.s">ud2.s</a> <a href="./asm/ud2.txt">ud2.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>ud2</code>命令は無効オペコード例外を発生させます．
通常実行では<code>ud2</code>を実行した時点でプロセスは，
シグナル<code>SIGILL</code> (illegal instruction)を受け取り，強制終了となります
デバッガ上でも，
<code>Program received signal SIGILL, Illegal instruction.</code>
というメッセージが出て，プロセスは終了になります．
本書では「実行が通るはずがない場所が本当かどうか」の確認のため
<code>ud2</code>を使います．(通るはずがない場所に<code>ud2</code>を置いて，<code>SIGILL</code>が発生しなければOKです)</li>
</ul>
<details>
<summary>
例外 (exception)とは
</summary>
<p><strong>例外</strong>(exception)はCPUが発生させる割り込み(ソフトウェア割り込み)です．
Intel用語で，例外はさらに<strong>フォールト</strong>(fault)，<strong>トラップ</strong>(trap)，
<strong>アボート</strong>(abort)に分類されます．
例えばゼロ割はフォールト，ブレークポイントはトラップです．
マイOS作りたい人は頑張って<a href="https://wiki.osdev.org/Exceptions">勉強</a>して下さい．</p>
</details>
<h3 id="endbr64命令"><a class="header" href="#endbr64命令"><code>endbr64</code>命令</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>endbr64</code></strong></td><td>end branch 64 bit</td><td>間接ジャンプ先として許す</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>endbr64</code></strong></td><td><code>endbr64</code></td><td>間接ジャンプ先として許す</td><td><a href="./asm/endbr64.s">endbr64.s</a> <a href="./asm/endbr64.txt">endbr64.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li>Intel CET IBT技術に対応したCPUの場合，
間接ジャンプ後のジャンプ先が<code>endbr64</code>以外だった場合，
例外が発生してプログラムは強制終了となります．</li>
<li>Intel CET IBT技術に未対応のCPUの場合は，<code>nop</code>命令として動作します．</li>
<li>逆アセンブルして<code>endbr64</code>を見てもビックリしないためにこの説明を書いています．</li>
<li>私のPCが古すぎて，Intel CET未対応だったため，2023/8/17現在，クラッシュが発生するサンプルコードを作れていません．</li>
</ul>
<h3 id="bndプリフィクス"><a class="header" href="#bndプリフィクス"><code>bnd</code>プリフィクス</a></h3>
<p>Intel MPX (Memory Protection Extensions)の機能の一部で，
制御命令 (ジャンプ命令やリターン命令など)に指定できます．
<code>BND0</code>から<code>BND3</code>レジスタに指定した境界に対して境界チェックを行います．
この機能をサポートしてないCPUでは<code>nop</code>として動作します．</p>
<ul>
<li>逆アセンブルして<code>bnd</code>を見てもビックリしないためにこの説明を書いています．<br />
以下のようにPLTセクションを見ると❶<code>bnd</code>が使われています．</li>
</ul>
<pre><code>$ objdump -d /bin/ls | less
(中略)
Disassembly of section .plt:

0000000000004030 &lt;.plt&gt;:
    4030:       ff 35 2a dc 01 00       push   0x1dc2a(%rip)        # 21c60 &lt;_ob
stack_memory_used@@Base+0x114b0&gt;
    4036:       f2 ff 25 2b dc 01 00 ❶ bnd jmp *0x1dc2b(%rip)        # 21c68 &lt;_obstack_memory_used@@Base+0x114b8&gt;
    403d:       0f 1f 00                nopl   (%rax)
</code></pre>
<h3 id="set"><a class="header" href="#set"><code>set␣</code>命令: ステータスフラグの値を取得</a></h3>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>set␣</code></strong> <em>op1</em></td><td>set byte on condition</td><td>if (条件␣が成立) <em>op1</em>=1; else <em>op1</em>=0;</td></tr>
</tbody></table>
</div>
<hr />
<!--
|[詳しい記法](./x86-list.md#詳しい記法)| 例 | 例の動作 | [サンプルコード](./6-inst.md#how-to-execute-x86-inst) | 
|-|-|-|-|
|**`set␣`** *r/m8*| `setz %al`| `%al` = ZF | [setz.s](./asm/setz.s) [setz.txt](./asm/setz.txt)|
|**`set␣`** *r/m8*| `setg %al`| `%al` = より大きい(greater)条件が成立なら1，違えば0 | [setg.s](./asm/setg.s) [setg.txt](./asm/setg.txt)|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td rowspan="2"><strong><code>set␣</code></strong> <em>r/m8</em></td><td><code>setz %al</code></td><td><code>%al</code> = ZF</td><td><a href="./asm/setz.s">setz.s</a> <a href="./asm/setz.txt">setz.txt</a></td></tr>
<tr><td><code>setg %al</code></td><td> より大きい(greater)条件が成立なら<code>%al</code> =1，違えば<code>%al</code> =0</td><td><a href="./asm/setg.s">setg.s</a> <a href="./asm/setg.txt">setg.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<div style="font-size: 70%;">
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#status-reg">CF</a></th><th><a href="./x86-list.html#status-reg">OF</a></th><th><a href="./x86-list.html#status-reg">SF</a></th><th><a href="./x86-list.html#status-reg">ZF</a></th><th><a href="./x86-list.html#status-reg">PF</a></th><th><a href="./x86-list.html#status-reg">AF</a></th></tr></thead><tbody>
<tr><td> </td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div></div>
<ul>
<li><code>set␣</code>命令はステータスフラグの値を取得します．
<code>␣</code>には条件付きジャンプ命令<code>j␣</code>の<code>␣</code>と同じものをすべて入れられます．</li>
</ul>
<h3 id="string-insn"><a class="header" href="#string-insn">ストリング命令</a></h3>
<p><code>movs</code>などのストリング命令はREPプリフィクスと組み合わせて使います．</p>
<ul>
<li>REPプリフィクス</li>
</ul>
<hr />
<!--
|[記法](./x86-list.md#詳しい記法)|何の略か| 動作 |
|-|-|-|
|**`rep`** *insn*| repeat | `%ecx==0`まで命令*insn*と`%ecx--`を繰り返し実行|
|**`repe`** *insn*| repeat while equal| `%ecx==0`またはフラグZF==0まで命令*insn*と`%ecx--`を繰り返し実行|
|**`repz`** *insn*| repeat while zero | `%ecx==0`またはフラグZF==0まで命令*insn*と`%ecx--`を繰り返し実行|
|**`repne`** *insn*| repeat while not equal| `%ecx==0`またはフラグZF==1まで命令*insn*と`%ecx--`を繰り返し実行|
|**`repnz`** *insn*| repeat while not zero | `%ecx==0`またはフラグZF==1まで命令*insn*と`%ecx--`を繰り返し実行|
-->
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>rep</code></strong> <em>insn</em></td><td>repeat</td><td><code>%ecx==0</code>になるまで<br/>命令<em>insn</em>と<code>%ecx--</code>を繰り返し実行</td></tr>
<tr><td><strong><code>repe</code></strong> <em>insn</em></td><td>repeat while equal</td><td rowspan=2><code>%ecx==0</code>またはフラグZF==0になるまで<br/>命令<em>insn</em>と<code>%ecx--</code>を繰り返し実行</td></tr>
<tr><td><strong><code>repz</code></strong> <em>insn</em></td><td>repeat while zero</td></tr>
<tr><td><strong><code>repne</code></strong> <em>insn</em></td><td>repeat while not equal</td><td rowspan=2><code>%ecx==0</code>またはフラグZF==1になるまで<br/>命令<em>insn</em>と<code>%ecx--</code>を繰り返し実行</td></tr>
<tr><td><strong><code>repnz</code></strong> <em>insn</em></td><td>repeat while not zero</td></tr>
</tbody></table>
</div>
<hr />
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><strong><code>rep</code></strong> <em>insn</em></td><td><code>rep movsb</code></td><td><code>while (%ecx-- &gt; 0) (*%rdi++) = (*%rsi++);</code> <br/> # 1バイトずつコピー</td><td><a href="./asm/rep.s">rep.s</a> <a href="./asm/rep.txt">rep.txt</a></td></tr>
<tr><td><strong><code>repe</code></strong> <em>insn</em> <br/> <strong><code>repz</code></strong> <em>insn</em></td><td><code>repe cmpsb</code> <br/> <code>repz cmpsb</code></td><td><code>while (%ecx-- &gt; 0 &amp;&amp; (*%rdi++ == *%rsi++)); </code> <br/> # 1バイトずつ比較</td><td><a href="./asm/repe.s">repe.s</a> <a href="./asm/repe.txt">repe.txt</a> <br/> <a href="./asm/repz.s">repz.s</a> <a href="./asm/repz.txt">repz.txt</a></td></tr>
<tr><td><strong><code>repne</code></strong> <em>insn</em> <br/> <strong><code>repnz</code></strong> <em>insn</em></td><td><code>repne cmpsb</code> <br/> <code>repnz cmpsb</code></td><td><code>while (%ecx-- &gt; 0 &amp;&amp; (*%rdi++ != *%rsi++)); </code> <br/> # 1バイトずつ比較</td><td><a href="./asm/repne.s">repne.s</a> <a href="./asm/repne.txt">repne.txt</a> <br/> <a href="./asm/repnz.s">repnz.s</a> <a href="./asm/repnz.txt">repnz.txt</a></td></tr>
</tbody></table>
</div>
<hr />
<blockquote>
<p>注意: DFフラグ(direction flag)が0の場合，<code>%rsi</code>と<code>%rdi</code>を増やす．DFが1の場合は減らす．上記の説明はDF==0を仮定．</p>
</blockquote>
<blockquote>
<p>注意: ストリング命令はセグメントレジスタ<code>%ds</code>と<code>%es</code>を使って，<code>%ds:(%rsi)</code>と<code>%es:(%rdi)</code>にアクセスします．が，x86-64では<code>%ds</code>も<code>%es</code>もベースレジスタをゼロと扱うので，<code>%ds</code>と<code>%es</code>は無視して構いません．</p>
</blockquote>
<img src="figs/rep-combi.svg" height="250px" id="fig:rep-combi">
<ul>
<li>
<p>ストリング命令</p>
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>movs␣</code></strong></td><td>move string</td><td><code>(%rsi)</code>を<code>(%rdi)</code>に<em>n</em>バイト転送; <code>%rsi</code> += <em>n</em>; <code>%rdi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>lods␣</code></strong></td><td>load string</td><td><code>(%rsi)</code>を<code>%rax</code>に<em>n</em>バイト転送; <code>%rsi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>stos␣</code></strong></td><td>store string</td><td><code>%rax</code>を<code>(%rdi)</code>に<em>n</em>バイト転送; <code>%rdi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>ins␣</code></strong></td><td>input string</td><td>I/Oポート<code>%dx</code>から<code>(%rdi)</code>に<em>n</em>バイト転送; <code>%rdi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>outs␣</code></strong></td><td>output string</td><td><code>(%rsi)</code>からI/Oポート<code>%dx</code>に<em>n</em>バイト転送; <code>%rsi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>cmps␣</code></strong></td><td>compare string</td><td><code>(%rsi)</code>と<code>(%rdi)</code>を<em>n</em>バイト比較; <code>%rsi</code> += <em>n</em>; <code>%rdi</code> += <em>n</em>;</td></tr>
<tr><td><strong><code>scas␣</code></strong></td><td>scan string</td><td><code>%rax</code>と<code>(%rdi)</code>を<em>n</em>バイト比較; <code>%rdi</code> += <em>n</em>;</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><code>rep movsb</code></td><td><code>rep movsb</code></td><td><code>while (%ecx-- &gt; 0) (*%rdi++) = (*%rsi++);</code> <br/> # 1バイトずつコピー</td><td><a href="./asm/rep.s">rep.s</a> <a href="./asm/rep.txt">rep.txt</a></td></tr>
<tr><td><code>rep lodsb</code></td><td><code>rep lodsb</code></td><td><code>while (%ecx-- &gt; 0) %al = (*%rsi++);</code> <br/> # 1バイトずつコピー</td><td><a href="./asm/lods.s">lods.s</a> <a href="./asm/lods.txt">lods.txt</a></td></tr>
<tr><td><code>rep stosq</code></td><td><code>rep stosq</code></td><td><code>while (%ecx-- &gt; 0) {(*%rdi) = %rax; %rdi+=8; }</code> <br/> # 8バイトずつコピー</td><td><a href="./asm/stos.s">stos.s</a> <a href="./asm/stos.txt">stos.txt</a></td></tr>
<tr><td><code>repe cmpsb</code></td><td><code>repe cmpsb</code></td><td><code>while (%ecx-- &gt; 0 &amp;&amp; (*%rdi++) == (*%rsi++);</code> <br/> # 1バイトずつ比較</td><td><a href="./asm/repe.s">repe.s</a> <a href="./asm/repe.txt">repe.txt</a></td></tr>
<tr><td><code>repne scasb</code></td><td><code>repne scasb</code></td><td><code>while (%ecx-- &gt; 0 &amp;&amp; (*%rdi++) != %rax);</code> <br/> # 1バイトずつ比較</td><td><a href="./asm/scas.s">scas.s</a> <a href="./asm/scas.txt">scas.txt</a></td></tr>
</tbody></table>
</div>
<ul>
<li><code>␣</code>には<code>b</code>，<code>w</code>，<code>l</code>，<code>q</code>が入り，それぞれ，
メモリ参照のサイズ(上では<em>n</em>と表記)が1バイト，2バイト，4バイト，8バイトになる．
(ただし，<code>ins</code>と<code>outs</code>は<code>b</code>，<code>w</code>，<code>l</code>のみ指定可能)．</li>
<li><code>%rax</code>はオペランドサイズにより，<code>%rax</code>，<code>%eax</code>，<code>%ax</code>，<code>%al</code>のいずれかになる．</li>
<li><code>ins␣</code>と<code>out␣</code>の実例はここでは無し．</li>
</ul>
</li>
<li>
<p>DFフラグ(方向フラグ)と<code>cld</code>命令・<code>std</code>命令</p>
<div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">記法</a></th><th>何の略か</th><th>動作</th></tr></thead><tbody>
<tr><td><strong><code>cld</code></strong></td><td>clear direction flag</td><td>DF=0</td></tr>
<tr><td><strong><code>std</code></strong></td><td>set direction flag</td><td>DF=1</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th><a href="./x86-list.html#%E8%A9%B3%E3%81%97%E3%81%84%E8%A8%98%E6%B3%95">詳しい記法</a></th><th>例</th><th>例の動作</th><th><a href="./6-inst.html#how-to-execute-x86-inst">サンプルコード</a></th></tr></thead><tbody>
<tr><td><code>cld</code></td><td><code>cld</code></td><td>DF=0</td><td><a href="./asm/cld.s">cld.s</a> <a href="./asm/cld.txt">cld.txt</a></td></tr>
<tr><td><code>std</code></td><td><code>std</code></td><td>DF=1</td><td><a href="./asm/cld.s">cld.s</a> <a href="./asm/cld.txt">cld.txt</a></td></tr>
</tbody></table>
</div>
<ul>
<li>DFフラグはストリング命令で，<code>%rsi</code>と<code>%rdi</code>を増減する方向を決めます．
<ul>
<li>DF=0 の時は<code>%rsi</code>と<code>%rdi</code>を増やします</li>
<li>DF=1 の時は<code>%rsi</code>と<code>%rdi</code>を減らします</li>
</ul>
</li>
<li>DFフラグの変更は<code>cld</code>や<code>std</code>で行います
(一般的にフラグレジスタの値を変更する場合，<code>pushf</code>でフラグレジスタの値を保存し，
<code>popf</code>で元に戻すのが安全です)．</li>
<li><a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">Linux AMD64のABI</a>により，
関数の出入り口ではDF=0に戻す必要があります．このお約束のため，
自分で<code>std</code>していなければ，必ずDF==0となります(わざわざ<code>cld</code>する必要はありません)．</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style type="text/css">
body { counter-reset: chapter 13; }
</style>
<h1 id="リンク集"><a class="header" href="#リンク集">リンク集</a></h1>
<ul>
<li>デバッグ情報の仕様書 <a href="https://dwarfstd.org/doc/DWARF5.pdf">dwarf5仕様書</a></li>
<li>WindowsのLinux環境 <a href="https://learn.microsoft.com/ja-jp/windows/wsl/install">WSL2</a> </li>
<li>仮想マシン <a href="https://www.virtualbox.org/">VirtualBox</a></li>
<li>コンテナ環境 <a href="https://www.docker.com/">Docker</a></li>
<li>オンライン開発環境 <a href="https://replit.com/">repl.it</a></li>
<li>OS自作本 <a href="https://www.amazon.co.jp/dp/4839975868/">ゼロからのOS自作入門</a></li>
<li>Linuxディストリビューション <a href="https://www.ubuntulinux.jp/home">Ubuntu</a></li>
<li>GNUアセンブラのマニュアル <a href="https://sourceware.org/binutils/docs-2.40/as/index.html">Using as</a></li>
<li>GCC 9.4のマニュアル <a href="https://gcc.gnu.org/onlinedocs/9.4.0/">9.4 Manuals</a></li>
<li>x86-64のマニュアル <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel 64 and IA-32 Architectures Software Developer Manuals</a></li>
<li>LinuxのABI <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a></li>
<li>Linux AMD64のABI <a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">System V ABI (AMD64)</a></li>
</ul>
<!-- - Linuxの標準 [Linux Standard Base (LSB)](https://refspecs.linuxfoundation.org/lsb.shtml) -->
<ul>
<li>
<p>マークダウン環境 <a href="https://rust-lang.github.io/mdBook/">mdbook</a></p>
</li>
<li>
<p><a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages">Github Pages</a></p>
</li>
<li>
<p>VDSO <a href="https://lwn.net/Articles/615809/">Implementing virtual system calls</a></p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vdso</a></p>
</li>
<li>
<p>call frame informationの短い解説 <a href="https://www.imperialviolet.org/2017/01/18/cfi.html">CFI</a></p>
</li>
<li>
<p><code>rdtscp</code>で実行時間を測る際の注意事項 <a href="https://github.com/tpn/pdfs/blob/master/How%20to%20Benchmark%20Code%20Execution%20Times%20on%20Intel%20IA-32%20and%20IA-64%20Instruction%20Set%20Architectures%20-%20September%2C%202010%20(324264-001).pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a></p>
</li>
<li>
<p><a href="https://www.sourceware.org/gdb/documentation/">GDBマニュアル</a></p>
</li>
<li>
<p><a href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.intro.html">ELFバイナリ形式</a></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">GCCインラインアセンブラ</a></p>
</li>
<li>
<p><a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf">x86-64 最適化マニュアル</a></p>
</li>
</ul>

		    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/elasticlunr.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F3GVG4RZLD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-F3GVG4RZLD');
</script>

    </div>
    </body>
</html>
